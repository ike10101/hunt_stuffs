(this.webpackChunknozbe4_web = this.webpackChunknozbe4_web || []).push([
    [179],
    [(e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            FP: () => l,
            Hocs: () => a,
            Hooks: () => o,
            Misc: () => c,
            Model: () => r,
            React: () => n,
            ReactUtils: () => d,
            Rx: () => u,
            Styling: () => i,
            zacs: () => m
        });
        var n = s(9),
            a = s(154),
            o = s(54),
            r = s(17),
            i = s(36),
            c = s(5),
            l = s(4),
            d = s(23),
            u = s(8);
        const m = s(241)
    }, , (e, t, s) => {
        "use strict";
        var n = s(36);
        s(241);
        const {
            vars: a,
            mixins: o,
            zcolor: r,
            rgba: i
        } = n
    }, (e, t, s) => {
        "use strict";
        var n = s(36);
        const {
            size: a,
            spacing: o,
            radius: r,
            color: i,
            layer: c,
            fontWeight: l
        } = n.vars
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            F: () => M.F,
            Retry: () => xt,
            T: () => O.T,
            all: () => Se.$,
            allPass: () => Pe.s,
            allPromises: () => Ue.allPromises,
            always: () => W.B,
            any: () => _e.Y,
            anyFalse: () => C.P,
            anyPass: () => R.H,
            anyTrue: () => _.h,
            append: () => Ne.R,
            apply: () => f.n,
            arrayDifference: () => We.Z,
            ascend: () => i.z,
            ascendLocale: () => Yt,
            both: () => xe.H,
            capitalize: () => mt,
            clamp: () => gt,
            compose: () => b.q,
            concat: () => ve.z,
            concatAll: () => At,
            concatUnique: () => Bt,
            cond: () => a.w,
            curry: () => ke.W,
            dec: () => A.E,
            defaultTo: () => X.y,
            delay: () => Le.g,
            delayedRetry: () => wt,
            descend: () => c.C,
            descendLocale: () => Jt,
            dropLast: () => $.m,
            dropWhile: () => Ft,
            dropWhileRight: () => Lt,
            either: () => oe.w,
            encodeUrl: () => Nt,
            equals_SLOW: () => re.f,
            filter: () => u.h,
            filterAsync: () => Gt,
            find: () => He.s,
            findIndex: () => De.c,
            flatten: () => m.x,
            flip: () => Y.R,
            forEach: () => Q.E,
            forEachAsync: () => Ge.default,
            formatBytes: () => zt,
            fromPairs: () => ze.P,
            getFirstNonEmptyArray: () => Wt,
            getFirstPosition: () => jt,
            getLastPosition: () => Pt,
            greaterThan: () => nt,
            greaterThanOrEqual: () => ot,
            groupBy: () => Ae.v,
            head: () => ne.Y,
            identical: () => r.U,
            identicalArrays: () => Ue.identicalArrays,
            identicalContains: () => Xe,
            identity: () => x.y,
            identityObj: () => Zt.default,
            ifElse: () => H.K,
            inOrder: () => $t,
            inOrderLocale: () => Xt,
            inc: () => we.a,
            indexOf: () => Me.c,
            insert: () => le.$,
            int: () => qe,
            intersectionDifference: () => St,
            is: () => D.is,
            isArray: () => rt,
            isArrayNotEmpty: () => dt,
            isEmpty: () => o.x,
            isLastOnList: () => Ot,
            isNil: () => fe.k,
            isNotEmpty: () => bt,
            isNotNil: () => pt,
            isNumber: () => lt,
            isObjEmpty: () => Et,
            isObject: () => Ue.isObj,
            isSameArray: () => Kt.Z,
            isString: () => Qe,
            isUrl: () => Ht.ZP,
            join: () => N.v,
            keys: () => L.X,
            last: () => Oe.Z,
            length: () => ue.k,
            lessThan: () => tt,
            lineBreakRegExp: () => yt,
            localeCompare: () => Qt,
            map: () => d.U,
            mapAsync: () => T.q,
            mapFastAsync: () => I.r,
            mapObjIndexed: () => P.I,
            memoizeWith: () => ce.b,
            noop: () => Ue.noop,
            normalizeText: () => Ve.normalizeText,
            not: () => je.f,
            nth: () => Fe.h,
            omit: () => w.C,
            once: () => G.I,
            parseUrl: () => It,
            partition: () => y.u,
            pick: () => Ce.e,
            pickAll: () => S.z,
            pipe: () => p.z,
            piped: () => g.Z,
            pluck: () => ge.j,
            pluckIds: () => ut,
            prop: () => E.v,
            propEq: () => F.O,
            randomElement: () => Ct,
            randomNumber: () => _t,
            range: () => v.w,
            reduce: () => j.u,
            reject: () => ye.d,
            replace: () => Be.g,
            reverse: () => J.G,
            roundTo: () => Dt,
            selectionAt: () => ct,
            sort: () => V.D,
            sortBy: () => q.M,
            sortByPredicate: () => $e,
            sortByProp: () => Je,
            sortWith: () => l.H,
            split: () => U.V,
            splitAt: () => z.l,
            splitBySelection: () => it,
            splitEvery: () => ie.M,
            splitLines: () => vt,
            splitWhen: () => n.F,
            startsWith: () => k.N,
            sum: () => pe.S,
            tail: () => se.G,
            take: () => Ee.q,
            test: () => ae.B,
            times: () => me.D,
            toLower: () => h.t,
            toPairs: () => Ie.Z,
            toUpper: () => ee.G,
            toggleSelected: () => Mt,
            trim: () => Te.f,
            uniqWith: () => K.s,
            unique: () => Rt,
            unless: () => de.q,
            unnest: () => be.U,
            unzip: () => Ut,
            update: () => Ze.V,
            values: () => Z.V,
            when: () => B.g,
            wrapClamp: () => ft,
            xor: () => es,
            xprod: () => he.i,
            zip: () => te.$,
            zipObj: () => Re._
        });
        var n = s(1051),
            a = s(1052),
            o = s(878),
            r = s(1053),
            i = s(1054),
            c = s(1055),
            l = s(1056),
            d = s(266),
            u = s(1423),
            m = s(1057),
            h = s(1058),
            p = s(792),
            g = s(1072),
            f = s(1060),
            b = s(1425),
            y = s(914),
            v = s(1424),
            w = s(1074),
            k = s(1075),
            x = s(1076),
            j = s(1077),
            T = s(1078),
            S = s(1061),
            P = s(1062),
            _ = s(1063),
            C = s(1064),
            R = s(1098),
            A = s(1073),
            I = s(1079),
            N = s(1080),
            E = s(1081),
            O = s(1082),
            M = s(1083),
            D = s(134),
            H = s(1084),
            F = s(1085),
            Z = s(1086),
            L = s(1088),
            B = s(1087),
            z = s(1090),
            U = s(1089),
            W = s(1091),
            G = s(1092),
            V = s(1093),
            q = s(1094),
            Q = s(1099),
            Y = s(1100),
            J = s(1101),
            K = s(1102),
            $ = s(1103),
            X = s(1104),
            ee = s(1105),
            te = s(1121),
            se = s(1122),
            ne = s(1123),
            ae = s(1124),
            oe = s(1125),
            re = s(1510),
            ie = s(1095),
            ce = s(1096),
            le = s(1097),
            de = s(1065),
            ue = s(1066),
            me = s(1067),
            he = s(1068),
            pe = s(1069),
            ge = s(1070),
            fe = s(1071),
            be = s(915),
            ye = s(1107),
            ve = s(1109),
            we = s(1106),
            ke = s(801),
            xe = s(1130),
            je = s(1131),
            Te = s(1113),
            Se = s(1114),
            Pe = s(1115),
            _e = s(182),
            Ce = s(1126),
            Re = s(1059),
            Ae = s(1127),
            Ie = s(1128),
            Ne = s(1116),
            Ee = s(1112),
            Oe = s(1117),
            Me = s(1118),
            De = s(1119),
            He = s(1120),
            Fe = s(916),
            Ze = s(1110),
            Le = s(1108),
            Be = s(1111),
            ze = s(1129),
            Ue = s(46),
            We = s(383),
            Ge = s(180),
            Ve = s(211);
        const qe = e => parseInt(e, 10),
            Qe = (0, D.is)(String);
        var Ye = s(1426);
        const Je = (0, Ye.P)(2, ((e, t) => (0, q.M)((0, E.v)(e), t)));
        var Ke = s(1427);
        const $e = (0, Ye.P)(2, ((e, t) => {
                const [s, n] = (0, j.u)(((t, s) => {
                    const [n, a] = t;
                    return e(s) ? n.push(s) : a.push(s), t
                }), (0, Ke.$)([], []), t);
                return s.concat(n)
            })),
            Xe = (0, Ye.P)(2, ((e, t) => (0, _e.Y)((0, r.U)(e), t)));
        var et = s(1428);
        const tt = (0, Ye.P)(2, ((e, t) => (0, et.lt)(t, e)));
        var st = s(1429);
        const nt = (0, Ye.P)(2, ((e, t) => (0, st.gt)(t, e)));
        var at = s(1430);
        const ot = (0, Ye.P)(2, ((e, t) => (0, at.e)(t, e))),
            rt = (0, D.is)(Array);

        function it(e, t) {
            return [e.slice(0, t.start), e.slice(t.start, t.end), e.slice(t.end)]
        }

        function ct(e) {
            return {
                start: e,
                end: e
            }
        }
        const lt = (0, D.is)(Number);

        function dt(e) {
            return 0 < e.length
        }

        function ut(e) {
            const t = e.length,
                s = new Array(t);
            for (let n = 0; n < t; n += 1) s[n] = e[n].id;
            return s
        }
        const mt = (0, s(1431).v)(ve.z, [(0, p.z)(ne.Y, ee.G), se.G]);
        var ht = s(1432);
        const pt = (0, ht.C)(fe.k);

        function gt(e, t, s) {
            return e < t ? t : e > s ? s : e
        }

        function ft(e, t, s) {
            return e < t ? s : e > s ? t : e
        }
        const bt = (0, ht.C)(o.x),
            yt = /[\n\r]/;

        function vt(e) {
            return e.split(yt)
        }
        async function wt(e, t) {
            invariant(e.length, "delayedRetry() requires at least one delay");
            for (let s = 0; s < e.length; s += 1) {
                await (0, Le.g)(e[s]);
                if (await t(s)) return !0
            }
            return !1
        }
        const kt = {
            min: 0,
            max: 3e4,
            add: 100,
            multiply: 2
        };
        class xt {
            constructor(e = {}) {
                this._config = Object.assign({}, kt, e), this.reset()
            }
            reset() {
                this.current = this._config.min
            }
            async wait() {
                if (this._waitPromise) return void await this._waitPromise;
                const e = (0, Le.g)(this.current);
                this._waitPromise = e, await e, this._waitPromise = null;
                const {
                    multiply: t,
                    add: s,
                    max: n
                } = this._config;
                this.current = Math.min(n, this.current * t + s)
            }
        }

        function jt(e, t) {
            if (0 === e.length) return 0;
            const s = e.map((e => t(e) || 0));
            return Math.min(...s) - 1
        }

        function Tt(e) {
            return e
        }

        function St(e, t = Tt) {
            if (!e.length) return [
                [],
                []
            ];
            const s = e[0],
                n = new Set(s.map(t)),
                a = new Set((0, K.s)(((e, s) => t(e) === t(s)), s)),
                o = new Set,
                r = [];
            e.forEach((e => {
                const s = new Set(e.map(t));
                a.forEach((e => {
                    const o = t(e);
                    s.has(o) || (a.delete(e), n.delete(o))
                })), e.forEach((e => {
                    const s = t(e);
                    o.has(s) || (o.add(s), r.push(e))
                }))
            }));
            return [
                [...a], r.filter((e => !n.has(t(e))))
            ]
        }

        function Pt(e, t) {
            if (0 === e.length) return 0;
            const s = e.map((e => t(e) || 0));
            return Math.max(...s) + 1
        }

        function _t(e, t) {
            return Math.round(Math.random() * (t - e)) + e
        }

        function Ct(e) {
            return e[_t(0, e.length - 1)]
        }

        function Rt(e) {
            const t = [];
            for (let s = 0, n = e.length; s < n; s += 1) {
                const n = e[s];
                let a = !0;
                for (let e = 0, s = t.length; e < s; e += 1)
                    if (n === t[e]) {
                        a = !1;
                        break
                    } a && t.push(n)
            }
            return t
        }
        const At = (...e) => (0, j.u)(((e, t) => e.concat(t)), [], e);

        function It(e) {
            const t = {},
                s = e.indexOf("://");
            if (-1 === s) throw new Error("Invalid URL, missing protocol");
            const n = e.slice(0, s + 1);
            t.protocol = n;
            const a = e.slice(s + 3),
                o = function(e) {
                    let t = -1;
                    return e.forEach((e => {
                        -1 < e && (e < t || -1 === t) && (t = e)
                    })), t
                }([a.indexOf("/"), a.indexOf("?"), a.indexOf("#")]),
                r = -1 < o,
                i = a.slice(0, r ? o : void 0);
            t.host = i;
            const c = r ? a.slice(o) : "",
                l = c.indexOf("#"),
                d = -1 < l,
                u = c.indexOf("?"),
                m = -1 < u && (!d || l > u);
            let h;
            m ? h = u : d && (h = l);
            const p = c.slice(0, h),
                g = ["http:", "https:", "ftp:"].includes(n) ? "/" : "";
            t.pathname = p || g;
            const f = m ? c.slice(h, d ? l : void 0) : "";
            t.search = 1 < f.length ? f : "";
            const b = d ? c.slice(l) : "";
            t.hash = 1 < b.length ? b : "";
            const y = Object.create(null);
            if (t.search.length) {
                f.slice(1).split("&").map((e => {
                    const [t, s = ""] = e.split("=");
                    return [t, s]
                })).forEach((([e, t]) => {
                    y[decodeURIComponent(e)] = decodeURIComponent(t.replace(/\+/g, " "))
                }))
            }
            return t.searchParams = y, t
        }

        function Nt(e) {
            const {
                protocol: t,
                host: s,
                pathname: n,
                hash: a,
                searchParams: o
            } = e, r = Object.entries(o).map((([e, t]) => encodeURIComponent(e).replace(/%5B/g, "[").replace(/%5D/g, "]") + "=" + encodeURIComponent(t))).join("&");
            return t + "//" + s + n + (r.length ? "?" : "") + r + a
        }
        const Et = e => 0 === (0, L.X)(e).length,
            Ot = (e, t) => e === t.length - 1;

        function Mt(e, t) {
            return Xe(e, t) ? t.filter((t => t !== e)) : (0, Ne.R)(e, t)
        }
        const Dt = e => t => Math.round(t / e) * e;
        var Ht = s(1142);
        const Ft = (e, t) => {
            const s = t.length;
            let n = 0;
            for (; n < s && e(t[n]);) n += 1;
            return t.slice(n)
        };
        var Zt = s(163);
        const Lt = (e, t) => {
                let s = t.length;
                for (; 0 < s && e(t[s - 1]);) s -= 1;
                return t.slice(0, s)
            },
            Bt = (e, t) => t.reduce(((t, s) => (Xe(s, e) || t.push(s), t)), e.slice()),
            zt = e => {
                if (0 >= e) return "0 B";
                const t = Math.floor(Math.log(e) / Math.log(1024));
                return parseFloat((e / 1024 ** t).toFixed(1)) + " " + ["B", "KB", "MB", "GB"][t]
            },
            Ut = e => {
                const {
                    length: t
                } = e, s = [
                    [],
                    []
                ];
                for (let n = 0; n < t; n += 1) {
                    const [t, a] = e[n];
                    s[0].push(t), s[1].push(a)
                }
                return s
            };

        function Wt(e) {
            return e.find(dt)
        }
        const Gt = async (e, t) => {
            const s = await (0, Ue.allPromises)(e, t);
            return t.filter(((e, t) => s[t]))
        }, Vt = new Map, qt = e => {
            var t;
            const n = Vt.get(e);
            if (n) return n;
            const a = {
                    numeric: !0
                },
                o = void 0 !== (null == (t = s.g.Intl) ? void 0 : t.Collator) ? new s.g.Intl.Collator(e, a) : {
                    compare: (t, s) => "function" == typeof t.localeCompare ? t.localeCompare(s, e, a) : t === s ? 0 : t < s ? -1 : 1
                };
            return Vt.set(e, o), o
        };

        function Qt(e) {
            const t = qt(e);
            return (e, s) => t.compare(e, s)
        }

        function Yt(e, t) {
            const s = Qt(t);
            return (t, n) => s(e(t), e(n))
        }

        function Jt(e, t) {
            const s = Qt(t);
            return (t, n) => -s(e(t), e(n))
        }
        var Kt = s(1433);

        function $t(e, t) {
            return "ascending" === t ? (0, i.z)(e) : (0, c.C)(e)
        }

        function Xt(e, t, s) {
            return "ascending" === t ? Yt(e, s) : Jt(e, s)
        }

        function es(e, t) {
            return (e || t) && !(e && t)
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            AsyncResourceCache: () => _,
            BuiltInErrorCodes: () => S.Vw,
            MemoryResourceStorage: () => C,
            Mutex: () => T,
            NozbeError: () => S.k,
            PROD_CONSOLE: () => a.Z,
            PROD_CONSOLE_REASON: () => a.p,
            appBuildDate: () => v,
            appVersion: () => y.Z,
            defer: () => k,
            determineErrorCode: () => S.lN,
            devMeasureTime: () => o.devMeasureTime,
            devMeasureTimeAsync: () => o.devMeasureTimeAsync,
            diagnosticError: () => S.y4,
            getPreciseTime: () => o.getPreciseTime,
            hasFeature: () => n.Z,
            hasFeatureOnProd: () => n.i,
            invariant_DONOTUSE: () => i.Z,
            isElectron: () => p.Z,
            isMAS: () => h,
            isPWA: () => m.Z,
            lazy: () => r.default,
            logError: () => S.H,
            makeDecorator: () => o.makeDecorator,
            nextTag: () => l,
            platform: () => u.Z,
            platformName: () => f,
            platformSelect: () => g,
            randomId: () => o.randomId,
            testIds: () => w,
            toWritableArray: () => R,
            wrapError: () => S.Jn
        });
        var n = s(210),
            a = s(95),
            o = s(49),
            r = s(174),
            i = s(1509);
        let c = 0;

        function l() {
            return c += 1, c
        }
        var d, u = s(1156),
            m = s(794);
        const h = Boolean(null == (d = globalThis.electron) ? void 0 : d.isMacAppStore);
        var p = s(345);

        function g(e) {
            return "web" in e ? e.web : e.default
        }
        const f = "web";
        var b, y = s(1049);
        const v = Number((null == (b = globalThis.document.body) ? void 0 : b.dataset.compiledAt) || 0);
        const w = s(163).default;

        function k() {
            const e = {};
            return e.promise = new Promise(((t, s) => {
                e.resolve = t, e.reject = s
            })), e
        }
        var x = s(4);
        const j = Symbol("MutexTimeout");
        class T {
            constructor(e) {
                this._pendingRequests = [], this._deadlockTimeout = null == e ? void 0 : e.deadlockTimeout, this._deadlockHandler = null == e ? void 0 : e.onDeadlock
            }
            async runExclusively(e) {
                const t = await this.acquireLock();
                try {
                    await e()
                } finally {
                    t()
                }
            }
            async acquireLock() {
                return await new Promise((e => {
                    1 === this._pendingRequests.push(e) && this._dispatch()
                }))
            }
            async _dispatch() {
                const [e] = this._pendingRequests;
                invariant(e, "Mutex expected a lock request");
                const t = new Promise((t => {
                        e(t)
                    })),
                    s = this._deadlockTimeout ? (0, x.delay)(this._deadlockTimeout).then((() => j)) : new Promise(x.noop);
                var n;
                await Promise.race([t, s]) === j && (null == (n = this._deadlockHandler) || n.call(this, new Error("Possible deadlock detected")));
                this._pendingRequests.shift(), this._pendingRequests.length && this._dispatch()
            }
        }
        var S = s(305),
            P = s(8);
        class _ {
            constructor({
                fetcher: e,
                storage: t,
                logger: s
            }) {
                this._fetching = new Map, this._fetcher = e, this._fetched = t, this._logger = s
            }
            read(e) {
                return this._fetched.get(e)
            }
            has(e) {
                return this._fetched.has(e)
            }
            fetch(e, t) {
                const s = this.read(e);
                var n;
                if (s) return null == (n = this._logger) || n.call(this, "Using cached resource", e), P.of(s);
                const a = this._fetching.get(e);
                var o;
                if (a) return null == (o = this._logger) || o.call(this, "Using inflight resource", e), a.subject;
                return this._createResourceFetch(e, t).subject
            }
            abort(e) {
                const t = this._fetching.get(e);
                t && (t.abortController.abort(), this._fetching.delete(e))
            }
            clear() {
                this._fetched.clear(), this._fetching.forEach((e => {
                    e.abortController.abort()
                })), this._fetching.clear()
            }
            _createResourceFetch(e, t) {
                const s = {
                    subject: new P.Subject,
                    abortController: new AbortController
                };
                return this._fetchResource(e, t, s), s
            }
            async _fetchResource(e, t, s) {
                var n;
                null == (n = this._logger) || n.call(this, "Fetching resource", e), this._fetching.set(e, s);
                const {
                    subject: a,
                    abortController: o
                } = s;
                try {
                    var r;
                    const s = await this._fetcher(e, o.signal, t);
                    await this._fetched.set(e, s), a.next(s), a.complete(), null == (r = this._logger) || r.call(this, "Fetched resource", e)
                } catch (t) {
                    var i;
                    if ("AbortError" === t.name) null == (i = this._logger) || i.call(this, "Aborted fetching resource", e);
                    else a.error(t)
                } finally {
                    this._fetching.delete(e)
                }
            }
        }
        class C {
            get entries() {
                return Array.from(this._storage.entries())
            }
            constructor(e = {}) {
                this._storage = new Map, this._options = e
            }
            get(e) {
                return this._storage.get(e)
            }
            has(e) {
                return this._storage.has(e)
            }
            set(e, t) {
                var s, n;
                this._performCleanup(), null == (s = (n = this._options).onAddResource) || s.call(n, [e, t]), this._storage.set(e, t)
            }
            clear() {
                const {
                    onRemoveResource: e
                } = this._options;
                e && this.entries.forEach((t => {
                    e(t)
                })), this._storage.clear()
            }
            _performCleanup() {
                const {
                    cleanup: e
                } = this._options;
                if (!e) return;
                const {
                    maxCachedSize: t,
                    getEntrySize: s,
                    onCleanup: n
                } = e, {
                    onRemoveResource: a
                } = this._options, o = this.entries;
                if ((0, x.sum)(o.map((e => s(e)))) <= t) return;
                const r = n(o),
                    i = new Map(r);
                a && o.forEach((e => {
                    const [t] = e;
                    i.has(t) || a(e)
                })), this._storage = i
            }
        }

        function R(e) {
            return e
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            u_: () => be,
            vR: () => d.vR,
            P9: () => d.P9,
            LU: () => fe
        });
        var n = s(52),
            a = s(0),
            o = s(113),
            r = s(4);
        const i = 20,
            c = ({
                target: e,
                contentDimensions: t,
                innerWindowHeight: s,
                innerWindowWidth: n,
                hasArrow: a,
                boundTo: o,
                minHeight: c,
                minWidth: l
            }) => {
                const {
                    width: d,
                    left: u,
                    top: m,
                    bottom: h
                } = e.getBoundingClientRect(), p = a ? 8 : 0, g = s - h - i - p > Math.max(t.height, c), f = m - p - i > Math.max(t.height, c), b = u + d / 2, y = ((e, t, s) => r.when(r.greaterThan(s - 40), r.always(s - 40))(t > e ? t : e))(t.width, l, n), v = (k = f, (w = g) || k ? w ? {
                    top: Math.max(i, h + p)
                } : {
                    bottom: s - m + p
                } : {
                    top: i
                });
                var w, k;
                const x = r.cond([
                        [r.identical("left"), r.always(u)],
                        [r.identical("right"), r.always(u - y + d)],
                        [r.T, r.always(b - y / 2)]
                    ]),
                    j = r.greaterThan(n - y - i),
                    T = r.lessThan(0),
                    S = r.cond([
                        [j, r.always(n - y - i)],
                        [T, r.always(i)],
                        [r.T, r.identity]
                    ]),
                    P = r.pipe(x, S)(o),
                    _ = r.when(r.lessThan(c), r.always(c)),
                    C = v.top || 0,
                    R = r.lessThan(24),
                    A = r.greaterThan(y - 24),
                    I = r.cond([
                        [r.always(!f && !g), r.always(void 0)],
                        [R, r.always(24)],
                        [A, r.always(y - 24)],
                        [r.T, r.identity]
                    ]);
                return Object.assign({}, v, {
                    left: P,
                    height: _(g || f ? g ? s - C - i : m - p - i : s - 40),
                    width: y,
                    isBoundToTop: !g && f,
                    arrowLeft: I(b - P)
                })
            },
            l = e => "right" === e.placement ? (({
                target: e,
                innerWindowHeight: t,
                innerWindowWidth: s,
                hasArrow: n,
                boundTo: a,
                placement: o,
                minWidth: r,
                minHeight: l,
                contentDimensions: d
            }) => {
                const {
                    width: u,
                    right: m,
                    top: h,
                    left: p,
                    bottom: g
                } = e.getBoundingClientRect(), f = s - m - i - 4 > r;
                if (!(p - i > r || f)) return c({
                    target: e,
                    innerWindowHeight: t,
                    innerWindowWidth: s,
                    hasArrow: n,
                    boundTo: a,
                    placement: o,
                    minWidth: r,
                    minHeight: l,
                    contentDimensions: d
                });
                const b = t - h - i > l,
                    y = b ? t - h - i : g - i,
                    v = f ? {
                        left: m + 4
                    } : {
                        right: s - m + u + 4
                    };
                return Object.assign({
                    left: v.left || void 0,
                    right: v.right || void 0
                }, t - i < l ? {
                    top: i,
                    bottom: i
                } : b ? {
                    top: Math.max(0, h)
                } : {
                    bottom: t - g
                }, {
                    height: y
                })
            })(e) : "bottom" === e.placement ? c(e) : null;
        var d = s(307);
        s(2), s(3);
        const u = s(430);
        var m = s(1);
        const h = 40 + (a.Misc.isElectron ? 48 : 0),
            p = a.Hocs.compose(a.Hocs.memo)((e => {
                const {
                    onClose: t,
                    onDismiss: s,
                    onOverlayPress: n = s,
                    size: r,
                    minWidth: i = 200,
                    minHeight: c = 190,
                    maxHeight: p,
                    maxWidth: g = 500,
                    boundTo: f = "center",
                    placement: b = "bottom",
                    level: y = 0,
                    children: v,
                    hasArrow: w = !0,
                    isDesktopModal: k,
                    onKeyDownCapture: x,
                    isClosingDisabled: j,
                    topPaletteStyle: T,
                    target: S,
                    isFloating: P,
                    shouldAnimateOverlay: _ = !0
                } = e, C = a.Hooks.useServices(), [R, A] = a.React.useState(null), I = a.Hooks.useLayoutDangerous(), N = !k && S && S.current && R && l({
                    target: S.current,
                    contentDimensions: {
                        height: R.height,
                        width: 300
                    },
                    innerWindowHeight: I.height,
                    innerWindowWidth: I.width,
                    hasArrow: w,
                    boundTo: f,
                    placement: b,
                    minWidth: i,
                    minHeight: c
                }), E = (() => {
                    if ("fullscreen" === r || k) return p ? Math.min(p, C.scene.webWindow.innerHeight) : I.height - h;
                    const e = N && N.height || 0;
                    return p && e > p ? p : e
                })(), O = (() => {
                    if (("fullscreen" === r || k) && c) return Math.min(c, C.scene.webWindow.innerHeight)
                })(), M = i + 40 > I.width ? I.width - 40 : i, D = "fullscreen" === r ? I.width - 40 : g, {
                    left: H,
                    top: F,
                    bottom: Z,
                    width: L,
                    arrowLeft: B,
                    right: z,
                    isBoundToTop: U
                } = N || {}, W = (0, d.Fz)(), G = a.React.useCallback((e => {
                    j || t(e)
                }), [j, t]), V = a.ReactUtils.unlessImeEvent((e => {
                    "Escape" === e.key && G(e)
                }));
                return a.Hooks.useEventListener({
                    eventName: "keydown",
                    handler: e => {
                        x ? x(e) : V(e)
                    }
                }), (0, m.jsx)(o.GR, {
                    name: "Modal",
                    children: (0, m.jsxs)("div", {
                        className: (N ? "" : u.screenCentered) + (T ? " " + u.topPalette : ""),
                        children: [(0, m.jsxs)("div", {
                            className: u.container + (!k && F ? " " + u.withMenuAnimation : "") + (k || F ? "" : " " + u.withTopMenuAnimation),
                            style: {
                                top: T && a.Misc.isElectron ? 48 : F,
                                bottom: Z,
                                right: z,
                                left: H,
                                zIndex: 90 + 11 * y
                            },
                            children: [(0, m.jsx)("div", {
                                className: u.content + (N ? "" : " " + u.contentCentered) + (N || k ? "" : " " + u.contentHidden),
                                children: (0, m.jsx)("div", {
                                    className: u.inner + (k ? " " + u.innerDesktop : ""),
                                    style: {
                                        width: L,
                                        maxHeight: E || "initial",
                                        minHeight: O,
                                        minWidth: M,
                                        maxWidth: D
                                    },
                                    ref: e => {
                                        e && !k && setTimeout((() => {
                                            const t = p ? Math.min(e.scrollHeight, p) : e.scrollHeight,
                                                s = g ? Math.min(e.scrollWidth, g) : e.scrollWidth;
                                            t === (null == R ? void 0 : R.height) && s === (null == R ? void 0 : R.width) || A({
                                                width: s,
                                                height: t
                                            })
                                        }), 0)
                                    },
                                    children: v(G)
                                })
                            }), w && B ? (0, m.jsx)("div", {
                                className: u.arrowContainer + (U ? " " + u.arrowContainerBottom : ""),
                                onClick: G,
                                children: (0, m.jsx)("div", {
                                    className: u.arrow + (U ? " " + u.arrowBottom : ""),
                                    style: {
                                        left: B
                                    }
                                })
                            }) : null]
                        }), (0, m.jsx)("div", {
                            className: u.overlay + (k && !_ ? " " + u.overlayBlack : "") + (k && _ ? " " + u.overlayBlackAnimated : ""),
                            style: Object.assign({
                                zIndex: 80 + 11 * y
                            }, P ? {
                                borderRadius: 20
                            } : void 0),
                            onClick: n || G
                        })]
                    }, W)
                })
            })),
            g = ["onClose", "isClosingDisabled", "isDesktopModal", "size", "minWidth", "children", "isFloating", "level", "onDismiss", "shouldAnimateOverlay", "__forwardedRef", "target"],
            f = e => {
                const {
                    outerRef: t,
                    value: s,
                    children: n
                } = e;
                return a.React.useImperativeHandle(t, (() => ({
                    closeAnimated: s.closeAnimated,
                    expand: s.expand
                }))), (0, m.jsx)(d.tC.Provider, {
                    value: s,
                    children: n
                })
            },
            b = a.Hocs.compose()((e => {
                const {
                    onClose: t,
                    isClosingDisabled: s = !1,
                    isDesktopModal: a,
                    size: o = "content",
                    minWidth: r = 300,
                    children: i,
                    isFloating: c,
                    level: l,
                    onDismiss: d,
                    shouldAnimateOverlay: u,
                    __forwardedRef: h,
                    target: b
                } = e, y = (0, n.Z)(e, g);
                return (0, m.jsx)(p, Object.assign({
                    onClose: t,
                    onDismiss: d,
                    size: o,
                    isClosingDisabled: s,
                    isDesktopModal: null != a ? a : !b,
                    minWidth: r,
                    isFloating: c,
                    level: l,
                    shouldAnimateOverlay: u,
                    target: b
                }, y, {
                    className: e.className,
                    style: e.style,
                    children: (e, n) => (0, m.jsx)(f, {
                        outerRef: h,
                        value: {
                            closeAnimated: e,
                            expand: n,
                            onClose: t,
                            isClosingDisabled: s,
                            isFloating: c,
                            size: o,
                            onDismiss: d,
                            level: l
                        },
                        children: i
                    })
                }))
            })),
            y = a.React.forwardRef(((e, t) => (0, m.jsx)(b, Object.assign({}, e, {
                __forwardedRef: t
            }))));
        var v = s(862),
            w = s(22),
            k = s(18);
        const x = s(23).identityElement,
            j = s(437),
            {
                AnimatedView: T
            } = a.Styling,
            S = e => {
                var t, s, n;
                const {
                    children: o,
                    isPickerHeader: r,
                    right: i,
                    queryText: c,
                    onQueryChange: l,
                    isSearchOpen: u,
                    canCancelSearch: h,
                    openSearch: p,
                    onCancelSearch: g,
                    onSearchFocus: f,
                    onSearchSubmit: b,
                    adjustFontSizeToFit: y = !0,
                    showLeftIcon: T = !0,
                    leftIconColor: S = "onBackground3",
                    leftIconAccessibilityLabel: P,
                    helpPageUrl: _
                } = e, C = a.Hooks.useIntl(), {
                    isClosingDisabled: R,
                    closeAnimated: A,
                    onDismiss: I
                } = (0, d.vR)(), N = !!l && !u, E = null != (t = e.isDraggingDisabled) ? t : R, O = R ? void 0 : "b", M = R ? void 0 : I || A, D = null != (s = e.leftIcon) ? s : O, H = null != (n = e.onLeftIconPress) ? n : M;
                return (0, m.jsx)(x, {
                    isDraggingDisabled: E,
                    children: (0, m.jsxs)("div", {
                        className: j.headerContainer + (u ? " " + j.headerContainer_withSearch : ""),
                        children: [(0, m.jsxs)("div", {
                            className: j.wrapper + (r ? " " + j.wrapper_pickerHeader : ""),
                            children: [T && (!r || P) && D ? (0, m.jsx)("div", {
                                className: j.iconContainer + " " + j.leftIconContainer,
                                children: (0, m.jsx)(w.default, {
                                    name: D,
                                    onPress: H,
                                    iconSize: 22,
                                    color: S,
                                    accessibilityLabel: null != P ? P : C.f.fh
                                })
                            }) : (0, m.jsx)("div", {
                                className: j.iconPlaceholder
                            }), (0, m.jsxs)("div", {
                                className: j.middle,
                                children: [(0, m.jsx)(k.default, {
                                    className: j.text + (r ? " " + j.text_pickerHeader : ""),
                                    adjustsFontSizeToFit: y,
                                    children: o
                                }), _ ? (0, m.jsx)(w.default, {
                                    name: "Ų",
                                    onPress: () => a.ReactUtils.openUrl(_),
                                    size: 20,
                                    hitSlop: {
                                        left: 8,
                                        right: 8,
                                        top: 8,
                                        bottom: 8
                                    },
                                    iconSize: 18,
                                    color: "onBackground3",
                                    accessibilityLabel: C.f.fC
                                }) : null]
                            }), i ? (0, m.jsx)("div", {
                                className: j.iconContainer + " " + j.rightIconContainer,
                                children: i
                            }) : null, N ? (0, m.jsx)("div", {
                                className: j.iconContainer + " " + j.rightIconContainer,
                                children: (0, m.jsx)(w.default, {
                                    name: "ƅ",
                                    onPress: p,
                                    iconSize: 22,
                                    color: "onBackground3",
                                    accessibilityLabel: C.f.fT
                                })
                            }) : null, i || N ? null : (0, m.jsx)("div", {
                                className: j.iconPlaceholder
                            })]
                        }), u && l ? (0, m.jsx)("div", {
                            className: j.searchContainer,
                            children: (0, m.jsx)(v.Z, {
                                query: c,
                                onFocus: f,
                                onSubmit: b,
                                onQueryChange: l,
                                onCancelSearch: g,
                                canCancelSearch: h,
                                autoCorrect: !1,
                                inputProps: {
                                    autoCapitalize: "none"
                                }
                            })
                        }) : null]
                    })
                })
            };
        var P = s(438),
            _ = s(440),
            C = s(304);
        const R = s(446),
            A = "row",
            I = a.Hocs.compose()((e => {
                const {
                    direction: t = A,
                    spacing: s = 8,
                    equalSizeButtons: n = !0,
                    children: o
                } = e;
                return (0, m.jsx)(C.QD, {
                    className: R.root + " " + (e.className || ""),
                    style: Object.assign({
                        gap: s,
                        flexDirection: t
                    }, e.style),
                    children: a.ReactUtils.flattenChildren(o).map(((e, t) => (0, m.jsx)("div", {
                        className: R.buttonWrapper + (n ? " " + R.buttonWrapperEqualSize : ""),
                        children: e
                    }, a.ReactUtils.getChildNodeKey(e, t))))
                })
            }));
        var N = s(12);
        const E = s(447),
            O = 20,
            M = a.Hocs.compose()((e => {
                const {
                    spacing: t = O,
                    children: s
                } = e;
                return (0, m.jsx)(I, {
                    className: E.root,
                    spacing: t,
                    equalSizeButtons: !1,
                    children: s
                })
            }));
        var D = s(57);
        const H = s(449),
            F = ({
                threshold: e,
                message: t,
                color: s
            }) => {
                const n = (e => {
                    const [t, s] = a.React.useState(!1), n = a.React.useRef();
                    return a.React.useEffect((() => (n.current = setTimeout((() => s(!0)), e), () => {
                        clearTimeout(n.current)
                    })), [e]), t
                })(e);
                return (0, m.jsx)("div", {
                    className: H.root,
                    children: n ? (0, m.jsxs)(m.Fragment, {
                        children: [(0, m.jsx)(C.QD, {
                            children: (0, m.jsx)(D.default, {
                                color: s
                            })
                        }), t ? (0, m.jsx)(C.xd, {
                            centered: !0,
                            children: t
                        }) : null]
                    }) : null
                })
            },
            Z = a.Hocs.compose()((e => {
                const t = a.Hooks.useIntl(),
                    {
                        loadingThreshold: s = 300,
                        children: n,
                        loadingMsg: o = t.f.e$,
                        successMsg: r,
                        errorMsg: i,
                        renderSuccess: c,
                        renderError: l,
                        renderLoading: d,
                        spinnerColor: u
                    } = e,
                    {
                        isLoading: h,
                        isSuccess: p,
                        isError: g
                    } = (e => {
                        if (e.status) {
                            const {
                                status: t
                            } = e;
                            return {
                                isLoading: "loading" === t,
                                isSuccess: "success" === t,
                                isError: "error" === t
                            }
                        }
                        if (e.state) {
                            const {
                                state: t
                            } = e;
                            return {
                                isLoading: t.isBusy,
                                isSuccess: t.isSuccess,
                                isError: t.isError
                            }
                        }
                        const {
                            isLoading: t,
                            isSuccess: s,
                            isError: n
                        } = e;
                        return {
                            isLoading: t,
                            isSuccess: !!s,
                            isError: !!n
                        }
                    })(e);
                return h ? d && d() || (0, m.jsx)(F, {
                    threshold: s,
                    message: o,
                    color: u
                }) : p ? c && c() || r && (0, m.jsx)(C.bA, {
                    children: r
                }) || n || null : g ? l && l() || (0, m.jsx)(C.fZ, {
                    children: i || t.f.a3
                }) : n || null
            }));
        var L = s(40);
        const B = s(450),
            z = a.Hocs.compose()((e => {
                const {
                    stack: t,
                    fillMaxSize: s
                } = e;
                return (0, m.jsx)(C.QD, {
                    className: B.root + " " + (e.className || ""),
                    style: e.style,
                    children: (0, m.jsx)(L.default, {
                        layers: t,
                        fillMaxSize: s
                    })
                })
            }));
        var U = s(201);
        const W = s(458),
            G = a.Hocs.compose()((e => (0, m.jsx)(C.QD, {
                className: e.className,
                style: e.style,
                children: (0, m.jsx)(U.Z, Object.assign({
                    className: W.switcher
                }, e))
            })));
        var V = s(68),
            q = s(444);
        const Q = a.Hocs.compose()((e => {
            const {
                asSection: t,
                topBarInset: s = 12,
                bottomBarInset: n = 12,
                children: a
            } = e;
            return (0, m.jsx)(V.Z, {
                className: (t ? q.Z.section : "") + " " + (e.className || ""),
                style: e.style,
                isAbsoluteFilled: !1,
                reachesTopOfScreen: !1,
                reachesBottomOfScreen: !1,
                topBarInset: s,
                bottomBarInset: n,
                children: a
            })
        }));
        var Y = s(352);
        const J = s(460),
            K = a.Hocs.compose()((e => {
                const {
                    children: t,
                    maxLines: s
                } = e;
                return (0, m.jsx)("div", {
                    className: J.root + " " + (e.className || ""),
                    style: e.style,
                    children: (0, m.jsx)(C.iO, {
                        className: J.text,
                        maxLines: s,
                        children: t
                    })
                })
            })),
            $ = s(461),
            X = a.Hocs.compose()((e => {
                const {
                    count: t
                } = e;
                return 1 > t ? null : (0, m.jsx)(K, {
                    className: $.root,
                    children: String(t)
                })
            })),
            ee = s(462),
            te = a.Hocs.compose()((e => {
                const {
                    children: t,
                    isSelectable: s
                } = e;
                return (0, m.jsx)("span", {
                    className: ee.value + " " + (e.className || ""),
                    style: e.style,
                    children: t
                })
            }));
        var se = s(157);
        const ne = s(464),
            ae = a.Hocs.compose()((e => {
                const {
                    children: t,
                    variant: s
                } = e, n = "secure" === s ? "•".repeat(t.length) : t;
                return (0, m.jsxs)("div", {
                    className: ne.root,
                    children: [(0, m.jsx)(k.default, {
                        className: ne.value + ("selectable" === s ? " " + ne.selectable : "") + " " + (e.className || ""),
                        style: e.style,
                        children: n
                    }), (0, m.jsx)(se.default, {
                        className: ne.button,
                        valueToCopy: t
                    })]
                })
            }));
        var oe = s(53);
        const re = s(465),
            ie = e => {
                const {
                    onDone: t,
                    onCancel: s,
                    isDoneDisabled: n,
                    cancelLabel: o,
                    doneLabel: r,
                    isFullWidth: i = !0
                } = e, c = a.Hooks.useIntl();
                return (0, m.jsxs)("div", {
                    className: re.buttonContainer,
                    children: [(0, m.jsx)(oe.default, {
                        className: re.button,
                        label: null != o ? o : c.f.fe,
                        onPress: s,
                        withFlexOnWeb: i,
                        hasMinWidth: !i
                    }), t ? (0, m.jsx)(oe.default, {
                        className: re.button,
                        label: null != r ? r : c.f.fr,
                        onPress: t,
                        type: "defaultAction",
                        isDisabled: n,
                        withFlexOnWeb: i,
                        hasMinWidth: !i
                    }) : null]
                })
            };
        var ce = s(919),
            le = s(11);
        const de = s(467),
            ue = a.Hocs.compose()((e => {
                const {
                    isSelected: t,
                    onPress: s
                } = e, n = a.Hooks.useIntl();
                return (0, m.jsx)("div", {
                    className: de.root,
                    children: (0, m.jsx)(le.Z, {
                        className: de.button + (t ? " " + de.buttonSelected : ""),
                        onPress: s,
                        children: (0, m.jsx)(k.default, {
                            className: de.text,
                            children: n.f.xS
                        })
                    })
                })
            })),
            me = s(468),
            he = a.Hocs.compose()((e => {
                const {
                    colors: t,
                    selectedColor: s,
                    onSelectColor: n
                } = e, a = !0 === e.allowNoColor ? (0, m.jsx)(ue, {
                    isSelected: !s,
                    onPress: () => e.onSelectColor(null)
                }) : null;
                return (0, m.jsxs)(C.QD, {
                    className: me.root,
                    children: [t.map((e => (0, m.jsx)(ce.Z, {
                        color: e,
                        isSelected: e === s,
                        onPress: () => n(e)
                    }, e))), a]
                })
            })),
            pe = ["onClose", "onWillClose", "onKeyDownCapture", "onOverlayPress", "onSwipeDown", "onDismiss", "size", "level", "placement", "minWidth", "maxWidth", "minHeight", "hasHandle", "isDesktopModal", "isFloating", "useCommentBoxStyle", "isClosingDisabled", "shouldDismissKeyboardOnClose", "target", "hasArrow"],
            ge = e => pe.includes(e),
            fe = e => t => function(s) {
                const [n, o] = (e => {
                    const t = Object.keys(e);
                    return a.FP.partition(ge, t).map((t => a.FP.pick(t, e)))
                })(s);
                return (0, m.jsx)(y, Object.assign({}, e, n, {
                    children: a.React.createElement(t, o)
                }))
            },
            be = Object.assign(y, {
                Header: S,
                Content: P.Z,
                List: _.Z,
                Buttons: I,
                Actions: M,
                ActionButton: e => (0, m.jsx)(N.default, Object.assign({
                    className: E.button + " " + (e.className || ""),
                    style: e.style,
                    isFullWidth: !1
                }, e)),
                Loader: Z,
                IconStack: z,
                Switch: G,
                Emphasis: C.wE,
                Error: C.fZ,
                Paragraph: C.xd,
                Heading: Y.Z,
                HeadingSublabel: K,
                HeadingCounter: X,
                Section: C.QD,
                Success: C.bA,
                Text: C.iO,
                Scroll: Q,
                SelectableValue: te,
                CopyValue: ae,
                CancelDone: ie,
                ColorSection: he
            })
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            BehaviorSubject: () => o.BehaviorSubject,
            Observable: () => n.Observable,
            ReplaySubject: () => r.ReplaySubject,
            Subject: () => a.Subject,
            cacheWhileConnected: () => V.cacheWhileConnected,
            cachedValue: () => ee,
            catchError: () => _.catchError,
            combineLatest: () => Q,
            combineLatestObject: () => J,
            combineLatestTuples: () => K,
            concat: () => I.z,
            concatAll: () => N.u,
            concatMap: () => P.b,
            debounceTime: () => z.b,
            defer: () => b.defer,
            delay: () => Z.g,
            delaySubscription: () => se,
            delayWhen: () => F.j,
            dematerialize: () => G.D,
            distinctUntilChanged: () => E.distinctUntilChanged,
            distinctUntilKeyChanged: () => O.g,
            distinctUntilKeysChanged: () => ne,
            doOnErrorComplete: () => ae,
            exhaustMap: () => B.z,
            filter: () => w.h,
            first: () => R.P,
            from: () => h.D,
            fromEvent: () => p.R,
            interval: () => m.F,
            map: () => y.map,
            mapTo: () => D.h,
            materialize: () => W.i,
            merge: () => d.merge,
            mergeMap: () => L.z,
            never: () => u.F,
            nowAndEveryDay: () => le,
            nowAndEveryHour: () => pe,
            nowAndEveryMinute: () => be,
            of: () => l.of,
            publishReplayLatestWhileConnected: () => V.publishReplayLatestWhileConnected,
            retryWhen: () => H.a,
            scan: () => j.R,
            share: () => U.B,
            skip: () => T.T,
            startWith: () => k.startWith,
            switchMap: () => S.switchMap,
            take: () => x.q,
            takeFirst: () => ve,
            takeLast: () => we,
            takeWhile: () => v.o,
            tap: () => C.b,
            throttleTime: () => M.throttleTime,
            throwError: () => f._,
            timeout: () => A.V,
            timer: () => g.H,
            wrap: () => ye
        });
        var n = s(59),
            a = s(100),
            o = s(390),
            r = s(1157),
            i = s(1513),
            c = s(1515),
            l = s(264),
            d = s(1158),
            u = s(1516),
            m = s(1517),
            h = s(116),
            p = s(1518),
            g = s(183),
            f = s(1438),
            b = s(1159),
            y = s(115),
            v = s(1160),
            w = s(1439),
            k = s(391),
            x = s(1519),
            j = s(1161),
            T = s(1162),
            S = s(392),
            P = s(1163),
            _ = s(1164),
            C = s(1165),
            R = s(1166),
            A = s(1520),
            I = s(1167),
            N = s(818),
            E = s(265),
            O = s(1168),
            M = s(393),
            D = s(1521),
            H = s(1169),
            F = s(795),
            Z = s(1170),
            L = s(140),
            B = s(1171),
            z = s(1172),
            U = s(1173),
            W = s(1522),
            G = s(1523),
            V = s(85),
            q = s(1441);
        const Q = (...e) => function(e) {
            if (2 < e.length) return !1;
            const [t, s] = e;
            return !(s && (n = s, !(n && "function" == typeof n.schedule || function(e) {
                return e && "function" == typeof e
            }(s)))) && Array.isArray(t) && 0 === t.length;
            var n
        }(e) ? (0, l.of)([]) : (0, q.a)(...e);
        var Y = s(4);

        function J(e) {
            const t = Object.keys(e),
                s = Object.values(e);
            if (1 === t.length) {
                const e = t[0];
                return (0, h.D)(s[0]).pipe((0, y.map)((t => ({
                    [e]: t
                }))))
            }
            return Q(s).pipe((0, y.map)((e => (0, Y.zipObj)(t, e))))
        }

        function K(e) {
            const t = e.map((e => e[0])),
                s = e.map((e => e[1]));
            return Q(s).pipe((0, y.map)((e => (0, Y.zip)(t, e))))
        }
        var $ = s(19),
            X = s(164);

        function ee(e, t, s, a) {
            return n.Observable.create((n => {
                let o;
                const r = (0, $.localStorageKey)("__rx_cachedValue_" + t);
                return n.next(s), e.localStorage._getSync(r, (t => {
                    void 0 !== t && n.next(t), (0, X.R)((() => {
                        o = a.subscribe({
                            next(t) {
                                n.next(t), e.localStorage.set(r, t)
                            },
                            error(e) {
                                n.error(e)
                            },
                            complete() {
                                n.complete()
                            }
                        })
                    }))
                })), () => {
                    o && o.unsubscribe()
                }
            }))
        }
        var te = s(816);

        function se(e, t = te.b.async) {
            return s => (0, l.of)(0).pipe((0, Z.g)(e, t), (0, S.switchMap)((() => s)))
        }

        function ne(e) {
            return t => t.pipe((0, E.distinctUntilChanged)(((t, s) => e.every((e => t[e] === s[e])))))
        }

        function ae(e) {
            return (0, C.b)(void 0, e, e)
        }
        var oe = s(41),
            re = s(64);
        const ie = new a.Subject,
            ce = () => {
                setTimeout((function() {
                    ie.next(), ce()
                }), (0, oe.Z)((0, re.Z)(new Date, 1)).getTime() - Date.now())
            };

        function le() {
            return ie.pipe((0, k.startWith)(0))
        }
        ce();
        var de = s(1442),
            ue = s(820);
        const me = new a.Subject,
            he = () => {
                setTimeout((() => {
                    me.next(), he()
                }), (0, de.Z)((0, ue.Z)(new Date, 1)).getTime() - Date.now())
            };

        function pe() {
            return me.pipe((0, k.startWith)(0))
        }
        he();
        var ge = s(272),
            fe = s(1443);
        const be = () => (0, g.H)((0, ge.Z)((0, fe.Z)(new Date), 1), 6e4).pipe((0, k.startWith)(0));

        function ye(e) {
            return function(e) {
                return e instanceof n.Observable || function(e) {
                    return !!e && "object" == typeof e && !!e.subscribe && "function" == typeof e.subscribe && !!e.pipe && "function" == typeof e.pipe
                }(e)
            }(e) ? e : (0, l.of)(e)
        }

        function ve(e) {
            return (0, i.z)(e)
        }

        function we(e) {
            return (0, c.n)(e)
        }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0);
        s(2), s(3);
        const a = s(426);
        var o = s(1);
        const r = n.Hocs.compose()((e => {
                const {
                    webComponent: t = "button",
                    type: s = "button",
                    isDisabled: n,
                    children: r,
                    title: i,
                    __webFixBlurEventOrder: c,
                    __forwardedRef: l,
                    onMouseEnter: d,
                    onMouseMove: u,
                    onMouseLeave: m,
                    testId: h,
                    accessibilityLabel: p,
                    onPressExtraParam: g,
                    onContextMenu: f,
                    onWheel: b
                } = e, y = t => e.onPress && !n && e.onPress(t, g);
                return (0, o.jsx)(t, {
                    className: a.root + (n ? " " + a.disabled : "") + (n || !e.onPress ? " " + a.defaultCursor : "") + " " + (e.className || ""),
                    style: e.style,
                    ref: l,
                    type: "button" === t ? s : void 0,
                    disabled: "button" === t && n,
                    "aria-label": p,
                    title: i,
                    onMouseDown: c ? y : void 0,
                    onMouseUp: c ? t => e.onPressOut && !n && e.onPressOut(t) : void 0,
                    onClick: c ? void 0 : y,
                    onMouseEnter: d,
                    onMouseMove: u,
                    onMouseLeave: m,
                    onWheel: b,
                    onContextMenu: f,
                    "data-testid": h,
                    children: r
                })
            })),
            i = n.React.forwardRef(((e, t) => (0, o.jsx)(r, Object.assign({
                __forwardedRef: e.__forwardedRef || t
            }, e))))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(13),
            o = s(176),
            r = s(428),
            i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                isDisabled: t,
                isFullWidth: s,
                label: n,
                variant: c,
                onPress: l,
                marginTop: d,
                iconName: u,
                color: m,
                onPressExtraParam: h,
                iconPadding: p,
                subLabel: g,
                iconPosition: f = "left",
                modalWebTarget: b,
                type: y
            } = e, v = (0, o.uu)(m, c), w = u ? (0, i.jsx)(a.default, {
                style: {
                    paddingBottom: p,
                    bottom: p
                },
                name: u,
                color: v
            }) : null, k = e.right || (w && "right" === f ? w : null);
            return (0, i.jsxs)(o.ej, {
                className: (g ? r.Z.buttonWithSubLabel : "") + " " + (e.className || ""),
                style: Object.assign({
                    marginTop: (() => {
                        switch (d) {
                            case "small":
                                return 8;
                            case "medium":
                                return 12;
                            case "big":
                                return 20;
                            case "huge":
                                return 44;
                            default:
                                return
                        }
                    })()
                }, e.style),
                color: m,
                modalWebTarget: b,
                isDisabled: t,
                onPressExtraParam: h,
                variant: c,
                onPress: l,
                isFullWidth: s,
                type: y,
                children: [w && "left" === f ? w : null, (0, i.jsxs)("div", {
                    className: r.Z.labelContainer,
                    style: {
                        paddingLeft: w && "left" === f ? 10 : void 0,
                        paddingRight: w && "right" === f ? 10 : void 0
                    },
                    children: [(0, i.jsx)(o.oD, {
                        label: n,
                        color: v,
                        isDisabled: t
                    }), g ? (0, i.jsx)(o.oD, {
                        label: g,
                        color: v,
                        isDisabled: t
                    }) : null]
                }), k]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => v
        });
        var n = s(0),
            a = s(419),
            o = s.n(a),
            r = s(420),
            i = s.n(r),
            c = s(421),
            l = s.n(c);
        s(2), s(3);
        const d = s(425);
        var u = s(1);
        let m = null,
            h = null;
        const p = n.FP.piped(i(), n.FP.toPairs, n.FP.map((([e, t]) => [t, e])), n.FP.fromPairs),
            g = e => p[e.name] || e.name,
            f = e => {
                if (e.startsWith("illustrations_")) return "illustrations";
                const t = i()[e];
                return o().basic.includes(t) ? "basic" : "extra"
            },
            b = e => {
                const {
                    color: t,
                    opacity: s,
                    accessibilityLabel: a
                } = e, o = g(e), r = f(o), i = (() => {
                    if ("basic" === r) return l()[o];
                    if ("extra" === r) return m ? m[o] : null;
                    if ("illustrations" === r) return h ? h[o] : null;
                    throw new Error("unreachable")
                })(), c = e.size || 24;
                return (0, u.jsx)("span", {
                    className: d.root + " " + (e.className || ""),
                    style: Object.assign({
                        minWidth: c,
                        minHeight: c,
                        opacity: s
                    }, e.style),
                    children: (0, u.jsxs)("svg", {
                        className: d.icon,
                        width: c,
                        height: c,
                        fill: n.Styling.factoryColorOrLiteral(t || "purple"),
                        viewBox: "0 0 44 44",
                        enableBackground: "new 0 0 44 44",
                        children: [a ? (0, u.jsx)("title", {
                            children: a
                        }) : null, (0, u.jsx)("path", {
                            d: i
                        })]
                    })
                })
            },
            y = e => {
                const t = n.Hooks.useForceUpdate(),
                    a = n.Hooks.useIsMounted(),
                    o = () => {
                        a.current && t()
                    },
                    r = f(g(e));
                return "extra" !== r || m ? "illustrations" !== r || h || s.e(110).then(s.t.bind(s, 1483, 23)).then((e => {
                    h = e.default
                })).then(o) : s.e(429).then(s.t.bind(s, 1482, 23)).then((e => {
                    m = e.default
                })).then(o), b(e)
            },
            v = e => {
                const t = (e => {
                    if ("basic" === e) return !0;
                    if ("extra" === e) return !!m;
                    if ("illustrations" === e) return !!h;
                    throw new Error("unreachable")
                })(f(g(e)));
                return t ? b(e) : n.React.createElement(y, e)
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            allRoutes: () => G,
            getPathToCurrentTeamRoot: () => Ee,
            getPathToTaskDetails: () => Ie,
            getPathToTaskList: () => Ae,
            getRawPathToTaskDetails: () => Re,
            getRawPathToTaskList: () => Ce,
            limitedAccountAllowedRoutes: () => q,
            pathTaskIdRegex: () => Oe,
            pathTo: () => r,
            pathToActivity: () => me,
            pathToAppleSignInRedirect: () => ee,
            pathToCalendar: () => Ne,
            pathToClaimPurchase: () => re,
            pathToDevTools: () => le,
            pathToFinishCreateTeam: () => X,
            pathToGoogleSignInRedirect: () => te,
            pathToIncoming: () => ue,
            pathToInvite: () => ae,
            pathToJoin: () => ne,
            pathToJoinProject: () => oe,
            pathToLogin: () => K,
            pathToMessages: () => pe,
            pathToMigrateNP: () => se,
            pathToPriority: () => de,
            pathToProject: () => fe,
            pathToProjectTask: () => xe,
            pathToResetPassword: () => J,
            pathToResetPasswordRequest: () => Y,
            pathToRoot: () => Q,
            pathToSearch: () => ge,
            pathToSignup: () => $,
            pathToSingleTasks: () => he,
            pathToTag: () => je,
            pathToTaskInvite: () => ie,
            routeToAppleSignInRedirect: () => p,
            routeToClaimPurchase: () => P,
            routeToDevTools: () => W,
            routeToEmailChangeConfirm: () => x,
            routeToFinishCreateTeam: () => d,
            routeToGoogleSignInRedirect: () => g,
            routeToInvite: () => u,
            routeToJoin: () => m,
            routeToJoinProject: () => T,
            routeToJumpTo: () => A,
            routeToLogin: () => c,
            routeToLoginProvider: () => b,
            routeToMember: () => B,
            routeToMemberTask: () => z,
            routeToMessages: () => I,
            routeToMessagesThread: () => N,
            routeToMigrateNP: () => y,
            routeToNozbeSignInRedirect: () => f,
            routeToProject: () => H,
            routeToProjectTask: () => F,
            routeToPromotion: () => S,
            routeToQuickAdd: () => R,
            routeToRegisterConfirm: () => h,
            routeToResetPassword: () => w,
            routeToResetPasswordRequest: () => v,
            routeToRoot: () => i,
            routeToSignup: () => l,
            routeToSingleTasks: () => M,
            routeToSingleTasksTask: () => D,
            routeToTag: () => Z,
            routeToTagTask: () => L,
            routeToTaskId: () => U,
            routeToTaskInvite: () => _,
            routeToTaskList: () => E,
            routeToTaskListTask: () => O,
            routeToThirdParty: () => j,
            routeToWellKnownChangePassword: () => k,
            smartPathToMember: () => Se,
            smartPathToProject: () => be,
            smartPathToProjectSection: () => ye,
            smartPathToTag: () => Te,
            smartPathToTask: () => ve,
            smartPathToTaskId: () => we,
            smartPathToThread: () => ke,
            taskRoutes: () => V
        });
        var n = s(4);
        const a = e => e.path || e.id || e,
            o = e => "/" === e[0] ? e.slice(1) : e,
            r = (...e) => {
                return "/" === (t = e.map(n.pipe(a, o)).join("/"))[0] ? t : "/" + t;
                var t
            },
            i = "/",
            c = "/login",
            l = "/signup",
            d = "/signup/:registerId",
            u = "/join/:inviteId",
            m = "/j/:joinCode",
            h = "/confirm/:confirmId",
            p = "/apple-signin",
            g = "/google-signin",
            f = "/nozbe-signin",
            b = "/login_providers/:loginProviderToken",
            y = "/migrate_np",
            v = "/password_reset",
            w = "/password_reset/:tokenId",
            k = "/.well-known/change-password",
            x = "/confirm_email/:confirmId",
            j = "/third_party/:thirdPartyName",
            T = "/join_project/:projectInvitationToken",
            S = "/promotion",
            P = "/claim_purchase/:tokenId",
            _ = "/join_task/:taskInvitationToken",
            C = "/(teams|personal)/:teamId?",
            R = C + "/quick_add",
            A = C + "/jump_to",
            I = C + "/messages",
            N = I + "/tasks/:taskId",
            E = C + "/:taskListName(messages|priority|incoming|activity|single_tasks|calendar|search)",
            O = E + "/tasks/:taskId",
            M = C + "/single_tasks",
            D = M + "/tasks/:taskId",
            H = C + "/projects/:projectId",
            F = H + "/tasks/:taskId",
            Z = C + "/tags/:tagId",
            L = Z + "/tasks/:taskId",
            B = C + "/members/:memberId",
            z = B + "/tasks/:taskId",
            U = C + "/task_id/:refTaskId",
            W = C + "/devtools",
            G = [i, O, E, F, H, L, Z, z, B, u, h, x, d, l, m, w, v, k, W, U, c, j, T, _, R, A, p, g, b, y],
            V = [O, F, z, L],
            q = [i, m, u, U, _, M, D],
            Q = {
                path: i
            },
            Y = {
                path: r("password_reset")
            },
            J = e => ({
                path: r("password_reset", e)
            }),
            K = {
                path: c
            },
            $ = {
                path: l
            },
            X = {
                path: d
            },
            ee = {
                path: p
            },
            te = {
                path: g
            },
            se = {
                path: y
            },
            ne = e => ({
                path: r("j", e)
            }),
            ae = e => ({
                path: r("join", e)
            }),
            oe = e => ({
                path: r("join_project", e)
            }),
            re = e => ({
                path: r("claim_purchase", e)
            }),
            ie = e => ({
                path: r("join_task", e)
            }),
            ce = e => e.isTeam ? r("teams", e) : r("personal"),
            le = e => ({
                path: r(ce(e), "devtools")
            }),
            de = e => ({
                path: r(ce(e), "priority")
            }),
            ue = e => ({
                path: r(ce(e), "incoming")
            }),
            me = e => ({
                path: r(ce(e), "activity")
            }),
            he = e => ({
                path: r(ce(e), "single_tasks")
            }),
            pe = e => ({
                path: r(ce(e), "messages")
            }),
            ge = e => ({
                path: r(ce(e), "search")
            }),
            fe = (e, t) => ({
                path: r(ce(e), "projects", t)
            }),
            be = (e, t) => t.isSingleTasks ? he(e) : Object.assign({}, fe(e, t)),
            ye = (e, t, s) => {
                const n = be(e, t);
                return Object.assign({}, n, {
                    path: n.path + "#section=" + s.id
                })
            },
            ve = (e, t, s) => ({
                path: r(be(e, t), "tasks", s)
            }),
            we = (e, t) => ({
                path: r(ce(e), "task_id", t)
            }),
            ke = (e, t) => ({
                path: r(pe(e), "tasks", t)
            }),
            xe = (e, t, s) => ({
                path: r(fe(e, t), "tasks", s)
            }),
            je = (e, t) => ({
                path: r(ce(e), "tags", t)
            }),
            Te = (e, t) => Object.assign({}, je(e, t)),
            Se = (e, t) => ({
                path: r(ce(e), "members", t)
            }),
            Pe = e => e.teamId ? r("teams", e.teamId) : r("personal"),
            _e = e => {
                const {
                    projectId: t,
                    tagId: s,
                    memberId: n,
                    taskListName: a
                } = e;
                return t ? r("projects", t) : s ? r("tags", s) : n ? r("members", n) : a ? (e => r(e))(a) : ""
            },
            Ce = e => r(Pe(e), _e(e)),
            Re = (e, t) => r(Pe(e), _e(e), (e => r("tasks", e))(t)),
            Ae = e => ({
                path: Ce(e)
            }),
            Ie = (e, t) => ({
                path: Re(e, t)
            }),
            Ne = e => ({
                path: r(ce(e), "calendar")
            }),
            Ee = (e, t) => t ? Q : de(e),
            Oe = /\/tasks\/([^\/]+)/
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            o: () => i,
            w: () => r
        });
        var n = s(76);
        const a = n.tableName,
            o = n.columnName,
            r = {
                businesses: a("businesses"),
                businessMembers: a("business_members"),
                teams: a("teams"),
                projects: a("projects"),
                projectSections: a("project_sections"),
                projectAccesses: a("project_accesses"),
                projectEvents: a("project_events"),
                projectPositions: a("project_positions"),
                tasks: a("tasks"),
                taskRecurrences: a("task_recurrences"),
                taskAccesses: a("task_accesses"),
                taskPositions: a("task_positions"),
                teamMembers: a("team_members"),
                users: a("users"),
                tags: a("tags"),
                tagAssignments: a("tag_assignments"),
                memberGroups: a("member_groups"),
                projectGroups: a("project_groups"),
                groupAssignments: a("group_assignments"),
                comments: a("comments"),
                taskEvents: a("task_events"),
                reminders: a("reminders"),
                settings: a("settings"),
                attachments: a("attachments"),
                attachmentVersions: a("attachment_versions")
            },
            i = {
                id: o("id"),
                businesses: {
                    name: o("name"),
                    color: o("color"),
                    limits: o("limits"),
                    planInfo: o("plan_info"),
                    paymentInfo: o("payment_info")
                },
                businessMembers: {
                    businessId: o("business_id"),
                    userId: o("user_id"),
                    role: o("role"),
                    vacations: o("vacations")
                },
                teams: {
                    color: o("color"),
                    name: o("name"),
                    avatarId: o("avatar_url"),
                    businessId: o("business_id"),
                    isPersonal: o("is_personal"),
                    limits: o("limits"),
                    planInfo: o("plan_info"),
                    paymentInfo: o("payment_info"),
                    isShared: o("is_shared_team"),
                    sidebarPosition: o("sidebar_position")
                },
                projects: {
                    authorId: o("author_id"),
                    userColor: o("color"),
                    teamColor: o("team_color"),
                    createdAt: o("created_at"),
                    description: o("description"),
                    endedAt: o("ended_at"),
                    extra: o("extra"),
                    isFavorite: o("is_favorite"),
                    isOpen: o("is_open"),
                    isTemplate: o("is_template"),
                    isSingleTasks: o("is_single_actions"),
                    lastEventAt: o("last_event_at"),
                    lastSeenEventAt: o("last_seen_event_at"),
                    name: o("name"),
                    preferences: o("preferences"),
                    sidebarPosition: o("sidebar_position"),
                    teamId: o("team_id"),
                    sharedTeamId: o("shared_team_id")
                },
                projectSections: {
                    archivedAt: o("archived_at"),
                    createdAt: o("created_at"),
                    name: o("name"),
                    position: o("position"),
                    projectId: o("project_id")
                },
                projectAccesses: {
                    isManager: o("is_manager"),
                    memberId: o("member_id"),
                    projectId: o("project_id")
                },
                projectEvents: {
                    authorId: o("author_id"),
                    createdAt: o("created_at"),
                    projectId: o("project_id"),
                    type: o("type")
                },
                projectPositions: {
                    projectId: o("project_id"),
                    listId: o("list_id"),
                    position: o("position")
                },
                tasks: {
                    authorId: o("author_id"),
                    createdAt: o("created_at"),
                    commentsCached: o("comments_cached"),
                    dueAt: o("due_at"),
                    endedAt: o("ended_at"),
                    isAbandoned: o("is_abandoned"),
                    isAllDay: o("is_all_day"),
                    isFollowed: o("is_followed"),
                    lastActivityAt: o("last_activity_at"),
                    lastReviewedAt: o("last_reviewed_at"),
                    lastSeenActivityAt: o("last_seen_activity_at"),
                    missedRepeats: o("missed_repeats"),
                    name: o("name"),
                    type: o("type"),
                    extra: o("extra"),
                    priorityPosition: o("priority_position"),
                    projectId: o("project_id"),
                    projectPosition: o("project_position"),
                    projectSectionId: o("project_section_id"),
                    recurrenceId: o("recurrence_id"),
                    responsibleId: o("responsible_id"),
                    reviewReason: o("review_reason"),
                    reviewTriggeredAt: o("review_triggered_at"),
                    timeNeeded: o("time_needed"),
                    timeSpent: o("time_spent"),
                    recurrenceOriginAt: o("recurrence_origin_at")
                },
                taskAccesses: {
                    taskId: o("task_id"),
                    granterId: o("granter_id"),
                    granteeId: o("grantee_id"),
                    granteeType: o("grantee_type"),
                    granteeEmail: o("grantee_email")
                },
                taskRecurrences: {
                    currentTaskId: o("current_task_id"),
                    pattern: o("pattern"),
                    projectId: o("project_id")
                },
                taskPositions: {
                    taskId: o("task_id"),
                    listId: o("list_id"),
                    position: o("position")
                },
                teamMembers: {
                    alias: o("alias"),
                    description: o("description"),
                    isFavorite: o("is_favorite"),
                    role: o("role"),
                    sidebarPosition: o("sidebar_position"),
                    status: o("status"),
                    teamId: o("team_id"),
                    userId: o("user_id"),
                    contactInfo: o("contact_info"),
                    vacations: o("vacations")
                },
                users: {
                    avatarId: o("avatar_url"),
                    color: o("color"),
                    email: o("email"),
                    invitationEmail: o("invitation_email"),
                    isPlaceholder: o("is_placeholder"),
                    isLimited: o("is_limited"),
                    name: o("name"),
                    timeZone: o("time_zone"),
                    isMe: o("is_me")
                },
                tags: {
                    userColor: o("color"),
                    teamColor: o("team_color"),
                    icon: o("icon"),
                    isFavorite: o("is_favorite"),
                    name: o("name"),
                    sidebarPosition: o("sidebar_position"),
                    teamId: o("team_id"),
                    preferences: o("preferences"),
                    archivedAt: o("archived_at")
                },
                tagAssignments: {
                    tagId: o("tag_id"),
                    taskId: o("task_id")
                },
                memberGroups: {
                    teamId: o("team_id"),
                    name: o("name"),
                    isAdminGroup: o("is_admin_group")
                },
                projectGroups: {
                    teamId: o("team_id"),
                    name: o("name"),
                    isPrivate: o("is_private"),
                    sidebarPosition: o("sidebar_position")
                },
                groupAssignments: {
                    groupId: o("group_id"),
                    objectId: o("object_id"),
                    groupType: o("group_type"),
                    sidebarPosition: o("sidebar_position")
                },
                comments: {
                    authorId: o("author_id"),
                    body: o("body"),
                    createdAt: o("created_at"),
                    editedAt: o("edited_at"),
                    extra: o("extra"),
                    isDeleted: o("is_deleted"),
                    isPinned: o("is_pinned"),
                    isTeam: o("is_team"),
                    reactions: o("reactions"),
                    taskId: o("task_id")
                },
                taskEvents: {
                    authorId: o("author_id"),
                    createdAt: o("created_at"),
                    change: o("change"),
                    taskId: o("task_id"),
                    integration: o("integration")
                },
                reminders: {
                    taskId: o("task_id"),
                    remindAt: o("remind_at"),
                    isRelative: o("is_relative"),
                    isAllDay: o("is_all_day")
                },
                settings: {
                    teamId: o("team_id"),
                    name: o("name"),
                    value: o("value")
                },
                attachments: {
                    parentId: o("parent_id")
                },
                attachmentVersions: {
                    name: o("name"),
                    size: o("size"),
                    status: o("status"),
                    integrationType: o("integration_type"),
                    mimeType: o("mime_type"),
                    attachmentId: o("attachment_id"),
                    authorId: o("author_id"),
                    createdAt: o("created_at"),
                    extra: o("extra")
                }
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            AdminBannerButtonActions: () => cu.AU,
            Columns: () => D.o,
            ContactInformationTypes: () => cu.Ot,
            MaxLengths: () => Be.Z,
            Models: () => lu,
            OwnerBannerButtonActions: () => cu.u7,
            Q: () => E.Q,
            SidebarBuiltinGroups: () => cu.Cc,
            SidebarBuiltinGroupsDisabledSortBy: () => cu.M6,
            SidebarGroupsSortBy: () => cu.qV,
            Tables: () => D.w,
            freePlanLimits: () => iu.c,
            nozbeSchema: () => ru.j
        });
        var n, a, o, r, i, c, l, d, u, m, h, p, g, f, b, y, v, w, k, x, j, T, S, P, _, C, R, A, I = s(69),
            N = s(24),
            E = s(19),
            O = s(33),
            M = s(879),
            D = s(16),
            H = s(5),
            F = s(8);
        const Z = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            L = D.o.businesses;
        let B = (n = H.lazy, a = (0, O.text)(L.name), o = (0, O.field)(L.color), r = (0, O.json)(L.limits, M.$r), i = (0, O.json)(L.planInfo, M.V1), c = (0, O.json)(L.paymentInfo, M.S$), l = (0, O.children)(D.w.businessMembers), d = (0, O.children)(D.w.teams), u = H.lazy, m = H.lazy, h = H.lazy, p = H.lazy, g = H.lazy, (A = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", b, this), (0, I.Z)(this, "name", y, this), (0, I.Z)(this, "color", v, this), (0, I.Z)(this, "limits", w, this), (0, I.Z)(this, "planInfo", k, this), (0, I.Z)(this, "paymentInfo", x, this), (0, I.Z)(this, "members", j, this), (0, I.Z)(this, "teams", T, this), (0, I.Z)(this, "users", S, this), (0, I.Z)(this, "activeUsers", P, this), (0, I.Z)(this, "_unsafeCurrentMember", _, this), (0, I.Z)(this, "currentMember", C, this), (0, I.Z)(this, "owner", R, this)
            }
            get isFree() {
                return this.planInfo.isFree
            }
            get isTrial() {
                return this.planInfo.isTrial
            }
            get isFreeOrTrial() {
                return this.planInfo.isFreeOrTrial
            }
            get expiresAt() {
                return this.planInfo.expiresAt
            }
            get isExpired() {
                return !this.isFree && this.planInfo.isExpired
            }
            async canBeRenamed() {
                return (await this._me).hasAdminPowers
            }
            async canCreateTeam() {
                if (this.isExpired) return !1;
                const e = await F.takeFirst(this._unsafeCurrentMember);
                return !!e && e.hasAdminPowers
            }
            get _me() {
                return F.takeFirst(this.currentMember)
            }
        }).table = D.w.businesses, A.associations = (0, E.associations)([D.w.businessMembers, {
            type: "has_many",
            foreignKey: D.o.businessMembers.businessId
        }], [D.w.teams, {
            type: "has_many",
            foreignKey: D.o.teams.businessId
        }]), b = Z(f = A, "do", [n], (function() {
            return (() => new(0, s(1227).Z)(this))()
        })), y = Z(f, "name", [a]), v = Z(f, "color", [o]), w = Z(f, "limits", [O.nochange, r]), k = Z(f, "planInfo", [O.nochange, i]), x = Z(f, "paymentInfo", [O.nochange, c]), j = Z(f, "members", [l]), T = Z(f, "teams", [d]), S = Z(f, "users", [u], (function() {
            return this.collections.get(D.w.users).query(E.Q.on(D.w.businessMembers, D.o.businessMembers.businessId, this.id))
        })), P = Z(f, "activeUsers", [m], (function() {
            return this.users.extend(E.Q.where(D.o.users.isPlaceholder, !1))
        })), _ = Z(f, "_unsafeCurrentMember", [h], (function() {
            return this.members.extend(E.Q.on(D.w.users, D.o.users.isMe, !0)).observe().pipe(F.switchMap((([e]) => e ? e.observe() : F.of(null))))
        })), C = Z(f, "currentMember", [p], (function() {
            return this._unsafeCurrentMember.pipe(F.map((e => (invariant(e, "No current member found for business " + this.id), e))))
        })), R = Z(f, "owner", [g], (function() {
            return this.members.extend(E.Q.where(D.o.businessMembers.role, "owner")).observe().pipe(F.switchMap((([e]) => (invariant(e, "No owner found for business " + this.id), e.observe()))))
        })), f);
        var z, U, W, G, V, q, Q, Y, J, K, $, X, ee, te, se, ne = s(326);
        const ae = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            oe = D.o.businessMembers;
        let re = (z = H.lazy, U = (0, O.field)(oe.role), W = (0, O.json)(oe.vacations, ne.k5), G = (0, O.immutableRelation)(D.w.businesses, oe.businessId), V = (0, O.immutableRelation)(D.w.users, oe.userId), (se = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", Q, this), (0, I.Z)(this, "role", Y, this), (0, I.Z)(this, "_vacations", J, this), (0, I.Z)(this, "business", K, this), (0, I.Z)(this, "user", $, this), (0, I.Z)(this, "spacesMemberships", X, this), (0, I.Z)(this, "businessVacations", ee, this), (0, I.Z)(this, "status", te, this)
            }
            get isOwner() {
                return "owner" === this.role
            }
            get isAdmin() {
                return "admin" === this.role
            }
            get hasAdminPowers() {
                return this.isOwner || this.isAdmin
            }
            async canBePromotedToAdmin() {
                return (await this._businessMe).isOwner && !this.isAdmin
            }
            async canBeDemotedAdmin() {
                return (await this._businessMe).isOwner && this.isAdmin
            }
            _ensureHasAdminPowers() {
                invariant(this.hasAdminPowers, "Admin privileges are required to perform the aciton")
            }
            get _businessMe() {
                return this.business.fetch().then((e => F.takeFirst(e.currentMember)))
            }
        }).table = D.w.businessMembers, se.associations = (0, E.associations)([D.w.businesses, {
            type: "belongs_to",
            key: oe.businessId
        }], [D.w.users, {
            type: "belongs_to",
            key: oe.userId
        }]), Q = ae(q = se, "do", [z], (function() {
            return (() => new(0, s(1228).Z)(this))()
        })), Y = ae(q, "role", [U]), J = ae(q, "_vacations", [W]), K = ae(q, "business", [G]), $ = ae(q, "user", [V]), X = ae(q, "spacesMemberships", [O.lazy], (function() {
            return this.collections.get(D.w.teamMembers).query(E.Q.on(D.w.teams, D.o.teams.businessId, this.business.id), E.Q.where(D.o.teamMembers.userId, this.user.id))
        })), ee = ae(q, "businessVacations", [O.lazy], (function() {
            return new ne.jw(this)
        })), te = ae(q, "status", [O.lazy], (function() {
            return this.spacesMemberships.observe().pipe(F.map((e => e.every((e => e.isExpired)) ? "expired" : e.every((e => e.isWaitingForActivation)) ? "pending" : "active")))
        })), q);
        var ie, ce, le, de, ue, me, he, pe, ge, fe, be, ye, ve, we, ke, xe, je, Te, Se, Pe, _e, Ce, Re, Ae, Ie, Ne, Ee, Oe, Me, De, He, Fe, Ze, Le = s(4),
            Be = s(327),
            ze = s(109),
            Ue = s(35);
        const We = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Ge = D.o.comments;
        let Ve = (ie = H.lazy, ce = (0, O.json)(Ge.reactions, Ue.NO), le = (0, O.field)(Ge.isDeleted), de = (0, O.immutableRelation)(D.w.tasks, Ge.taskId), ue = (0, O.experimentalFailsafe)(), me = (0, O.relation)(D.w.teamMembers, Ge.authorId), he = (0, O.children)(D.w.attachments), pe = H.lazy, ge = (0, O.date)(Ge.createdAt), fe = (0, O.field)(Ge.createdAt), be = (0, O.date)(Ge.editedAt), ye = (0, O.field)(Ge.isPinned), ve = (0, O.field)(Ge.isTeam), we = (0, O.text)(Ge.body), ke = (0, O.json)(Ge.body, Ue.RB), xe = (0, O.json)(Ge.extra, Ue.ub), (Ze = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", Te, this), (0, I.Z)(this, "reactions", Se, this), (0, I.Z)(this, "isDeleted", Pe, this), (0, I.Z)(this, "task", _e, this), (0, I.Z)(this, "author", Ce, this), (0, I.Z)(this, "attachments", Re, this), (0, I.Z)(this, "latestAttachmentVersions", Ae, this), (0, I.Z)(this, "createdAt", Ie, this), (0, I.Z)(this, "_createdAt", Ne, this), (0, I.Z)(this, "editedAt", Ee, this), (0, I.Z)(this, "isPinned", Oe, this), (0, I.Z)(this, "isTeam", Me, this), (0, I.Z)(this, "_bodyText", De, this), (0, I.Z)(this, "_bodyJSON", He, this), (0, I.Z)(this, "extra", Fe, this), this._drafts = new F.Subject
            }
            get isIncomplete() {
                return null === this._getRaw(Ge.reactions) && "" === this._getRaw(Ge.body) && !this.isDeleted
            }
            get isRestorable() {
                return !!this._deletedCommentBody
            }
            get hasBeenEdited() {
                return !!this.editedAt
            }
            get body() {
                return this._bodyJSON || (0, Ue.OU)(this._bodyText)
            }
            set body(e) {
                const t = Le.isObject(e) || "string" == typeof e;
                if (invariant(t, "Comment body must be a CommentBody object or string"), "string" == typeof e) {
                    const t = e.length > Be.Z.comments.body ? (H.logError(H.PROD_CONSOLE_REASON.SAFE_ID, "Comment body too long: " + e.length + " (limit: " + Be.Z.comments.body + ")"), e.slice(0, Be.Z.comments.body - 3) + "…") : e;
                    this._bodyJSON = null, this._bodyText = t
                } else "object" == typeof e && (this._bodyText = "", this._bodyJSON = e)
            }
            getBodyForCheapoWysiwyg(e) {
                return this._bodyJSON || (0, Ue.OU)(this._bodyText, e)
            }
            get draft() {
                return F.from(this.getDraft()).pipe(F.concat(this._drafts), F.startWith(void 0), F.distinctUntilChanged())
            }
            async getDraft() {
                try {
                    const e = await this.db.adapter.getLocal(this._draftKey),
                        t = e ? JSON.parse(e) : void 0;
                    return t && t.savedBody === this._bodyText ? t.draftBody : void 0
                } catch (e) {
                    return
                }
            }
            async saveDraft(e) {
                if (e === this._bodyText) return void await this.removeDraft();
                const t = {
                    savedBody: this._bodyText,
                    draftBody: e
                };
                this._drafts.next(e), await this.db.adapter.setLocal(this._draftKey, JSON.stringify(t))
            }
            async removeDraft() {
                this._drafts.next(void 0), await this.db.adapter.removeLocal(this._draftKey)
            }
            async canBeEdited() {
                if (this.isDeleted) return !1;
                if (this.isTeam) return !0;
                return (await this._me).id === this.author.id
            }
            async canBeMarkedAsTeam() {
                const e = await this.task.fetch();
                if (this.isTeam || this.isDeleted || e.isThread) return !1;
                return (await this._me).id === this.author.id
            }
            get _me() {
                return this.task.fetch().then((e => e._me))
            }
            get _draftKey() {
                return "comment_edit_draft_" + this.id
            }
        }).table = D.w.comments, Ze.associations = (0, E.associations)([D.w.tasks, {
            type: "belongs_to",
            key: Ge.taskId
        }], [D.w.attachments, {
            type: "has_many",
            foreignKey: D.o.attachments.parentId
        }], [D.w.teamMembers, {
            type: "belongs_to",
            key: D.o.comments.authorId
        }]), Te = We(je = Ze, "do", [ie], (function() {
            return (() => new(0, s(1235).Z)(this))()
        })), Se = We(je, "reactions", [ce]), Pe = We(je, "isDeleted", [le]), _e = We(je, "task", [de]), Ce = We(je, "author", [ue, me]), Re = We(je, "attachments", [he]), Ae = We(je, "latestAttachmentVersions", [pe], (function() {
            return this.attachments.observe().pipe(F.switchMap((e => {
                const t = e.map((e => e.latestVersion));
                return F.combineLatest(t)
            })), F.map((e => e.filter(Boolean))), F.map((e => (0, ze.xv)(e))))
        })), Ie = We(je, "createdAt", [O.nochange, ge]), Ne = We(je, "_createdAt", [fe]), Ee = We(je, "editedAt", [be]), Oe = We(je, "isPinned", [ye]), Me = We(je, "isTeam", [ve]), De = We(je, "_bodyText", [we]), He = We(je, "_bodyJSON", [ke]), Fe = We(je, "extra", [xe]), je);
        var qe, Qe, Ye, Je, Ke, $e, Xe, et, tt = s(477);
        const st = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            nt = D.o.projectAccesses;
        let at = (qe = (0, O.field)(nt.isManager), Qe = (0, O.immutableRelation)(D.w.projects, nt.projectId), Ye = (0, O.immutableRelation)(D.w.teamMembers, nt.memberId), (et = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "isManager", Ke, this), (0, I.Z)(this, "project", $e, this), (0, I.Z)(this, "member", Xe, this)
            }
            get _me() {
                return this.project.fetch().then((e => e._me))
            }
        }).table = D.w.projectAccesses, et.associations = (0, E.associations)([D.w.projects, {
            type: "belongs_to",
            key: nt.projectId
        }], [D.w.teamMembers, {
            type: "belongs_to",
            key: nt.memberId
        }]), Ke = st(Je = et, "isManager", [qe]), $e = st(Je, "project", [Qe]), Xe = st(Je, "member", [Ye]), Je);
        var ot, rt, it, ct, lt, dt, ut, mt, ht, pt, gt, ft, bt, yt, vt, wt, kt, xt, jt = s(279),
            Tt = s(29);
        const St = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Pt = D.o.projectSections;
        let _t = (ot = H.lazy, rt = (0, O.text)(Pt.name), it = (0, O.field)(Pt.position), ct = (0, O.date)(Pt.archivedAt), lt = (0, O.date)(Pt.createdAt), dt = (0, O.immutableRelation)(D.w.projects, Pt.projectId), ut = (0, O.children)(D.w.tasks), (xt = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", ht, this), (0, I.Z)(this, "name", pt, this), (0, I.Z)(this, "position", gt, this), (0, I.Z)(this, "archivedAt", ft, this), (0, I.Z)(this, "createdAt", bt, this), (0, I.Z)(this, "project", yt, this), (0, I.Z)(this, "allTasks", vt, this), (0, I.Z)(this, "activeTasks", wt, this), (0, I.Z)(this, "endedTasks", kt, this)
            }
            get isActive() {
                return !this.archivedAt
            }
            get isArchived() {
                return !!this.archivedAt
            }
            async getTopPosition() {
                const e = await this.activeTasks.fetch();
                return (0, Tt.Fv)(e)
            }
            async getBottomPosition() {
                const e = await this.activeTasks.fetch();
                return (0, Tt.pv)(e)
            }
            get canBeDeleted() {
                return this.isArchived || 5 > (0, jt.Z)(new Date, this.createdAt)
            }
            async isInActiveProject() {
                return (await this.project.fetch()).isActive
            }
            async canBeCloned() {
                const e = await this.isInActiveProject();
                return this.isActive && e
            }
            async canBeConvertedToProject() {
                const e = await this.project.fetch();
                return this.isActive && e.isActive && !e.isSingleTasks && !e.isShared
            }
            async markAsDeleted() {
                if (this.canBeDeleted) {
                    const e = await this.allTasks.fetch();
                    await this.do._moveTasksToNullSection(e), await super.markAsDeleted()
                }
            }
            async _ensureActiveProject() {
                (await this.project.fetch())._ensureNotEnded()
            }
            get _me() {
                return this.project.fetch().then((e => e._me))
            }
        }).table = D.w.projectSections, xt.associations = (0, E.associations)([D.w.projects, {
            type: "belongs_to",
            key: Pt.projectId
        }], [D.w.tasks, {
            type: "has_many",
            foreignKey: D.o.tasks.projectSectionId
        }]), ht = St(mt = xt, "do", [ot], (function() {
            return (() => new(0, s(1238).Z)(this))()
        })), pt = St(mt, "name", [rt]), gt = St(mt, "position", [it]), ft = St(mt, "archivedAt", [ct]), bt = St(mt, "createdAt", [O.nochange, lt]), yt = St(mt, "project", [dt]), vt = St(mt, "allTasks", [ut]), wt = St(mt, "activeTasks", [O.lazy], (function() {
            return this.allTasks.extend(Tt.rG)
        })), kt = St(mt, "endedTasks", [O.lazy], (function() {
            return this.allTasks.extend(Tt.kU)
        })), mt);
        var Ct, Rt, At, It, Nt, Et, Ot, Mt, Dt, Ht, Ft;
        const Zt = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Lt = D.o.projectEvents;
        let Bt = (Ct = (0, O.field)(Lt.type), Rt = (0, O.immutableRelation)(D.w.projects, Lt.projectId), At = (0, O.experimentalFailsafe)(), It = (0, O.immutableRelation)(D.w.teamMembers, Lt.authorId), Nt = (0, O.date)(Lt.createdAt), (Ft = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "type", Ot, this), (0, I.Z)(this, "project", Mt, this), (0, I.Z)(this, "author", Dt, this), (0, I.Z)(this, "createdAt", Ht, this)
            }
        }).table = D.w.projectEvents, Ft.associations = (0, E.associations)([D.w.projects, {
            type: "belongs_to",
            key: Lt.projectId
        }]), Ot = Zt(Et = Ft, "type", [O.nochange, Ct]), Mt = Zt(Et, "project", [Rt]), Dt = Zt(Et, "author", [At, It]), Ht = Zt(Et, "createdAt", [O.nochange, Nt]), Et);
        var zt, Ut, Wt, Gt, Vt, qt, Qt, Yt;
        const Jt = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Kt = D.o.projectPositions;
        let $t = (zt = (0, O.immutableRelation)(D.w.projects, Kt.projectId), Ut = (0, O.field)(Kt.listId), Wt = (0, O.field)(Kt.position), (Yt = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "project", Vt, this), (0, I.Z)(this, "listId", qt, this), (0, I.Z)(this, "position", Qt, this)
            }
            preparePositionUpdate(e) {
                return this.prepareUpdate((t => {
                    t.position = e
                }))
            }
        }).table = D.w.projectPositions, Yt.associations = (0, E.associations)([D.w.projects, {
            type: "belongs_to",
            key: Kt.projectId
        }]), Vt = Jt(Gt = Yt, "project", [zt]), qt = Jt(Gt, "listId", [O.nochange, Ut]), Qt = Jt(Gt, "position", [Wt]), Gt);
        var Xt, es, ts, ss, ns, as = s(108),
            os = s(65),
            rs = s(124),
            is = s(153);
        const cs = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            ls = D.o.tags;
        let ds = (Xt = (0, O.field)(ls.isFavorite), es = (0, O.field)(ls.sidebarPosition), ss = cs(ts = class {
            get asModel() {
                return this.tag
            }
            constructor(e) {
                (0, I.Z)(this, "isFavorite", ss, this), (0, I.Z)(this, "sidebarPosition", ns, this), this.tag = e
            }
        }, "isFavorite", [Xt]), ns = cs(ts, "sidebarPosition", [es]), ts);
        class us {
            get teamId() {
                return this.team.id
            }
            get teamSettings() {
                return this.tag.teamSettings[this.teamId] || {
                    sidebar_position: null,
                    is_favorite: !1
                }
            }
            get sidebarPosition() {
                return this.teamSettings.sidebar_position
            }
            set sidebarPosition(e) {
                this.tag.preferences = Object.assign({}, this.tag.preferences, {
                    [is.mc.teamSettings]: Object.assign({}, this.tag.preferences[is.mc.teamSettings], {
                        [this.teamId]: Object.assign({}, this.teamSettings, {
                            sidebar_position: e
                        })
                    })
                })
            }
            get isFavorite() {
                return this.teamSettings.is_favorite
            }
            set isFavorite(e) {
                this.tag.preferences = Object.assign({}, this.tag.preferences, {
                    [is.mc.teamSettings]: Object.assign({}, this.tag.preferences[is.mc.teamSettings], {
                        [this.teamId]: Object.assign({}, this.teamSettings, {
                            is_favorite: e
                        })
                    })
                })
            }
            constructor(e, t) {
                this.tag = e, this.team = t
            }
        }
        var ms, hs, ps, gs, fs, bs, ys, vs, ws, ks, xs, js, Ts, Ss, Ps, _s, Cs, Rs, As, Is, Ns, Es, Os, Ms, Ds;
        const Hs = (e, t, s) => (0, N.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            Fs = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Zs = [
                ["mapMarker", "map-marker"],
                ["appleTag", "apple-tag"],
                ["imageTag", "image-tag"],
                ["shieldX", "shield-x"],
                ["qrCode", "qr-code"]
            ],
            Ls = new Map(Zs),
            Bs = new Map(Zs.map((([e, t]) => [t, e]))),
            zs = D.o.tags;
        let Us = (ms = H.lazy, hs = (0, O.text)(zs.name), ps = (0, O.field)(zs.icon), gs = (0, O.field)(zs.userColor), fs = (0, O.field)(zs.teamColor), bs = (0, O.json)(zs.preferences, is.G4, {
            memo: !0
        }), ys = (0, O.date)(zs.archivedAt), vs = (0, O.immutableRelation)(D.w.teams, zs.teamId), ws = (0, O.children)(D.w.tagAssignments), Ds = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", xs, this), (0, I.Z)(this, "name", js, this), (0, I.Z)(this, "_icon", Ts, this), (0, I.Z)(this, "userColor", Ss, this), (0, I.Z)(this, "teamColor", Ps, this), (0, I.Z)(this, "preferences", _s, this), (0, I.Z)(this, "archivedAt", Cs, this), (0, I.Z)(this, "team", Rs, this), (0, I.Z)(this, "allTasks", As, this), (0, I.Z)(this, "allTasksInProjects", Is, this), (0, I.Z)(this, "tasks", Ns, this), (0, I.Z)(this, "activeTasks", Es, this), (0, I.Z)(this, "endedTasks", Os, this), (0, I.Z)(this, "tagAssignments", Ms, this)
            }
            get icon() {
                var e;
                return Bs.get(null == (e = this._icon) ? void 0 : e.replace("_", "-")) || this._icon
            }
            set icon(e) {
                this._icon = Ls.get(e) || e
            }
            get color() {
                return this.isShared ? this.teamColor || this.userColor : this.userColor || this.teamColor
            }
            get isActive() {
                return !this.archivedAt
            }
            get isArchived() {
                return !!this.archivedAt
            }
            get isShared() {
                return null !== this.team.id
            }
            get isPrivate() {
                return null === this.team.id
            }
            get teamSettings() {
                return this.preferences[is.mc.teamSettings]
            }
            async openOnSidebar(e) {
                this._ensureActive();
                const t = await F.takeFirst(e.allTagsOnSidebarNotFavorite);
                await (0, as.NV)(this, t, e, {
                    maxOpen: 5
                })
            }
            async removeFromSidebar(e) {
                this._ensureActive(), await (0, as.OO)(this, e)
            }
            async updateSidebarPosition(e, t) {
                this._ensureActive(), await (0, as.D5)(this, t, e)
            }
            async favorite(e) {
                this._ensureActive(), await (0, as.GD)(this, e)
            }
            async unfavorite(e) {
                this._ensureActive();
                const t = await F.takeFirst(e.allTagsOnSidebarNotFavorite);
                await (0, as.WN)(this, t, e)
            }
            asSidebarFavoritable(e) {
                return this.isShared ? this.team.id !== e.id ? new as.ke : new ds(this) : new us(this, e)
            }
            extendTagsQuery(e) {
                return e.extend(E.Q.on(D.w.tagAssignments, D.o.tagAssignments.tagId, this.id))
            }
            tasksInTeam(e, t = !1) {
                const s = e.grantedTaskAccessesIds.pipe(F.map((s => (t ? this.allTasks : this.allTasksInProjects).extend(...(0, rs.UB)(e.id, s))))),
                    n = e.grantedTaskAccessesIds.pipe(F.map((s => (t ? this.allTasks : this.allTasksInProjects).extend(...(0, rs.F1)(e.id, s))))),
                    a = {
                        allTasks: s,
                        tasks: n,
                        activeTasks: n.pipe(F.map((e => e.extend(Tt.rG)))),
                        endedTasks: n.pipe(F.map((e => e.extend(Tt.kU))))
                    };
                return a
            }
            _ensureActive() {
                invariant(this.isActive, "Action can be performed only on a active tag")
            }
            _ensureArchived() {
                invariant(this.isArchived, "Action can be performed only on a archived tag")
            }
        }, Ds.table = D.w.tags, Ds.associations = (0, E.associations)([D.w.teams, {
            type: "belongs_to",
            key: zs.teamId
        }], [D.w.tagAssignments, {
            type: "has_many",
            foreignKey: D.o.tagAssignments.tagId
        }]), xs = Fs(ks = Ds, "do", [ms], (function() {
            return (() => new(0, s(1240).Z)(this))()
        })), js = Fs(ks, "name", [hs]), Ts = Fs(ks, "_icon", [ps]), Ss = Fs(ks, "userColor", [gs]), Ps = Fs(ks, "teamColor", [fs]), _s = Fs(ks, "preferences", [bs]), Cs = Fs(ks, "archivedAt", [ys]), Rs = Fs(ks, "team", [vs]), As = Fs(ks, "allTasks", [O.lazy], (function() {
            return this.collections.get(D.w.tasks).query(E.Q.on(D.w.tagAssignments, D.o.tagAssignments.tagId, this.id))
        })), Is = Fs(ks, "allTasksInProjects", [O.lazy], (function() {
            return this.allTasks.extend(E.Q.or(E.Q.where(D.o.tasks.projectId, Tt.sW), E.Q.on(D.w.projects, os.Vf)))
        })), Ns = Fs(ks, "tasks", [O.lazy], (function() {
            return this.allTasks.extend(E.Q.or(E.Q.where(D.o.tasks.projectId, Tt.sW), E.Q.on(D.w.projects, os.Y3)))
        })), Es = Fs(ks, "activeTasks", [O.lazy], (function() {
            return this.tasks.extend(Tt.rG)
        })), Os = Fs(ks, "endedTasks", [O.lazy], (function() {
            return this.tasks.extend(Tt.kU)
        })), Ms = Fs(ks, "tagAssignments", [ws]), Hs(ks, "openOnSidebar", [O.writer]), Hs(ks, "removeFromSidebar", [O.writer]), Hs(ks, "updateSidebarPosition", [O.writer]), Hs(ks, "favorite", [O.writer]), Hs(ks, "unfavorite", [O.writer]), ks);
        var Ws, Gs, Vs, qs, Qs, Ys, Js, Ks, $s, Xs, en, tn, sn, nn, an, on, rn = s(281),
            cn = s(21),
            ln = s(120);
        const dn = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            un = D.o.tasks;
        let mn = (Ws = H.lazy, Gs = (0, O.field)(un.missedRepeats), Vs = (0, O.experimentalFailsafe)(), qs = (0, O.relation)(D.w.taskRecurrences, un.recurrenceId), Qs = (0, O.children)(D.w.reminders), Ys = (0, O.date)(un.recurrenceOriginAt), Js = (0, O.date)(un.dueAt), Ks = (0, O.field)(un.isAllDay), Xs = dn($s = class {
            get asModel() {
                return this.task
            }
            get database() {
                return this.task.database
            }
            get db() {
                return this.task.database
            }
            constructor(e) {
                (0, I.Z)(this, "do", Xs, this), (0, I.Z)(this, "missedRepeats", en, this), (0, I.Z)(this, "recurrence", tn, this), (0, I.Z)(this, "reminders", sn, this), (0, I.Z)(this, "_recurrenceOriginAt", nn, this), (0, I.Z)(this, "_dueAt", an, this), (0, I.Z)(this, "_isAllDay", on, this), this.task = e
            }
            get dueDate() {
                return this.task.ghostInfo ? this.task.ghostInfo.instanceDueDate : this._dueAt ? cn.DateTime.fromLegacyDueDate({
                    date: this._dueAt,
                    isAllDay: !!this._isAllDay
                }) : null
            }
            set dueDate(e) {
                if (e) {
                    const {
                        legacyDueDate: t
                    } = e;
                    this._dueAt = t.date, this._isAllDay = t.isAllDay
                } else this._dueAt = null, this._isAllDay = !1
            }
            get isOverdue() {
                const {
                    task: e
                } = this;
                return e.isActive && !e.isGhost && (0, Tt.GY)(this.dueDate)
            }
            get isDueToday() {
                const {
                    dueDate: e
                } = this;
                return !!e && (0, ln.Z)(e.local, new Date)
            }
            async isDueDateRelative() {
                try {
                    return (await this.task._project.fetch()).isTemplate
                } catch (e) {
                    return !!this._dueAt && this._dueAt.getTime() < 15768e7
                }
            }
            get recurrenceOrigin() {
                return this._recurrenceOriginAt ? cn.DateTime.fromLegacyDueDate({
                    date: this._recurrenceOriginAt,
                    isAllDay: !!this._isAllDay
                }) : this.dueDate
            }
            set recurrenceOrigin(e) {
                this._recurrenceOriginAt = e ? e.legacyDueDate.date : null
            }
            get isRecurring() {
                return !!this.recurrence.id
            }
            async isCurrentRecurringInstance() {
                var e;
                const t = await this.recurrence.fetch().catch((() => null));
                return (null == t || null == (e = t.currentTask) ? void 0 : e.id) === this.task.id
            }
            async canUpdateRecurrence() {
                return !this.task.isGranted && (!this.isRecurring || this.isCurrentRecurringInstance())
            }
        }, "do", [Ws], (function() {
            return (() => new(0, s(1241).Z)(this.task))()
        })), en = dn($s, "missedRepeats", [Gs]), tn = dn($s, "recurrence", [Vs, qs]), sn = dn($s, "reminders", [Qs]), nn = dn($s, "_recurrenceOriginAt", [Ys]), an = dn($s, "_dueAt", [Js]), on = dn($s, "_isAllDay", [Ks]), $s);
        var hn, pn, gn, fn, bn, yn, vn, wn, kn, xn, jn, Tn;
        const Sn = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Pn = D.o.tasks;
        let _n = (hn = H.lazy, pn = (0, O.children)(D.w.comments), gn = (0, O.children)(D.w.taskEvents), fn = (0, O.field)(Pn.commentsCached), yn = Sn(bn = class {
            get asModel() {
                return this.task
            }
            get database() {
                return this.task.database
            }
            get db() {
                return this.task.database
            }
            constructor(e) {
                (0, I.Z)(this, "do", yn, this), (0, I.Z)(this, "comments", vn, this), (0, I.Z)(this, "activeComments", wn, this), (0, I.Z)(this, "pinnedComments", kn, this), (0, I.Z)(this, "unreadCommentsQuery", xn, this), (0, I.Z)(this, "events", jn, this), (0, I.Z)(this, "cachedCommentCount", Tn, this), this._newCommentDrafts = new F.Subject, this.task = e
            }
            get hasIncompleteTimeline_v2() {
                return "number" == typeof this.cachedCommentCount
            }
            hasIncompleteTimeline(e, t) {
                return this.hasIncompleteTimeline_v2 || t.some((e => e.isIncomplete)) || e.some((e => e.isIncomplete))
            }
            get newCommentDraft() {
                return F.from(this.getNewCommentDraft()).pipe(F.concat(this._newCommentDrafts))
            }
            async getNewCommentDraft() {
                try {
                    const e = await this.db.adapter.getLocal(this._newCommentDraftKey);
                    return e ? JSON.parse(e) : void 0
                } catch (e) {
                    return
                }
            }
            async saveNewCommentDraft(e) {
                this._newCommentDrafts.next(e), await this.db.adapter.setLocal(this._newCommentDraftKey, JSON.stringify(e))
            }
            async removeNewCommentDraft() {
                this._newCommentDrafts.next(void 0), await this.db.adapter.removeLocal(this._newCommentDraftKey)
            }
            get _newCommentDraftKey() {
                return "comment_draft_" + this.task.id
            }
        }, "do", [hn], (function() {
            return (() => new(0, s(1242).Z)(this.task))()
        })), vn = Sn(bn, "comments", [pn]), wn = Sn(bn, "activeComments", [O.lazy], (function() {
            return this.comments.extend(E.Q.where(D.o.comments.isDeleted, !1))
        })), kn = Sn(bn, "pinnedComments", [O.lazy], (function() {
            return this.activeComments.extend(E.Q.where(D.o.comments.isPinned, !0))
        })), xn = Sn(bn, "unreadCommentsQuery", [O.lazy], (function() {
            return this.task.observe().pipe(F.map((e => {
                var t;
                return null == (t = e.lastSeenActivityAt) ? void 0 : t.getTime()
            })), F.distinctUntilChanged(), F.switchMap((e => {
                const t = e ? this.activeComments.extend((0, Ue.WU)(e)) : this.activeComments;
                return F.of(t)
            })))
        })), jn = Sn(bn, "events", [gn]), Tn = Sn(bn, "cachedCommentCount", [fn]), bn);
        var Cn, Rn, An, In, Nn, En, On, Mn, Dn, Hn, Fn, Zn, Ln, Bn, zn, Un, Wn, Gn, Vn, qn, Qn, Yn, Jn, Kn, $n, Xn, ea, ta, sa, na, aa, oa, ra, ia, ca, la, da, ua, ma, ha, pa, ga, fa, ba, ya, va, wa, ka, xa, ja, Ta, Sa, Pa, _a, Ca, Ra, Aa, Ia, Na = s(478);
        const Ea = (e, t, s) => (0, N.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            Oa = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Ma = D.o.tasks;
        let Da = (Cn = H.lazy, Rn = (0, O.text)(Ma.name), An = (0, O.field)(Ma.priorityPosition), In = (0, O.field)(Ma.projectPosition), Nn = (0, O.field)(Ma.isFollowed), En = (0, O.date)(Ma.endedAt), On = (0, O.field)(Ma.endedAt), Mn = (0, O.json)(Ma.extra, Na.u), Dn = (0, O.date)(Ma.lastActivityAt), Hn = (0, O.date)(Ma.lastSeenActivityAt), Fn = (0, O.date)(Ma.reviewTriggeredAt), Zn = (0, O.date)(Ma.lastReviewedAt), Ln = (0, O.relation)(D.w.projects, Ma.projectId), Bn = (0, O.relation)(D.w.projectSections, Ma.projectSectionId), zn = (0, O.experimentalFailsafe)(), Un = (0, O.immutableRelation)(D.w.teamMembers, Ma.authorId), Wn = (0, O.experimentalFailsafe)(), Gn = (0, O.relation)(D.w.teamMembers, Ma.responsibleId), Vn = (0, O.children)(D.w.tagAssignments), qn = (0, O.date)(Ma.createdAt), Qn = (0, O.field)(Ma.isAbandoned), Yn = (0, O.field)(Ma.reviewReason), Jn = (0, O.field)(Ma.timeNeeded), Kn = (0, O.field)(Ma.timeSpent), $n = (0, O.field)(Ma.type), Xn = (0, O.children)(D.w.taskAccesses), Ia = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "dates", ta, this), (0, I.Z)(this, "timeline", sa, this), (0, I.Z)(this, "do", na, this), (0, I.Z)(this, "name", aa, this), (0, I.Z)(this, "priorityPosition", oa, this), (0, I.Z)(this, "projectPosition", ra, this), (0, I.Z)(this, "isFollowed", ia, this), (0, I.Z)(this, "endedAt", ca, this), (0, I.Z)(this, "_endedAt", la, this), (0, I.Z)(this, "extra", da, this), (0, I.Z)(this, "lastActivityAt", ua, this), (0, I.Z)(this, "lastSeenActivityAt", ma, this), (0, I.Z)(this, "reviewTriggeredAt", ha, this), (0, I.Z)(this, "lastReviewedAt", pa, this), (0, I.Z)(this, "_project", ga, this), (0, I.Z)(this, "projectSection", fa, this), (0, I.Z)(this, "author", ba, this), (0, I.Z)(this, "responsible", ya, this), (0, I.Z)(this, "allTags", va, this), (0, I.Z)(this, "tags", wa, this), (0, I.Z)(this, "tagAssignments", ka, this), (0, I.Z)(this, "createdAt", xa, this), (0, I.Z)(this, "_isEndedByAbandonment", ja, this), (0, I.Z)(this, "_reviewReason", Ta, this), (0, I.Z)(this, "_timeNeeded", Sa, this), (0, I.Z)(this, "_timeSpent", Pa, this), (0, I.Z)(this, "type", _a, this), (0, I.Z)(this, "timeAttributes", Ca, this), (0, I.Z)(this, "_taskAccesses", Ra, this), (0, I.Z)(this, "taskAccess", Aa, this)
            }
            get isPriority() {
                return null !== this.priorityPosition
            }
            get isActive() {
                return !this._endedAt
            }
            get isEnded() {
                return !!this._endedAt && !this.isGhost
            }
            get isCompleted() {
                return !!this._endedAt && !this._isEndedByAbandonment
            }
            get isAbandoned() {
                return !!this._endedAt && this._isEndedByAbandonment
            }
            get status() {
                return this.isAbandoned ? Tt.TE.ABANDONED : this.isCompleted ? Tt.TE.COMPLETED : Tt.TE.ACTIVE
            }
            get isEndedMoreThan7DaysAgo() {
                const {
                    endedAt: e
                } = this;
                return !!e && 7 < (0, rn.Z)(new Date, e)
            }
            get isUnread() {
                return !this.isGhost && (!this.lastSeenActivityAt || this.lastActivityAt > this.lastSeenActivityAt)
            }
            get isRead() {
                return !this.isUnread
            }
            get doesNeedReview() {
                return !this.isGhost && !!this.reviewTriggeredAt && (!this.lastReviewedAt || this.reviewTriggeredAt > this.lastReviewedAt) && !!this._reviewReason
            }
            get reviewReason() {
                return this.doesNeedReview ? this._reviewReason : null
            }
            get isGhost() {
                return !!this.ghostInfo
            }
            get isThread() {
                return "thread" === this.type
            }
            async canBeManaged() {
                if (this.isGranted) return !1;
                const e = await this._project.fetch();
                if (e.isSingleTasks) return !0;
                const t = 5 > (0, jt.Z)(new Date, this.createdAt),
                    s = this.author.id === (await this._me).id;
                return !(!t || !s) || e.permissions.canBeManaged()
            }
            async canBeCloned() {
                const e = await this.isInActiveProject();
                return this.isActive && e && !this.isGhost
            }
            async canBeConvertedToProject() {
                const e = await this.fetchCurrentProject();
                return this.isActive && !this.isGhost && e.isActive && !e.isShared
            }
            async canBeGranted() {
                if (this.isGranted) return !1;
                return 1 > await this._taskAccesses.fetchCount()
            }
            async _isSectionArchived() {
                const e = this.projectSection.id;
                if (!e) return !1;
                return (await this.collections.get(D.w.projectSections).find(e)).isArchived
            }
            _unassignResponsible() {
                this.responsible.set(null), this.dates.do._removeDueDate()
            }
            async isInActiveProject() {
                if (this.isGranted || this.isThread) return !0;
                return (await this._project.fetch()).isActive
            }
            async canRestoreDueToHistoryLimits() {
                const e = await this._me;
                if ((await e.user.fetch()).isLimited) return !0;
                return !((await this._fetchCurrentTeam()).isFree && this.isEndedMoreThan7DaysAgo)
            }
            async canUpdateTimeAttributes() {
                if (this.isGhost || this.isThread) return !1;
                const e = await this.fetchCurrentProject();
                return e.areTimeAttributesEnabled || e.canEnableTimeAttributes()
            }
            async _projectTopPosition() {
                invariant(!this.isGranted, "Cannot get project position for granted task");
                return (await this._project.fetch()).getTopPosition()
            }
            async fetchCurrentProject() {
                if (this.isGranted || this.isThread) {
                    const e = await this._getTeamFromTaskAccess();
                    return F.takeFirst(e.singleTasks)
                }
                return this._project.fetch()
            }
            observeCurrentProject() {
                return this.isGranted || this.isThread ? F.from(this._getTeamFromTaskAccess()).pipe(F.switchMap((e => e.singleTasks))) : this._project.observe()
            }
            get forwardedEmailMetadata() {
                return this.extra[Na.k.forwardedEmailMetadata]
            }
            get isGranted() {
                return this._project.id === Tt.sW
            }
            observeThreadName() {
                return invariant("thread" === this.type, "observing thread name is only avaliable for tasks with type of 'thread'"), this._taskAccesses.observe().pipe(F.switchMap((e => {
                    if (e.every((e => "member" === e.granteeType || !e.granteeType))) return F.combineLatest(e.map((e => e._grantee.observe()))).pipe(F.switchMap((e => F.combineLatestTuples(e.map((e => [e, e.user.observe()]))).pipe(F.switchMap((e => F.combineLatest(e.filter((([, e]) => !e.isMe)).map((([e]) => null == e ? void 0 : e.preferredName))))), F.switchMap((e => F.of(e.filter(Boolean).join(", "))))))));
                    const t = e.find((e => "team" === e.granteeType));
                    if (t) return t._granteeTeam.observe().pipe(F.map((e => e.name)));
                    const s = e.find((e => "member_group" === e.granteeType));
                    return s ? s._granteeGroup.observe().pipe(F.map((e => e.name))) : F.of("")
                })))
            }
            observeThreadType() {
                return invariant("thread" === this.type, "observing thread type is only avaliable for tasks with type of 'thread'"), this._taskAccesses.observe().pipe(F.switchMap((e => {
                    if (e.every((e => "member" === e.granteeType || !e.granteeType))) return F.of("member");
                    if (e.find((e => "team" === e.granteeType))) return F.of("team");
                    return e.find((e => "member_group" === e.granteeType)) ? F.of("member_group") : F.of("member")
                })))
            }
            observeThreadMembers() {
                return invariant("thread" === this.type, "observing thread members is only avaliable for tasks with type of 'thread'"), this._taskAccesses.observe().pipe(F.switchMap((e => F.combineLatest(e.map((e => {
                    if (!e) return F.of(null);
                    switch (e.granteeType) {
                        case "team":
                            return e._granteeTeam.observe().pipe(F.switchMap((e => F.combineLatest(e.activeMembers.observe()))));
                        case "member_group":
                            return e._granteeGroup.observe().pipe(F.switchMap((e => F.combineLatest(e.allMembers.observe()))));
                        default:
                            return e._grantee.observe()
                    }
                }))))), F.map((e => e.flat(2))))
            }
            observeCurrentTaskAccessMember() {
                return this.taskAccess.pipe(F.switchMap((e => e ? this.isGranted ? e.granter.observe() : !e.grantee.id || "member" !== e.granteeType && e.granteeType ? F.of(null) : e._grantee.observe() : F.of(null))))
            }
            observeTaskAccessMembers() {
                return this.isThread ? this.observeThreadMembers() : this.observeCurrentTaskAccessMember().pipe(F.map((e => [e])))
            }
            async _ensureActiveProject() {
                if (this.isGranted || this.isThread) return;
                (await this._project.fetch())._ensureNotEnded()
            }
            async _getTeamFromTaskAccess() {
                const e = await this._taskAccesses.fetch();
                invariant(0 < e.length, "Cannot get task's team. User shouldn't have access to this task!"), 1 < e.length && !this.isThread && H.logError("safe literal", "User has more than 1 TaskAccess to a Task with id: " + this.id + ". This should not have happend!");
                const t = e[0],
                    {
                        granteeType: s
                    } = t;
                switch (s) {
                    case "team":
                        return t._granteeTeam.fetch();
                    case "member_group":
                        return (await t._granteeGroup.fetch()).team.fetch();
                    default: {
                        const t = e[0].grantee.id;
                        invariant(t, "Unexpected missing grantee ID when trying to get team from task access");
                        const s = await this.collections.get(D.w.teamMembers).find(t);
                        return await s.team.fetch()
                    }
                }
            }
            async _fetchCurrentTeam() {
                if (this.isGranted) return this._getTeamFromTaskAccess();
                if (this.isThread) {
                    const e = await this.author.fetch(),
                        t = await (null == e ? void 0 : e.team.fetch());
                    return invariant(t, "Missing team of the author"), t
                }
                return (await this._project.fetch()).getCurrentTeam()
            }
            get _me() {
                return this._fetchCurrentTeam().then((e => F.takeFirst(e.currentMember)))
            }
            async _ensureCanMoveToProject(e) {
                if (await e._ensureNotEnded(), this.isGranted) return;
                if (await this.canBeManaged()) return;
                const t = await this._project.fetch();
                t.isShared && (await t.isHostSharedProject || invariant(t.team.id === e.team.id && t.sharedTeam.id === e.sharedTeam.id || t.team.id === e.sharedTeam.id && t.sharedTeam.id === e.team.id, "Task can only be moved to a project shared between teams"))
            }
            _ensureActive() {
                invariant(this.isActive, "Operation allowed only for an active task")
            }
            async _ensureCanUpdateTimeAttributes() {
                invariant(await this.canUpdateTimeAttributes(), "Time attribute cannot be updated for the task")
            }
            unsafeSetReviewReason(e) {
                this._reviewReason = e, e && (this.reviewTriggeredAt = new Date)
            }
            makeGhost(e) {
                const t = this.collection.disposableFromDirtyRaw(this._raw);
                return t.ghostInfo = this.dates.dueDate ? {
                    instanceDueDate: e,
                    originalTaskId: this.id
                } : void 0, t
            }
        }, Ia.table = D.w.tasks, Ia.associations = (0, E.associations)([D.w.projects, {
            type: "belongs_to",
            key: Ma.projectId
        }], [D.w.projectSections, {
            type: "belongs_to",
            key: Ma.projectSectionId
        }], [D.w.taskRecurrences, {
            type: "belongs_to",
            key: Ma.recurrenceId
        }], [D.w.teamMembers, {
            type: "belongs_to",
            key: Ma.authorId
        }], [D.w.tagAssignments, {
            type: "has_many",
            foreignKey: D.o.tagAssignments.taskId
        }], [D.w.comments, {
            type: "has_many",
            foreignKey: D.o.comments.taskId
        }], [D.w.taskEvents, {
            type: "has_many",
            foreignKey: D.o.taskEvents.taskId
        }], [D.w.reminders, {
            type: "has_many",
            foreignKey: D.o.reminders.taskId
        }], [D.w.taskAccesses, {
            type: "has_many",
            foreignKey: D.o.taskAccesses.taskId
        }]), ta = Oa(ea = Ia, "dates", [O.lazy], (function() {
            return new mn(this)
        })), sa = Oa(ea, "timeline", [O.lazy], (function() {
            return new _n(this)
        })), na = Oa(ea, "do", [Cn], (function() {
            return (() => new(0, s(1243).Z)(this))()
        })), aa = Oa(ea, "name", [Rn]), oa = Oa(ea, "priorityPosition", [An]), ra = Oa(ea, "projectPosition", [In]), ia = Oa(ea, "isFollowed", [Nn]), ca = Oa(ea, "endedAt", [En]), la = Oa(ea, "_endedAt", [On]), da = Oa(ea, "extra", [Mn]), ua = Oa(ea, "lastActivityAt", [Dn]), ma = Oa(ea, "lastSeenActivityAt", [Hn]), ha = Oa(ea, "reviewTriggeredAt", [Fn]), pa = Oa(ea, "lastReviewedAt", [Zn]), ga = Oa(ea, "_project", [Ln]), fa = Oa(ea, "projectSection", [Bn]), ba = Oa(ea, "author", [zn, Un]), ya = Oa(ea, "responsible", [Wn, Gn]), va = Oa(ea, "allTags", [O.lazy], (function() {
            return this.collections.get(D.w.tags).query(E.Q.on(D.w.tagAssignments, D.o.tagAssignments.taskId, this.id))
        })), wa = Oa(ea, "tags", [O.lazy], (function() {
            return this.allTags.extend(is.Eq)
        })), ka = Oa(ea, "tagAssignments", [Vn]), xa = Oa(ea, "createdAt", [O.nochange, qn]), ja = Oa(ea, "_isEndedByAbandonment", [Qn]), Ta = Oa(ea, "_reviewReason", [Yn]), Sa = Oa(ea, "_timeNeeded", [Jn]), Pa = Oa(ea, "_timeSpent", [Kn]), _a = Oa(ea, "type", [$n]), Ca = Oa(ea, "timeAttributes", [O.lazy], (function() {
            return this.observeCurrentProject().pipe(F.switchMap((e => F.wrap(e.areTimeAttributesEnabled ? this.observe() : null))), F.map((e => {
                if (!e) return null;
                return {
                    timeNeeded: (0, Tt.C9)(e._timeNeeded),
                    timeSpent: (0, Tt.C9)(e._timeSpent)
                }
            })), F.cacheWhileConnected)
        })), Ra = Oa(ea, "_taskAccesses", [Xn]), Aa = Oa(ea, "taskAccess", [O.lazy], (function() {
            return this._taskAccesses.observe().pipe(F.tap((e => {
                this.isThread || invariant(2 > e.length, "Task cannot have more than 1 task access granted")
            })), F.map((e => 0 < e.length ? e[0] : null)))
        })), Ea(ea, "observeThreadName", [O.lazy]), Ea(ea, "observeThreadType", [O.lazy]), Ea(ea, "observeThreadMembers", [O.lazy]), Ea(ea, "observeCurrentTaskAccessMember", [O.lazy]), Ea(ea, "observeTaskAccessMembers", [O.lazy]), ea);
        var Ha, Fa, Za, La, Ba, za, Ua, Wa, Ga, Va, qa, Qa, Ya, Ja, Ka, $a, Xa, eo, to;
        const so = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            no = D.o.taskAccesses;
        let ao = (Ha = (0, O.experimentalFailsafe)(), Fa = (0, O.relation)(D.w.teamMembers, no.granteeId), Za = (0, O.experimentalFailsafe)(), La = (0, O.immutableRelation)(D.w.memberGroups, no.granteeId), Ba = (0, O.experimentalFailsafe)(), za = (0, O.immutableRelation)(D.w.teams, no.granteeId), Ua = (0, O.immutableRelation)(D.w.teamMembers, no.granterId), Wa = (0, O.field)("grantee_type"), Ga = (0, O.immutableRelation)(D.w.tasks, no.taskId), Va = (0, O.text)(no.granteeEmail), (to = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "_grantee", Qa, this), (0, I.Z)(this, "_granteeGroup", Ya, this), (0, I.Z)(this, "_granteeTeam", Ja, this), (0, I.Z)(this, "granter", Ka, this), (0, I.Z)(this, "granteeType", $a, this), (0, I.Z)(this, "task", Xa, this), (0, I.Z)(this, "granteeEmail", eo, this)
            }
            get grantee() {
                switch (this.granteeType) {
                    case "member_group":
                        return this._granteeGroup;
                    case "team":
                        return this._granteeTeam;
                    default:
                        return this._grantee
                }
            }
            get isGranteePending() {
                return !this.grantee.id
            }
            get isGTMLinkActive() {
                return this.isGranteePending && !this.granteeEmail
            }
            _prepareRevoke() {
                return this.prepareMarkAsDeleted()
            }
        }).table = D.w.taskAccesses, to.associations = (0, E.associations)([D.w.tasks, {
            type: "belongs_to",
            key: no.taskId
        }], [D.w.teamMembers, {
            type: "belongs_to",
            key: no.granteeId
        }], [D.w.teams, {
            type: "belongs_to",
            key: no.granteeId
        }], [D.w.memberGroups, {
            type: "belongs_to",
            key: no.granteeId
        }]), Qa = so(qa = to, "_grantee", [Ha, Fa]), Ya = so(qa, "_granteeGroup", [Za, La]), Ja = so(qa, "_granteeTeam", [Ba, za]), Ka = so(qa, "granter", [Ua]), $a = so(qa, "granteeType", [O.nochange, Wa]), Xa = so(qa, "task", [Ga]), eo = so(qa, "granteeEmail", [Va]), qa);
        var oo, ro, io, co, lo, uo, mo, ho, po = s(1234);
        const go = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            fo = D.o.taskPositions;
        let bo = (oo = (0, O.immutableRelation)(D.w.tasks, fo.taskId), ro = (0, O.field)(fo.listId), io = (0, O.field)(fo.position), (ho = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "task", lo, this), (0, I.Z)(this, "listId", uo, this), (0, I.Z)(this, "position", mo, this)
            }
            preparePositionUpdate(e) {
                return this.prepareUpdate((t => {
                    t.position = e
                }))
            }
        }).table = D.w.taskPositions, ho.associations = (0, E.associations)([D.w.tasks, {
            type: "belongs_to",
            key: fo.taskId
        }]), lo = go(co = ho, "task", [oo]), uo = go(co, "listId", [O.nochange, ro]), mo = go(co, "position", [io]), co);
        var yo, vo, wo, ko, xo, jo;
        const To = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            So = D.o.tagAssignments;
        let Po = (yo = (0, O.immutableRelation)(D.w.tags, So.tagId), vo = (0, O.immutableRelation)(D.w.tasks, So.taskId), (jo = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "tag", ko, this), (0, I.Z)(this, "task", xo, this)
            }
        }).table = D.w.tagAssignments, jo.associations = (0, E.associations)([D.w.tags, {
            type: "belongs_to",
            key: So.tagId
        }], [D.w.tasks, {
            type: "belongs_to",
            key: So.taskId
        }]), ko = To(wo = jo, "tag", [yo]), xo = To(wo, "task", [vo]), wo);
        var _o, Co, Ro, Ao, Io, No, Eo, Oo, Mo, Do;
        const Ho = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Fo = D.o.reminders;
        let Zo = (_o = (0, O.field)(Fo.isRelative), Co = (0, O.immutableRelation)(D.w.tasks, Fo.taskId), Ro = (0, O.field)(Fo.isAllDay), Ao = (0, O.field)(Fo.remindAt), (Do = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "isRelative", No, this), (0, I.Z)(this, "task", Eo, this), (0, I.Z)(this, "_isAllDay", Oo, this), (0, I.Z)(this, "_remindAt", Mo, this)
            }
            get remindAt() {
                return this.isRelative ? {
                    dueDateOffset: this._remindAt
                } : {
                    at: cn.DateTime.fromLegacyDueDate({
                        date: new Date(this._remindAt),
                        isAllDay: this._isAllDay
                    })
                }
            }
            set remindAt(e) {
                if (e.at) {
                    const {
                        date: t,
                        isAllDay: s
                    } = e.at.legacyDueDate;
                    this.isRelative = !1, this._remindAt = +new Date(t), this._isAllDay = s
                } else this.isRelative = !0, this._remindAt = e.dueDateOffset, this._isAllDay = !1
            }
            get isAbsolute() {
                return !this.isRelative
            }
        }).table = D.w.reminders, Do.associations = (0, E.associations)([D.w.tasks, {
            type: "belongs_to",
            key: Fo.taskId
        }]), No = Ho(Io = Do, "isRelative", [O.nochange, _o]), Eo = Ho(Io, "task", [Co]), Oo = Ho(Io, "_isAllDay", [O.nochange, Ro]), Mo = Ho(Io, "_remindAt", [O.nochange, Ao]), Io);
        var Lo, Bo, zo, Uo, Wo, Go, Vo, qo;
        const Qo = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Yo = D.o.taskRecurrences;
        let Jo = (Lo = (0, O.field)(Yo.pattern), Bo = (0, O.relation)(D.w.tasks, Yo.currentTaskId), zo = (0, O.relation)(D.w.projects, Yo.projectId), (qo = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "rawPattern", Wo, this), (0, I.Z)(this, "currentTask", Go, this), (0, I.Z)(this, "project", Vo, this)
            }
            async isActive() {
                const e = await this.currentTask.fetch().catch((() => null));
                return !(!e || e.dates.recurrence.id !== this.id) && e.isInActiveProject()
            }
        }).table = D.w.taskRecurrences, qo.associations = (0, E.associations)([D.w.tasks, {
            type: "has_many",
            foreignKey: D.o.tasks.recurrenceId
        }], [D.w.projects, {
            type: "belongs_to",
            key: Yo.projectId
        }]), Wo = Qo(Uo = qo, "rawPattern", [Lo]), Go = Qo(Uo, "currentTask", [Bo]), Vo = Qo(Uo, "project", [zo]), Uo);

        function Ko() {
            return F.nowAndEveryDay().pipe(F.map((() => 0)))
        }
        var $o = s(921);

        function Xo(e, t) {
            return F.combineLatest(e, t).pipe(F.map((([e, t]) => [...e, ...t])), F.cacheWhileConnected)
        }
        var er, tr, sr, nr, ar, or, rr, ir, cr, lr, dr, ur, mr, hr, pr, gr, fr, br, yr, vr, wr, kr, xr, jr, Tr, Sr, Pr, _r, Cr, Rr, Ar, Ir, Nr, Er, Or, Mr, Dr, Hr, Fr, Zr, Lr, Br, zr, Ur, Wr, Gr, Vr, qr, Qr, Yr, Jr, Kr, $r, Xr, ei, ti, si, ni, ai, oi, ri, ii, ci, li, di, ui, mi, hi, pi, gi, fi, bi, yi, vi, wi, ki, xi, ji, Ti, Si, Pi, _i, Ci, Ri, Ai, Ii, Ni, Ei, Oi, Mi, Di, Hi, Fi, Zi, Li, Bi, zi, Ui, Wi, Gi, Vi, qi = s(328);
        const Qi = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Yi = D.o.teams;
        let Ji = (er = H.lazy, tr = (0, O.json)(Yi.planInfo, M.V1), sr = (0, O.json)(Yi.paymentInfo, M.S$), nr = (0, O.json)(Yi.limits, M.$r), ar = (0, O.field)(Yi.isPersonal), or = (0, O.field)(Yi.isShared), rr = (0, O.text)(Yi.name), ir = (0, O.field)(Yi.color), cr = (0, O.field)(Yi.avatarId), lr = (0, O.field)(Yi.sidebarPosition), dr = (0, O.relation)(D.w.businesses, Yi.businessId), ur = (0, O.children)(D.w.projects), mr = (0, O.children)(D.w.tags), hr = (0, O.children)(D.w.projectGroups), pr = (0, O.children)(D.w.memberGroups), gr = (0, O.children)(D.w.teamMembers), Vi = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", br, this), (0, I.Z)(this, "_planInfo", yr, this), (0, I.Z)(this, "paymentInfo", vr, this), (0, I.Z)(this, "_limits", wr, this), (0, I.Z)(this, "isPersonal", kr, this), (0, I.Z)(this, "isShared", xr, this), (0, I.Z)(this, "name", jr, this), (0, I.Z)(this, "color", Tr, this), (0, I.Z)(this, "avatarId", Sr, this), (0, I.Z)(this, "sidebarPosition", Pr, this), (0, I.Z)(this, "isPending", _r, this), (0, I.Z)(this, "business", Cr, this), (0, I.Z)(this, "projects", Rr, this), (0, I.Z)(this, "allProjects", Ar, this), (0, I.Z)(this, "allProjectsWithoutSingleTasks", Ir, this), (0, I.Z)(this, "allProjectsWithoutTemplates", Nr, this), (0, I.Z)(this, "activeProjectsWithSingleTasks", Er, this), (0, I.Z)(this, "activeProjects", Or, this), (0, I.Z)(this, "activeProjectsWithoutTemplates", Mr, this), (0, I.Z)(this, "allFollowedNotFavoriteProjects", Dr, this), (0, I.Z)(this, "followedNotFavoriteProjects", Hr, this), (0, I.Z)(this, "allFollowedProjects", Fr, this), (0, I.Z)(this, "followedProjects", Zr, this), (0, I.Z)(this, "allFavoriteProjects", Lr, this), (0, I.Z)(this, "favoriteProjects", Br, this), (0, I.Z)(this, "singleTasks", zr, this), (0, I.Z)(this, "endedProjects", Ur, this), (0, I.Z)(this, "endedProjectsWithoutTemplates", Wr, this), (0, I.Z)(this, "sharedProjects", Gr, this), (0, I.Z)(this, "projectsWithTimeAttributesEnabled", Vr, this), (0, I.Z)(this, "projectTemplates", qr, this), (0, I.Z)(this, "activeProjectTemplates", Qr, this), (0, I.Z)(this, "endedProjectTemplates", Yr, this), (0, I.Z)(this, "activeSections", Jr, this), (0, I.Z)(this, "allSharedTags", Kr, this), (0, I.Z)(this, "sharedTags", $r, this), (0, I.Z)(this, "allTags", Xr, this), (0, I.Z)(this, "tags", ei, this), (0, I.Z)(this, "archivedTags", ti, this), this._allPrivateTags = this.collections.get(D.w.tags).query(E.Q.where(D.o.tags.teamId, null), E.Q.where(D.o.tags.preferences, E.Q.like('%"' + is.mc.teamSettings + '":%"' + this.id + '":%'))), this._privateTags = this._allPrivateTags.extend(is.Eq), (0, I.Z)(this, "allTagsOnSidebarNotFavorite", si, this), (0, I.Z)(this, "allTagsOnSidebar", ni, this), (0, I.Z)(this, "allFavoriteTags", ai, this), (0, I.Z)(this, "allProjectGroups", oi, this), (0, I.Z)(this, "projectGroupsOnSidebar", ri, this), (0, I.Z)(this, "allMemberGroups", ii, this), (0, I.Z)(this, "nonAdminGroups", ci, this), (0, I.Z)(this, "allMembers", li, this), (0, I.Z)(this, "members", di, this), (0, I.Z)(this, "membersExcludingRequests", ui, this), (0, I.Z)(this, "_unsafeCurrentMember", mi, this), (0, I.Z)(this, "currentMember", hi, this), (0, I.Z)(this, "owner", pi, this), (0, I.Z)(this, "membersOnSidebar", gi, this), (0, I.Z)(this, "membersOnSidebarNotFavorite", fi, this), (0, I.Z)(this, "favoriteMembers", bi, this), (0, I.Z)(this, "archivedMembers", yi, this), (0, I.Z)(this, "pendingMembers", vi, this), (0, I.Z)(this, "expiredMembers", wi, this), (0, I.Z)(this, "activeMembers", ki, this), (0, I.Z)(this, "membersRequestingJoin", xi, this), (0, I.Z)(this, "isTeamOfOne", ji, this), (0, I.Z)(this, "allTasks", Ti, this), (0, I.Z)(this, "tasksInActiveProjects", Si, this), (0, I.Z)(this, "tasksInActiveProjectsWithoutTemplates", Pi, this), (0, I.Z)(this, "activeTasks", _i, this), (0, I.Z)(this, "currentTasks", Ci, this), this.triggeredReminders = this.tasksInActiveProjectsWithoutTemplates.pipe(F.map((e => e.extend(E.Q.where(D.o.tasks.reviewReason, "reminder"), E.Q.where(D.o.tasks.reviewTriggeredAt, E.Q.weakGt(E.Q.column(D.o.tasks.lastReviewedAt))))))), (0, I.Z)(this, "allMessageThreads", Ri, this), (0, I.Z)(this, "activeMessageThreads", Ai, this), (0, I.Z)(this, "tasksWithRecurrence", Ii, this), (0, I.Z)(this, "allPriorityTasks", Ni, this), (0, I.Z)(this, "activePriorityTasks", Ei, this), (0, I.Z)(this, "activePriorityTasksCounter", Oi, this), (0, I.Z)(this, "currentPriorityTasks", Mi, this), (0, I.Z)(this, "grantedTaskAccesses", Di, this), (0, I.Z)(this, "grantedTaskAccessesIds", Hi, this), (0, I.Z)(this, "incomingTasks", Fi, this), (0, I.Z)(this, "incomingTasksCounter", Zi, this), (0, I.Z)(this, "activityTasks", Li, this), (0, I.Z)(this, "activityTasksCounter", Bi, this), (0, I.Z)(this, "unreadThreadsCounter", zi, this), (0, I.Z)(this, "singleAndGrantedTasksCounter", Ui, this), (0, I.Z)(this, "projectEventsInUnseenProjects", Wi, this), (0, I.Z)(this, "billableMembersCount", Gi, this)
            }
            get planInfo() {
                return this._ensureNotShared(), this._planInfo
            }
            get isFree() {
                return this.planInfo.isFree
            }
            get isTrial() {
                return this.planInfo.isTrial
            }
            get isFreeOrTrial() {
                return this.planInfo.isFreeOrTrial
            }
            get expiresAt() {
                return this.planInfo.expiresAt
            }
            get isExpired() {
                return !this.isFree && this.planInfo.isExpired
            }
            get limits() {
                return this._ensureNotShared(), this._limits
            }
            get isTeam() {
                return !this.isPersonal
            }
            getAllFavoriteTagsObservable(e) {
                return Xo((0, as.c0)(this.sharedTags).observeWithColumns([...e, ...is.A3]), this._privateTags.observeWithColumns([...e, ...is.ST]).pipe(F.map((e => e.filter((e => (0, as.Dq)(e, this)))))))
            }
            calendarDueTasks(e, t, n) {
                return s(1245).p(this, e, t, n)
            }
            activeRemindersBetween(e, t) {
                return s(1246)._(this, e, t)
            }
            withGrantedTasksQuery(e) {
                return this.grantedTaskAccessesIds.pipe(F.map((t => e(E.Q.and(E.Q.where(D.o.id, E.Q.oneOf(t)), E.Q.where(D.o.tasks.type, null))))))
            }
            getIncomingTasksNotInPriorityFor(e) {
                return this.incomingTasks.pipe(F.map((t => t.extend(E.Q.where(D.o.tasks.reviewReason, e), E.Q.where(D.o.tasks.priorityPosition, null)))))
            }
            async findThreadForMember(e) {
                return this._findThreadFor([E.Q.experimentalNestedJoin(D.w.taskAccesses, D.w.teamMembers), E.Q.on(D.w.taskAccesses, E.Q.on(D.w.teamMembers, E.Q.where(D.o.id, e.id)))])
            }
            async findThreadForTeam(e) {
                return this._findThreadFor([E.Q.experimentalNestedJoin(D.w.taskAccesses, D.w.teams), E.Q.on(D.w.taskAccesses, E.Q.on(D.w.teams, E.Q.where(D.o.id, e.id)))])
            }
            async findThreadForGroup(e) {
                return this._findThreadFor([E.Q.experimentalNestedJoin(D.w.taskAccesses, D.w.memberGroups), E.Q.on(D.w.taskAccesses, E.Q.on(D.w.memberGroups, E.Q.where(D.o.id, e.id)))])
            }
            async _findThreadFor(e) {
                return (await F.takeFirst(this.activeMessageThreads.pipe(F.switchMap((t => t.extend(e).fetch())))))[0]
            }
            async getAllFavorites() {
                const [e, t, s] = await Promise.all([this.favoriteProjects.fetch(), this.favoriteMembers.fetch(), F.takeFirst(this.allFavoriteTags)]);
                return [...e, ...t, ...s]
            }
            async canBeRenamed() {
                if (this.isPersonal || this.isShared) return !1;
                const e = await F.takeFirst(this.currentMember);
                return await F.takeFirst(e.hasAdminPowers)
            }
            async canCreateMemberGroup() {
                const e = this.limits.memberGroups;
                return await this.allMemberGroups.fetchCount() < e
            }
            async canCreateProjectGroup() {
                const e = this.limits.projectGroups;
                return await this.allProjectGroups.fetchCount() < e
            }
            get canEnableTimeAttributes() {
                return !this.isShared && !this.isFree && !this.isExpired
            }
            async _canCreateProjects(e, t = 1) {
                if (this.isShared) return !1;
                return await this.activeProjects.extend(E.Q.and(E.Q.where(D.o.projects.isTemplate, !1), e ? E.Q.or(E.Q.where(D.o.projects.isOpen, !0), E.Q.where(D.o.projects.sharedTeamId, E.Q.notEq(null))) : E.Q.where(D.o.projects.isOpen, !1))).fetchCount() + (t || 1) <= (e ? this.limits.openProjects : this.limits.sharedProjects)
            }
            async canCreateOpenProjects(e) {
                return this._canCreateProjects(!0, e)
            }
            async canInviteToProject() {
                return this._canCreateProjects(!1)
            }
            async canCreateProjectTemplate() {
                if (this.isShared) return !1;
                return await this.activeProjectTemplates.fetchCount() < this.limits.projectTemplates
            }
            async canCreateSharedTag() {
                if (this.isShared || this.isPersonal) return !1;
                return await this.sharedTags.fetchCount() < this.limits.sharedTags
            }
            async canCreatePrivateTag() {
                return !this.isShared && await this._privateTags.fetchCount() < this.limits.privateTags
            }
            async canCreateAnyTag() {
                if (this.isShared) return !1;
                const e = await this.canCreateSharedTag(),
                    t = await this.canCreatePrivateTag();
                return e || t
            }
            async canInviteMembers(e) {
                if (this.isShared || this.isPersonal) return !1;
                if (this.isTrial) return !0;
                return await F.takeFirst(this.billableMembersCount) + e <= this.limits.teamMembers
            }
            async canInviteBusinessMembers() {
                if (this.isShared || this.isPersonal || !this.planInfo.isBusiness) return !1;
                const e = await F.takeFirst(this.currentMember);
                if (await F.takeFirst(e.hasAdminPowers)) return !0;
                const t = await this.business.fetch();
                invariant(t, "Expected team with business plan to be assigned to a business");
                return (await t._me).hasAdminPowers
            }
            async markAsDeleted() {
                H.logError(H.PROD_CONSOLE_REASON.SAFE_LITERAL, "Attempted to destroy Team from client side", "warning")
            }
            _ensureNotShared() {
                invariant(!this.isShared, "Operation not allowed on a shared team")
            }
            _ensureNotPersonal() {
                invariant(!this.isPersonal, "Operation not allowed on a personal team")
            }
        }, Vi.table = D.w.teams, Vi.associations = (0, E.associations)([D.w.businesses, {
            type: "belongs_to",
            key: Yi.businessId
        }], [D.w.projects, {
            type: "has_many",
            foreignKey: D.o.projects.teamId
        }], [D.w.projectGroups, {
            type: "has_many",
            foreignKey: D.o.projectGroups.teamId
        }], [D.w.memberGroups, {
            type: "has_many",
            foreignKey: D.o.memberGroups.teamId
        }], [D.w.tags, {
            type: "has_many",
            foreignKey: D.o.tags.teamId
        }], [D.w.settings, {
            type: "has_many",
            foreignKey: D.o.settings.teamId
        }], [D.w.teamMembers, {
            type: "has_many",
            foreignKey: D.o.teamMembers.teamId
        }]), br = Qi(fr = Vi, "do", [er], (function() {
            return (() => new(0, s(1247).Z)(this))()
        })), yr = Qi(fr, "_planInfo", [O.nochange, tr]), vr = Qi(fr, "paymentInfo", [O.nochange, sr]), wr = Qi(fr, "_limits", [O.nochange, nr]), kr = Qi(fr, "isPersonal", [O.nochange, ar]), xr = Qi(fr, "isShared", [O.nochange, or]), jr = Qi(fr, "name", [rr]), Tr = Qi(fr, "color", [O.nochange, ir]), Sr = Qi(fr, "avatarId", [cr]), Pr = Qi(fr, "sidebarPosition", [lr]), _r = Qi(fr, "isPending", [O.lazy], (function() {
            return this._unsafeCurrentMember.pipe(F.map((e => !e)))
        })), Cr = Qi(fr, "business", [dr]), Rr = Qi(fr, "projects", [ur]), Ar = Qi(fr, "allProjects", [O.lazy], (function() {
            return this.collections.get(D.w.projects).query((0, os.J$)(this.id))
        })), Ir = Qi(fr, "allProjectsWithoutSingleTasks", [O.lazy], (function() {
            return this.allProjects.extend(E.Q.where(D.o.projects.isSingleTasks, !1))
        })), Nr = Qi(fr, "allProjectsWithoutTemplates", [O.lazy], (function() {
            return this.allProjects.extend(os.Vf)
        })), Er = Qi(fr, "activeProjectsWithSingleTasks", [O.lazy], (function() {
            return this.allProjects.extend(os.Y3)
        })), Or = Qi(fr, "activeProjects", [O.lazy], (function() {
            return this.activeProjectsWithSingleTasks.extend(E.Q.where(D.o.projects.isSingleTasks, !1))
        })), Mr = Qi(fr, "activeProjectsWithoutTemplates", [O.lazy], (function() {
            return this.activeProjects.extend(os.Vf)
        })), Dr = Qi(fr, "allFollowedNotFavoriteProjects", [O.lazy], (function() {
            return (0, as.s)(this.allProjectsWithoutSingleTasks)
        })), Hr = Qi(fr, "followedNotFavoriteProjects", [O.lazy], (function() {
            return (0, as.s)(this.activeProjects)
        })), Fr = Qi(fr, "allFollowedProjects", [O.lazy], (function() {
            return (0, as.bb)(this.allProjects)
        })), Zr = Qi(fr, "followedProjects", [O.lazy], (function() {
            return (0, as.bb)(this.activeProjects)
        })), Lr = Qi(fr, "allFavoriteProjects", [O.lazy], (function() {
            return (0, as.c0)(this.allProjectsWithoutSingleTasks)
        })), Br = Qi(fr, "favoriteProjects", [O.lazy], (function() {
            return (0, as.c0)(this.activeProjects)
        })), zr = Qi(fr, "singleTasks", [O.lazy], (function() {
            return this.projects.extend(E.Q.where(D.o.projects.isSingleTasks, !0)).observe().pipe(F.switchMap((([e]) => (invariant(e, "No Single Tasks project for team " + this.id), e.observe()))))
        })), Ur = Qi(fr, "endedProjects", [O.lazy], (function() {
            return this.allProjects.extend(os.yK)
        })), Wr = Qi(fr, "endedProjectsWithoutTemplates", [O.lazy], (function() {
            return this.endedProjects.extend(os.Vf)
        })), Gr = Qi(fr, "sharedProjects", [O.lazy], (function() {
            return this.allProjects.extend(E.Q.where(D.o.projects.sharedTeamId, E.Q.notEq(null)))
        })), Vr = Qi(fr, "projectsWithTimeAttributesEnabled", [O.lazy], (function() {
            return this.activeProjects.extend(E.Q.where(D.o.projects.extra, E.Q.like('%"' + os.ku.areTimeAttributesEnabled + ':%true"%')))
        })), qr = Qi(fr, "projectTemplates", [O.lazy], (function() {
            return this.allProjectsWithoutSingleTasks.extend(os.ck)
        })), Qr = Qi(fr, "activeProjectTemplates", [O.lazy], (function() {
            return this.projectTemplates.extend(os.Y3)
        })), Yr = Qi(fr, "endedProjectTemplates", [O.lazy], (function() {
            return this.projectTemplates.extend(os.yK)
        })), Jr = Qi(fr, "activeSections", [O.lazy], (function() {
            return this.collections.get(D.w.projectSections).query(E.Q.on(D.w.projects, E.Q.and((0, os.J$)(this.id), os.Y3)), E.Q.where(D.o.projectSections.archivedAt, null))
        })), Kr = Qi(fr, "allSharedTags", [mr]), $r = Qi(fr, "sharedTags", [O.lazy], (function() {
            return this.allSharedTags.extend(is.Eq)
        })), Xr = Qi(fr, "allTags", [O.lazy], (function() {
            return this.collections.get(D.w.tags).query(E.Q.or(E.Q.where(D.o.tags.teamId, this.id), E.Q.where(D.o.tags.teamId, null)))
        })), ei = Qi(fr, "tags", [O.lazy], (function() {
            return this.allTags.extend(is.Eq)
        })), ti = Qi(fr, "archivedTags", [O.lazy], (function() {
            return this.allTags.extend(is.EX)
        })), si = Qi(fr, "allTagsOnSidebarNotFavorite", [O.lazy], (function() {
            return Xo((0, as.s)(this.sharedTags).observeWithColumns(is.A3), this._privateTags.observeWithColumns(is.ST).pipe(F.map((e => e.filter((e => (0, as.S1)(e, this) && !(0, as.Dq)(e, this)))))))
        })), ni = Qi(fr, "allTagsOnSidebar", [O.lazy], (function() {
            return Xo((0, as.bb)(this.sharedTags).observeWithColumns(is.A3), this._privateTags.observeWithColumns(is.ST).pipe(F.map((e => e.filter((e => (0, as.S1)(e, this)))))))
        })), ai = Qi(fr, "allFavoriteTags", [O.lazy], (function() {
            return this.getAllFavoriteTagsObservable([])
        })), oi = Qi(fr, "allProjectGroups", [hr]), ri = Qi(fr, "projectGroupsOnSidebar", [O.lazy], (function() {
            return this.allProjectGroups.extend(E.Q.where(D.o.projectGroups.sidebarPosition, E.Q.notEq(null)))
        })), ii = Qi(fr, "allMemberGroups", [pr]), ci = Qi(fr, "nonAdminGroups", [O.lazy], (function() {
            return this.allMemberGroups.extend(E.Q.where(D.o.memberGroups.isAdminGroup, !1))
        })), li = Qi(fr, "allMembers", [gr]), di = Qi(fr, "members", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.where(D.o.teamMembers.status, E.Q.notEq("archived")))
        })), ui = Qi(fr, "membersExcludingRequests", [O.lazy], (function() {
            return this.members.extend(E.Q.and(E.Q.where(D.o.teamMembers.status, E.Q.notEq("requesting_join"))))
        })), mi = Qi(fr, "_unsafeCurrentMember", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.on(D.w.users, D.o.users.isMe, !0)).observe().pipe(F.switchMap((([e]) => e ? e.observe() : F.of(null))))
        })), hi = Qi(fr, "currentMember", [O.lazy], (function() {
            return this._unsafeCurrentMember.pipe(F.switchMap((e => (invariant(e, "No current member found for team " + this.id), e.observe()))))
        })), pi = Qi(fr, "owner", [O.lazy], (function() {
            return this.members.extend(E.Q.where(D.o.teamMembers.role, "owner")).observe().pipe(F.switchMap((([e]) => (invariant(e, "No owner found for team " + this.id), e.observe()))))
        })), gi = Qi(fr, "membersOnSidebar", [O.lazy], (function() {
            return (0, as.bb)(this.members)
        })), fi = Qi(fr, "membersOnSidebarNotFavorite", [O.lazy], (function() {
            return (0, as.s)(this.members.extend(E.Q.on(D.w.users, D.o.users.isMe, !1)))
        })), bi = Qi(fr, "favoriteMembers", [O.lazy], (function() {
            return (0, as.c0)(this.members)
        })), yi = Qi(fr, "archivedMembers", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.where(D.o.teamMembers.status, "archived"))
        })), vi = Qi(fr, "pendingMembers", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.where(D.o.teamMembers.status, "pending"))
        })), wi = Qi(fr, "expiredMembers", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.where(D.o.teamMembers.status, "expired"))
        })), ki = Qi(fr, "activeMembers", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.where(D.o.teamMembers.status, "active"))
        })), xi = Qi(fr, "membersRequestingJoin", [O.lazy], (function() {
            return this.allMembers.extend(E.Q.where(D.o.teamMembers.status, "requesting_join"))
        })), ji = Qi(fr, "isTeamOfOne", [O.lazy], (function() {
            return this.members.observeCount().pipe(F.map((e => 1 >= e)))
        })), Ti = Qi(fr, "allTasks", [O.lazy], (function() {
            return this.grantedTaskAccessesIds.pipe(F.map((e => this.collections.get(D.w.tasks).query(...(0, qi.UB)(this.id, e), E.Q.where(D.o.tasks.type, null)))))
        })), Si = Qi(fr, "tasksInActiveProjects", [O.lazy], (function() {
            return this.grantedTaskAccessesIds.pipe(F.map((e => this.collections.get(D.w.tasks).query(...(0, qi.F1)(this.id, e)))))
        })), Pi = Qi(fr, "tasksInActiveProjectsWithoutTemplates", [O.lazy], (function() {
            return this.grantedTaskAccessesIds.pipe(F.map((e => this.collections.get(D.w.tasks).query(...(0, qi.kB)(this.id, e)))), F.cacheWhileConnected)
        })), _i = Qi(fr, "activeTasks", [O.lazy], (function() {
            return this.tasksInActiveProjects.pipe(F.map((e => e.extend(Tt.rG))))
        })), Ci = Qi(fr, "currentTasks", [O.lazy], (function() {
            return this.tasksInActiveProjects.pipe(F.switchMap(Tt.P7))
        })), Ri = Qi(fr, "allMessageThreads", [O.lazy], (function() {
            return this.allMembers.observe().pipe(F.map((e => {
                const t = e.map((e => e.id));
                return this.collections.get(D.w.tasks).query(E.Q.experimentalJoinTables([D.w.taskAccesses]), E.Q.on(D.w.taskAccesses, E.Q.or(E.Q.where(D.o.taskAccesses.granteeId, E.Q.oneOf(t)), E.Q.where(D.o.taskAccesses.granterId, E.Q.oneOf(t)))), E.Q.where(D.o.tasks.type, "thread"))
            })))
        })), Ai = Qi(fr, "activeMessageThreads", [O.lazy], (function() {
            return this.allMessageThreads.pipe(F.map((e => e.extend(E.Q.where(D.o.tasks.endedAt, null)))))
        })), Ii = Qi(fr, "tasksWithRecurrence", [O.lazy], (function() {
            return this.allTasks.pipe(F.map((e => e.extend(...Tt.tH))))
        })), Ni = Qi(fr, "allPriorityTasks", [O.lazy], (function() {
            return this.withGrantedTasksQuery((e => this.collections.get(D.w.tasks).query(E.Q.experimentalJoinTables([D.w.projects]), E.Q.where(D.o.tasks.priorityPosition, E.Q.notEq(null)), E.Q.or(E.Q.on(D.w.projects, E.Q.and(os.Y3, (0, os.J$)(this.id))), e))))
        })), Ei = Qi(fr, "activePriorityTasks", [O.lazy], (function() {
            return this.allPriorityTasks.pipe(F.map((e => e.extend(Tt.rG))))
        })), Oi = Qi(fr, "activePriorityTasksCounter", [O.lazy], (function() {
            return this.activePriorityTasks.pipe(F.switchMap((e => e.observeCount())))
        })), Mi = Qi(fr, "currentPriorityTasks", [O.lazy], (function() {
            return this.allPriorityTasks.pipe(F.switchMap((e => (0, Tt.P7)(e))))
        })), Di = Qi(fr, "grantedTaskAccesses", [O.lazy], (function() {
            return this.currentMember.pipe(F.switchMap((e => e.grantedTaskAccesses.observe())))
        })), Hi = Qi(fr, "grantedTaskAccessesIds", [O.lazy], (function() {
            return this.grantedTaskAccesses.pipe(F.map((e => e.map((e => e.task.id)))))
        })), Fi = Qi(fr, "incomingTasks", [O.lazy], (function() {
            return this.withGrantedTasksQuery((e => this.collections.get(D.w.tasks).query(E.Q.experimentalJoinTables([D.w.projects]), E.Q.where(D.o.tasks.reviewReason, E.Q.notEq(null)), E.Q.where(D.o.tasks.reviewTriggeredAt, E.Q.weakGt(E.Q.column(D.o.tasks.lastReviewedAt))), E.Q.or(E.Q.on(D.w.projects, (0, os.J$)(this.id)), e))))
        })), Zi = Qi(fr, "incomingTasksCounter", [O.lazy], (function() {
            return this.isPending.pipe(F.switchMap((e => e ? F.of(0) : this.incomingTasks.pipe(F.switchMap((e => e.observeCount()))))), F.cacheWhileConnected)
        })), Li = Qi(fr, "activityTasks", [O.lazy], (function() {
            return Ko().pipe(F.switchMap((e => this.withGrantedTasksQuery((t => this.collections.get(D.w.tasks).query(E.Q.experimentalJoinTables([D.w.projects]), Tt.DY, E.Q.where(D.o.tasks.lastActivityAt, E.Q.gte(e)), E.Q.or(E.Q.and(E.Q.or(E.Q.on(D.w.projects, (0, os.J$)(this.id)), t), E.Q.where(D.o.tasks.isFollowed, !0)), E.Q.on(D.w.projects, E.Q.and((0, os.J$)(this.id), E.Q.where(D.o.projects.sidebarPosition, E.Q.notEq(null)))))))))))
        })), Bi = Qi(fr, "activityTasksCounter", [O.lazy], (function() {
            return this.activityTasks.pipe(F.switchMap((e => e.observeCount())))
        })), zi = Qi(fr, "unreadThreadsCounter", [O.lazy], (function() {
            return this.activeMessageThreads.pipe(F.switchMap((e => e.extend(Tt.DY).observeCount())))
        })), Ui = Qi(fr, "singleAndGrantedTasksCounter", [O.lazy], (function() {
            return F.combineLatest(this.singleTasks.pipe(F.switchMap((e => e.activeTasks.observeCount()))), this.currentMember.pipe(F.switchMap((e => e.grantedTasks.pipe(F.switchMap((e => e.observeCount()))))))).pipe(F.map((([e, t]) => t + e)))
        })), Wi = Qi(fr, "projectEventsInUnseenProjects", [O.lazy], (function() {
            return Ko().pipe(F.map((e => this.collections.get(D.w.projectEvents).query(E.Q.where(D.o.projectEvents.createdAt, E.Q.gte(e)), E.Q.on(D.w.projects, [(0, os.J$)(this.id), os.O6])))))
        })), Gi = Qi(fr, "billableMembersCount", [O.lazy], (function() {
            return (0, $o.S)(this)
        })), fr);
        var Ki, $i, Xi, ec, tc, sc, nc, ac, oc, rc, ic, cc, lc, dc, uc, mc, hc, pc, gc, fc, bc, yc, vc, wc, kc, xc, jc, Tc, Sc, Pc, _c, Cc, Rc, Ac, Ic, Nc, Ec, Oc, Mc, Dc, Hc, Fc, Zc, Lc, Bc, zc, Uc, Wc, Gc, Vc = s(123);
        const qc = (e, t, s) => (0, N.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            Qc = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Yc = D.o.teamMembers;
        let Jc = (Ki = H.lazy, $i = (0, O.field)(Yc.role), Xi = (0, O.field)(Yc.status), ec = (0, O.text)(Yc.alias), tc = (0, O.text)(Yc.description), sc = (0, O.json)(Yc.contactInfo, Vc.Ml), nc = (0, O.json)(Yc.vacations, ne.k5), ac = (0, O.field)(Yc.sidebarPosition), oc = (0, O.field)(Yc.isFavorite), rc = (0, O.immutableRelation)(D.w.teams, Yc.teamId), ic = (0, O.relation)(D.w.users, Yc.userId), cc = (0, O.children)(D.w.projectAccesses), lc = (0, O.children)(D.w.groupAssignments), dc = (0, O.children)(D.w.attachmentVersions), uc = (0, O.children)(D.w.taskAccesses), (Gc = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", hc, this), (0, I.Z)(this, "hasAdminPowers", pc, this), (0, I.Z)(this, "role", gc, this), (0, I.Z)(this, "status", fc, this), (0, I.Z)(this, "alias", bc, this), (0, I.Z)(this, "preferredName", yc, this), (0, I.Z)(this, "secondaryName", vc, this), (0, I.Z)(this, "description", wc, this), (0, I.Z)(this, "contactInfo", kc, this), (0, I.Z)(this, "_vacations", xc, this), (0, I.Z)(this, "sidebarPosition", jc, this), (0, I.Z)(this, "isFavorite", Tc, this), (0, I.Z)(this, "team", Sc, this), (0, I.Z)(this, "user", Pc, this), (0, I.Z)(this, "businessMember", _c, this), (0, I.Z)(this, "projectAccesses", Cc, this), (0, I.Z)(this, "groupAssignments", Rc, this), (0, I.Z)(this, "attachmentVersions", Ac, this), (0, I.Z)(this, "grantedTaskAccesses", Ic, this), (0, I.Z)(this, "taskAccesses", Nc, this), (0, I.Z)(this, "grantedTasks", Ec, this), (0, I.Z)(this, "allTasksResponsibleFor", Oc, this), (0, I.Z)(this, "allTasksResponsibleForInProjects", Mc, this), (0, I.Z)(this, "tasksResponsibleFor", Dc, this), (0, I.Z)(this, "tasksResponsibleForInProjects", Hc, this), (0, I.Z)(this, "activeTasksResponsibleFor", Fc, this), (0, I.Z)(this, "groups", Zc, this), (0, I.Z)(this, "teamVacations", Lc, this), (0, I.Z)(this, "businessVacations", Bc, this), (0, I.Z)(this, "allActiveVacations", zc, this), (0, I.Z)(this, "awayOnVacationUntil", Uc, this), (0, I.Z)(this, "isAwayOnVacation", Wc, this)
            }
            get isOwner() {
                return "owner" === this.role
            }
            get isAdmin() {
                return "admin" === this.role
            }
            get isActive() {
                return "active" === this.status
            }
            get isPending() {
                return "pending" === this.status || "expired" === this.status
            }
            get isExpired() {
                return "expired" === this.status
            }
            get isWaitingForActivation() {
                return this.isPending && !this.isExpired
            }
            get isWaitingForApproval() {
                return "requesting_join" === this.status
            }
            get isArchived() {
                return "archived" === this.status
            }
            get isTeamMember() {
                return this.team.fetch().then((e => e.isTeam))
            }
            get isPersonalTeamMember() {
                return this.team.fetch().then((e => e.isPersonal))
            }
            get isSharedTeamMember() {
                return this.team.fetch().then((e => e.isShared))
            }
            async openOnSidebar() {
                this._ensureNotArchived(), await this._ensureNotShared();
                const e = await this.team.fetch(),
                    t = await e.membersOnSidebarNotFavorite.fetch();
                await (0, as.NV)(this, t, e, {
                    maxOpen: 4
                })
            }
            async removeFromSidebar() {
                this._ensureNotArchived(), await this._ensureNotShared();
                const e = await this.team.fetch();
                await (0, as.OO)(this, e)
            }
            async favorite() {
                this._ensureNotArchived(), await this._ensureNotShared();
                const e = await this.team.fetch();
                await (0, as.GD)(this, e)
            }
            async unfavorite() {
                this._ensureNotArchived(), await this._ensureNotShared();
                const e = await this.team.fetch(),
                    t = await e.membersOnSidebarNotFavorite.fetch();
                await (0, as.WN)(this, t, e)
            }
            async updateSidebarPosition(e, t) {
                await this._ensureNotShared(), invariant(t.id === this.team.id, "Model does not belong to the given team"), await (0, as.D5)(this, t, e)
            }
            asSidebarFavoritable(e) {
                return e.id !== this.team.id ? new as.ke : this
            }
            async canHaveAliasRenamed() {
                const e = await this._me;
                return await this.isTeamMember && this === e
            }
            async canHaveDescriptionUpdated() {
                const e = await this._me,
                    t = await F.takeFirst(e.hasAdminPowers);
                return await this.isTeamMember && !await this.isSharedTeamMember && (this === e || this.isPending && t)
            }
            async canBePromotedToAdminDueToLimits() {
                if (await this.isSharedTeamMember) return !1;
                const e = await this.team.fetch();
                return await this.collection.query(E.Q.where(Yc.role, "admin"), E.Q.where(Yc.teamId, e.id), E.Q.where(Yc.status, E.Q.notEq("archived"))).fetchCount() < e.limits.teamAdmins
            }
            async canBePromotedToAdmin() {
                const e = await this._me,
                    t = await F.takeFirst(e.hasAdminPowers);
                return await this.isTeamMember && !await this.isSharedTeamMember && !this.isArchived && "member" === this.role && t
            }
            async canBeDemotedAdmin() {
                const e = await this._me,
                    t = await F.takeFirst(e.hasAdminPowers);
                return await this.isTeamMember && !await this.isSharedTeamMember && !this.isArchived && this.isAdmin && !this.isOwner && t
            }
            async canBeArchived() {
                const e = await this._me,
                    t = await F.takeFirst(e.hasAdminPowers);
                return !this.isArchived && ((this.isAdmin || this.isOwner ? e.isOwner : t) || this.id === e.id) && !await this.isSharedTeamMember
            }
            async canBeAccepted() {
                const e = await this._me,
                    t = await F.takeFirst(e.hasAdminPowers);
                return this.isWaitingForApproval && (this.isAdmin ? e.isOwner : t) && !await this.isSharedTeamMember
            }
            async markAsDeleted() {
                H.logError(H.PROD_CONSOLE_REASON.SAFE_LITERAL, "Attempted to destroy TeamMember instead of archiving it", "warning")
            }
            async _getCurrentTeam() {
                const e = await this.team.fetch();
                if (e.isShared) {
                    const t = await e.sharedProjects.fetch();
                    invariant(t.length, "Member belongs to a shared team but there are no projects associated with it");
                    const [s] = t;
                    return s.getCurrentTeam()
                }
                return e
            }
            get _me() {
                return this._getCurrentTeam().then((e => F.takeFirst(e.currentMember)))
            }
            _ensureNotArchived() {
                invariant(!this.isArchived, "Operation not allowed on archived members")
            }
            async _ensureNotShared() {
                const e = await this.isSharedTeamMember;
                invariant(!e, "Operation not allowed on shared members")
            }
        }).table = D.w.teamMembers, Gc.associations = (0, E.associations)([D.w.teams, {
            type: "belongs_to",
            key: Yc.teamId
        }], [D.w.users, {
            type: "belongs_to",
            key: Yc.userId
        }], [D.w.groupAssignments, {
            type: "has_many",
            foreignKey: D.o.groupAssignments.objectId
        }], [D.w.projectAccesses, {
            type: "has_many",
            foreignKey: D.o.projectAccesses.memberId
        }], [D.w.attachmentVersions, {
            type: "has_many",
            foreignKey: D.o.attachmentVersions.authorId
        }], [D.w.taskAccesses, {
            type: "has_many",
            foreignKey: D.o.taskAccesses.granteeId
        }]), hc = Qc(mc = Gc, "do", [Ki], (function() {
            return (() => new(0, s(1248).Z)(this))()
        })), pc = Qc(mc, "hasAdminPowers", [O.lazy], (function() {
            return this.observe().pipe(F.switchMap((() => this.isOwner || this.isAdmin ? F.of(!0) : this.businessMember.pipe(F.map((e => !(null == e || !e.hasAdminPowers)))))), F.cacheWhileConnected)
        })), gc = Qc(mc, "role", [$i]), fc = Qc(mc, "status", [Xi]), bc = Qc(mc, "alias", [ec]), yc = Qc(mc, "preferredName", [O.lazy], (function() {
            return this.observe().pipe(F.switchMap((e => e.alias ? F.of(e.alias) : this.user.observe().pipe(F.map((e => e.name))))), F.cacheWhileConnected)
        })), vc = Qc(mc, "secondaryName", [O.lazy], (function() {
            return this.observe().pipe(F.switchMap((e => e.alias ? this.user.observe().pipe(F.map((e => e.name))) : F.of(null))), F.cacheWhileConnected)
        })), wc = Qc(mc, "description", [tc]), kc = Qc(mc, "contactInfo", [O.readonly, sc]), xc = Qc(mc, "_vacations", [nc]), jc = Qc(mc, "sidebarPosition", [ac]), Tc = Qc(mc, "isFavorite", [oc]), Sc = Qc(mc, "team", [rc]), Pc = Qc(mc, "user", [ic]), _c = Qc(mc, "businessMember", [O.lazy], (function() {
            return this.team.observe().pipe(F.switchMap((e => e.business)), F.switchMap((e => e ? this.collections.get(D.w.businessMembers).query(E.Q.where(D.o.businessMembers.businessId, e.id), E.Q.where(D.o.businessMembers.userId, this.user.id)).observe().pipe(F.map((e => e[0]))) : F.of(null))), F.cacheWhileConnected)
        })), Cc = Qc(mc, "projectAccesses", [cc]), Rc = Qc(mc, "groupAssignments", [lc]), Ac = Qc(mc, "attachmentVersions", [dc]), Ic = Qc(mc, "grantedTaskAccesses", [uc]), Nc = Qc(mc, "taskAccesses", [O.lazy], (function() {
            return this.collections.get(D.w.taskAccesses).query(E.Q.or(E.Q.where(D.o.taskAccesses.granteeId, this.id), E.Q.where(D.o.taskAccesses.granterId, this.id)), E.Q.experimentalJoinTables([D.w.tasks]), E.Q.on(D.w.tasks, E.Q.where(D.o.tasks.type, null)))
        })), Ec = Qc(mc, "grantedTasks", [O.lazy], (function() {
            return this.grantedTaskAccesses.observe().pipe(F.map((e => {
                const t = e.map((e => e.task.id));
                return this.collections.get(D.w.tasks).query(E.Q.and(E.Q.where(D.o.id, E.Q.oneOf(t)), E.Q.where(D.o.tasks.projectId, Tt.sW)), Tt.rG)
            })))
        })), Oc = Qc(mc, "allTasksResponsibleFor", [O.lazy], (function() {
            return this.collections.get(D.w.tasks).query(E.Q.where(D.o.tasks.responsibleId, this.id))
        })), Mc = Qc(mc, "allTasksResponsibleForInProjects", [O.lazy], (function() {
            return this.allTasksResponsibleFor.extend(E.Q.experimentalJoinTables([D.w.projects, D.w.taskAccesses]), E.Q.on(D.w.projects, os.Vf))
        })), Dc = Qc(mc, "tasksResponsibleFor", [O.lazy], (function() {
            return this.allTasksResponsibleFor.extend(E.Q.experimentalJoinTables([D.w.projects, D.w.taskAccesses]), E.Q.or(E.Q.on(D.w.taskAccesses, [E.Q.or(E.Q.where(D.o.taskAccesses.granterId, this.id), E.Q.where(D.o.taskAccesses.granteeId, this.id))]), E.Q.on(D.w.projects, os.Y3)))
        })), Hc = Qc(mc, "tasksResponsibleForInProjects", [O.lazy], (function() {
            return this.allTasksResponsibleFor.extend(E.Q.experimentalJoinTables([D.w.projects, D.w.taskAccesses]), E.Q.or(E.Q.on(D.w.taskAccesses, [E.Q.or(E.Q.where(D.o.taskAccesses.granterId, this.id), E.Q.where(D.o.taskAccesses.granteeId, this.id))]), E.Q.on(D.w.projects, [os.Y3, os.Vf])))
        })), Fc = Qc(mc, "activeTasksResponsibleFor", [O.lazy], (function() {
            return this.tasksResponsibleForInProjects.extend(Tt.rG)
        })), Zc = Qc(mc, "groups", [O.lazy], (function() {
            return this.collections.get(D.w.memberGroups).query(E.Q.on(D.w.groupAssignments, D.o.groupAssignments.objectId, this.id))
        })), Lc = Qc(mc, "teamVacations", [O.lazy], (function() {
            return new ne.jw(this)
        })), Bc = Qc(mc, "businessVacations", [O.lazy], (function() {
            return this.businessMember.pipe(F.map((e => null == e ? void 0 : e.businessVacations)), F.switchMap((e => F.wrap(null == e ? void 0 : e.observe()))))
        })), zc = Qc(mc, "allActiveVacations", [O.lazy], (function() {
            return F.combineLatestObject({
                teamVacations: this.teamVacations.observe(),
                businessVacations: this.businessVacations
            }).pipe(F.map((({
                teamVacations: e,
                businessVacations: t
            }) => {
                var s;
                const n = e.active,
                    a = null != (s = null == t ? void 0 : t.active) ? s : [];
                return n.concat(a)
            })))
        })), Uc = Qc(mc, "awayOnVacationUntil", [O.lazy], (function() {
            return F.nowAndEveryHour().pipe(F.switchMap((() => this.allActiveVacations)), F.map((e => (0, ne.gr)(e))), F.cacheWhileConnected)
        })), Wc = Qc(mc, "isAwayOnVacation", [O.lazy], (function() {
            return this.awayOnVacationUntil.pipe(F.map((e => !!e)))
        })), qc(mc, "openOnSidebar", [O.writer]), qc(mc, "removeFromSidebar", [O.writer]), qc(mc, "favorite", [O.writer]), qc(mc, "unfavorite", [O.writer]), qc(mc, "updateSidebarPosition", [O.writer]), mc);
        const Kc = ["admin", "owner"];
        var $c, Xc, el, tl, sl, nl, al, ol, rl, il, cl, ll, dl, ul, ml, hl, pl, gl, fl, bl, yl, vl, wl, kl, xl, jl, Tl, Sl, Pl, _l, Cl, Rl, Al;
        const Il = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Nl = D.o.users;
        let El = ($c = H.lazy, Xc = (0, O.field)(Nl.isMe), el = (0, O.text)(Nl.name), tl = (0, O.text)(Nl.invitationEmail), sl = (0, O.field)(Nl.avatarId), nl = (0, O.field)(Nl.color), al = (0, O.field)(Nl.timeZone), ol = (0, O.field)(Nl.isPlaceholder), rl = (0, O.field)(Nl.isLimited), il = (0, O.children)(D.w.businessMembers), cl = (0, O.children)(D.w.teamMembers), ll = (0, O.text)(Nl.email), (Al = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", ul, this), (0, I.Z)(this, "isMe", ml, this), (0, I.Z)(this, "name", hl, this), (0, I.Z)(this, "invitationEmail", pl, this), (0, I.Z)(this, "avatarId", gl, this), (0, I.Z)(this, "color", fl, this), (0, I.Z)(this, "timeZone", bl, this), (0, I.Z)(this, "isPlaceholder", yl, this), (0, I.Z)(this, "isLimited", vl, this), (0, I.Z)(this, "businessMemberships", wl, this), (0, I.Z)(this, "allTeamMemberships", kl, this), (0, I.Z)(this, "_rawEmail", xl, this), (0, I.Z)(this, "teamMemberships", jl, this), (0, I.Z)(this, "notSharedTeamMemberships", Tl, this), (0, I.Z)(this, "ownedTeams", Sl, this), (0, I.Z)(this, "ownedBusinesses", Pl, this), (0, I.Z)(this, "manageableBusinesses", _l, this), (0, I.Z)(this, "manageableTeams", Cl, this), (0, I.Z)(this, "manageableStandaloneTeams", Rl, this)
            }
            get myEmail() {
                invariant(this.isMe, "myEmail called on not me");
                const e = this._rawEmail;
                return invariant(e, "myEmail must not be null"), e
            }
            get emailHash() {
                return invariant(!this.isMe, "emailHash called on me"), this._rawEmail
            }
            async canBeRenamed() {
                const [e] = await this.notSharedTeamMemberships.fetch();
                invariant(e, "Renaming user that doesn't belong to a team");
                const t = await e._me,
                    s = await F.takeFirst(t.hasAdminPowers);
                return this.isMe || this.isPlaceholder && s
            }
            async markAsDeleted() {
                H.logError(H.PROD_CONSOLE_REASON.SAFE_LITERAL, "Attempted to delete User from client side", "warning")
            }
        }).table = D.w.users, Al.associations = (0, E.associations)([D.w.businessMembers, {
            type: "has_many",
            foreignKey: D.o.businessMembers.userId
        }], [D.w.teamMembers, {
            type: "has_many",
            foreignKey: D.o.teamMembers.userId
        }]), ul = Il(dl = Al, "do", [$c], (function() {
            return (() => new(0, s(1249).Z)(this))()
        })), ml = Il(dl, "isMe", [O.nochange, Xc]), hl = Il(dl, "name", [el]), pl = Il(dl, "invitationEmail", [O.nochange, tl]), gl = Il(dl, "avatarId", [O.nochange, sl]), fl = Il(dl, "color", [O.nochange, nl]), bl = Il(dl, "timeZone", [al]), yl = Il(dl, "isPlaceholder", [O.nochange, ol]), vl = Il(dl, "isLimited", [O.nochange, rl]), wl = Il(dl, "businessMemberships", [il]), kl = Il(dl, "allTeamMemberships", [cl]), xl = Il(dl, "_rawEmail", [O.nochange, ll]), jl = Il(dl, "teamMemberships", [O.lazy], (function() {
            return this.allTeamMemberships.extend(E.Q.on(D.w.teams, D.o.teams.isPersonal, !1))
        })), Tl = Il(dl, "notSharedTeamMemberships", [O.lazy], (function() {
            return this.allTeamMemberships.extend(E.Q.on(D.w.teams, D.o.teams.isShared, !1))
        })), Sl = Il(dl, "ownedTeams", [O.lazy], (function() {
            return this.collections.get(D.w.teams).query(E.Q.on(D.w.teamMembers, [E.Q.where(D.o.teamMembers.userId, this.id), E.Q.where(D.o.teamMembers.role, "owner")]))
        })), Pl = Il(dl, "ownedBusinesses", [O.lazy], (function() {
            return this.collections.get(D.w.businesses).query(E.Q.on(D.w.businessMembers, [E.Q.where(D.o.businessMembers.userId, this.id), E.Q.where(D.o.businessMembers.role, "owner")]))
        })), _l = Il(dl, "manageableBusinesses", [O.lazy], (function() {
            return this.collections.get(D.w.businesses).query(E.Q.on(D.w.businessMembers, [E.Q.where(D.o.businessMembers.userId, this.id), E.Q.where(D.o.businessMembers.role, E.Q.oneOf(Kc))]))
        })), Cl = Il(dl, "manageableTeams", [O.lazy], (function() {
            return this.collections.get(D.w.teams).query(E.Q.on(D.w.teamMembers, [E.Q.where(D.o.teamMembers.userId, this.id), E.Q.where(D.o.teamMembers.role, E.Q.oneOf(Kc))]))
        })), Rl = Il(dl, "manageableStandaloneTeams", [O.lazy], (function() {
            return this.manageableTeams.extend(E.Q.where(D.o.teams.businessId, null))
        })), dl);
        var Ol, Ml, Dl, Hl, Fl, Zl, Ll, Bl, zl, Ul;
        const Wl = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Gl = D.o.settings,
            Vl = Le.unless(Le.isObject, Le.always({})),
            ql = Le.unless(Le.isArray, Le.always([])),
            Ql = Le.unless(Le.isNumber, Le.always(0));
        let Yl = (Ol = (0, O.field)(Gl.name), Ml = (0, O.json)(Gl.value, Le.identity), Dl = (0, O.field)(Gl.value), Hl = (0, O.immutableRelation)(D.w.teams, Gl.teamId), (Ul = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "name", Zl, this), (0, I.Z)(this, "_value", Ll, this), (0, I.Z)(this, "_valueJSON", Bl, this), (0, I.Z)(this, "team", zl, this)
            }
            get asObject() {
                return Vl(this._value)
            }
            set asObject(e) {
                throw new Error("don't use this")
            }
            get asArray() {
                return ql(this._value)
            }
            get asNumber() {
                return Ql(this._value)
            }
            get asString() {
                return "string" == typeof this._value ? this._value : ""
            }
            async updateValue(e) {
                this._shouldUpdateValue(e) && await this.update((() => {
                    this._value = e
                }))
            }
            prepareUpdateValue(e) {
                return this._shouldUpdateValue(e) ? this.prepareUpdate((() => {
                    this._value = e
                })) : null
            }
            _shouldUpdateValue(e) {
                return !Le.equals_SLOW(e, this._value)
            }
        }).table = D.w.settings, Ul.associations = (0, E.associations)([D.w.teams, {
            type: "belongs_to",
            key: Gl.teamId
        }]), Zl = Wl(Fl = Ul, "name", [O.nochange, Ol]), Ll = Wl(Fl, "_value", [Ml]), Bl = Wl(Fl, "_valueJSON", [Dl]), zl = Wl(Fl, "team", [Hl]), Fl);
        var Jl, Kl, $l, Xl, ed, td, sd;
        const nd = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            ad = D.o.attachments;
        let od = (Jl = (0, O.immutableRelation)(D.w.comments, ad.parentId), Kl = (0, O.children)(D.w.attachmentVersions), (sd = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "parent", Xl, this), (0, I.Z)(this, "versions", ed, this), (0, I.Z)(this, "latestVersion", td, this)
            }
        }).table = D.w.attachments, sd.associations = (0, E.associations)([D.w.comments, {
            type: "belongs_to",
            key: ad.parentId
        }], [D.w.attachmentVersions, {
            type: "has_many",
            foreignKey: D.o.attachmentVersions.attachmentId
        }]), Xl = nd($l = sd, "parent", [Jl]), ed = nd($l, "versions", [Kl]), td = nd($l, "latestVersion", [O.lazy], (function() {
            return this.versions.observe().pipe(F.map(Le.pipe(ze.xv, Le.head)), F.switchMap((e => F.wrap(null == e ? void 0 : e.observe()))))
        })), $l);
        var rd, id, cd, ld, dd, ud, md, hd, pd, gd, fd, bd, yd, vd, wd = s(474);
        const kd = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            xd = D.o.groupAssignments;
        let jd = (rd = (0, O.immutableRelation)(D.w.projectes, xd.objectId), id = (0, O.immutableRelation)(D.w.teamMembers, xd.objectId), cd = (0, O.immutableRelation)(D.w.memberGroups, xd.groupId), ld = (0, O.immutableRelation)(D.w.projectGroups, xd.groupId), dd = (0, O.field)(xd.groupType), ud = (0, O.field)(xd.sidebarPosition), (vd = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "_project", hd, this), (0, I.Z)(this, "_teamMember", pd, this), (0, I.Z)(this, "_memberGroup", gd, this), (0, I.Z)(this, "_projectGroup", fd, this), (0, I.Z)(this, "groupType", bd, this), (0, I.Z)(this, "sidebarPosition", yd, this)
            }
            async updateSidebarPosition(e) {
                await this.update((() => {
                    this.sidebarPosition = e
                }))
            }
            get group() {
                switch (this.groupType) {
                    case "project":
                        return this._projectGroup;
                    case "member":
                        return this._memberGroup;
                    default:
                        throw new Error("unsupported groupType")
                }
            }
            get object() {
                switch (this.groupType) {
                    case "project":
                        return this._project;
                    case "member":
                        return this._teamMember;
                    default:
                        throw new Error("unsupported groupType")
                }
            }
        }).table = D.w.groupAssignments, vd.associations = (0, E.associations)([D.w.projectGroups, {
            type: "belongs_to",
            key: xd.groupId
        }], [D.w.memberGroups, {
            type: "belongs_to",
            key: xd.groupId
        }], [D.w.projects, {
            type: "belongs_to",
            key: xd.objectId
        }], [D.w.teamMembers, {
            type: "belongs_to",
            key: xd.objectId
        }]), hd = kd(md = vd, "_project", [rd]), pd = kd(md, "_teamMember", [id]), gd = kd(md, "_memberGroup", [cd]), fd = kd(md, "_projectGroup", [ld]), bd = kd(md, "groupType", [O.nochange, dd]), yd = kd(md, "sidebarPosition", [ud]), ((e, t, s) => {
            (0, N.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype)
        })(md, "updateSidebarPosition", [O.writer]), md);
        var Td, Sd, Pd, _d, Cd, Rd, Ad, Id, Nd, Ed, Od, Md, Dd;
        const Hd = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            Fd = D.o.memberGroups;
        let Zd = (Td = H.lazy, Sd = (0, O.text)(Fd.name), Pd = (0, O.field)(Fd.isAdminGroup), _d = (0, O.immutableRelation)(D.w.teams, Fd.teamId), Cd = (0, O.children)(D.w.groupAssignments), (Dd = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", Ad, this), (0, I.Z)(this, "name", Id, this), (0, I.Z)(this, "isAdminGroup", Nd, this), (0, I.Z)(this, "team", Ed, this), (0, I.Z)(this, "allMembers", Od, this), (0, I.Z)(this, "assignments", Md, this)
            }
        }).table = D.w.memberGroups, Dd.associations = (0, E.associations)([D.w.teams, {
            type: "belongs_to",
            key: Fd.teamId
        }], [D.w.groupAssignments, {
            type: "has_many",
            foreignKey: D.o.groupAssignments.groupId
        }]), Ad = Hd(Rd = Dd, "do", [Td], (function() {
            return (() => new(0, s(1250).Z)(this))()
        })), Id = Hd(Rd, "name", [Sd]), Nd = Hd(Rd, "isAdminGroup", [O.nochange, Pd]), Ed = Hd(Rd, "team", [_d]), Od = Hd(Rd, "allMembers", [O.lazy], (function() {
            return this.collections.get(D.w.teamMembers).query(E.Q.on(D.w.groupAssignments, D.o.groupAssignments.groupId, this.id))
        })), Md = Hd(Rd, "assignments", [Cd]), Rd);
        var Ld, Bd, zd, Ud, Wd, Gd, Vd, qd, Qd, Yd, Jd, Kd, $d, Xd, eu, tu, su;
        const nu = (e, t, s, n = null) => (0, N.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            au = D.o.projectGroups;
        let ou = (Ld = H.lazy, Bd = (0, O.text)(au.name), zd = (0, O.field)(au.isPrivate), Ud = (0, O.field)(au.sidebarPosition), Wd = (0, O.immutableRelation)(D.w.teams, au.teamId), Gd = (0, O.children)(D.w.groupAssignments), (su = class extends E.Model {
            constructor(...e) {
                super(...e), (0, I.Z)(this, "do", qd, this), (0, I.Z)(this, "name", Qd, this), (0, I.Z)(this, "isPrivate", Yd, this), (0, I.Z)(this, "sidebarPosition", Jd, this), (0, I.Z)(this, "team", Kd, this), (0, I.Z)(this, "allProjects", $d, this), (0, I.Z)(this, "activeProjects", Xd, this), (0, I.Z)(this, "endedProjects", eu, this), (0, I.Z)(this, "assignments", tu, this)
            }
            async canBeManaged() {
                const e = await this._me,
                    t = await F.takeFirst(e.hasAdminPowers);
                return this.isPrivate || t
            }
            get _me() {
                return this.team.fetch().then((e => F.takeFirst(e.currentMember)))
            }
        }).table = D.w.projectGroups, su.associations = (0, E.associations)([D.w.teams, {
            type: "belongs_to",
            key: au.teamId
        }], [D.w.groupAssignments, {
            type: "has_many",
            foreignKey: D.o.groupAssignments.groupId
        }]), qd = nu(Vd = su, "do", [Ld], (function() {
            return (() => new(0, s(1251).Z)(this))()
        })), Qd = nu(Vd, "name", [Bd]), Yd = nu(Vd, "isPrivate", [zd]), Jd = nu(Vd, "sidebarPosition", [Ud]), Kd = nu(Vd, "team", [Wd]), $d = nu(Vd, "allProjects", [O.lazy], (function() {
            return this.collections.get(D.w.projects).query(E.Q.on(D.w.groupAssignments, D.o.groupAssignments.groupId, this.id))
        })), Xd = nu(Vd, "activeProjects", [O.lazy], (function() {
            return this.allProjects.extend(os.Y3)
        })), eu = nu(Vd, "endedProjects", [O.lazy], (function() {
            return this.allProjects.extend(os.yK)
        })), tu = nu(Vd, "assignments", [Gd]), Vd);
        var ru = s(1511),
            iu = s(1527),
            cu = s(303);
        const lu = {
            Business: B,
            BusinessMember: re,
            Comment: Ve,
            Project: tt.Z,
            ProjectAccess: at,
            ProjectSection: _t,
            ProjectEvent: Bt,
            ProjectPosition: $t,
            Tag: Us,
            GroupAssignment: jd,
            MemberGroup: Zd,
            ProjectGroup: ou,
            Task: Da,
            TaskAccess: ao,
            TaskEvent: po.Z,
            TaskPosition: bo,
            TagAssignment: Po,
            Reminder: Zo,
            TaskRecurrence: Jo,
            Team: Ji,
            TeamMember: Jc,
            User: El,
            SettingEntry: Yl,
            Attachment: od,
            AttachmentVersion: wd.Z
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0);
        s(2), s(3);
        const a = s(427);
        var o = s(1);
        const r = n.React.forwardRef(((e, t) => {
            const {
                children: s,
                adjustsFontSizeToFit: n,
                maxLines: r = 1,
                allowFontScaling: i,
                hoverText: c
            } = e, l = 1 < r;
            return (0, o.jsx)("span", {
                className: a.text + (l ? " " + a.multiline : "") + " " + (e.className || ""),
                style: Object.assign({}, l ? {
                    WebkitLineClamp: r
                } : void 0, e.style),
                ref: e.__forwardedRef || t,
                title: c,
                children: s
            })
        }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n = s(0),
            a = s(242),
            o = s(869),
            r = s(151);
        s(2), s(3);
        const i = s(490);
        var c = s(1);
        const l = n.ReactUtils.lazy((() => s(40))),
            d = n.FP.omit(["icon"]),
            u = e => (t, s) => {
                const {
                    left: n,
                    icon: a,
                    iconColor: o = "onBackground3",
                    iconLayers: r,
                    isDisabled: i,
                    hoverColor: d,
                    isActive: u,
                    activeColor: m,
                    badge: h
                } = e, p = i ? "textSecondary" : u && m ? m : s && d ? d : o, g = r ? r.map((e => Object.assign({
                    color: p,
                    size: 22
                }, e))) : a ? [{
                    iconName: a,
                    color: p,
                    size: 22
                }] : [];
                null != h && h.isDotStyle && g.push({
                    iconName: h.icon,
                    color: h.color,
                    size: 22
                });
                const f = g.length ? (0, c.jsx)(l, {
                    layers: g
                }) : null;
                return n || f ? (0, c.jsxs)(c.Fragment, {
                    children: [n, f]
                }) : null
            },
            m = e => (t, s) => {
                var a;
                const {
                    textColor: r = "textPrimary",
                    label: l,
                    isDisabled: d,
                    isActive: u,
                    activeColor: m,
                    hoverColor: h,
                    hoverText: p
                } = e, g = null != (a = e.isTextBolded) ? a : u, f = d ? "textSecondary" : u && m ? m : s && h ? h : r;
                return (0, c.jsx)(o.Z, {
                    className: i.label,
                    style: {
                        color: n.Styling.factoryColor(f),
                        fontWeight: g ? "600" : "normal"
                    },
                    hoverText: p,
                    children: l
                })
            },
            h = e => (t, s) => {
                const {
                    badge: n
                } = e;
                return (0, c.jsxs)(c.Fragment, {
                    children: [e.renderRight ? e.renderRight(t, s) : null, n && !n.isDotStyle ? (0, c.jsx)(a.Z, {
                        badge: n
                    }) : null]
                })
            },
            p = e => {
                const {
                    badge: t
                } = e, s = !t && e.hasArrow, a = e.onPress ? (s, n) => {
                    null == e.onPress || e.onPress(s, n), null == t || null == t.dismiss || t.dismiss()
                } : void 0;
                return n.React.createElement(r.Z, Object.assign({}, d(e), {
                    renderLeft: u(e),
                    renderLabel: m(e),
                    renderRight: h(e),
                    hasArrow: s,
                    onPress: a
                }))
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            DateTime: () => n.ZP,
            dateTimeEquals: () => n.sB,
            formatDateTime: () => _,
            formatDateTimeRelative: () => R,
            formatDateTimeRelativeFromNow: () => A,
            formatTimeAttribute: () => F,
            formatVacation: () => I,
            formatVacationDateTime: () => N,
            fromLocalTimeFormat: () => o,
            getTimeAttributeLabel: () => H,
            getTimeZone: () => P,
            isDateTimeBefore: () => n.pu,
            isDayBeforeDay: () => E,
            parseTimeAttribute: () => D,
            toAbsoluteDateTime: () => O,
            toLocalTimeFormat: () => a,
            toRelativeDateTime: () => M,
            toYMD: () => L.Z,
            weekStartsOn: () => v
        });
        var n = s(306);
        const a = (e, t) => {
                switch (t) {
                    case "h11":
                        return {
                            hour: e[0] % 12, minute: e[1], period: 12 > e[0] ? "AM" : "PM"
                        };
                    case "h12":
                        return {
                            hour: 0 === e[0] || 12 === e[0] ? 12 : e[0] % 12, minute: e[1], period: 12 > e[0] ? "AM" : "PM"
                        };
                    case "h23":
                        return {
                            hour: e[0], minute: e[1]
                        };
                    case "h24":
                        return {
                            hour: 0 === e[0] ? 24 : e[0], minute: e[1]
                        };
                    default:
                        return t
                }
            },
            o = (e, t) => {
                switch (t) {
                    case "h11":
                        return ["PM" === e.period ? e.hour + 12 : e.hour, e.minute];
                    case "h12": {
                        const t = 12 === e.hour ? 0 : e.hour;
                        return ["PM" === e.period ? t + 12 : t, e.minute]
                    }
                    case "h23":
                        return [e.hour, e.minute];
                    case "h24":
                        return [24 === e.hour ? 0 : e.hour, e.minute];
                    default:
                        return t
                }
            };
        var r = s(189),
            i = s(273),
            c = s(144),
            l = s(190),
            d = s(821),
            u = s(145),
            m = s(41),
            h = s(274),
            p = s(102),
            g = s(64),
            f = s(146),
            b = s(822),
            y = s(823);
        s(210);

        function v(e) {
            return {
                weekStartsOn: w(e)
            }
        }
        const w = e => 7 === e ? 0 : e;
        var k = s(5),
            x = s(347);
        const j = () => (new Intl.DateTimeFormat).resolvedOptions().timeZone;
        let T = null,
            S = !1;

        function P() {
            if (T) return T;
            try {
                const e = j();
                return T = e, S || (S = !0, x.Z.subscribe((() => {
                    T = null
                }))), e
            } catch (e) {
                return (0, k.logError)("diagnostic error", e), null
            }
        }
        const _ = ({
            dateTime: e,
            intl: t,
            format: s = "short"
        }) => {
            const {
                local: n,
                isAllDay: a
            } = e, o = new Date, l = "numeric" === s, d = C(n, o), u = (0, r.Z)(n, {
                end: (0, i.Z)(o, v(1)),
                start: (0, c.Z)(o, v(1))
            }) && !d;
            return "" + t.formatDate(n, {
                month: u && !l ? void 0 : "short",
                day: u && !l ? void 0 : "numeric",
                year: d ? "numeric" : void 0,
                hour: a ? void 0 : "2-digit",
                minute: a ? void 0 : "2-digit",
                timeZone: P(),
                weekday: "short" === s || "long" === s ? s : void 0
            })
        };

        function C(e, t = new Date) {
            return !(0, r.Z)(e, {
                end: (0, l.Z)(t, 2),
                start: (0, d.Z)(t, 2)
            }) && !(0, u.Z)(e, t)
        }
        const R = ({
                dateTime: e,
                intl: t,
                format: s = "short"
            }) => {
                const {
                    local: n
                } = e, a = new Date;
                return (0, r.Z)(n, {
                    start: (0, m.Z)((0, h.Z)(a, 1)),
                    end: (0, p.Z)((0, g.Z)(a, 1))
                }) ? A({
                    dateTime: e,
                    intl: t
                }) : _({
                    dateTime: e,
                    intl: t,
                    format: s
                })
            },
            A = ({
                dateTime: e,
                intl: t
            }) => {
                const {
                    isAllDay: s,
                    local: n
                } = e, {
                    value: a,
                    unit: o
                } = (e => {
                    const t = new Date,
                        s = (0, f.Z)(e, t);
                    if (100 > Math.abs(s)) return {
                        value: s,
                        unit: "day"
                    };
                    const n = (0, b.Z)(e, t);
                    return 12 > Math.abs(n) ? {
                        value: n,
                        unit: "month"
                    } : {
                        value: (0, y.Z)(e, t),
                        unit: "year"
                    }
                })(n);
                return (t.formatRelativeTime(a, o, {
                    timeZone: P(),
                    numeric: "auto"
                }) + " " + (s || "day" !== o ? "" : t.formatTime(n)) + " ").trim()
            };

        function I({
            vacation: e,
            intl: t,
            format: s
        }) {
            const n = N({
                    dateTime: e.from,
                    timeZone: e.timeZone,
                    intl: t,
                    format: s
                }),
                a = N({
                    dateTime: e.to,
                    timeZone: e.timeZone,
                    intl: t,
                    format: s
                });
            return e.spansOverOneDay ? n + " - " + a : a
        }

        function N({
            dateTime: e,
            timeZone: t,
            intl: s,
            format: n = "short"
        }) {
            const a = e.local,
                o = P();
            return s.formatDate(a, Object.assign({}, function(e, t) {
                const s = C(e);
                return {
                    short: {
                        day: "2-digit",
                        month: "2-digit",
                        year: s ? "2-digit" : void 0
                    },
                    long: {
                        day: "numeric",
                        month: "long",
                        year: s ? "numeric" : void 0
                    }
                } [t]
            }(a, n), {
                timeZone: t || o,
                timeZoneName: t && t !== o ? "short" : void 0
            }))
        }

        function E(e, t) {
            return (0, m.Z)(e) < (0, m.Z)(t)
        }
        const O = (e, t) => {
                if (!e) return null;
                const s = t || n.ZP.onDay(new Date),
                    a = new Date(s.local.getTime() + e.timestamp);
                return n.ZP.fromLegacyDueDate({
                    date: a,
                    isAllDay: e.isAllDay
                })
            },
            M = e => {
                const t = e.local.getTime() - (0, m.Z)(new Date).getTime(),
                    s = new Date(t);
                return n.ZP.fromLegacyDueDate({
                    date: s,
                    isAllDay: e.isAllDay
                })
            };

        function D(e) {
            if (!e) return {
                hours: 0,
                minutes: 0
            };
            const t = parseInt(e / 1e3 / 60, 10),
                s = parseInt(t / 60, 10);
            return {
                hours: s,
                minutes: t - 60 * s
            }
        }

        function H(e, t, s) {
            const {
                hours: n,
                minutes: a
            } = e;
            return "short" === (null == s ? void 0 : s.format) ? t.g("Gb", {
                hours: n,
                minutes: Z(a)
            }) : t.g("Ga", {
                hours: n,
                minutes: a
            })
        }

        function F(e, t, s) {
            return H(D(e), t, s)
        }

        function Z(e) {
            return String(e).padStart(2, "0")
        }
        var L = s(1524)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(11),
            o = s(40);
        s(2), s(3);
        const r = s(433);
        var i = s(1);
        const c = n.ReactUtils.lazy((() => s(71))),
            l = 40,
            d = n.Hocs.compose()((e => {
                const {
                    onPressExtraParam: t,
                    longPressExtraParam: s,
                    onPress: d,
                    onLongPress: u,
                    name: m,
                    hoverColor: h,
                    withHover: p,
                    isDisabled: g,
                    size: f = l,
                    badge: b,
                    __webFixBlurEventOrder: y,
                    androidBorderless: v = !0,
                    androidNoRipple: w = !1,
                    androidRippleRadius: k,
                    onPressOut: x,
                    testId: j,
                    accessibilityLabel: T,
                    keyboardShortcutID: S,
                    hitSlop: P,
                    tooltipActivationTime: _ = 500,
                    usesRNGH: C,
                    disableLongPressHaptics: R
                } = e, {
                    isHovering: A,
                    onMouseEnter: I,
                    onMouseLeave: N
                } = n.Hooks.useHover({
                    onMouseEnter: e.onMouseEnter,
                    onMouseLeave: e.onMouseLeave
                }), E = g ? "disabled" : e.color ? e.color : "purple", O = e.iconSize || 24, M = [{
                    iconName: m,
                    color: A && h && p ? h : E,
                    size: O
                }, b ? {
                    iconName: "H",
                    color: b.color,
                    size: O
                } : null].filter(Boolean), D = !g && d ? e => {
                    d(e, t), null == b || null == b.dismiss || b.dismiss()
                } : void 0, H = !g && u ? e => {
                    u(e, s)
                } : void 0;
                return (0, i.jsx)(c, {
                    keyboardShortcutID: S,
                    renderLabel: T,
                    timeToActivite: _,
                    children: (0, i.jsx)(a.Z, {
                        className: r.root + " " + (e.className || ""),
                        style: Object.assign({
                            width: f,
                            height: f
                        }, e.style),
                        onPress: D,
                        onLongPress: H,
                        onPressOut: x,
                        isDisabled: g,
                        onMouseEnter: I,
                        onMouseLeave: N,
                        accessibilityLabel: T,
                        __webFixBlurEventOrder: y,
                        androidBorderless: v,
                        androidNoRipple: w,
                        androidRippleRadius: k,
                        usesRNGH: C,
                        hitSlop: P,
                        testId: j,
                        disableLongPressHaptics: R,
                        children: (0, i.jsx)(o.default, {
                            className: r.icon,
                            style: {
                                backgroundColor: A && p ? n.Styling.rgba(n.Styling.factoryColor(h || E), .1) : void 0
                            },
                            layers: M,
                            accessibilityLabel: T
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            TopographerUtils: () => n,
            afterLaunch: () => W.R,
            animateNext: () => v,
            appBecameActive: () => M.Z,
            appState: () => O.Z,
            callBoth: () => E,
            copyToClipboard: () => S,
            createQueryParamParser: () => Oe,
            currentTarget: () => r,
            devAlert: () => k.Z,
            devConfirm: () => x.Z,
            devCopyToClipboard: () => T,
            devPrompt: () => C,
            devUnimplementedAlert: () => R,
            dismissKeyboard: () => z,
            downloadBlob: () => c,
            downloadObjectUrl: () => i,
            flattenChildren: () => _e,
            fullUrl: () => Z,
            getChildNodeKey: () => Se,
            getDeviceBrand: () => G,
            getDeviceModel: () => Q,
            getDeviceName: () => Y.Z,
            getDeviceOS: () => J,
            getDeviceOSVersion: () => $,
            getTargetValue: () => m,
            hasCommandModifier: () => U,
            helpUrl: () => H,
            identityElement: () => w,
            isApple: () => K.Z,
            isImeEvent: () => oe,
            lazy: () => b,
            mapAsyncStateActivity: () => Ie,
            mapAsyncStateProgress: () => Ae,
            mapAsyncStateResult: () => Ne,
            mapAsyncStateStatus: () => Re,
            measure: () => y,
            nullElement: () => g,
            nullEvent: () => p,
            onOnline: () => B,
            openEmailUrl: () => ae,
            openUrl: () => te,
            parseQueryParam: () => Ee,
            preventDefault: () => a,
            scrollIntoView: () => u,
            scrollToBottom: () => I,
            scrollToTop: () => A,
            share: () => P,
            showToast: () => Te,
            stopPropagation: () => o,
            topographer: () => xe,
            unlessImeEvent: () => je,
            webAppUrl: () => F
        });
        var n = {};
        s.r(n), s.d(n, {
            absFrameIn: () => de,
            center: () => ue,
            contains: () => ye,
            equals: () => le,
            inset: () => ve,
            intersection: () => ge,
            intersects: () => be,
            offsetBy: () => we,
            setCenter: () => me,
            setCenterX: () => pe,
            setCenterY: () => he,
            slice: () => ke,
            union: () => fe,
            zeroPoint: () => re,
            zeroRect: () => ce,
            zeroSize: () => ie
        });
        const a = e => e.preventDefault(),
            o = e => e.stopPropagation(),
            r = e => e.currentTarget;

        function i(e, t) {
            const s = globalThis.document.createElement("a"),
                {
                    body: n
                } = globalThis.document;
            invariant(n, "no body"), s.style.display = "none", s.download = t, s.href = e, n.appendChild(s), s.click(), s.remove()
        }

        function c(e, t) {
            const s = URL.createObjectURL(e);
            i(s, t), URL.revokeObjectURL(s)
        }
        var l = s(1445);
        const d = {
                center: "center",
                top: "start",
                bottom: "end",
                nearest: "nearest"
            },
            u = async ({
                element: e,
                yOffset: t,
                alignment: s = "center",
                scrollMode: n = "if-needed",
                behavior: a = "smooth"
            }) => {
                (0, l.Z)(e, {
                    behavior: a,
                    block: d[s],
                    scrollMode: n
                })
            }, m = e => e.target.value, h = CustomEvent, p = () => new h("nullEvent", {}), g = () => null;
        var f = s(9);

        function b(e) {
            let t = null;
            return s => (t || (t = e().default), f.createElement(t, s))
        }

        function y() {
            throw new Error("unimplemented")
        }

        function v() {}
        const w = ({
            children: e
        }) => e || null;
        var k = s(181),
            x = s(1446),
            j = s(5);

        function T(e) {
            invariant(!1, "Don't use devCopyToClipboard for user-facing code"), S(e)
        }

        function S(e) {
            if (globalThis.electron) return void globalThis.electron.copyToClipboard(e);
            const t = globalThis.document.createElement("textarea"),
                {
                    body: s
                } = globalThis.document;
            invariant(s, "no body"), t.value = e, t.setAttribute("readonly", ""), t.style.position = "absolute", t.style.left = "-9999px", s.appendChild(t), t.select(), globalThis.document.execCommand("copy") || j.logError(j.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Copying to clipboard failed", "warning"), s.removeChild(t)
        }
        async function P({
            message: e,
            formatMessage: t
        }) {
            S(e)
        }
        var _ = s(191);
        async function C(e, t = "") {
            return globalThis.electron ? (0, _.Z)().electron.prompt(e, t) : globalThis.prompt(e, t)
        }
        const R = () => {
                (0, k.Z)("Coming soon!")
            },
            A = e => {
                e.scrollTo({
                    top: 0
                })
            },
            I = e => {
                e.scrollTop = e.scrollHeight
            },
            N = new WeakMap;

        function E(e, t) {
            const s = N.get(e) || new WeakMap,
                n = s.get(t);
            if (n) return n;
            const a = function(e, t) {
                return (...s) => {
                    e(...s), t(...s)
                }
            }(e, t);
            return s.set(t, a), N.set(e, s), a
        }
        var O = s(1198),
            M = s(347);
        const D = {
            "de-DE": "de",
            "es-ES": "es",
            fr: "fr",
            ja: "ja",
            nl: "nl",
            pl: "pl",
            "zh-CN": "zh"
        };

        function H(e, t) {
            const s = D[e.locale];
            return "https://nozbe.help/" + (s ? s + "/" : "") + t
        }
        const F = "https://nozbe.app";

        function Z(e) {
            const {
                path: t
            } = e, s = e.hash || "";
            return "" + F + t + s
        }
        var L = s(8);
        const B = L.fromEvent(globalThis, "online").pipe(L.mapTo(void 0)),
            z = () => {},
            U = e => e.metaKey || e.ctrlKey;
        var W = s(164);

        function G() {
            return globalThis.electron ? globalThis.electron.isMacAppStore ? "MAS|electron" : "electron" : "web"
        }
        var V = s(159),
            q = s.n(V);
        async function Q() {
            const e = q().getParser(globalThis.navigator.userAgent);
            return "" + (globalThis.electron ? globalThis.electron.isMacAppStore ? "(MAS|Electron)" : "(Electron)" : "") + e.getBrowserName()
        }
        var Y = s(348);

        function J() {
            return q().getParser(globalThis.navigator.userAgent).getOSName()
        }
        var K = s(1212);

        function $() {
            return globalThis.electron ? globalThis.electron.osVersion : -1
        }
        var X = s(128);
        const ee = (e, t) => {
            const s = document.createElement("a");
            return s.href = e, s.target = t, s.rel = "noopener noreferrer", s
        };
        async function te(e, t = "_blank") {
            ee((0, X.Nm)(e), t).dispatchEvent(new MouseEvent("click"))
        }
        var se = s(4);
        const ne = (e, t) => t ? e + "=" + encodeURIComponent(t) : "",
            ae = e => {
                te((({
                    to: e,
                    subject: t,
                    body: s
                }) => "mailto:" + (e || "") + se.piped([ne("subject", t), ne("body", s ? s.replaceAll("\n", "\r\n") : "")], se.filter(Boolean), se.join("&"), (e => e ? "?" + e : "")))(e))
            },
            oe = e => {
                const {
                    isComposing: t,
                    keyCode: s
                } = e;
                return t || 229 === s
            },
            re = Object.freeze({
                x: 0,
                y: 0
            }),
            ie = Object.freeze({
                width: 0,
                height: 0
            }),
            ce = Object.freeze(Object.assign({}, re, ie));

        function le(e, t) {
            const s = e,
                n = t;
            return s.x === n.x && s.y === n.y && s.width === n.width && s.height === n.height && s.top === n.top && s.bottom === n.bottom && s.left === n.left && s.right === n.right
        }

        function de(e, t) {
            return {
                width: t.width,
                height: t.height,
                top: t.y,
                bottom: e.height - (t.y + t.height),
                left: t.x,
                right: e.width - (t.x + t.width)
            }
        }

        function ue(e) {
            return {
                x: e.x + e.width / 2,
                y: e.y + e.height / 2
            }
        }

        function me(e, t) {
            const {
                width: s,
                height: n
            } = e;
            if (0 >= s || 0 >= n) return ce;
            return {
                x: t.x - e.width / 2,
                y: t.y - e.height / 2,
                width: s,
                height: n
            }
        }

        function he(e, t) {
            const {
                width: s,
                height: n,
                x: a
            } = e;
            if (0 >= s || 0 >= n) return ce;
            return {
                x: a,
                y: t - e.height / 2,
                width: s,
                height: n
            }
        }

        function pe(e, t) {
            const {
                width: s,
                height: n,
                y: a
            } = e;
            if (0 >= s || 0 >= n) return ce;
            return {
                x: t - e.width / 2,
                y: a,
                width: s,
                height: n
            }
        }

        function ge(e, t) {
            const s = Math.max(e.x, t.x),
                n = Math.max(e.y, t.y),
                a = Math.min(e.x + e.width, t.x + t.width) - s,
                o = Math.min(e.y + e.height, t.y + t.height) - n;
            return 0 >= a || 0 >= o ? ce : {
                x: s,
                y: n,
                width: a,
                height: o
            }
        }

        function fe(e, t) {
            const s = Math.min(e.x, t.x),
                n = Math.min(e.y, t.y);
            return {
                x: s,
                y: n,
                width: Math.max(e.x + e.width, t.x + t.width) - s,
                height: Math.max(e.y + e.height, t.y + t.height) - n
            }
        }

        function be(e, t) {
            return !le(ge(e, t), ce)
        }

        function ye(e, t) {
            if (le(e, ce)) return !1;
            return le(fe(e, Object.assign({
                width: 0,
                height: 0
            }, t)), e)
        }

        function ve(e, t, s = t) {
            const n = e.x + t,
                a = e.y + s,
                o = e.width - 2 * t,
                r = e.height - 2 * s;
            return 0 >= o || 0 >= r ? ce : {
                x: n,
                y: a,
                width: o,
                height: r
            }
        }

        function we(e, t, s) {
            const n = e.x + t,
                a = e.y + s,
                {
                    width: o,
                    height: r
                } = e;
            return 0 >= o || 0 >= r ? ce : {
                x: n,
                y: a,
                width: o,
                height: r
            }
        }

        function ke(e, t, s) {
            const {
                x: n,
                y: a,
                width: o,
                height: r
            } = e;
            if (s >= ("top" === t || "bottom" === t ? r : o)) return [e, ce];
            if (0 >= s) return [ce, e];
            switch (t) {
                case "left":
                    return [{
                        x: n,
                        y: a,
                        width: s,
                        height: r
                    }, {
                        x: n + s,
                        y: a,
                        width: o - s,
                        height: r
                    }];
                case "right":
                    return [{
                        x: n + o - s,
                        y: a,
                        width: s,
                        height: r
                    }, {
                        x: n,
                        y: a,
                        width: o - s,
                        height: r
                    }];
                case "top":
                    return [{
                        x: n,
                        y: a,
                        width: o,
                        height: s
                    }, {
                        x: n,
                        y: a + s,
                        width: o,
                        height: r - s
                    }];
                case "bottom":
                    return [{
                        x: n,
                        y: a + r - s,
                        width: o,
                        height: s
                    }, {
                        x: n,
                        y: a,
                        width: o,
                        height: r - s
                    }];
                default:
                    throw new Error("bad edge")
            }
        }

        function xe() {
            throw new Error("Topographer unavailable on web")
        }
        const je = e => t => {
                oe(t) || e(t)
            },
            Te = se.noop;

        function Se(e, t) {
            return f.isValidElement(e) ? String(e.key || t) : String(t)
        }
        const Pe = (e, t = 0, s = []) => f.Children.toArray(e).reduce(((e, n, a) => {
                const o = Se(n, a),
                    r = s.concat(o);
                return n.type === f.Fragment ? e.push(...Pe(n.props.children, t + 1, r)) : f.isValidElement(n) ? e.push(f.cloneElement(n, {
                    key: r.join("_")
                })) : "string" != typeof n && "number" != typeof n || e.push(n), e
            }), []),
            _e = Pe,
            Ce = () => null;

        function Re(e, t) {
            const s = e._ || Ce;
            return (e[t.status] || s)(t)
        }

        function Ae(e, t) {
            const s = e._ || Ce,
                {
                    succeeded: n = s,
                    errored: a = s,
                    unresolved: o = s
                } = e;
            return t.hasSucceeded ? n(t) : t.hasErrored ? a(t) : o(t)
        }

        function Ie(e, t) {
            const s = e._ || Ce,
                {
                    idle: n = s,
                    busy: a = s
                } = e;
            return (t.isBusy ? a : n)(t)
        }

        function Ne(e, t) {
            const s = e._ || Ce,
                {
                    value: n = s,
                    error: a = s,
                    unresolved: o = s
                } = e;
            return t.hasSucceeded ? n(t) : t.hasErrored ? a(t) : void 0 !== t.value ? n(t) : o(t)
        }

        function Ee(e, t) {
            return Oe(e)(t)
        }

        function Oe(e) {
            const t = new RegExp("[?&]" + e + "=([^&]*)&?");
            return e => {
                const s = t.exec(decodeURIComponent(e));
                return s ? s[1] : null
            }
        }
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => g
        });
        var n = s(0),
            a = s(6),
            o = s(53),
            r = s(1526),
            i = s(13);
        s(2), s(3);
        const c = s(470);
        var l = s(1);
        const d = n.Hocs.compose()((e => {
                const {
                    iconTitle: t,
                    iconTitleColor: s = "white",
                    compact: a
                } = e, o = n.Styling.factoryColor(e.color);
                return (0, l.jsx)("div", {
                    className: c.root + (a ? " " + c.compact : ""),
                    style: {
                        backgroundColor: o,
                        borderColor: o
                    },
                    children: (0, l.jsx)(i.default, {
                        name: t,
                        size: 31,
                        color: s
                    })
                })
            })),
            u = s(471),
            m = e => e.f.fe,
            h = {
                accept: {
                    buttonType: "accept",
                    color: "darkgreen",
                    confirmButtonMessage: e => e.f.e_,
                    icon: "]"
                },
                delete: {
                    buttonType: "destructive",
                    color: "red",
                    confirmButtonMessage: e => e.f.fp,
                    icon: "Ʊ"
                },
                confirm: {
                    buttonType: "warning",
                    color: "orange",
                    confirmButtonMessage: e => e.f.fi,
                    icon: "y"
                }
            },
            p = n.Hocs.compose(n.Hocs.memo),
            g = Object.assign(p((e => {
                const {
                    onBackPress: t,
                    onConfirmPress: s,
                    onClose: i,
                    closeOnConfirm: c = !0,
                    children: p,
                    hasTextContent: g = !0,
                    secondaryButtonMessage: f,
                    secondaryButtonIcon: b,
                    isConfirmDisabled: y,
                    type: v,
                    level: w,
                    isClosingDisabled: k,
                    modalRef: x,
                    fullWidthButton: j,
                    maxWidth: T
                } = e, S = n.Hooks.useIntl(), P = h[v], {
                    buttonType: _,
                    color: C
                } = P, R = e.headerIcon || P.icon, A = e.confirmButtonMessage || P.confirmButtonMessage(S), [{
                    closeAnimated: I
                }, N] = (0, a.P9)(x), E = e => {
                    y || (s(e), c && I(e))
                }, O = n.ReactUtils.unlessImeEvent((e => {
                    "Enter" === e.key ? E(e) : "Escape" === e.key && i(e)
                }));
                return (0, l.jsxs)(a.u_, {
                    ref: N,
                    onClose: i,
                    hasArrow: !1,
                    size: "content",
                    level: w,
                    onKeyDownCapture: O,
                    isClosingDisabled: k,
                    maxWidth: T,
                    children: [(0, l.jsx)(d, {
                        color: C,
                        iconTitle: R
                    }), (0, l.jsx)("div", {
                        className: u.content,
                        children: (0, l.jsxs)(r.Z, {
                            children: [g ? (0, l.jsx)("span", {
                                className: u.textContainer,
                                children: p
                            }) : p, (0, l.jsxs)("div", {
                                className: u.buttonsContainer,
                                children: [t ? (0, l.jsx)(o.default, {
                                    label: f || m(S),
                                    icon: void 0 !== b ? b : null,
                                    onPress: t
                                }) : null, (0, l.jsx)(o.default, {
                                    className: j ? u.fullWidthButton : "",
                                    label: A,
                                    icon: null,
                                    isDisabled: y,
                                    onPress: E,
                                    type: _
                                })]
                            })]
                        })
                    })]
                })
            })), {
                Paragraph: e => (0, l.jsx)("span", {
                    className: u.textContainer + " " + (e.className || ""),
                    style: e.style,
                    children: e.children
                })
            })
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            $S: () => T,
            C9: () => F,
            DY: () => y,
            EF: () => I,
            Fv: () => k,
            GY: () => Z,
            Gn: () => j,
            P7: () => w,
            PB: () => g,
            TE: () => h,
            aZ: () => C,
            c_: () => R,
            ct: () => N,
            gq: () => H,
            kQ: () => D,
            kU: () => b,
            pv: () => x,
            rG: () => f,
            rq: () => M,
            sW: () => p,
            tH: () => v,
            w0: () => O,
            yN: () => E,
            yw: () => P
        });
        s(5);
        var n = s(4),
            a = (s(23), s(8)),
            o = (s(21), s(19)),
            r = s(41),
            i = s(102),
            c = s(278),
            l = s(192),
            d = s(16),
            u = s(65);
        const m = d.o.tasks,
            h = {
                ACTIVE: "ACTIVE",
                ABANDONED: "ABANDONED",
                COMPLETED: "COMPLETED"
            },
            p = "task_me",
            g = {
                project: null,
                isPriority: !1,
                responsibleId: null,
                projectSection: null,
                dueDate: null,
                recurrence: null,
                projectPosition: null,
                priorityPosition: null,
                reminders: {
                    added: [],
                    removed: []
                },
                tags: {
                    added: [],
                    removed: []
                },
                shouldCheckAccess: !1
            },
            f = o.Q.and(o.Q.where(m.type, null), o.Q.where(m.endedAt, null)),
            b = o.Q.and(o.Q.where(m.type, null), o.Q.where(m.endedAt, o.Q.notEq(null))),
            y = o.Q.where(m.lastActivityAt, o.Q.weakGt(o.Q.column(m.lastSeenActivityAt))),
            v = [o.Q.experimentalJoinTables([d.w.projects]), o.Q.and(o.Q.where(m.recurrenceId, o.Q.notEq(null)), o.Q.on(d.w.projects, d.o.projects.endedAt, null), o.Q.on(d.w.projects, d.o.projects.isTemplate, !1), o.Q.or(o.Q.where(m.endedAt, null), o.Q.where(m.endedAt, o.Q.gte((0, r.Z)(new Date).getTime()))))],
            w = e => a.nowAndEveryDay().pipe(a.map((() => {
                const t = (0, r.Z)(new Date).getTime();
                return e.extend(o.Q.or(f, o.Q.where(m.endedAt, o.Q.gte(t))))
            })), a.cacheWhileConnected),
            k = e => n.getFirstPosition(e, (e => e.projectPosition)),
            x = e => n.getLastPosition(e, (e => e.projectPosition)),
            j = e => n.getFirstPosition(e, (e => e.priorityPosition)),
            T = e => n.getLastPosition(e, (e => e.priorityPosition)),
            S = [m.endedAt, m.projectPosition, m.projectId, m.projectSectionId],
            P = [m.endedAt, m.projectPosition, m.projectId, m.projectSectionId, m.priorityPosition, m.dueAt, m.lastActivityAt, m.name, m.timeNeeded, m.timeSpent],
            _ = (e, t) => {
                const s = n.pipe(n.prop(e), n.ifElse(n.is(String), n.toLower, n.identity));
                return n.inOrder(s, t)
            },
            C = (n.sortWith([n.descend(n.prop("isActive")), n.descend(n.prop("endedAt")), n.descend(n.prop("projectPosition")), n.ascend(n.pipe(n.prop("name"), n.toLower)), n.ascend((e => e.id))]), (e, t, s, a) => {
                const o = new Set(s.map((e => e.id))),
                    r = e => {
                        var t;
                        const s = e.isGhost ? null == (t = e.ghostInfo) ? void 0 : t.originalTaskId : e.id;
                        return o.has(s)
                    },
                    i = a ? [...Array.isArray(e) ? e : [e], n.descend((e => r(e) ? null : e.endedAt))] : [n.descend((e => r(e) ? null : e.endedAt)), ...Array.isArray(e) ? e : [e]];
                return n.sortWith([n.descend((e => !!r(e) || e.isActive)), ...i, n.ascend(n.pipe(n.prop("name"), n.toLower))])(t)
            }),
            R = (e, t, s, o, r) => e ? A(e, s).pipe(a.map((e => C(e, s, t, !0)))) : a.combineLatestObject(s.reduce(((e, t) => (e[t.id] = t.observeCurrentProject(), e)), {})).pipe(a.map((e => {
                const a = [n.ascend((e => {
                    var t;
                    const s = r[e.id];
                    return null != (t = null == s ? void 0 : s.position) ? t : 0
                })), ...(0, u.WY)(o, (t => e[t.id])), n.ascend((e => e.projectPosition))];
                return C(a, s, t, !1)
            }))),
            A = (e, t) => {
                const {
                    by: s,
                    order: o
                } = e;
                return "name" === s || "projectPosition" === s || "priorityPosition" === s || "lastActivityAt" === s || "createdAt" === s ? a.of(_(s, o)) : "timeNeeded" === s ? a.of(_("_timeNeeded", o)) : "timeSpent" === s ? a.of(_("_timeSpent", o)) : "dueDate" === s ? a.of(n.inOrder((e => {
                    const {
                        dates: {
                            dueDate: t
                        }
                    } = e;
                    return t ? t.isAllDay ? (0, i.Z)(t.local) : t.local : Number.POSITIVE_INFINITY
                }), o)) : "assignee" === s ? a.combineLatest(t.map((e => e.responsible.observe()))).pipe(a.switchMap((e => a.combineLatestTuples(e.filter(Boolean).map((e => [e, e.preferredName]))))), a.map((e => {
                    const t = new Map;
                    return e.forEach((([e, s]) => {
                        t.set(e.id, s)
                    })), n.inOrder((e => {
                        const s = t.get(e.responsible.id);
                        return s ? n.toLower(s) : Number.POSITIVE_INFINITY
                    }), o)
                }))) : "comments" === s ? a.combineLatestObject(t.reduce(((e, t) => (e[t.id] = t.timeline.activeComments.observeCount(), e)), {})).pipe(a.map((e => n.inOrder((t => e[t.id]), o)))) : a.of(null)
            },
            I = (e, t, s) => n => n.observeWithColumns(P).pipe(a.switchMap((n => A(t, n).pipe(a.map((t => C(t, n, e, s))))))),
            N = e => e.observeWithColumns(S);
        async function E(e) {
            await n.allPromises((e => e.callWriter((() => e.do.assignResponsible(null)))), await e.fetch())
        }

        function O(e) {
            const t = (0, r.Z)(null != e ? e : new Date);
            return e => function(e, t) {
                return !!e.endedAt && (0, c.Z)(e.endedAt, t)
            }(e, t)
        }
        const M = (e, t) => {
            const s = new Set(t.map((e => e.id))),
                n = O();
            return e.reduce(((e, t) => ((e => {
                var t;
                const n = e.isGhost ? null == (t = e.ghostInfo) ? void 0 : t.originalTaskId : e.id;
                return s.has(n)
            })(t) || null === t.endedAt ? e.activeAndJustEndedTasks.push(t) : n(t) ? e.endedTodayTasks.push(t) : e.endedBeforeTodayTasks.push(t), e)), {
                activeAndJustEndedTasks: [],
                endedTodayTasks: [],
                endedBeforeTodayTasks: []
            })
        };
        async function D(e, t) {
            await t.write((async () => {
                const s = e.map((e => e.prepareUpdate((e => {
                    e.do._markAsRead()
                }))));
                await t.batch(...s)
            }), "markTasksAsRead")
        }
        async function H(e, t) {
            await t.write((async () => {
                const s = e.map((e => e.prepareUpdate((e => {
                    e.do.markAsUnread(e.lastSeenActivityAt)
                }))));
                await t.batch(...s)
            }), "markTasksAsUnread")
        }

        function F(e) {
            return !e || 0 >= e ? null : e
        }

        function Z(e) {
            if (!e) return !1;
            const t = e.isAllDay ? (0, r.Z)(new Date) : new Date;
            return (0, l.Z)(e.local, t)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            fy: () => T,
            xD: () => g,
            Q0: () => u,
            bu: () => P,
            U0: () => H,
            TR: () => y,
            v0: () => w,
            si: () => k.default,
            oO: () => K,
            _O: () => Y._O,
            PA: () => Y.PA,
            Qp: () => V.Z,
            ji: () => Y.ZP,
            Rg: () => G,
            f0: () => W,
            AG: () => J,
            tZ: () => Q,
            F4: () => x.Z
        });
        var n = s(0),
            a = s(626),
            o = s(68),
            r = s(94),
            i = s(13),
            c = s(82);
        s(2), s(3);
        const l = s(627);
        var d = s(1);
        const u = e => {
                const {
                    withTermsLink: t,
                    showText: a = !0
                } = e, o = n.Hooks.useServices(), u = n.Hooks.useIntl(), m = n.Styling.theme.isLight() ? s(628) : s(629), {
                    title: h,
                    subtitle: p
                } = o.ab.entryTagline.map({
                    a: {
                        title: u.f.kJ,
                        subtitle: u.f.kH
                    },
                    b: {
                        title: u.f.kK,
                        subtitle: u.f.kI
                    }
                });
                return n.React.useEffect((() => {
                    o.ab.triggerEntryTaglineRendered()
                }), [o.ab]), (0, d.jsxs)("div", {
                    className: l.root,
                    children: [(0, d.jsx)(i.default, {
                        className: l.logo,
                        name: "ř",
                        color: "textPrimary",
                        size: 150
                    }), (0, d.jsx)("div", {
                        className: l.imageContainer,
                        children: (0, d.jsx)(r.Z, {
                            className: l.image,
                            source: m
                        })
                    }), a ? (0, d.jsxs)("div", {
                        className: l.textContainer,
                        children: [(0, d.jsx)("span", {
                            className: l.title,
                            children: h
                        }), (0, d.jsx)("span", {
                            className: l.subTitle,
                            children: p
                        }), t ? (0, d.jsx)(c.Z, {
                            to: u.f.kx,
                            children: (0, d.jsx)("span", {
                                className: l.termsLink,
                                children: u.f.kw
                            })
                        }) : null]
                    }) : null]
                })
            },
            m = s(630),
            h = n.React.forwardRef(((e, t) => (0, d.jsx)(o.Z, Object.assign({}, e, {
                scrollRef: t
            })))),
            p = ({
                children: e,
                title: t,
                withTermsLink: s,
                showTextUnderIllustration: n = !0
            }) => (0, d.jsxs)(d.Fragment, {
                children: [(0, d.jsx)("div", {
                    className: m.leftColumn,
                    children: (0, d.jsx)(u, {
                        withTermsLink: s,
                        showText: n
                    })
                }), (0, d.jsxs)("div", {
                    className: m.rightColumn,
                    children: [t ? (0, d.jsx)("span", {
                        className: m.title,
                        children: t
                    }) : null, e]
                })]
            }),
            g = e => {
                n.Hooks.useOnDidLaunch();
                const t = n.Hooks.useServices();
                n.React.useEffect((() => {
                    t.ab.triggerEntryLaunched()
                }), [t.ab]);
                const {
                    children: s,
                    scrollRef: o,
                    isCentered: r,
                    withoutMarginsNative: i,
                    forceNoScroll: c,
                    title: l,
                    withTermsLink: u
                } = e, g = n.Hooks.useDesktopLayout(), {
                    topInset: f,
                    bottomInset: b
                } = n.Hooks.useLayoutInsets(), y = m.scrollContent;
                return n.Hooks.useStatusBar({
                    style: "auto",
                    level: n.Hooks.useStatusBar.levels.main
                }), (0, d.jsx)(d.Fragment, {
                    children: (0, d.jsx)(h, {
                        className: m.scroll,
                        scrollIndicatorInsets: {
                            top: f,
                            bottom: b
                        },
                        contentContainerStyle: y,
                        keyboardShouldPersistTaps: "handled",
                        removeClippedSubviews: !1,
                        isAbsoluteFilled: !0,
                        ref: o,
                        children: (0, d.jsx)(p, {
                            title: l,
                            withTermsLink: u,
                            children: (0, d.jsx)(a.Z, {
                                className: m.keyboardAvoidingView + (r || g && !i ? " " + m.centered : ""),
                                children: s
                            })
                        })
                    })
                })
            },
            f = s(631),
            b = s(632),
            y = e => {
                const {
                    withFlex: t,
                    size: s
                } = e, n = s || "large";
                return (0, d.jsx)("div", {
                    className: f.root + ("small" === n ? " " + f.rootSmall : "") + ("medium" === n ? " " + f.rootMedium : "") + (t ? " " + f.flex : ""),
                    children: (0, d.jsx)(r.Z, {
                        className: f.image + ("small" === n ? " " + f.imageSmall : ""),
                        source: b
                    })
                })
            },
            v = s(633),
            w = e => {
                const {
                    atBottom: t = !0,
                    text: s
                } = e;
                return (0, d.jsx)("span", {
                    className: v.root + (t ? " " + v.atTheBottom : "") + " " + (e.className || ""),
                    style: e.style,
                    children: s
                })
            };
        var k = s(363),
            x = s(364);
        s(635);
        const j = s(636),
            T = n.Hocs.compose()((e => {
                const {
                    children: t
                } = e;
                return t ? (0, d.jsx)("span", {
                    className: j.text,
                    children: t
                }) : null
            })),
            S = s(637),
            P = n.Hocs.compose()((e => {
                const {
                    label: t,
                    rightLabel: s,
                    rightLabelColor: a,
                    description: o,
                    hasTopMargin: r
                } = e, i = s ? (0, d.jsxs)("div", {
                    className: S.labelContainer,
                    children: [(0, d.jsx)("span", {
                        className: S.labelCommon + " " + S.label,
                        children: t
                    }), (0, d.jsx)("span", {
                        className: S.labelCommon + " " + S.labelRight,
                        style: {
                            color: a ? n.Styling.factoryColor(a) : void 0
                        },
                        children: s
                    })]
                }) : (0, d.jsx)("span", {
                    className: S.labelCommon + " " + S.label,
                    children: t
                });
                return (0, d.jsxs)("div", {
                    className: S.root + (r ? " " + S.hasTopMargin : ""),
                    children: [t ? i : null, o ? (0, d.jsx)("span", {
                        className: S.description,
                        children: o
                    }) : null]
                })
            }));
        var _ = s(43),
            C = s(14),
            R = s(127),
            A = s(45),
            I = s(11),
            N = s(12),
            E = s(131),
            O = s(638);
        const M = s(639),
            D = n.ReactUtils.lazy((() => s(1321))),
            H = n.Hocs.compose()((e => {
                var t, s;
                const {
                    onSubmit: a,
                    onFocus: o,
                    canSubmit: r,
                    buttonLabel: i,
                    preFilledEmail: c,
                    preFilledPassword: l,
                    resetBusyState: u,
                    provider: m,
                    signInWithApple: h,
                    signInWithGoogle: p
                } = e, g = n.Hooks.useIntl(), f = n.Hooks.useServices(), [b, y] = n.React.useState(c || ""), [v, w] = n.React.useState(l || ""), [k, x] = n.React.useState(0), j = n.Hooks.useModalState(), T = n.Hooks.useValidation({
                    email: [b, [_.C1]],
                    password: [v, [_.C1]]
                }), S = r && T.isValid, H = async () => {
                    if (S && a) {
                        const {
                            needsOTP: e
                        } = await a({
                            email: b,
                            password: v
                        }) || {};
                        e ? j.open() : j.close()
                    }
                };
                return n.React.useEffect((() => {
                    c && l && H()
                }), []), n.React.useEffect((() => {
                    k >= E.fS && (y(""), w(""), j.close())
                }), [k, j]), (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsxs)(R.Z, {
                        className: M.form,
                        onSubmit: H,
                        children: [(0, d.jsx)(P, {
                            label: g.f.uf
                        }), (0, d.jsx)(A.default, {
                            placeholder: g.f.iR,
                            autoFocus: !c,
                            onFocus: o,
                            autoComplete: "username",
                            autoCorrect: !1,
                            type: "email",
                            onChange: y,
                            value: b,
                            returnKeyType: "next",
                            errors: T.email.errors,
                            blurOnSubmit: !0,
                            forEntryViews: !0,
                            testId: n.Misc.testIds.loginModal_username
                        }), (0, d.jsx)(P, {
                            label: g.f.up,
                            hasTopMargin: !0
                        }), (0, d.jsx)(A.default, {
                            placeholder: g.f.j5,
                            type: "password",
                            autoComplete: "current-password",
                            returnKeyType: "next",
                            onFocus: o,
                            onChange: w,
                            value: v,
                            errors: T.password.errors,
                            blurOnSubmit: !0,
                            forEntryViews: !0,
                            autoFocus: !!c,
                            testId: n.Misc.testIds.loginModal_password
                        }), (0, d.jsx)(N.default, {
                            onPress: H,
                            isDisabled: !S || j.isOpen,
                            type: "submit",
                            marginTop: "small",
                            variant: "opaque",
                            color: "purple",
                            label: i
                        })]
                    }), (0, d.jsx)(I.Z, {
                        className: M.resetPasswordLink,
                        webComponent: "a",
                        onPress: () => f.router.goTo(C.pathToResetPasswordRequest),
                        children: (0, d.jsx)("span", {
                            className: M.resetPasswordText,
                            children: g.f.jg
                        })
                    }), h && p ? (() => {
                        switch (m) {
                            case "apple":
                                return (0, d.jsx)("div", {
                                    className: M.thirdPartyWrapper,
                                    children: t || (t = (0, d.jsx)(O.X, {
                                        intl: g,
                                        onPress: h
                                    }))
                                });
                            case "google":
                                return (0, d.jsx)("div", {
                                    className: M.thirdPartyWrapper,
                                    children: s || (s = (0, d.jsx)(O.V, {
                                        intl: g,
                                        onPress: p
                                    }))
                                });
                            default:
                                return null
                        }
                    })() : null, j.isOpen ? (0, d.jsx)(D, {
                        onClose: n.ReactUtils.callBoth(j.close, u),
                        onSubmit: async e => {
                            if (a) {
                                await a({
                                    email: b,
                                    password: v,
                                    otp: e
                                }) || x(k + 1)
                            }
                        }
                    }) : null]
                })
            }));
        var F = s(256);
        const Z = s(641),
            L = n.Hocs.compose()((e => {
                const {
                    onClose: t
                } = e, s = n.Hooks.useIntl(), a = n.Hooks.useServices(), o = e => async t => {
                    await a.notifications.register((async () => {
                        const e = await a.api.getVapidPublicKey();
                        e && await a.native.serviceWorker.subscribeToNotifications(e)
                    })), e(t)
                };
                return (0, d.jsx)(F.Z, {
                    iconStack: [{
                        iconName: "_",
                        color: "incoming",
                        opacity: .1,
                        size: 200
                    }, {
                        iconName: "'",
                        color: "incoming",
                        size: 110
                    }],
                    closeMenu: t,
                    title: s.f.jd,
                    message: s.f.jc,
                    isDesktopModal: !0,
                    children: e => (0, d.jsxs)("div", {
                        className: Z.notificationButtonContainer,
                        children: [(0, d.jsx)(N.default, {
                            className: Z.modalEntryButton,
                            style: {
                                marginRight: 6
                            },
                            onPress: e,
                            label: s.f.fh
                        }), (0, d.jsx)(N.default, {
                            className: Z.modalEntryButton,
                            style: {
                                marginLeft: 6
                            },
                            onPress: o(e),
                            label: s.f.fy,
                            color: "incoming",
                            variant: "opaque"
                        })]
                    })
                })
            }));
        var B = s(9),
            z = s(54),
            U = s(23);
        s(5), s(36);
        const W = ({
            signIn: e,
            isSyncing: t,
            notificationState: s,
            onSuccessfulLogin: n,
            invalidErrorMessage: a
        }) => {
            var o;
            const r = z.useServices(),
                i = z.useIntl(),
                [l, u] = B.useState(!1),
                [m, h] = B.useState(!1),
                {
                    isNotificationExplainerOpen: p,
                    openNotificationExplainer: g,
                    closeNotificationExplainer: f
                } = (e => {
                    const t = B.useRef(null !== e),
                        [s, n] = B.useState(t.current && "notDetermined" === e),
                        [a, o] = B.useState(!1);
                    return {
                        isNotificationExplainerOpen: a,
                        openNotificationExplainer: B.useCallback((() => {
                            t.current && s && o(!0)
                        }), [s]),
                        closeNotificationExplainer: B.useCallback((() => {
                            t.current && (n(!1), o(!1))
                        }), [])
                    }
                })(s),
                [b, y] = B.useState(!1),
                [v, w] = B.useState(null),
                k = B.useCallback((() => w(null)), []),
                x = B.useCallback((() => u(!1)), []),
                j = B.useRef(null);
            B.useEffect((() => {
                m && !p && (r.appState.isLoggedIn.next(!0), r.history.redirectAfterLogin())
            }), [m, p, r.appState.isLoggedIn, r.history]), B.useEffect((() => {
                l && t ? (y(!0), g()) : l || y(!1)
            }), [l, g, t]), B.useLayoutEffect((() => {
                j.current && U.scrollToTop(j.current)
            }), [t]);
            const T = z.useIsMounted(),
                S = B.useCallback((async t => {
                    if (l) return null;
                    try {
                        u(!0), k();
                        const s = await e(t);
                        return s.needsOTP || s.needsInviteCode || s.needsConfirmation ? T.current && u(!1) : (n && await n(), T.current && h(!0)), s
                    } catch (e) {
                        return T.current && (w((e => {
                            if (e.isNetworkErrorLikely) return "offline";
                            const t = e.originalResponse;
                            if (t) {
                                if (400 === t.status || 401 === t.status) return "invalid";
                                if (429 === t.status) return "too_many_requests";
                                if (449 === t.status) return "np_credentials"
                            }
                            return "error"
                        })(e)), u(!1)), null
                    }
                }), [k, l, e, n, T]),
                P = v ? ((e, t, s) => {
                    switch (e) {
                        case "offline":
                            return t.f.i_;
                        case "invalid":
                            return s || t.f.i8;
                        case "error":
                            return t.f.i7;
                        case "too_many_requests":
                            return t.f.ja;
                        case "np_credentials":
                            return t.g("i9", {
                                appUrl: (0, d.jsx)(c.Z, {
                                    to: "https://app.nozbe.com",
                                    children: (0, d.jsx)("span", {
                                        style: {
                                            textDecoration: "underline",
                                            color: "#FF5428"
                                        },
                                        children: "https://app.nozbe.com"
                                    })
                                }, "npCredentials_appUrl")
                            });
                        default:
                            return ""
                    }
                })(v, i, a) : null;
            return {
                submit: S,
                error: P,
                clearError: k,
                scrollRef: j,
                isSyncingNice: b,
                isSubmitting: l,
                resetBusyState: x,
                renderNotificationExplainModal: () => b && p ? o || (o = (0, d.jsx)(L, {
                    onClose: f
                })) : null
            }
        };

        function G(e) {
            const t = z.useServices();
            return s => {
                const {
                    state: n
                } = s || {}, {
                    path: a,
                    state: o
                } = function() {
                    if (e && "invalid" !== (null == e ? void 0 : e.status)) switch (e.type) {
                        case "team_code":
                            return {
                                path: (0, C.pathToJoin)(e.id)
                            };
                        case "team_invitations":
                            return {
                                path: (0, C.pathToInvite)(e.id)
                            };
                        case "project_invitations":
                            return {
                                path: (0, C.pathToJoinProject)(e.id)
                            };
                        case "task_invitations":
                            return {
                                path: (0, C.pathToTaskInvite)(e.id)
                            };
                        case "account_upgrade":
                            return {
                                path: C.pathToRoot, state: {
                                    accountUpgradeToken: e
                                }
                            }
                    }
                    const s = t.appState.claimPurchaseToken.getValue();
                    return s ? {
                        path: (0, C.pathToClaimPurchase)(s)
                    } : {
                        path: C.pathToRoot
                    }
                }(), r = Object.assign({}, n, o);
                t.router.goTo(a, r)
            }
        }
        var V = s(365),
            q = s(149);
        const Q = e => {
            const t = (0, q.Z)();
            B.useEffect((() => {
                e && t.api.telemetry.trackSignupProcess(e)
            }), [t.api, e])
        };
        var Y = s(209);
        const J = () => {
                const {
                    isNarrowerThan: e
                } = z.useLayoutVariant();
                return e("wide")
            },
            K = () => {}
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            ZP: () => m,
            XH: () => a.P9
        });
        var n = s(0),
            a = s(6),
            o = s(1);
        const r = n.React.forwardRef(((e, t) => {
            const {
                onClose: s,
                minHeight: n,
                minWidth: r,
                boundTo: i = "left",
                children: c,
                target: l,
                level: d,
                placement: u,
                isDesktopModal: m = !1,
                hasArrow: h = !1,
                maxWidth: p
            } = e;
            return (0, o.jsx)(a.u_, {
                ref: t,
                onClose: s,
                level: d,
                minHeight: n,
                minWidth: r,
                boundTo: i,
                target: l,
                hasArrow: h,
                placement: u,
                size: "content",
                isDesktopModal: m,
                maxWidth: p,
                children: c
            })
        }));
        s(2), s(3);
        const i = s(543),
            c = ({
                label: e
            }) => (0, o.jsx)("div", {
                className: i.container,
                children: (0, o.jsx)("span", {
                    className: i.text,
                    children: e
                })
            });
        var l = s(874),
            d = s(881),
            u = s(138);
        const m = Object.assign(r, {
            Header: c,
            SectionHeader: l.Z,
            Separator: d.Z,
            ThreeDotButton: u.Z
        })
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Ds: () => S,
            OU: () => l,
            Ji: () => d,
            fk: () => k,
            ku: () => U,
            tz: () => C,
            _i: () => u,
            sI: () => f,
            fb: () => b,
            hw: () => z,
            Nx: () => g,
            kx: () => H,
            tJ: () => q,
            sU: () => y,
            Gu: () => T.Gu,
            bo: () => w,
            mL: () => Y,
            P1: () => B,
            _6: () => M,
            RB: () => h,
            LJ: () => p,
            ub: () => W,
            NO: () => D,
            uD: () => _,
            mO: () => V,
            Tu: () => I,
            SR: () => N,
            WU: () => Q,
            zJ: () => X
        });
        var n = s(19),
            a = s(16),
            o = (s(5), s(4)),
            r = s(8),
            i = s(327),
            c = s(88);

        function l(e, t) {
            const n = new(0, s(1231).Z)(e, t),
                {
                    nodes: a,
                    richContent: o
                } = n.getResult();
            return d(a, {
                richContent: o
            })
        }

        function d(e, t = {}) {
            return {
                object: "value",
                document: {
                    object: "document",
                    data: t,
                    nodes: e
                }
            }
        }

        function u(e) {
            var t;
            return "string" == typeof e ? e : null == (t = e.document.data) ? void 0 : t.importMetadata
        }
        const m = /^(?:\((\+|\-)\)|-\s\[[\sx]\]) *$/gm;

        function h(e) {
            return e && "value" === e.object && e.document && e.document ? function(e) {
                const {
                    document: t
                } = e;
                return Object.assign({}, e, {
                    document: Object.assign({}, t, {
                        nodes: o.map(o.when((e => "checklist" === e.type), (e => {
                            const t = o.map(o.when((e => "checklist-item" === e.type), (e => {
                                const {
                                    object: t,
                                    type: s,
                                    data: n
                                } = e;
                                return {
                                    object: t,
                                    type: s,
                                    data: {
                                        isCompleted: !!n.isCompleted,
                                        id: n.id
                                    },
                                    nodes: e.nodes
                                }
                            })), e.nodes);
                            return Object.assign({}, e, {
                                nodes: t
                            })
                        })), t.nodes)
                    })
                })
            }(e) : null
        }

        function p(e) {
            return e.replace(m, "")
        }
        const g = ["following", "all"];

        function f(e) {
            return g.map((t => {
                switch (t) {
                    case "all":
                        return {
                            type: "all", translation: e.f.q9
                        };
                    case "following":
                        return {
                            type: "following", translation: e.f.q$
                        };
                    default:
                        throw new Error(t + " is not valid type of predefined mention")
                }
            }))
        }

        function b(e, t) {
            const s = (() => {
                if ("string" == typeof e) return e;
                if ("string" == typeof e.type) return e.type;
                throw new Error("niether groupMention nor groupMention.type is string")
            })();
            switch (s) {
                case "all":
                    return t.f.q9;
                case "following":
                    return t.f.q$;
                default:
                    throw new Error("Unexpected Group Mention Type " + s)
            }
        }
        const y = e => g.includes(e);
        var v = s(245);

        function w({
            services: e,
            project: t,
            task: s,
            comments: n = [],
            commentEditorValue: a = ""
        }) {
            const {
                modelRoot: o
            } = e, i = t.permissions.members.pipe(r.switchMap((e => e.observe()))), c = t.currentTeam.pipe(r.switchMap((e => e.archivedMembers.observe()))), l = r.wrap(null == s ? void 0 : s.observeTaskAccessMembers()).pipe(r.map(((e = []) => e.filter(Boolean)))), d = r.combineLatest(i, c, l).pipe(r.map((([e, t, s]) => e.concat(t, s)))), u = t.currentTeam.pipe(r.switchMap((e => e.allMemberGroups.observe())));
            return r.combineLatest(o.allTeams.observe(), d, u).pipe(r.switchMap((([t, s, o]) => k({
                services: e,
                comments: n,
                teams: t,
                members: s,
                memberGroups: o,
                commentEditorValue: a
            }))))
        }
        async function k({
            services: e,
            comments: t,
            teams: s,
            members: n,
            memberGroups: a,
            commentEditorValue: o,
            searchQuery: r
        }) {
            const [i, c] = await Promise.all([x(e, t, s, o), j(n)]);
            return {
                teams: s,
                internalLinkModelMap: i,
                membersWithNames: c,
                memberGroups: a,
                availableGroupMentions: g,
                rootBlockTypeForNestedNodes: null,
                searchQuery: r
            }
        }
        async function x(e, t, s, o) {
            const i = t.map((e => (0, v.W)(e._bodyText, s))).flat();

            function c(t, s) {
                return e.database.collections.get(s).find(t).catch((() => null))
            }
            o && i.push(...(0, v.W)(o, s));
            const l = await Promise.all(i.map((e => e.taskId ? c(e.taskId, a.w.tasks) : e.projectId ? c(e.projectId, a.w.projects) : e.sectionId ? c(e.sectionId, a.w.projectSections) : e.tagId ? c(e.tagId, a.w.tags) : e.memberId ? c(e.memberId, a.w.teamMembers).then((async e => e ? {
                member: e,
                preferredName: await r.takeFirst(e.preferredName)
            } : null)) : Promise.resolve(null))));
            return new Map(l.filter(Boolean).map((e => [e instanceof n.Model ? e.id : e.member.id, e])))
        }
        async function j(e) {
            return Promise.all(e.map((async e => ({
                member: e,
                preferredName: await r.takeFirst(e.preferredName)
            }))))
        }
        s(1232);
        var T = s(221);

        function S(e, t) {
            return o.piped(_("string" == typeof e ? e : e.document, t), o.trim)
        }
        const P = e => t => t.concat(e);

        function _(e, t) {
            const s = o.pipe(o.join(""), t ? o.trim : o.identity);
            switch (e.object) {
                case "document":
                case "block": {
                    const {
                        nodes: s
                    } = e;
                    return o.piped(s, o.map((e => _(e, t))), o.join(""), P("\n\n"))
                }
                case "inline":
                    return o.piped(e.nodes, o.map((e => _(e, t))), s);
                case "text":
                    return e.leaves ? o.piped(e.leaves, o.map((e => e.text)), s) : e.text;
                default:
                    return ""
            }
        }

        function C(e, t) {
            const s = [];
            return e.forEach(((e, n) => {
                t(e, n) ? s.push(e) : e.nodes && s.push(...C(e.nodes, t))
            })), s
        }
        const R = /^\((\+|\-)\)\s/,
            A = /^-\s\[([\sx])\]\s/;

        function I(e, t) {
            return e._bodyJSON ? function(e, t) {
                const {
                    document: s
                } = e, n = Object.assign({}, e, {
                    document: Object.assign({}, s, {
                        nodes: o.map(o.when((e => "checklist" === e.type), (e => {
                            const s = o.map(o.when((e => "checklist-item" === e.type && e.data.id === t), (e => {
                                const {
                                    data: t
                                } = e;
                                return Object.assign({}, e, {
                                    data: Object.assign({}, t, {
                                        isCompleted: !t.isCompleted
                                    })
                                })
                            })), e.nodes);
                            return Object.assign({}, e, {
                                nodes: s
                            })
                        })), s.nodes)
                    })
                });
                return n
            }(e.body, t) : function(e, t) {
                const [n, a] = t.split("-").map(Number);
                return s(475).Z(e).map((([e, t], s) => "checklist" === e && s === n ? t.map(((e, t) => {
                    return a === t ? (s = e).startsWith("(") ? s.replace(R, ((e, t) => "-" === t ? "(+) " : "(-) ")) : s.replace(A, ((e, t) => "x" === t ? "- [ ] " : "- [x] ")) : e;
                    var s
                })).join("\n") : t.join("\n"))).join("\n\n")
            }(e._bodyText, t)
        }

        function N(e) {
            return e._bodyJSON ? function(e) {
                const {
                    document: t
                } = e, s = Object.assign({}, e, {
                    document: Object.assign({}, t, {
                        nodes: o.map(o.when((e => "checklist" === e.type), (e => {
                            const t = o.map(o.when((e => "checklist-item" === e.type), (e => {
                                const {
                                    data: t
                                } = e;
                                return Object.assign({}, e, {
                                    data: Object.assign({}, t, {
                                        isCompleted: !1
                                    })
                                })
                            })), e.nodes);
                            return Object.assign({}, e, {
                                nodes: t
                            })
                        })), t.nodes)
                    })
                });
                return s
            }(e.body) : (t = e._bodyText, o.splitLines(t).map((e => R.test(e) ? e.replace(R, (() => "(-) ")) : A.test(e) ? e.replace(A, (() => "- [ ] ")) : e)).join("\n"));
            var t
        }
        var E = s(123),
            O = s(39);
        const M = ["up", "down", "heart", "laugh", "sad"],
            D = o.pipe(o.unless(o.isObject, o.always({})), o.pick(M), o.map(o.pipe(o.unless(o.isArray, o.always([])), o.filter(o.isString)))),
            H = o.pipe(o.values, o.all(o.isEmpty), o.not),
            F = (e, t) => o.piped(e, o.toPairs, o.find((([, e]) => e.includes(t.id))), o.defaultTo([]), o.nth(0)),
            Z = e => o.map(o.reject(o.identical(e))),
            L = (e, t) => s => {
                const n = o.pipe(o.defaultTo([]), o.append(t));
                return Object.assign({}, s, {
                    [e]: n(s[e])
                })
            };

        function B(e, t, s) {
            const n = F(e, s) === t;
            return o.pipe(Z(s.id), n ? o.identity : L(t, s.id))(e)
        }

        function z({
            comment: e,
            type: t,
            currentMember: s,
            intl: o
        }) {
            const i = e.reactions[t] || [];
            return e.collections.get(a.w.teamMembers).query(n.Q.where(a.o.id, n.Q.oneOf(i))).observe().pipe(r.switchMap((0, E.dd)(o)), r.switchMap((e => r.combineLatest((0, O.moveRecordToListBeginning)(s.id, e).map((e => e === s ? r.of(o.f.uG) : e.preferredName))).pipe(r.map((e => e.join(", ")))))))
        }
        const U = {
            clonedFromId: "cloned_from_id"
        };

        function W(e) {
            const t = {};
            if (o.isObject(e)) {
                const s = e[U.clonedFromId];
                o.isString(s) && Boolean(s) && (t[U.clonedFromId] = s)
            }
            return t
        }
        const G = a.o.comments,
            V = o.sort(o.ascend(o.prop("createdAt")));

        function q(e, t) {
            return e.createdAt.getTime() > t
        }

        function Q(e) {
            return n.Q.where(G.createdAt, n.Q.gt(e))
        }

        function Y(e, t) {
            const {
                body: s,
                inputFiles: n = []
            } = e;
            if (! function(e) {
                    if ("string" != typeof e) return !1;
                    const t = "string" == typeof e ? o.splitLines(e) : [],
                        s = t.some((e => J.test(e))) ? i.Z.comments.body : i.Z.comments.bodyWithoutChecklist;
                    return e.length > s
                }(s)) return e;
            const a = s,
                r = t.f.uc.toLowerCase() + ".txt",
                l = (0, c.M8)({
                    source: "local",
                    file: new globalThis.File([a], r, {
                        type: "text/plain"
                    })
                });
            return {
                body: $(a, t),
                inputFiles: [l, ...n]
            }
        }
        const J = /^(?:\((\+|\-)\)|-\s\[[\sx]\])\s/;
        const K = 280;

        function $(e, t) {
            const s = e.split("\n").filter(Boolean),
                [n] = s;
            return (n.length <= K ? n : e.slice(0, K) + "…") + "\n\n" + t.f.g1
        }

        function X(e) {
            return e
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            AnimatedView: () => m,
            avatarColors: () => F,
            backIcon: () => M,
            blendWithSurface: () => H,
            businessColors: () => L,
            color: () => r(),
            compareLayoutVariant: () => V,
            createAnimatedComponent: () => b,
            createMemberName: () => I,
            defaultTagIcon: () => P,
            defaultTextSecondary: () => S,
            determineLayoutVariant: () => G,
            factoryAvatarDotSize: () => T,
            factoryAvatarFontSize: () => j,
            factoryAvatarSize: () => x,
            factoryColor: () => v,
            factoryColorLiteral: () => w,
            factoryColorOrLiteral: () => k,
            formatLayout: () => W,
            getAttachmentIcon: () => X,
            getContactInfoIcon: () => O,
            getMemberGroupName: () => N,
            getProjectIcon: () => _,
            getProjectIconColor: () => C,
            getProjectName: () => R,
            getTeamName: () => A,
            hairlineWidth: () => u,
            icon: () => a(),
            isLayoutNarrowerThan: () => Q,
            isLayoutWiderThan: () => q,
            isValidTheme: () => l.u,
            layoutBreakpoints: () => U,
            mix: () => z,
            mixins: () => p(),
            projectColors: () => Z,
            rgba: () => f,
            shareIcon: () => D,
            tagIcons: () => B,
            theme: () => l.Z,
            vars: () => c(),
            zcolor: () => d
        });
        var n = s(314),
            a = s.n(n),
            o = s(324),
            r = s.n(o),
            i = s(212),
            c = s.n(i),
            l = s(325);
        const d = undefined,
            u = 0,
            m = () => {
                throw new Error("AnimatedView not implemented on web")
            };
        var h = s(351),
            p = s.n(h),
            g = s(160);
        const f = (e, t) => (0, g.Z)(e).setAlpha(t).toRgbString(),
            b = () => {
                throw new Error("createAnimatedComponent not implemented on web")
            };
        var y = s(4);
        s(5);
        const v = e => c().color[e],
            w = e => e,
            k = e => v(e) || e,
            x = e => c().avatar.size[e],
            j = e => c().avatar.fontSize[e],
            T = e => c().avatar.dotSize[e],
            S = (0, y.defaultTo)(r().textSecondary),
            P = (0, y.defaultTo)(a().tag),
            _ = e => e.isTemplate ? a().template : e.isEnded ? a().projectDone : e.isSingleTasks ? a().singleTasks : e.permissions.isOpen ? a().openProject : a().inviteOnlyProject,
            C = e => e.isEnded ? r().onBackground2 : e.isSingleTasks ? r().singleTasks : e.color,
            R = (e, t) => e.isSingleTasks ? t.f.EO : e._name,
            A = (e, t) => e.isPersonal ? t.f.Et : e.name,
            I = (e, t, s) => {
                const n = [];
                return null != s && s.shouldRenderYou ? e ? n.push(e, "(" + t.f.uG + ")") : n.push(t.f.uG) : e && n.push(e), n.length && null != s && s.isAwayOnVacation && n.push("🌴"), n.filter(Boolean).join(" ")
            },
            N = (e, t) => e.isAdminGroup ? t.f.Ea : e.name,
            E = {
                email: a().email,
                phone: a().phone,
                misc: a().globe
            },
            O = e => E[e.type],
            M = a().arrowLeft,
            D = a().share,
            H = (e, t) => g.Z.mix(c().color.surface, v(e), 100 * t),
            F = [r().avatarColor1, r().avatarColor2, r().avatarColor3, r().avatarColor4, r().avatarColor5, r().avatarColor6, r().avatarColor7, r().avatarColor8, r().avatarColor9, r().avatarColor10, r().avatarColor11, r().avatarColor12],
            Z = [r().red, r().yellow, r().sand, r().darkgreen, r().stone, r().pink, r().orange, r().dustpink, r().olive, r().lightblue, r().lightpink, r().ocher, r().taupe, r().green, r().blue, r().heather, r().brown, r().burntsienna, r().aquamarine, r().ultramarine, r().purple, r().karmin, r().mauve, r().teal, r().indigo, r().deeppurple, r().aubergine, r().midnight, r().ocean, r().navy, r().pedro, r().toto, r().fluffy, r().felus, r().luna, r().rufus, r().maja, r().elwis],
            L = [r().avatarColor4, r().purple, r().dodgerblue, r().red, r().yellow, r().pink],
            B = [a().cart, a().errands, a().phone, a().home, a().bulb, a().dollar, a().coffee, a().timer, a().book, a().car, a().battery, a().wrench, a().camera, a().heart, a().plane, a().baby, a().mapMarker, a().rocket, a().music, a().blob, a().hardware, a().accessibility, a().appleTag, a().buy, a().cards, a().clothes, a().computer, a().delivery, a().down, a().electricity, a().food, a().forklift, a().gift, a().imageTag, a().measure, a().mic, a().movie, a().nok, a().note, a().ok, a().play, a().promo, a().saw, a().up, a().pet, a().hourglass, a().gamepad, a().shieldX, a().shield, a().hammer, a().palette, a().student, a().puzzle, a().layers, a().crown, a().volume, a().folder, a().qrCode, a().user],
            z = (e, t, s) => g.Z.mix(k(e), k(t), s).toHexString(),
            U = s(424);

        function W(e, t) {
            const {
                width: s,
                height: n
            } = e;
            return {
                width: s,
                height: n,
                variant: G(s),
                isLandscape: s > n,
                isDesktop: !0,
                topInset: t.top,
                bottomInset: t.bottom
            }
        }

        function G(e) {
            return e >= U.ultrawide ? "ultrawide" : e >= U.wide ? "wide" : e >= U.standard ? "standard" : "narrow"
        }

        function V(e, t) {
            return e === t ? 0 : 0 < U[e] - U[t] ? -1 : 1
        }

        function q(e, t) {
            return 0 > V(e, t)
        }

        function Q(e, t) {
            return 0 < V(e, t)
        }
        const Y = ["application/x-7z-compressed", "application/zip", "application/x-tar", "application/x-gtar", "application/vnd.rar", "application/x-rar-compressed", "application/gzip", "application/x-bzip", "application/x-bzip2", "application/x-freearc", "application/x-apple-diskimage"],
            J = ["application/xml", "text/xml", "application/xhtml+xml", "application/x-httpd-php", "text/javascript", "application/ld+json", "application/json", "application/java-archive", "text/html", "text/css", "application/x-csh", "application/octet-stream"],
            K = ["application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/msword", "application/epub+zip", "application/vnd.amazon.ebook", "application/x-mobipocket-ebook"],
            $ = ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-excel", "application/vnd.oasis.opendocument.spreadsheet", "text/csv"];

        function X(e) {
            return J.includes(e) ? a().attachmentCode : Y.includes(e) ? a().attachmentRar : null != e && e.startsWith("video") ? a().attachmentVideo : null != e && e.startsWith("image") ? a().imageTag : $.includes(e) ? a().attachmentExcel : null != e && e.startsWith("text") || null != e && e.includes("pdf") || K.includes(e) ? a().attachmentDoc : null != e && e.startsWith("audio") ? a().attachmentMusic : a().attachment
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            a: () => o,
            d: () => i
        });
        var n = s(19);
        s(5);

        function a(e) {
            return "nozbe_teams_" + e
        }
        class o {
            constructor(e) {
                this._localStorage = e
            }
            get(e) {
                const t = a(e),
                    s = globalThis.localStorage.getItem(t);
                try {
                    return JSON.parse(String(s))
                } catch (e) {
                    return null
                }
            }
            getSlowly(e) {
                return Promise.resolve(this.get(e))
            }
            set(e, t) {
                const s = a(e),
                    n = JSON.stringify(t);
                globalThis.localStorage.setItem(s, String(n))
            }
            remove(e) {
                const t = a(e);
                globalThis.localStorage.removeItem(t)
            }
        }
        const r = n.localStorageKey,
            i = Object.freeze({
                hasUnfinishedLogin: r("has_unfinished_login"),
                lastRoute: r("last_route"),
                lastPromptedForReviewAt: r("last_prompted_for_review_at"),
                lastPromptedForNPSSurveyAt: r("last_prompted_for_nps_survey_at"),
                serverUrl: r("_sync_server"),
                serviceMode: r("service_mode"),
                syncDisabled: r("sync_disabled"),
                apiToken: r("api_token"),
                nozbe3Token: r("nozbe3_api_token"),
                diagnosticLoggedInAt: r("diagnostic_logged_in_at"),
                diagnosticSyncCount: r("diagnostic_sync_count"),
                theme: r("theme"),
                newTaskShowParams: r("newTask_params_expanded"),
                sidebarCollapsed: r("sidebar_collapsed"),
                sidebarGroupCollapsed: r("sidebar_groups_collapsed"),
                sidebarDefaultInnerView: r("sidebar_default_view"),
                sectionsCollapsed: r("sections_collapsed"),
                usesDenseLayout: r("uses_dense_layout"),
                tasksWithPinnedCommentsView: r("tasks_pinned_comments_view"),
                filterSettings: r("filter_settings"),
                newTaskDrafts: r("new_task_drafts"),
                notificationBadge: r("badge"),
                taskInvitationId: r("task_invitation_id"),
                quickAddHotkey: r("quickAddHotkey")
            })
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            allDayUTCFixupOffsets: () => w,
            calculateNewPosition: () => o,
            calculateReorders: () => i,
            getNewPosition: () => r,
            getNewPositionForForm: () => m,
            localeToBlogLanguage: () => h,
            moveRecordToListBeginning: () => c,
            moveRecordToTupleListBeginning: () => d,
            moveRecordsToListBeginning: () => l,
            moveRecordsToTupleListBeginning: () => u,
            queryBetweenDays: () => b,
            whereIncludesNormalized: () => x
        });
        var n = s(5),
            a = s(4);

        function o(e, t, s) {
            if (0 === e.length || 0 >= t) return (0, a.getFirstPosition)(e, s);
            if (t >= e.length) return (0, a.getLastPosition)(e, s);
            const o = s(e[t - 1]),
                r = s(e[t]);
            if ("number" != typeof o || "number" != typeof r) return null;
            const i = (o + r) / 2;
            return i === o || i === r ? ((0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.SAFE_LITERAL).warn("Precision lost when positioning item"), null) : i
        }
        async function r({
            list: e,
            index: t,
            selector: s,
            updater: n
        }) {
            const r = o(e, t, s);
            return "number" != typeof r || Number.isNaN(r) ? (await async function(e, t) {
                if (!e.length) return;
                const [s] = e, {
                    database: n
                } = s.collection;
                await n.write((async () => n.batch(...(0, a.map)(((e, s) => e.prepareUpdate((e => {
                    t(e, s)
                }))), e))), "Updating position series for " + s.table)
            }(e, n), o(e, t, s) || -1) : r
        }

        function i(e, t, s, n) {
            var a;
            const r = new Map,
                i = t.filter((t => t !== e));
            let c = o(i, s, n);
            return "number" != typeof c && (i.forEach(((e, t) => r.set(e, t))), c = o(i, s, (e => i.indexOf(e)))), r.set(e, null != (a = c) ? a : -1), r
        }
        const c = (e, t) => (0, a.sortByPredicate)((t => t.id === e), t),
            l = (e, t) => (0, a.sortByPredicate)((t => (0, a.identicalContains)(t.id, e)), t),
            d = (e, t) => (0, a.sortByPredicate)((t => t[0].id === e), t),
            u = (e, t) => (0, a.sortByPredicate)((t => (0, a.identicalContains)(t[0].id, e)), t);
        const m = async function({
            position: e,
            list: t,
            getTopPosition: s,
            getBottomPosition: n,
            selector: a,
            updater: o
        }) {
            return "top" === e ? s() : "bottom" === e ? n() : r({
                list: t,
                index: e,
                selector: a,
                updater: o
            })
        }, h = e => ["zh-tw", "zh-cn"].includes(e) ? e : e.split("-")[0];
        var p = s(19),
            g = s(41),
            f = s(102);
        s(21);

        function b({
            start: e,
            end: t,
            isAllDayColumn: s,
            timestampColumn: n
        }) {
            return e && invariant(e.isAllDay, "`start` must be all-day"), t && invariant(t.isAllDay, "`end` must be all-day"), invariant(e || t, "either `start` or `end` must be provided"), p.Q.or(p.Q.and([p.Q.where(s, !0), e ? p.Q.where(n, p.Q.gte(e.timestamp + y)) : null, t ? p.Q.where(n, p.Q.lte(t.timestamp + v)) : null].filter(Boolean)), p.Q.and([p.Q.where(s, !1), e ? p.Q.where(n, p.Q.gte((0, g.Z)(e.local).getTime())) : null, t ? p.Q.where(n, p.Q.lte((0, f.Z)(t.local).getTime())) : null].filter(Boolean)))
        }
        const y = -486e5,
            v = 378e5,
            w = [y, v];
        var k = s(211);

        function x(e, t) {
            return p.Q.unsafeLokiTransform((s => {
                const n = (0, k.normalizeText)(t);
                return s.filter((t => (0, k.normalizeText)(t[e] || "").includes(n)))
            }))
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i,
            devPlaceholderIllustration: () => r
        });
        s(0);
        var n = s(13);
        s(2), s(3);
        const a = s(432);
        var o = s(1);

        function r(e) {
            return [Object.assign({
                iconName: "y",
                color: "textPrimary",
                opacity: 1,
                size: 150
            }, e)]
        }
        const i = e => {
            const {
                layers: t,
                accessibilityLabel: s,
                fillMaxSize: r
            } = e;
            invariant(r && !t.find((e => e.size)) || !r && t.find((e => e.size)), "You need to provide size to the layers, or add fillMaxSize prop to the component");
            const i = Math.max(...t.map((e => {
                var t;
                return null != (t = e.size) ? t : 0
            })));
            return (0, o.jsx)("div", {
                className: a.root + " " + (e.className || ""),
                style: Object.assign({
                    width: r ? "100%" : i,
                    height: r ? "100%" : i
                }, e.style),
                children: t.map((({
                    iconName: e,
                    color: t,
                    opacity: s = 1,
                    size: i
                }, c) => (0, o.jsx)(n.default, {
                    className: a.icon,
                    name: e,
                    color: t || "onBackground2",
                    opacity: s,
                    size: r ? "100%" : i
                }, "" + e + c)))
            })
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(216), s.e(419), s.e(284)]).then(s.bind(s, 1498))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Jh: () => u.ZP,
            mt: () => w.ZP,
            xT: () => m.ZP,
            JY: () => T,
            x_: () => p,
            BS: () => d,
            Ei: () => l,
            dZ: () => v,
            C1: () => o
        });
        var n = s(4);
        const a = (0, n.pipe)(n.trim, n.isNotEmpty),
            o = e => ({
                isValid: a(e)
            });
        s(9);
        var r = s(61),
            i = s(1);
        const c = e => e.length,
            l = e => {
                const t = (e => (0, n.pipe)(n.trim, c, (0, n.greaterThanOrEqual)(e)))(e),
                    s = (e => (0, i.jsx)(r.Z, {
                        id: "KK",
                        values: {
                            minLength: e
                        }
                    }, "validation.min.length.message"))(e),
                    a = (0, n.either)(t, n.isEmpty);
                return e => ({
                    error: s,
                    isValid: a(e)
                })
            },
            d = e => {
                const t = (e => (0, i.jsx)(r.Z, {
                        id: "KJ",
                        values: {
                            maxLength: e
                        }
                    }, "validation.max.length.message"))(e),
                    s = (0, n.either)((e => t => (0, n.trim)(t).length <= e)(e), n.isEmpty);
                return e => ({
                    error: t,
                    isValid: s(e)
                })
            };
        var u = s(83),
            m = s(349);
        const h = (0, i.jsx)(r.Z, {
                id: "KI"
            }, "validation.matchesInput.message"),
            p = e => (t, s) => ({
                error: h,
                isValid: t === (null == s ? void 0 : s[e])
            }),
            g = (r.Z, /^[a-zA-Z0-9]*$/),
            f = ((0, n.either)(n.isEmpty, (e => (0, n.test)(g, e))), (0, i.jsx)(r.Z, {
                id: "KM"
            }, "validation.passwordCharacters.message")),
            b = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!"#$%&'()*+,\-.\/:;<=>?@[\]^_`{|}~])/,
            y = (0, n.either)(n.isEmpty, (e => (0, n.test)(b, e))),
            v = [e => ({
                error: f,
                isValid: y(e)
            }), o, l(10), d(64)];
        var w = s(322);
        const k = [],
            x = (0, n.propEq)("isValid", !0),
            j = (0, n.all)(x);
        const T = (...e) => (t, s) => {
            const a = (0, n.map)((e => e(t, s)), e),
                o = j(a),
                r = o ? k : function(e) {
                    return e.reduce(((e, t) => (!t.isValid && t.error && e.push(t.error), e)), [])
                }(a);
            return {
                isValid: o,
                errors: r
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            B7: () => l,
            G8: () => k,
            I: () => c,
            M6: () => u,
            N7: () => T,
            Nk: () => p,
            Or: () => v,
            SK: () => f,
            YU: () => x,
            aO: () => w,
            f5: () => j,
            xr: () => d
        });
        var n = s(0),
            a = s(14),
            o = s(37),
            r = s(1297),
            i = s(114);
        const c = (e, t, s) => {
                const {
                    positionGroup: a,
                    isShown: o
                } = t;
                return o && a ? e.map((e => {
                    if (a.section !== e.root) return e;
                    const t = ((e, t) => "top" === e.position ? 0 : "bottom" === e.position ? t.length : e.position)(a, e.items),
                        o = n.FP.insert(t, Object.assign({}, i.lf, {
                            inputRef: s,
                            position: a.position
                        }), e.items);
                    return Object.assign({}, e, {
                        items: o
                    })
                })) : e
            },
            l = () => 44,
            d = () => ({
                endedTasksState: "hidden",
                nextEndedTasksState: null,
                hasEndedToday: !1,
                endedTodayCounters: {
                    completed: 0,
                    abandoned: 0
                }
            }),
            u = ({
                root: e,
                nextEndedTasksState: t
            }, s) => t ? () => s(e, t) : null,
            m = Object.freeze([]),
            h = (e, t) => {
                switch (t.type) {
                    case "SET": {
                        const {
                            groupRoot: s,
                            state: a
                        } = t.payload, o = "string" != typeof s && s ? s.id : s, r = n.FP.findIndex((e => e.groupId === o), e);
                        if (-1 === r) return e.concat({
                            groupId: o,
                            state: a
                        });
                        return e[r].state !== a ? n.FP.update(r, {
                            groupId: o,
                            state: a
                        }, e) : e
                    }
                    case "TOGGLE_SECTION": {
                        const {
                            taskGroupRootId: s
                        } = t.payload, a = n.FP.findIndex((e => e.groupId === s), e);
                        if (-1 === a) return e.concat({
                            groupId: s,
                            state: i.VH
                        });
                        const o = "number" == typeof e[a].state ? "hidden" : i.VH;
                        return n.FP.update(a, Object.assign({}, e[a], {
                            state: o
                        }), e)
                    }
                    default:
                        return e
                }
            },
            p = (e, t) => {
                const [s, a] = n.Hooks.useReducerResettable(h, m, [e]), o = n.React.useCallback(((e, t) => {
                    a({
                        type: "SET",
                        payload: {
                            groupRoot: e,
                            state: t
                        }
                    })
                }), [a]), r = n.React.useCallback(((e, t) => {
                    a({
                        type: "TOGGLE_SECTION",
                        payload: {
                            taskGroupRootId: t
                        }
                    })
                }), [a]), [i, c] = n.Hooks.useStateResettable(!!t, [e]);
                return {
                    isShowingThePast: i,
                    toggleShowThePast: n.React.useCallback((() => c((e => !e))), [c]),
                    endedTasksStates: s,
                    setEndedTasksState: o,
                    toggleSectionShowingThePast: r,
                    setIsShowingThePast: c
                }
            },
            g = o.d.sectionsCollapsed,
            f = () => {
                const e = n.Hooks.useFastLocalStorage(),
                    [t, s] = n.React.useState(e.get(g) || []),
                    a = n.React.useCallback((async a => {
                        if (null == a) return;
                        if (-1 === n.FP.findIndex((e => e === a), t)) {
                            const n = t.concat(a);
                            return s(n), void await e.set(g, n)
                        }
                        const o = t.filter((e => e !== a));
                        s(o), await e.set(g, o)
                    }), [t, e]);
                return {
                    collapsedSectionsStates: t,
                    toggleSectionCollapse: a
                }
            },
            b = (e, t, s) => {
                const a = s.find((e => e.root === t.section));
                invariant(a, "Unexpected missing task group when adding a task");
                const o = (e => {
                    const {
                        root: t,
                        items: s
                    } = e;
                    return {
                        root: t,
                        items: n.FP.filter((e => e.isActive), s)
                    }
                })(a);
                return e.do.getProjectPositionForForm(t.position, o.items)
            },
            y = {
                position: "top",
                section: null
            };

        function v(e) {
            const t = n.Hooks.useServices(),
                s = n.Hooks.useRouteMatch(e),
                o = !!s,
                r = s ? s.params.taskId : null,
                i = s ? (0, a.getPathToTaskList)(s.params) : null;
            return n.React.useMemo((() => ({
                routeToTaskDetails: e,
                areTaskDetailsOpen: o,
                taskDetailsId: r,
                dismissTaskDetails: e => {
                    i && t.router.goTo(i, {
                        shouldOpenNewTask: e
                    })
                }
            })), [t, e, o, r, i])
        }

        function w(e, {
            areTaskDetailsOpen: t,
            dismissTaskDetails: s
        }) {
            return n.React.useCallback((() => {
                e && (t ? s(!0) : e())
            }), [t, s, e])
        }
        const k = ({
                rootRecord: e,
                defaultProject: t,
                defaultTeam: s,
                defaultResponsible: o,
                defaultTags: r,
                initialComment: i,
                fromCommentId: c,
                shouldCheckAccess: l,
                isPriorityActive: d,
                taskGroups: u,
                mapNewTaskOptions: m,
                showSnackbarInsteadOfOpening: h,
                shouldAddToIncoming: p
            }) => {
                const g = n.Hooks.useIntl(),
                    [f, v] = n.Hooks.useStateResettable(y, [e]),
                    w = n.Hooks.useRouteMatch(),
                    k = n.Hooks.useServices(),
                    {
                        currentMember: x,
                        currentTeam: j
                    } = n.Hooks.useIdentity(),
                    [T, S] = n.React.useState(!1),
                    P = n.React.useCallback((() => {
                        S(!0)
                    }), []),
                    _ = n.React.useCallback((() => {
                        S(!1)
                    }), []),
                    C = n.React.useMemo((() => ({
                        isNewTaskFormShown: T,
                        onNewTaskFormHide: _,
                        onNewTaskFormShow: P
                    })), [T, _, P]),
                    R = o || x,
                    A = s || j;
                return {
                    newTaskFormProps: n.React.useMemo((() => ({
                        onSubmit: async (s, o) => {
                            var r;
                            const i = ((e, t, s) => e.projectSection && e.projectSection.do ? e.projectSection : e.project && e.project !== s ? e.project : t.section && "string" != typeof t.section ? t.section : s)(s, f, t),
                                y = i === e || i === f.section ? await b(i, f, u) : void 0,
                                v = Object.assign({
                                    responsibleId: R.id,
                                    shouldCheckAccess: !!l,
                                    isPriority: !!d,
                                    reviewReason: p ? "newly_added" : void 0
                                }, s, {
                                    fromCommentId: c,
                                    projectPosition: y
                                }),
                                j = await i.do.addTask(m ? await m(v) : v);
                            null != (r = s.comment) && r.inputFiles && k.uploader.performUpload(x);
                            const T = e => {
                                const t = n.FP.isEmpty(w.params) && null != (s = v.project) && s.team ? v.project.isSingleTasks ? {
                                    teamId: v.project.team.id,
                                    taskListName: "single_tasks"
                                } : {
                                    teamId: v.project.team.id,
                                    projectId: v.project.id
                                } : w.params;
                                var s;
                                const o = (0, a.getPathToTaskDetails)(t, j);
                                k.router.goTo(o, {
                                    shouldOpenNewTask: e
                                })
                            };
                            h || k.uiState.isAutoTaskOpenPrevented.getValue() || T(o), h && k.uiState.pushSnackbar({
                                message: g.g("tC", {
                                    taskName: j.name
                                }),
                                buttonText: g.f.f9,
                                onButtonPress: T
                            })
                        },
                        onShow: P,
                        onHide: _,
                        isShown: T,
                        positionGroup: f,
                        setPositionGroup: v,
                        project: t,
                        team: A,
                        tags: r,
                        responsible: R,
                        shouldCheckAccess: l,
                        isPriorityActive: d,
                        intl: g,
                        comment: i
                    })), [g, d, T, l, A, R, _, P, f, v, t, r, x, m, w, e, k, u, p, h, c, i]),
                    newTaskFormVisibility: C
                }
            },
            x = (e, t) => {
                const s = new Map;
                return t.forEach((t => {
                    const n = e(t),
                        a = s.get(n);
                    a ? a.push(t) : s.set(n, [t])
                })), s
            },
            j = (e, t) => x((e => t => t.isGranted ? e.id : t._project.id)(t), e),
            T = (e, t) => {
                const {
                    matched: s,
                    taskname: n
                } = (0, r.C0)(e, t), a = Object.keys(s).reduce(((e, t) => {
                    const n = s[t];
                    if (Array.isArray(n)) {
                        const s = n.map((e => e.value));
                        return e[t] = s, Object.assign({}, e, {
                            [t]: s
                        })
                    }
                    return Object.assign({}, e, {
                        [t]: n.value
                    })
                }), {});
                return Object.assign({}, a, {
                    taskname: n
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            Error: () => w,
            ErrorsContainer: () => v,
            InputErrors: () => k,
            default: () => x
        });
        var n = s(0),
            a = s(90),
            o = s(36);
        s(160);
        const {
            vars: r,
            mixins: i,
            zcolor: c,
            rgba: l
        } = o, {
            size: d,
            spacing: u,
            radius: m,
            color: h,
            layer: p,
            fontWeight: g
        } = r, f = s(527);
        var b = s(356),
            y = s(1);
        const v = e => (0, y.jsx)("div", {
                className: f.errorsContainer,
                children: e.children
            }),
            w = e => (0, y.jsx)("span", {
                className: f.error,
                children: e.children
            }),
            k = ({
                messages: e
            }) => (0, y.jsx)(v, {
                children: e.map(((e, t) => e ? (0, y.jsx)(w, {
                    children: e
                }, t) : null))
            }),
            x = n.Hocs.compose()((e => {
                const {
                    onChange: t,
                    onSubmit: s,
                    onSubmitExtraParam: n,
                    value: o,
                    errors: r,
                    placeholder: i,
                    type: c,
                    autoCapitalize: l,
                    autoCorrect: d,
                    textContentType: u,
                    keyboardType: m,
                    returnKeyType: h,
                    isDisabled: p,
                    autoFocus: g,
                    autoComplete: v,
                    blurOnSubmit: w,
                    maxLength: x,
                    forEntryViews: j,
                    testId: T,
                    hasTopMargin: S,
                    inputRef: P,
                    multiline: _,
                    showErrorMessage: C = !0,
                    withBorderOnNative: R,
                    defaultHasErrors: A,
                    helpText: I
                } = e, {
                    isFocused: N,
                    hasErrors: E,
                    onFocus: O,
                    onBlur: M
                } = (0, b.m)(r, A), D = E && C;
                return (0, y.jsxs)("div", {
                    className: f.root + (S ? " " + f.hasTopMargin : "") + (j ? " " + f.entryViewsRoot : ""),
                    children: [(0, y.jsx)(a.Z, {
                        className: f.input + (j ? " " + f.entryViewsInput : "") + (R ? " " + f.withBorderOnNative : "") + (j && N ? " " + f.entryViewsInputFocused : "") + (E && !j ? " " + f.erroredInput : "") + (p ? " " + f.disabled : "") + (_ ? " " + f.multiline : "") + (j ? "" : " " + f.borderedInput) + (j ? " " + f.underlinedInput : "") + " " + (e.className || ""),
                        style: e.style,
                        onChange: t,
                        onBlur: () => {
                            null == e.onBlur || e.onBlur(), M()
                        },
                        ref: P,
                        autoFocus: g,
                        onFocus: () => {
                            null == e.onFocus || e.onFocus(), O()
                        },
                        value: o,
                        placeholder: i,
                        isDisabled: p,
                        type: c,
                        autoCapitalize: l,
                        autoCorrect: d,
                        keyboardType: m,
                        textContentType: u,
                        returnKeyType: h,
                        onSubmit: s,
                        onSubmitExtraParam: n,
                        autoComplete: v,
                        blurOnSubmit: w,
                        maxLength: x,
                        multiline: _,
                        testId: T
                    }), !D && I ? (0, y.jsx)("span", {
                        className: f.helpText,
                        children: I
                    }) : null, D && r ? (0, y.jsx)(k, {
                        messages: r
                    }) : null]
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => g,
            x: () => h
        });
        var n = s(0),
            a = s(20),
            o = s(29),
            r = s(15),
            i = s(1463),
            c = s(1464);

        function l(e, t) {
            var s, n;
            if (arguments.length < 1) throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
            var a = (0, r.Z)(e);
            if (!(0, i.Z)(a)) throw new RangeError("Invalid time value");
            var o = String(null !== (s = null == t ? void 0 : t.format) && void 0 !== s ? s : "extended"),
                l = String(null !== (n = null == t ? void 0 : t.representation) && void 0 !== n ? n : "complete");
            if ("extended" !== o && "basic" !== o) throw new RangeError("format must be 'extended' or 'basic'");
            if ("date" !== l && "time" !== l && "complete" !== l) throw new RangeError("representation must be 'date', 'time', or 'complete'");
            var d = "",
                u = "extended" === o ? "-" : "",
                m = "extended" === o ? ":" : "";
            if ("time" !== l) {
                var h = (0, c.Z)(a.getDate(), 2),
                    p = (0, c.Z)(a.getMonth() + 1, 2),
                    g = (0, c.Z)(a.getFullYear(), 4);
                d = "".concat(g).concat(u).concat(p).concat(u).concat(h)
            }
            if ("date" !== l) {
                var f = (0, c.Z)(a.getHours(), 2),
                    b = (0, c.Z)(a.getMinutes(), 2),
                    y = (0, c.Z)(a.getSeconds(), 2),
                    v = "" === d ? "" : " ";
                d = "".concat(d).concat(v).concat(f).concat(m).concat(b).concat(m).concat(y)
            }
            return d
        }
        var d = s(21);
        const u = /^[=+\-@\t\r].*$/,
            m = e => u.test(e) ? "'" + e : e,
            h = (e, t, s) => {
                const a = n.Hooks.useIntl(),
                    r = [a.f.uy, a.f.uB, a.f.us, a.f.uw, a.f.uv, a.f.ue, a.f.uz, a.f.uE, a.f.uF, a.f.ID, a.f.IC],
                    i = '"' + r.join('","') + '"';
                return async () => {
                    return c = t + ".csv", u = i + '\n"' + await (async () => (await n.FP.mapAsync((async e => {
                        const t = await e.fetchCurrentProject().catch((() => null)),
                            i = s ? s(e) : await e.projectSection.fetch().then((e => null == e ? void 0 : e.name)),
                            c = (await e.tags.fetch()).map((e => e.name)),
                            u = await e.responsible.fetch(),
                            h = u ? await n.Rx.takeFirst(u.preferredName) : "",
                            p = await n.Rx.takeFirst(e.timeAttributes) || {},
                            {
                                status: g
                            } = e,
                            f = (() => {
                                switch (g) {
                                    case o.TE.ABANDONED:
                                        return a.f.Jl;
                                    case o.TE.COMPLETED:
                                        return e.isGhost ? a.f.Jm : a.f.Jn;
                                    case o.TE.ACTIVE:
                                        return a.f.Jm;
                                    default:
                                        return ""
                                }
                            })(),
                            b = e.dates.dueDate,
                            y = [f, m(e.name), t ? m(n.Styling.getProjectName(t, a)) : "", i ? m(i) : "", m(h), b ? l(b.local) : "", m(c.join(",")), null != p && p.timeNeeded ? (0, d.formatTimeAttribute)(p.timeNeeded, a, {
                                format: "short"
                            }) : "", null != p && p.timeSpent ? (0, d.formatTimeAttribute)(p.timeSpent, a, {
                                format: "short"
                            }) : "", l(e.createdAt), e.endedAt && !e.isGhost ? l(e.endedAt) : ""];
                        return invariant(y.length === r.length, "there should be same number of columns in a row as there are columns declared. Broken on task " + e.id + " (" + e.name + ") Row: " + y.length + " Columns: " + r.length), y.map((e => "string" == typeof e ? e.replace(/"/g, '""') : e)).join('","')
                    }), e)).join('"\n"'))() + '"', void n.ReactUtils.downloadBlob(new Blob([u]), c);
                    var c, u
                }
            };
        var p = s(1);
        const g = e => {
            const {
                onPress: t
            } = e, s = n.Hooks.useIntl();
            return (0, p.jsx)(a.Z, {
                icon: "}",
                label: s.f.k1,
                onPress: t
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            MV: () => R,
            aq: () => M,
            sY: () => o,
            W$: () => j,
            _d: () => T,
            bB: () => E,
            y: () => A,
            dR: () => I,
            h$: () => D
        });
        var n = s(0);
        const a = " • ";

        function o(...e) {
            return e.filter(Boolean).join(a)
        }
        var r, i, c, l, d, u, m, h, p = s(69),
            g = s(24),
            f = s(278),
            b = s(41),
            y = s(29);

        function v(e, t) {
            e.count += t.count, e.timeNeeded += t.timeNeeded, e.timeSpent += t.timeSpent
        }

        function w(e, t) {
            return e.count !== t.count || e.timeNeeded !== t.timeNeeded || e.timeSpent !== t.timeSpent
        }
        const k = (e, t, s, n = null) => (0, g.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let x = (r = n.Misc.lazy, i = n.Misc.lazy, l = k(c = class {
            constructor(e) {
                (0, p.Z)(this, "groups", l, this), (0, p.Z)(this, "list", d, this), this._taskGroups = e
            }
            _createTaskGroupCounters() {
                const e = (0, y.w0)(),
                    t = t => t.timeAttributes.pipe(n.Rx.map((s => {
                        var n, a;
                        return {
                            isActive: t.isActive || t.isGhost,
                            isEndedToday: e(t),
                            timeNeeded: null != (n = null == s ? void 0 : s.timeNeeded) ? n : 0,
                            timeSpent: null != (a = null == s ? void 0 : s.timeSpent) ? a : 0
                        }
                    })), n.Rx.distinctUntilKeysChanged(["isActive", "isEndedToday", "timeNeeded", "timeSpent"]));
                return new Map(this._taskGroups.map((e => [e, n.Rx.combineLatest(e.tasks.map(t)).pipe(n.Rx.map((e => {
                    const t = {
                        activeTasks: {
                            count: 0,
                            timeNeeded: 0,
                            timeSpent: 0
                        },
                        endedTodayTasks: {
                            count: 0,
                            timeNeeded: 0,
                            timeSpent: 0
                        }
                    };
                    return e.forEach((e => {
                        const s = {
                            count: 1,
                            timeNeeded: e.timeNeeded,
                            timeSpent: e.timeSpent
                        };
                        e.isActive ? v(t.activeTasks, s) : e.isEndedToday && v(t.endedTodayTasks, s)
                    })), t
                })), n.Rx.cacheWhileConnected)])))
            }
            _createTaskListCounters() {
                const e = Array.from(this.groups.values());
                return n.Rx.combineLatest(e).pipe(n.Rx.map((e => {
                    const t = {
                        activeTasks: {
                            count: 0,
                            timeNeeded: 0,
                            timeSpent: 0
                        }
                    };
                    return e.forEach((e => {
                        v(t.activeTasks, e.activeTasks)
                    })), t
                })))
            }
        }, "groups", [r], (function() {
            return this._createTaskGroupCounters()
        })), d = k(c, "list", [i], (function() {
            return this._createTaskListCounters()
        })), c);

        function j(e, t) {
            const {
                currentTeam: s
            } = n.Hooks.useIdentity(), a = t || s, o = a instanceof n.Model.Models.Project ? a.areTimeAttributesEnabled : a.canEnableTimeAttributes;
            return n.React.useMemo((() => o ? new x(e) : null), [o, e])
        }

        function T(e, t) {
            const {
                currentTeam: s
            } = n.Hooks.useIdentity(), a = t || s, o = a instanceof n.Model.Models.Project ? a.areTimeAttributesEnabled : a.canEnableTimeAttributes, [r, i] = n.React.useState((() => o ? new S(e) : null));
            if (n.React.useEffect((() => () => {
                    r && r._unsubscribeFromSource()
                }), [r]), !r || r.hasGroupsChanged(e)) {
                const t = o ? new S(e) : null;
                return t !== r && i(t), t
            }
            return o ? r : null
        }
        let S = (u = n.Misc.lazy, h = k(m = class {
            constructor(e) {
                (0, p.Z)(this, "list", h, this), this._counters = this._createCounters(e), this._source = this._createListSource(), this._subscribable = new n.Rx.ReplaySubject(1)
            }
            get(e) {
                return this._counters.get(e)
            }
            get groups() {
                return {
                    get: e => {
                        var t;
                        return null == (t = this.get(e.root)) ? void 0 : t.observe()
                    }
                }
            }
            observeListCounter() {
                return this._sourceSubscription || (this._sourceSubscription = this._source.subscribe((e => {
                    this._subscribable.next(e)
                }))), this._subscribable
            }
            hasGroupsChanged(e) {
                return this._counters.size !== e.length || e.some((e => {
                    const t = this.get(e.root);
                    return !t || t.hasChanged(e.tasks)
                }))
            }
            _createCounters(e) {
                const t = new Map;
                return e.forEach((e => {
                    t.set(e.root, new P(e.tasks))
                })), t
            }
            _createListSource() {
                return n.Rx.combineLatest(Array.from(this._counters.values()).map((e => e.observe()))).pipe(n.Rx.map((e => {
                    const t = {
                        count: 0,
                        timeNeeded: 0,
                        timeSpent: 0
                    };
                    return e.forEach((e => {
                        e && v(t, e.activeTasks)
                    })), {
                        activeTasks: t
                    }
                })))
            }
            _unsubscribeFromSource() {
                this._sourceSubscription && (this._sourceSubscription.unsubscribe(), this._sourceSubscription = void 0), this._counters.forEach((e => {
                    e._unsubscribeFromSource()
                }))
            }
        }, "list", [u], (function() {
            return this.observeListCounter()
        })), m);
        class P {
            constructor(e) {
                this._tasks = e, this._subscribable = new n.Rx.ReplaySubject(1), this._source = this._createCountersSource()
            }
            observe() {
                return this._sourceSubscription || (this._sourceSubscription = this._source.subscribe((e => {
                    this._subscribable.next(e)
                }))), this._subscribable
            }
            hasChanged(e) {
                return this._tasks.length !== e.length || e.some(((e, t) => e !== this._tasks[t]))
            }
            _createCountersSource() {
                return n.Rx.combineLatest(this._tasks.map((e => e.observe()))).pipe(n.Rx.switchMap((e => n.Rx.combineLatestTuples(e.map((e => [e, e.timeAttributes]))).pipe(n.Rx.map((e => {
                    const t = {
                            count: 0,
                            timeNeeded: 0,
                            timeSpent: 0
                        },
                        s = {
                            count: 0,
                            timeNeeded: 0,
                            timeSpent: 0
                        };
                    return e.forEach((([e, n]) => {
                        var a, o;
                        const r = {
                            count: 1,
                            timeNeeded: null != (a = null == n ? void 0 : n.timeNeeded) ? a : 0,
                            timeSpent: null != (o = null == n ? void 0 : n.timeSpent) ? o : 0
                        };
                        e.isActive ? v(t, r) : e.endedAt && (0, f.Z)(e.endedAt, (0, b.Z)(new Date)) && v(s, r)
                    })), {
                        activeTasks: t,
                        endedTodayTasks: s
                    }
                }))))), n.Rx.distinctUntilChanged(((e, t) => ! function(e, t) {
                    return w(e.activeTasks, t.activeTasks) || w(e.endedTodayTasks, t.endedTodayTasks)
                }(e, t))))
            }
            _unsubscribeFromSource() {
                this._sourceSubscription && (this._sourceSubscription.unsubscribe(), this._sourceSubscription = void 0)
            }
        }
        var _ = s(1);
        const C = n.React.createContext(null),
            R = ({
                children: e,
                counters: t
            }) => (0, _.jsx)(C.Provider, {
                value: t,
                children: e
            });

        function A() {
            return n.React.useContext(C)
        }

        function I(e) {
            const t = n.Hooks.useServices();
            return n.React.useMemo((() => {
                async function s(s) {
                    await async function(s) {
                        if ("recurringTaskAbandoned" === s) {
                            return !await e.dates.canUpdateRecurrence()
                        }
                        return !!(await t.modelRoot.settings.seenTaskActionEvents.fetch())[s]
                    }(s) || await t.uiState.taskActionEventModal.open({
                        type: s,
                        task: e
                    })
                }
                return {
                    abandonTask: async () => {
                        await e.do.abandon(), e.dates.isRecurring && await s("recurringTaskAbandoned")
                    },
                    completeTask: async () => {
                        await e.do.complete(), e.dates.isRecurring && await s("recurringTaskCompleted")
                    },
                    assignTaskResponsible: async t => {
                        t.isEmail ? await e.do.shareWithEmail(t.email) : await e.do.assignResponsible(t.member, t.shouldCheckAccess);
                        const n = t.isEmail || !!t.member && t.shouldCheckAccess;
                        e.dates.isRecurring && n && await s("recurringTaskGranted")
                    }
                }
            }), [t, e])
        }
        const N = n.ReactUtils.lazy((() => s(1255)));

        function E({
            root: e,
            tasks: t,
            taskGroups: s,
            filterState: a
        }) {
            const [o, r] = n.React.useState(null);
            return {
                stats: n.React.useMemo((() => ({
                    showForList: () => {
                        r({
                            mode: "list"
                        })
                    },
                    showForSection: e => {
                        r({
                            mode: "section",
                            root: e
                        })
                    }
                })), []),
                renderStatsModal: n.React.useCallback((() => {
                    const n = () => r(null);
                    switch (null == o ? void 0 : o.mode) {
                        case "list":
                            return (0, _.jsx)(N, {
                                root: e,
                                tasks: t,
                                filterState: a,
                                onClose: n
                            });
                        case "section": {
                            var i;
                            const e = o.root,
                                t = s.find((t => t.root === e)),
                                r = null != (i = null == t ? void 0 : t.tasks) ? i : [];
                            return (0, _.jsx)(N, {
                                root: e,
                                tasks: r,
                                filterState: a,
                                onClose: n
                            })
                        }
                        default:
                            return null
                    }
                }), [e, t, s, a, o])
            }
        }
        const O = n.React.createContext(null),
            M = ({
                children: e,
                stats: t
            }) => (0, _.jsx)(O.Provider, {
                value: t,
                children: e
            });

        function D() {
            return n.React.useContext(O)
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            M: () => a,
            x: () => n
        });
        const n = {
                FAVORITE: "FAVORITE",
                PROJECT: "PROJECT",
                PROJECT_GROUP: "PROJECT_GROUP",
                TASK: "TASK",
                SECTION: "SECTION",
                TEAM: "TEAM",
                SIDEBAR_GROUP: "SIDEBAR_GROUP",
                SIDEBAR_GROUP_ITEM: "SIDEBAR_GROUP_ITEM"
            },
            a = {
                droppable: "droppable",
                draggable: "draggable"
            }
    }, , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n = s(0),
            a = s(13),
            o = s(11),
            r = s(18);
        s(2), s(3);
        const i = s(463);
        var c = s(1);
        const l = ["normal", "cancel", "transparent"],
            d = ["defaultAction", "development", "follow"],
            u = e => "normal" === e ? "onBackground3" : "warning" === e ? "orange" : d.includes(e) ? "purple" : "destructive" === e || "favorite" === e ? "red" : l.includes(e) ? "onBackground3" : "white",
            m = e => {
                const {
                    isDisabled: t,
                    label: s,
                    onPress: d,
                    type: m = "normal",
                    icon: h,
                    color: p,
                    onPressExtraParam: g,
                    withFlexOnWeb: f,
                    hasMinWidth: b = !0
                } = e, y = p && !t ? {
                    color: n.Styling.factoryColor(p)
                } : void 0;
                return (0, c.jsx)(o.Z, {
                    className: i.touchable + (b ? " " + i.hasMinWidth : "") + ("normal" === m || "cancel" === m ? " " + i.normalButton : "") + ("favorite" === m || "follow" === m ? " " + i.favFollowButton : "") + ("pickerAccept" === m ? " " + i.pickerAcceptButton : "") + ("transparent" === m ? " " + i.transparentButton : "") + ("development" === m ? " " + i.developmentButton : "") + ("defaultAction" === m ? " " + i.standardButton : "") + ("warning" === m ? " " + i.warningButton : "") + ("accept" === m ? " " + i.acceptButton : "") + ("destructive" === m ? " " + i.destructiveButton : "") + ("incoming" === m ? " " + i.incomingButton : "") + (t ? " " + i.disactivatedButton : "") + (f ? " " + i.flex : "") + " " + (e.className || ""),
                    style: e.style,
                    onPress: d,
                    onPressExtraParam: g,
                    isDisabled: t,
                    androidBorderless: "pickerAccept" === m,
                    children: (0, c.jsxs)("div", {
                        className: i.content,
                        children: [h ? (0, c.jsx)(a.default, {
                            name: h,
                            color: t ? "onBackground2" : p || u(m)
                        }) : null, (0, c.jsx)(r.default, {
                            className: i.text + (l.includes(m) ? "" : " " + i.coloredButtonText) + ("development" === m ? " " + i.developmentText : "") + ("pickerAccept" === m ? " " + i.pickerAcceptText : "") + ("normal" === m ? " " + i.normalText : "") + ("defaultAction" === m ? " " + i.standardText : "") + ("warning" === m ? " " + i.warningText : "") + ("accept" === m ? " " + i.acceptText : "") + ("destructive" === m ? " " + i.destructiveText : "") + ("favorite" === m ? " " + i.favoriteText : "") + ("follow" === m ? " " + i.followText : "") + ("follow" === m || "favorite" === m ? " " + i.favFollowText : "") + ("incoming" === m ? " " + i.incomingText : "") + (t ? " " + i.disactivatedText : ""),
                            style: y,
                            children: "development" === m || "pickerAccept" === m ? s : n.FP.toUpper(s)
                        })]
                    })
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            useAbortController: () => Z,
            useArrowNavigationInList: () => B,
            useAsyncEffect: () => Y,
            useAsyncFetcher: () => ne,
            useAsyncFetcherWithParams: () => ae,
            useAsyncState: () => K,
            useAttachments: () => Be,
            useBackButton: () => H,
            useContactSupport: () => we,
            useDebouncedValue: () => Oe,
            useDebugRenderCount: () => pe,
            useDense: () => xe,
            useDesktopLayout: () => q,
            useDisplayTeam: () => De,
            useDnd: () => u,
            useDocumentTitle: () => Ce,
            useDroppedFiles: () => oe,
            useErrorHandler: () => Ie,
            useEventListener: () => _e,
            useFastLocalStorage: () => Ae,
            useFileUrl: () => He,
            useForceUpdate: () => g,
            useFuzzySearchList: () => R,
            useGoToTask: () => Me,
            useHasDroppableFiles: () => ge,
            useHover: () => ze,
            useIdentity: () => r.Z,
            useIntl: () => F,
            useIsMounted: () => te.Z,
            useKeyMapper: () => ue,
            useKeyboard: () => he,
            useLayoutBottomInset: () => V,
            useLayoutDangerous: () => U,
            useLayoutInsets: () => W,
            useLayoutTopInset: () => G,
            useLayoutVariant: () => Q,
            useLoadingState: () => Se,
            useLocation: () => n.useLocation,
            useModal: () => y,
            useModalRenderer: () => b,
            useModalState: () => f,
            useModel: () => ie,
            useMultipleRefs: () => We,
            useMultipleValidation: () => A,
            useOnClearedOut: () => je,
            useOnDidLaunch: () => M,
            useParams: () => n.useParams,
            usePrevious: () => Ee,
            useReducerResettable: () => fe,
            useRefWithFallback: () => Ue,
            useRemindExpired: () => T,
            useRouteMatch: () => n.useRouteMatch,
            useServices: () => o.Z,
            useShortcutProviders: () => N,
            useShortcuts: () => I,
            useShownInViewport: () => D.Z,
            useStateMachine: () => Pe,
            useStateResettable: () => be,
            useStatusBar: () => me,
            useSuppressShortcuts: () => E,
            useThrottledSetter: () => ce,
            useThrottledValue: () => le,
            useToggle: () => de,
            useUISettings: () => C,
            useValidation: () => x
        });
        var n = s(80),
            a = s(9),
            o = s(149),
            r = s(200),
            i = s(4),
            c = s(39);
        const l = (e, t) => (0, i.filter)((e => e !== t), e),
            d = (e, t) => 0 === e ? "top" : e >= t.length ? "bottom" : e;

        function u(e) {
            const t = (0, o.Z)(),
                {
                    currentTeam: s
                } = (0, r.Z)();
            return (0, a.useMemo)((() => ({
                onDragEnd: async n => {
                    if (t.payments.remindExpired(s)) return;
                    const {
                        getDroppedSection: a,
                        getSourceList: o,
                        setNewTaskFormPosition: r,
                        selector: u,
                        updatePosition: m,
                        mapToModel: h,
                        updater: p,
                        getItemDraggableId: g
                    } = e(n), {
                        destination: f,
                        draggableId: b
                    } = n;
                    if (!f) return;
                    const {
                        root: y,
                        items: v
                    } = a(), w = o ? o() : null, k = f.index;
                    if (r && "NEW_TASK" === b) {
                        return void r({
                            position: d(k, v),
                            section: y || null
                        })
                    }
                    const x = g || (e => {
                            if (Array.isArray(e)) throw new Error("items are tuple, but you didn`t pass the [getItemDraggableId]");
                            return e.id
                        }),
                        j = (0, i.find)((e => x(e) === b), w || v);
                    invariant(j, "Unexpected missing dragged item");
                    const T = l(v, j),
                        S = h ? T.map(h) : T,
                        P = await (0, c.getNewPosition)({
                            list: S,
                            index: k,
                            selector: u,
                            updater: p
                        });
                    await m(j, P, y)
                }
            })), [e])
        }
        var m = s(414),
            h = s(8);
        const p = e => e + 1;

        function g() {
            const [, e] = a.useReducer(p, 0);
            return e
        }

        function f(e) {
            const [t] = a.useState((() => new m.Z(e))), s = a.useRef(), n = g();
            a.useEffect((() => {
                const e = t.observe().pipe(h.skip(1)).subscribe((() => n()));
                return () => {
                    e.unsubscribe()
                }
            }), [t, n]);
            const {
                state: o
            } = t, r = a.useCallback((e => {
                t.open(e)
            }), [t]), i = a.useCallback((() => {
                t.close()
            }), [t]);
            return a.useMemo((() => Object.assign({}, o, {
                target: s,
                open: r,
                close: i
            })), [o, i, r])
        }

        function b(e, t) {
            return a.useCallback((s => e.isOpen ? t(e, s) : null), [e, t])
        }

        function y(e, t) {
            const s = f(t),
                n = b(s, e);
            return Object.assign({}, s, {
                render: n
            })
        }
        var v = s(43);
        const w = (0, i.pipe)(i.values, (0, i.all)((0, i.propEq)("isValid", !0))),
            k = (0, i.pipe)(i.values, (0, i.any)((0, i.propEq)("isValid", !0)));

        function x(e) {
            const t = (0, i.map)((([e]) => e), e),
                s = (0, i.map)((([e, s]) => (0, v.JY)(...s)(e, t)), e);
            return Object.assign({}, s, {
                isValid: w(s),
                isAnyValid: k(s),
                validResults: (0, i.filter)((e => e.isValid), s),
                invalidResults: (0, i.filter)((e => !e.isValid), s)
            })
        }
        var j = s(14);

        function T(e, t) {
            const s = (0, o.Z)(),
                {
                    currentTeam: n,
                    isLimitedAccount: a
                } = (0, r.Z)(),
                i = t || n;
            return t => (...o) => i.isExpired ? (e(), s.payments.remindExpired(i), n !== i && s.router.goTo((0, j.getPathToCurrentTeamRoot)(i, a)), null) : t(...o)
        }
        var S = s(5),
            P = s(240),
            _ = s(416);

        function C() {
            return (0, a.useContext)(_.Z)
        }

        function R(e) {
            var t;
            const {
                isFuzzySearchEnabled: s
            } = C(), n = null != (t = e.strategy) ? t : s ? "smart" : "off", a = Object.assign({
                strategy: n
            }, e);
            return (0, P.useFuzzySearchList)(a)
        }

        function A(e, t) {
            return x(t.reduce(((t, s, n) => Object.assign({}, t, {
                ["" + n]: [s, e]
            })), {}))
        }

        function I(e) {
            const t = (0, o.Z)();
            a.useEffect((() => {
                t.shortcuts.setShortcuts(e)
            }), [e, t.shortcuts]), a.useEffect((() => () => t.shortcuts.setShortcuts([])), [t.shortcuts])
        }

        function N(e) {
            const t = (0, o.Z)();
            a.useEffect((() => (t.shortcuts.updateActionProviders(e), () => t.shortcuts.removeActionProviders(e))), [e, t.shortcuts])
        }

        function E() {
            const e = (0, o.Z)();
            a.useEffect((() => (e.shortcuts.suppress(), () => e.shortcuts.unsuppress())), [e])
        }
        var O = s(164);
        const M = () => {
            const e = (0, o.Z)();
            (0, a.useEffect)((() => {
                e.native.hideSplashScreen(), e.performance.markPageLoaded(), setTimeout((() => (0, O.d)()), 0)
            }), [e.native, e.performance])
        };
        var D = s(350);
        const H = () => {};
        const F = s(147).Z,
            Z = () => {
                const [e] = a.useState(new AbortController);
                return e
            };
        var L = s(23);
        const B = ({
            list: e,
            numberOfItemsNotMappedAtTop: t = 0,
            numberOfItemsNotMappedAtBottom: s = 0,
            initialIndex: n = 0,
            scrollElementRef: o
        }) => {
            const [r, i] = a.useState(n), c = function(e) {
                const t = a.useRef();
                return null != e ? e : t
            }(o), l = a.useRef();
            a.useEffect((() => {
                i(n)
            }), [n, e.length]);
            const d = -1 * t,
                u = e.length + s,
                m = e => {
                    e.preventDefault(), e.stopPropagation(), requestAnimationFrame((() => {
                        invariant(!0, "fix nativeViewElement to support native"), invariant(l.current && c.current, "scrollToActive - missing refs"), (0, L.scrollIntoView)({
                            element: l.current,
                            scrollElement: c.current,
                            nativeViewElement: null
                        })
                    }))
                };
            return {
                activeItemIndex: r,
                arrowNavigationKeyEventHandler: t => {
                    e.length && "ArrowDown" === t.key && (i((e => e < u - 1 ? e + 1 : d)), m(t)), e.length && "ArrowUp" === t.key && (i((e => e > d ? e - 1 : u - 1)), m(t))
                },
                scrollElementRef: c,
                activeItemRef: l
            }
        };
        var z = s(417);

        function U() {
            return (0, a.useContext)(z.VY)
        }

        function W() {
            return (0, a.useContext)(z.ZX)
        }

        function G() {
            return (0, a.useContext)(z.LJ)
        }

        function V() {
            return (0, a.useContext)(z.Y2)
        }

        function q() {
            return (0, a.useContext)(z.v9)
        }

        function Q() {
            return (0, a.useContext)(z.hU)
        }

        function Y(e, t) {
            a.useEffect((() => {
                let t = !0;
                return e({
                    isPending: () => t
                }), () => {
                    t = !1
                }
            }), t)
        }
        class J {
            get lastIdleSnapshot() {
                return this._lastIdleSnapshot
            }
            get isStateFetchAborted() {
                var e, t;
                return null != (e = null == (t = this._pendingFetchController) ? void 0 : t.signal.aborted) && e
            }
            constructor(e, t) {
                var s;
                this._lock = new S.Mutex({
                    deadlockTimeout: null != (s = null == t ? void 0 : t.maxFetchDuration) ? s : 6e4,
                    onDeadlock: () => {
                        this.isStateFetchAborted || this.abortStateFetch()
                    }
                }), this.registerSnapshot(e)
            }
            registerSnapshot(e) {
                e.isBusy || (this._lastIdleSnapshot = e)
            }
            performStateFetch(e) {
                return this._lock.runExclusively((async () => {
                    invariant(!this._pendingFetchController, "Unexpected concurrent transition"), this._pendingFetchController = new AbortController;
                    try {
                        await e(this._pendingFetchController.signal)
                    } finally {
                        this._pendingFetchController = null
                    }
                }))
            }
            abortStateFetch() {
                var e;
                null == (e = this._pendingFetchController) || e.abort()
            }
        }

        function K(e, t) {
            const [s, n] = a.useReducer($, X(e)), o = function(e, t) {
                const [s] = a.useState((() => new J(e, t)));
                return a.useEffect((() => {
                    s.registerSnapshot(e)
                }), [s, e]), s
            }(s, t), r = a.useMemo((() => ({
                toFetch: () => {
                    n({
                        type: "fetch"
                    })
                },
                toSuccess: e => {
                    n({
                        type: "success",
                        payload: e
                    })
                },
                toError: e => {
                    const t = (0, S.wrapError)(e);
                    n({
                        type: "error",
                        payload: t
                    })
                },
                toInitialState: e => {
                    n({
                        type: "reset",
                        payload: e
                    })
                },
                toLastIdleState: () => {
                    n({
                        type: "rollback",
                        payload: o._lastIdleSnapshot
                    })
                }
            })), [o]);
            return a.useMemo((() => {
                const e = Object.assign({}, s, {
                    transition: r,
                    map: {
                        status: t => (0, L.mapAsyncStateStatus)(t, e),
                        progress: t => (0, L.mapAsyncStateProgress)(t, e),
                        result: t => (0, L.mapAsyncStateResult)(t, e),
                        activity: t => (0, L.mapAsyncStateActivity)(t, e)
                    },
                    __internals: o
                });
                return e
            }), [s, r, o])
        }

        function $(e, t) {
            switch (t.type) {
                case "fetch":
                    return "success" === e.status ? {
                        status: "refetching",
                        value: e.value,
                        error: void 0,
                        isFetching: !1,
                        isRefetching: !0,
                        isRetrying: !1,
                        isBusy: !0,
                        isSuccess: !1,
                        isError: !1,
                        hasSucceeded: !0,
                        hasErrored: !1
                    } : "error" === e.status ? {
                        status: "retrying",
                        value: void 0,
                        error: e.error,
                        isFetching: !1,
                        isRefetching: !1,
                        isRetrying: !0,
                        isBusy: !0,
                        isSuccess: !1,
                        isError: !1,
                        hasSucceeded: !1,
                        hasErrored: !0
                    } : {
                        status: "fetching",
                        value: e.value,
                        error: void 0,
                        isFetching: !0,
                        isRefetching: !1,
                        isRetrying: !1,
                        isBusy: !0,
                        isSuccess: !1,
                        isError: !1,
                        hasSucceeded: !1,
                        hasErrored: !1
                    };
                case "success":
                    return {
                        status: "success", value: t.payload, error: void 0, isFetching: !1, isRefetching: !1, isRetrying: !1, isBusy: !1, isSuccess: !0, isError: !1, hasSucceeded: !0, hasErrored: !1
                    };
                case "error":
                    return {
                        status: "error", value: void 0, error: t.payload, isFetching: !1, isRefetching: !1, isRetrying: !1, isBusy: !1, isSuccess: !1, isError: !0, hasSucceeded: !1, hasErrored: !0
                    };
                case "reset":
                    return X(t.payload);
                case "rollback": {
                    if (!e.isBusy) return e;
                    const s = t.payload;
                    return invariant(s, "Async state must have at least one idle snapshot"), s
                }
                default:
                    return e
            }
        }

        function X(e) {
            return {
                status: "init",
                value: ee(e),
                error: void 0,
                isFetching: !1,
                isRefetching: !1,
                isRetrying: !1,
                isBusy: !1,
                isSuccess: !1,
                isError: !1,
                hasSucceeded: !1,
                hasErrored: !1
            }
        }

        function ee(e) {
            switch (typeof e) {
                case "undefined":
                    return;
                case "function":
                    return e();
                default:
                    return e
            }
        }
        var te = s(323);
        const se = Symbol("AsyncStateRollback");

        function ne(e, t) {
            return ae(e, t)
        }

        function ae(e, t) {
            const s = (0, te.Z)();
            return async n => {
                const {
                    isPending: a,
                    onSuccess: o,
                    onError: r
                } = n || {}, i = null == n ? void 0 : n.params, c = e.__internals;
                await c.performStateFetch((async n => {
                    const c = {
                            rollback: () => se,
                            isPending: () => !1 !== (null == a ? void 0 : a()) && s.current,
                            params: i,
                            abortSignal: n
                        },
                        l = () => {
                            throw new Error("Fetch aborted")
                        };
                    try {
                        n.addEventListener("abort", l), e.transition.toFetch();
                        const s = await t(c);
                        c.isPending() && (s === se ? e.transition.toLastIdleState() : (e.transition.toSuccess(s), await (null == o ? void 0 : o(s))))
                    } catch (t) {
                        if (c.isPending()) {
                            const s = (0, S.wrapError)(t);
                            e.transition.toError(s), await (null == r ? void 0 : r(s))
                        }
                    } finally {
                        n.removeEventListener("abort", l)
                    }
                }))
            }
        }
        const oe = e => t => {
                const {
                    dataTransfer: s
                } = t;
                s.types.includes("Files") && (t.preventDefault(), e(Array.from(s.files)))
            },
            re = "subscribe via useModel";

        function ie(e) {
            const t = g();
            return a.useEffect((() => e.experimentalSubscribe(t, re)), [e]), e
        }

        function ce(e, t) {
            const s = a.useRef(void 0),
                n = a.useRef();
            return a.useEffect((() => () => clearTimeout(n.current)), []), a => {
                s.current = a, n.current || (n.current = setTimeout((() => {
                    n.current = null, e(s.current)
                }), t))
            }
        }

        function le(e, t) {
            const [s, n] = a.useState(e), o = a.useRef({
                isPending: !1
            }), r = a.useRef();
            return a.useEffect((() => {
                r.current ? o.current = {
                    isPending: !0,
                    value: e
                } : (n(e), function e() {
                    r.current = setTimeout((() => {
                        o.current.isPending ? (n(o.current.value), o.current = {
                            isPending: !1
                        }, e()) : r.current = void 0
                    }), t)
                }())
            }), [e, t]), a.useEffect((() => () => {
                clearTimeout(r.current)
            }), []), s
        }
        const de = e => {
                const [t, s] = (0, a.useState)(!!e);
                return [t, (0, a.useCallback)((() => {
                    s((e => !e))
                }), [])]
            },
            ue = e => {
                const t = a.useRef({
                    rootRecord: e,
                    itemToKey: {},
                    keyCounter: 0
                });
                t.current.rootRecord !== e && (t.current = {
                    rootRecord: e,
                    itemToKey: {},
                    keyCounter: 0
                });
                const {
                    current: s
                } = a.useRef((e => ((e, t) => {
                    if (t.itemToKey[e]) return t.itemToKey[e];
                    t.keyCounter += 1;
                    const s = "Mapped-" + t.keyCounter;
                    return t.itemToKey[e] = s, s
                })(e, t.current)));
                return s
            };

        function me({
            style: e,
            level: t,
            isHidden: s = !1,
            isTransparentAndroid: n = !0
        }) {
            const r = (0, o.Z)(),
                {
                    statusBar: i
                } = r.scene,
                c = q();
            a.useEffect((() => {
                const a = c ? {
                    style: "auto",
                    isHidden: s,
                    animation: "fade",
                    isTransparentAndroid: !0
                } : {
                    style: e,
                    isHidden: s,
                    animation: "fade",
                    isTransparentAndroid: n
                };
                return i.setOptionsAtLevel(t, a), () => {
                    i.setOptionsAtLevel(t, null)
                }
            }), [e, t, s, n, i, c])
        }
        me.levels = {
            ignore: -1,
            sidebar: 0,
            sidebarInner: 1,
            main: 2,
            taskDetails: 3,
            modal: 4
        };
        const he = function() {
            return {
                isVisible: !1,
                height: 0
            }
        };

        function pe() {
            const e = a.useRef(0);
            return e.current += 1, e.current
        }

        function ge() {
            const e = (0, o.Z)(),
                [t, s] = a.useState(!1);
            return a.useEffect((() => {
                const t = e.nativeScene.hasDroppableFiles.subscribe(s);
                return () => t.unsubscribe()
            }), [e.nativeScene]), t
        }

        function fe(e, t, s) {
            const n = a.useRef(s),
                o = a.useRef(!1);
            (function(e, t) {
                if (e === t) return !1;
                if (e.length !== t.length) return !0;
                for (let s = 0; s < e.length; s += 1)
                    if (!Object.is(e[s], t[s])) return !0;
                return !1
            })(n.current, s) && (n.current = s, o.current = !0);
            const r = a.useMemo((() => t), s),
                i = a.useCallback(((t, s) => {
                    const n = o.current;
                    if (o.current = !1, n) return [e(r, s)];
                    const a = t[0],
                        i = e(a, s);
                    return Object.is(a, i) ? t : [i]
                }), [e, r]),
                [c, l] = a.useReducer(i, [t]);
            return [o.current ? r : c[0], l]
        }

        function be(e, t) {
            return fe(ye, e, t)
        }

        function ye(e, t) {
            return "function" == typeof t ? t(e) : t
        }
        var ve = s(418);

        function we() {
            const e = F(),
                t = (0, o.Z)(),
                n = (0, r.Z)(),
                a = async () => {
                    const e = await n.currentMember.user.fetch(),
                        t = await h.takeFirst(n.currentTeam.billableMembersCount);
                    return (0, ve.z)({
                        currentTeam: n.currentTeam,
                        user: e,
                        membersCount: t
                    }, '"email support"')
                }, c = async () => {
                    const e = await s(107).tl();
                    return await e.runDiagnostics({
                        isFull: !1,
                        setLog: i.noop,
                        services: t,
                        currentMember: null == n ? void 0 : n.currentMember
                    })
                }, l = async (t, s, n) => {
                    try {
                        const o = await a();
                        if (!t) return "\n\n\n" + o;
                        const r = await (async e => {
                            const t = new Promise(((e, t) => {
                                setTimeout(t, 1e3, new Error("diagnostics timeout"))
                            }));
                            return Promise.race([t, c()]).then((t => "Basic diagnostics (" + t.issueCount + " issues found):\n\n" + (e ? "(Please attach diagnostics)" : t.log))).catch((async e => "Diagnostics error: " + e.toString() + "\n\n" + await a()))
                        })(n);
                        return "\n\n\n\n\n\n\n" + e.f.CE + "\n\n______________________________________\n\n" + (s || "") + "\n\n" + o + "\n\n" + r
                    } catch (e) {
                        return "\n\n(Diagnostics error)"
                    }
                };
            return async ({
                body: e,
                subject: t,
                withDiagnostics: s,
                extraDiagnosticText: n
            }) => {
                const a = !(await L.getDeviceName()).includes("Safari"),
                    o = "" + (e || "") + await l(s, n, a),
                    r = a && 1500 < o.length;
                r && S.logError(S.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "mailto: body too long (" + o.length + ")");
                const i = r ? o.slice(0, 1500) + "… (truncated)" : o;
                L.openEmailUrl({
                    to: "support@nozbe.com",
                    subject: t,
                    body: i
                })
            }
        }
        var ke = s(472);

        function xe() {
            return (0, a.useContext)(ke.B)
        }

        function je(e, t, s) {
            const n = a.useRef([e, t]);
            a.useEffect((() => {
                const [a, o] = n.current;
                n.current = [e, t], o === t && 0 === e && 0 < a && s()
            }))
        }
        const Te = (e, t) => {
                switch (t.type) {
                    case "load":
                        return Object.assign({}, e, {
                            status: "loading"
                        });
                    case "success":
                        return Object.assign({}, e, {
                            status: "success",
                            result: t.result,
                            error: null,
                            hasFetched: !0
                        });
                    case "error":
                        return Object.assign({}, e, {
                            status: "error",
                            result: null,
                            error: t.error,
                            hasFetched: !0
                        });
                    case "reset":
                        return Object.assign({}, e, {
                            status: "idle",
                            result: null,
                            error: null
                        });
                    default:
                        throw new Error("Unknown action type: " + t.type)
                }
            },
            Se = (e = {}) => {
                const t = Object.assign({
                        status: "idle",
                        result: void 0,
                        error: void 0,
                        hasFetched: !1
                    }, e),
                    [s, n] = a.useReducer(Te, t),
                    o = a.useCallback((() => {
                        n({
                            type: "load"
                        })
                    }), []),
                    r = a.useCallback((e => {
                        n({
                            type: "success",
                            result: e
                        })
                    }), []),
                    i = a.useCallback((e => {
                        n({
                            type: "error",
                            error: e
                        })
                    }), []),
                    c = a.useCallback((() => {
                        n({
                            type: "reset"
                        })
                    }), []);
                return [Object.assign({}, s, {
                    isLoading: "loading" === s.status,
                    isSuccess: "success" === s.status,
                    isError: "error" === s.status,
                    isInitialLoad: "loading" === s.status && !s.hasFetched,
                    isIdle: "idle" === s.status
                }), o, r, i, c]
            };

        function Pe(e, t) {
            const [
                [s, n], o
            ] = a.useState([e, t]), r = a.useCallback(((e, t) => () => o([e, t])), []);
            return [{
                current: s,
                map(e) {
                    const t = e[s];
                    return t ? t(n) : null
                }
            }, r]
        }
        const _e = e => {
            var t;
            const {
                eventName: s,
                handler: n,
                shouldCapture: r
            } = e, i = (0, o.Z)().scene.webWindow.document, c = null != (t = e.target) ? t : i;
            a.useEffect((() => c && c.addEventListener ? (c.addEventListener(s, n, r), () => {
                c.removeEventListener(s, n, r)
            }) : () => {}), [s, n, r, c])
        };

        function Ce(e) {
            const t = (0, o.Z)(),
                s = F().f.eI,
                {
                    webWindow: n,
                    id: r
                } = t.scene;
            a.useEffect((() => {
                var t;
                const a = null != (t = n.document.title) ? t : s;
                return S.isPWA() || S.isElectron ? () => {} : (n.document.title = e ? e + " - " + s : s, () => {
                    n.document.title = a
                })
            }), [s, e, n, r])
        }
        var Re = s(37);

        function Ae() {
            const e = (0, o.Z)(),
                [t] = a.useState((() => new Re.a(e.localStorage)));
            return t
        }

        function Ie(e) {
            const t = function() {
                const e = F();
                return (t, s) => {
                    switch (s) {
                        case S.BuiltInErrorCodes.TooManyRequest:
                            return e.f.kX;
                        case S.BuiltInErrorCodes.InternalServerError:
                            return e.f.kT;
                        case S.BuiltInErrorCodes.ServiceUnavailable:
                            return e.f.kW;
                        case S.BuiltInErrorCodes.NetworkLikely:
                            return e.f.kU
                    }
                    return s !== S.BuiltInErrorCodes.Unknown ? e.f.kT : e.f.kY
                }
            }();
            return {
                boom: (e, t) => new S.NozbeError(e, t),
                handle: async t => {
                    if (!t) return;
                    const s = (0, S.determineErrorCode)(t),
                        n = null == e ? void 0 : e[s];
                    "object" == typeof n && await n.handle(t)
                },
                translate: s => {
                    if (!s) return "";
                    const n = (0, S.determineErrorCode)(s);
                    if (null != e && e[n]) {
                        const t = e[n],
                            a = "object" == typeof t ? t.translate : t;
                        if (a) return "function" == typeof a ? a(s) : a
                    }
                    return t(s, n)
                },
                map: (e, t) => (t[(0, S.determineErrorCode)(e)] || t._ || (() => null))(e),
                ErrorCodes: Ne
            }
        }
        const Ne = new Proxy({}, {
            get: (e, t) => t
        });

        function Ee(e) {
            const t = a.useRef();
            return a.useEffect((() => {
                t.current = e
            })), t.current
        }

        function Oe(e, t) {
            const [s, n] = a.useState(e);
            return a.useEffect((() => {
                const s = setTimeout((() => {
                    n(e)
                }), t);
                return () => {
                    clearTimeout(s)
                }
            }), [e, t]), s
        }

        function Me() {
            const e = (0, o.Z)();
            return async t => {
                const s = await t.fetchCurrentProject(),
                    n = await s.team.fetch();
                e.router.goTo((0, j.smartPathToTask)(n, s, t.id))
            }
        }

        function De() {
            const e = (0, o.Z)(),
                {
                    currentTeam: t,
                    isLimitedAccount: s
                } = (0, r.Z)();
            return a.useCallback((n => {
                if (n !== t) {
                    const t = (0, j.getPathToCurrentTeamRoot)(n, s);
                    e.router.goTo(t)
                }
            }), [t, s, e])
        }

        function He(e) {
            const [t] = be(URL.createObjectURL(e), [e]);
            return a.useEffect((() => () => {
                URL.revokeObjectURL(t)
            }), [t]), t
        }
        s(17);
        var Fe = s(88),
            Ze = s(1);
        const Le = L.lazy((() => s(479)));

        function Be({
            uploadedFiles: e = [],
            onDropCallback: t,
            team: s
        }) {
            const n = (0, o.Z)(),
                r = a.useRef(""),
                c = f(),
                l = f(),
                [d, u] = a.useState([]),
                m = T(i.noop),
                h = async e => {
                    const {
                        files: t,
                        error: n
                    } = await (0, Fe.ox)(e, s);
                    "file_size_exceeded" === n && c.open(), u(d.concat(t.map((e => (0, Fe.M8)({
                        source: "local",
                        file: e
                    })))))
                }, p = e => {
                    u(d.filter((({
                        id: t
                    }) => t !== e)))
                }, g = a.useCallback((() => {
                    u([])
                }), []), b = oe(m((e => {
                    h(e), t()
                }))), y = ge(), v = F();
            return a.useEffect((() => {
                const t = i.pluckIds(d),
                    s = e.map((e => (0, Fe.zK)(e))).filter((e => !t.includes(e.id)));
                u(d.concat(s))
            }), [e.length]), {
                attachedFiles: d,
                clearAttachedFiles: g,
                confirmRemoveAttachedFile: e => {
                    const t = d.find((({
                        id: t
                    }) => t === e));
                    t && t.version ? (r.current = e, l.open()) : p(e)
                },
                pickAttachments: (e, t) => {
                    n.nativeScene.pickFile((async e => {
                        e && await h(e), t && t(e)
                    }), {
                        type: e || "files",
                        multiple: !0,
                        mimeType: "*/*"
                    })
                },
                addExternalAttachments: e => {
                    const t = d.map((e => "external" === e.content.source ? e.content.file.sourceId : null)).filter(Boolean),
                        s = e.filter((e => !t.includes(e.sourceId))).map((e => (0, Fe.M8)({
                            source: "external",
                            file: e
                        })));
                    u(d.concat(s))
                },
                pasteAttachments: async e => {
                    var t;
                    const s = Array.from((null == (t = e.clipboardData) ? void 0 : t.items) || []).filter((e => "file" === e.kind));
                    if (!s.length) return;
                    e.preventDefault();
                    const n = s.map((async e => {
                            const t = e.getAsFile();
                            if (!t) return null;
                            try {
                                const e = await t.arrayBuffer();
                                return new File([e], t.name, {
                                    type: t.type
                                })
                            } catch (e) {
                                return null
                            }
                        })),
                        a = (await Promise.all(n)).filter(Boolean);
                    a.length && h(a)
                },
                removeAttachmentConfirm: l,
                removeAttachedFileAfterConfirm: () => {
                    p(r.current)
                },
                uploadLimitModal: c,
                renderDropZone: () => y ? (0, Ze.jsx)(Le, {
                    onDrop: b,
                    header: v.f.eL,
                    description: v.f.eM
                }) : null
            }
        }

        function ze(e) {
            const [t, s] = a.useState(!1), {
                onMouseEnter: n,
                onMouseLeave: o
            } = null != e ? e : {};
            return {
                isHovering: t,
                onMouseEnter: a.useCallback((() => {
                    n && n(), s(!0)
                }), [n]),
                onMouseLeave: a.useCallback((() => {
                    o && o(), s(!1)
                }), [o])
            }
        }

        function Ue(e) {
            const t = a.useRef(null);
            return e || t
        }

        function We(...e) {
            return t => {
                e.forEach((e => {
                    e && (e.current = t)
                }))
            }
        }
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(93),
            o = s(155),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            member: e || n.Rx.of(null)
        }))), n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            user: e ? e.user : n.Rx.of(null)
        }))), (0, o.Z)((({
            user: e
        }) => ({
            avatarId: null == e ? void 0 : e.avatarId
        }))))((e => {
            const {
                member: t,
                user: s,
                avatarSource: o,
                size: i,
                avatarStyle: c = "round"
            } = e, l = (null == t ? void 0 : t.alias) || (null == s ? void 0 : s.name) || "", d = t && s ? t.isArchived ? "onBackground3" : s.color : "onBackground1", u = t ? n.Styling.vars.avatar.status[t.status] : void 0, m = n.Styling.factoryAvatarSize(i || "normal");
            return (0, r.jsx)(a.default, {
                name: l,
                color: d,
                source: o,
                size: i,
                dotColor: u,
                className: e.className,
                style: Object.assign({}, "message" === c ? {
                    borderRadius: m,
                    borderTopRightRadius: .2 * m
                } : void 0, e.style)
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0);
        s(2), s(3);
        const a = s(448);
        var o = s(1);
        const r = {
                small: 20,
                large: 40
            },
            i = e => {
                const {
                    size: t,
                    color: s = "#A902D2"
                } = e;
                return (0, o.jsx)("div", {
                    className: a.indicator + " " + (e.className || ""),
                    style: Object.assign({
                        width: r[t],
                        borderColor: s + " transparent"
                    }, e.style)
                })
            },
            c = n.Hocs.compose()((e => {
                const {
                    size: t = "large",
                    color: s
                } = e, a = s ? n.Styling.factoryColor(s) : void 0;
                return (0, o.jsx)(i, {
                    size: t,
                    color: a,
                    className: e.className,
                    style: e.style
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Zv: () => f
        });
        var n = s(52),
            a = s(0),
            o = s(12),
            r = s(6);
        s(2), s(3);
        const i = s(469);
        var c, l, d = s(1);
        const u = a.ReactUtils.lazy((() => s(25))),
            m = a.Hocs.compose()((e => {
                const {
                    getPromise: t,
                    children: s,
                    onCancel: n,
                    mode: m = "default"
                } = e, h = a.Hooks.useIntl(), p = a.Hooks.useIsMounted(), [g, f] = a.Hooks.useStateResettable("loading", [t]), [b, y] = a.Hooks.useStateResettable(null, [t]);
                a.React.useEffect((() => {
                    t().then((e => {
                        p.current && y((() => e))
                    })).catch((e => {
                        a.Misc.logError(a.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Could not load code-split chunk: " + e.message), p.current && f("error"), "silent" === m && n()
                    })), setTimeout((() => {
                        p.current && f((e => "loading" === e ? "long" : e))
                    }), 1500)
                }), [t]);
                const v = () => globalThis.location.reload();
                if (b) return s(b);
                if ("loading" === g || "silent" === m) return null;
                if ("long" === g) return "screen" === m ? (0, d.jsx)("div", {
                    className: i.root,
                    children: c || (c = (0, d.jsx)(r.u_.Loader, {
                        isLoading: !0,
                        loadingThreshold: 0
                    }))
                }) : (0, d.jsx)(r.u_, {
                    onClose: n,
                    children: (0, d.jsxs)(r.u_.Content, {
                        children: [l || (l = (0, d.jsx)(r.u_.Loader, {
                            isLoading: !0,
                            loadingThreshold: 0
                        })), (0, d.jsx)(r.u_.Buttons, {
                            children: (0, d.jsx)(o.default, {
                                label: h.f.fe,
                                onPress: n
                            })
                        })]
                    })
                });
                if ("error" === g) return "screen" === m ? (0, d.jsx)("div", {
                    className: i.root,
                    children: (0, d.jsxs)("div", {
                        className: i.errorInfo,
                        children: [(0, d.jsx)("span", {
                            className: i.errorText,
                            children: h.f.gT
                        }), (0, d.jsxs)("div", {
                            className: i.errorButtons,
                            children: [(0, d.jsx)(o.default, {
                                className: i.errorButton,
                                label: h.f.gS,
                                onPress: v
                            }), (0, d.jsx)(o.default, {
                                className: i.errorButton,
                                label: h.f.fF,
                                onPress: n
                            })]
                        })]
                    })
                }) : (0, d.jsx)(u, {
                    type: "delete",
                    headerIcon: "y",
                    onConfirmPress: n,
                    confirmButtonMessage: h.f.fF,
                    onClose: n,
                    secondaryButtonMessage: h.f.gS,
                    onBackPress: v,
                    children: h.f.gT
                });
                throw new Error("unreachable")
            })),
            h = ["bundle$close", "bundle$mode", "__forwardedRef"];

        function p(e) {
            return (t, s) => function(e, t, s) {
                return (0, d.jsx)(m, {
                    getPromise: e,
                    onCancel: t,
                    children: s
                })
            }(e, t, s)
        }

        function g(e) {
            const t = Object.create(null);
            return new Proxy({}, {
                get: (s, o) => {
                    const r = t[o];
                    if (r) return r;

                    function i(t) {
                        const {
                            bundle$close: s,
                            bundle$mode: r,
                            __forwardedRef: i
                        } = t, c = (0, n.Z)(t, h);
                        return (0, d.jsx)(m, {
                            getPromise: e,
                            onCancel: s,
                            mode: r,
                            children: e => {
                                const t = e[o];
                                if (!t) throw new Error('CodeSplitLoader: component "' + o + '" not found');
                                return a.React.createElement(t, Object.assign({
                                    ref: i
                                }, c))
                            }
                        })
                    }
                    const c = a.React.forwardRef(((e, t) => (0, d.jsx)(i, Object.assign({}, e, {
                        __forwardedRef: t
                    }))));
                    return t[o] = c, c
                }
            })
        }

        function f(e) {
            return {
                getImported: e,
                render: p(e),
                components: g(e)
            }
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            tu: () => r,
            gq: () => o
        });
        s(0), s(2), s(3);
        const n = s(502);
        var a = s(1);
        const o = e => (0, a.jsx)("div", {
                className: n.row + (e.centered ? " " + n.centered : "") + " " + (e.className || ""),
                style: Object.assign({
                    alignItems: e.align,
                    justifyContent: e.justify,
                    gap: e.gap
                }, e.style),
                children: e.children
            }),
            r = e => (0, a.jsx)("div", {
                className: n.column + (e.centered ? " " + n.centered : "") + " " + (e.className || ""),
                style: Object.assign({
                    alignItems: e.align,
                    justifyContent: e.justify,
                    gap: e.gap
                }, e.style),
                children: e.children
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(9);
        var n = s(1448),
            a = s(1);
        const o = e => {
            const {
                id: t,
                values: s
            } = e;
            return (0, a.jsx)(n.Z, {
                id: t,
                values: s
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        s(0);
        var n = s(1458);
        s(2), s(3);
        const a = s(523);
        var o = s(1);
        const r = e => {
            const {
                id: t,
                children: s,
                type: r
            } = e;
            return (0, o.jsx)(n.Z, {
                droppableId: t,
                type: r,
                children: t => (0, o.jsxs)("div", Object.assign({
                    className: a.droppable + " " + (e.className || ""),
                    style: e.style,
                    ref: t.innerRef
                }, t.droppableProps, {
                    children: [s, t.placeholder]
                }))
            })
        }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Y3: () => b,
            yK: () => w,
            ku: () => P.k,
            WY: () => c,
            T9: () => g,
            Q4: () => p,
            rc: () => T,
            Dp: () => S,
            Vf: () => v,
            qg: () => l,
            O6: () => k,
            J$: () => x,
            pW: () => j,
            Mx: () => m,
            ck: () => y,
            _O: () => _
        });
        var n = s(19),
            a = s(16),
            o = s(8),
            r = s(4);
        s(5);
        const i = a.o.projects;

        function c(e, t) {
            const s = e => (...s) => t(...s)[e];
            return [r.descend(s("isActive")), r.descend(s("isSingleTasks")), r.descend(s("endedAt")), r.descend(s("isFavorite")), r.descend(s("isFollowed")), r.ascend(s("sidebarPosition")), r.ascendLocale(s("_name"), e.locale)]
        }
        const l = [i.endedAt, i.sidebarPosition, i.name, i.isFavorite],
            d = [i.name],
            u = [i.endedAt];

        function m(e) {
            return r.sortWith(c(e, r.identity))
        }
        const h = r.sort(r.descend(r.prop("endedAt"))),
            p = e => e.observeWithColumns(u).pipe(o.map(h));

        function g(e, t = []) {
            return s => s.observeWithColumns([...d, ...t]).pipe(o.map(function(e) {
                return r.sort(r.ascendLocale(r.prop("_name"), e.locale))
            }(e)))
        }
        const f = a.o.projects,
            b = n.Q.where(f.endedAt, null),
            y = n.Q.where(f.isTemplate, !0),
            v = n.Q.where(f.isTemplate, !1),
            w = n.Q.where(f.endedAt, n.Q.notEq(null)),
            k = n.Q.where(f.lastEventAt, n.Q.weakGt(n.Q.column(f.lastSeenEventAt)));

        function x(e) {
            return n.Q.or(n.Q.where(f.teamId, e), n.Q.where(f.sharedTeamId, e))
        }

        function j(e, t) {
            return n.Q.or(n.Q.and(n.Q.where(f.teamId, e), n.Q.where(f.sharedTeamId, t)), n.Q.and(n.Q.where(f.teamId, e), n.Q.where(f.sharedTeamId, t)))
        }

        function T(e, t, s, o) {
            var i;
            const c = r.unique(t.map((e => {
                    var t;
                    if (e.table === a.w.tasks) {
                        var n;
                        const t = e;
                        return t.isGranted ? s.id : null == (n = t._project) ? void 0 : n.id
                    }
                    return null == (t = e.project) ? void 0 : t.id
                }))),
                l = null == (i = null == o ? void 0 : o.withEnded) || i,
                d = e.get(a.w.projects).query(n.Q.where(a.o.id, n.Q.oneOf(c)));
            return (l ? d : d.extend(b)).observe()
        }

        function S(e, t, s, n, a) {
            return T(e, t, s, a).pipe(o.map(m(n)))
        }
        var P = s(1233);

        function _({
            project: e,
            isNew: t,
            isManager: s
        }) {
            return async n => {
                const a = void 0 === s ? await e.permissions.hasGrantedManagerAccess(n) : s;
                return {
                    member: n,
                    isNew: t,
                    isManager: a,
                    isInitialManager: a
                }
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Bd: () => u,
            H8: () => c,
            Uq: () => d,
            dq: () => l,
            p5: () => m
        });
        var n = s(0),
            a = s(1);
        const o = () => ({
                isSelecting: !1,
                ids: new Set([]),
                lastSelectedId: null,
                requestedToggleRangeToId: null
            }),
            r = e => new Set([...e]),
            i = (e, t) => {
                switch (t.type) {
                    case "reset":
                        return o();
                    case "enable":
                        return Object.assign({}, e, {
                            isSelecting: !0
                        });
                    case "select": {
                        const s = r(e.ids),
                            a = t.ids;
                        return a.forEach((e => {
                            s.size < 1e3 && s.add(e)
                        })), {
                            ids: s,
                            isSelecting: !0,
                            lastSelectedId: n.FP.last(a) || null,
                            requestedToggleRangeToId: null
                        }
                    }
                    case "deselect": {
                        const s = r(e.ids);
                        return t.ids.forEach((e => {
                            s.delete(e)
                        })), {
                            ids: s,
                            isSelecting: !0,
                            lastSelectedId: null,
                            requestedToggleRangeToId: null
                        }
                    }
                    case "toggle": {
                        const s = r(e.ids),
                            {
                                id: n
                            } = t;
                        return s.has(n) ? s.delete(n) : s.size < 1e3 && s.add(n), {
                            ids: s,
                            isSelecting: !0,
                            lastSelectedId: n,
                            requestedToggleRangeToId: null
                        }
                    }
                    case "request_toggle_range":
                        return Object.assign({}, e, {
                            requestedToggleRangeToId: t.toId
                        });
                    default:
                        return e
                }
            },
            c = e => n.Hooks.useReducerResettable(i, o(), [e]),
            l = n.React.createContext(void 0);
        l.displayName = "SelectionStateContext";
        const d = () => {
            const e = n.React.useContext(l);
            return invariant(e, "SelectionStateContext is empty!"), e
        };

        function u() {
            const {
                isLimitedAccount: e
            } = n.Hooks.useIdentity(), t = d();
            return n => {
                if (e) return null;
                const o = s(1303).Z;
                return (0, a.jsx)(o, {
                    selectionStateProps: t,
                    onPress: n
                })
            }
        }

        function m(e, t) {
            return t.every((t => e.ids.has(t)))
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(18),
            o = s(91),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            member: e || n.Rx.of(null)
        }))), n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            preferredName: e ? e.preferredName : n.Rx.of(null),
            isAwayOnVacation: e ? e.isAwayOnVacation : n.Rx.of(!1)
        }))))((e => {
            const {
                member: t,
                preferredName: s,
                isUpper: i,
                allowFontScaling: c,
                shouldRenderYou: l,
                highlightRanges: d,
                isAwayOnVacation: u
            } = e, m = n.Hooks.useIntl(), h = n.Styling.createMemberName(s, m, {
                isAwayOnVacation: u,
                shouldRenderYou: l
            }), p = i ? n.FP.toUpper(h) : h;
            let g = p;
            return d && t && h === s && (g = (0, r.jsx)(o.Z, {
                text: p,
                ranges: h === t.alias ? d.alias : d.name
            })), (0, r.jsx)(a.default, {
                allowFontScaling: c,
                className: e.className,
                style: e.style,
                children: g
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(0), s(2), s(3);
        const n = s(441);
        var a = s(1);
        const o = e => {
            const {
                children: t,
                contentContainerStyle: s,
                scrollRef: o,
                onScroll: r,
                isAbsoluteFilled: i
            } = e, c = "string" == typeof s ? {
                className: s
            } : {
                style: s
            };
            return (0, a.jsx)("div", {
                className: n.root + (i ? " " + n.abosluteFilled : "") + " " + (e.className || ""),
                style: e.style,
                onScroll: r,
                ref: o,
                children: (0, a.jsx)("div", Object.assign({}, c, {
                    children: t
                }))
            })
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            MF: () => d.MF,
            JS: () => o.JS,
            De: () => d.De,
            og: () => m.og,
            US: () => o.US,
            rZ: () => m.rZ,
            i0: () => m.i0,
            NM: () => m.NM,
            SM: () => m.SM,
            Hd: () => m.Hd,
            R5: () => m.R5,
            Jp: () => m.Jp,
            _k: () => m._k,
            xw: () => m.xw,
            LB: () => u,
            xn: () => m.xn,
            hp: () => i,
            pQ: () => l.p
        });
        var n = s(0),
            a = (s(21), s(37)),
            o = s(309);
        const r = {
                filterName: "",
                filterProject: void 0,
                filterProjects: void 0,
                filterSection: void 0,
                filterResponsibles: void 0,
                filterTags: void 0,
                filterDueDateRelative: !1,
                filterDueDateOverdue: !1,
                filterDueDate: void 0,
                filterDueDateStart: void 0,
                filterDueDateEnd: void 0,
                filterTimeNeeded: void 0,
                filterPriority: void 0,
                filterGroups: void 0,
                filterIsShared: void 0,
                sort: null,
                groupBy: null,
                disabledOptions: []
            },
            i = e => n.Hocs.compose(n.Hocs.withServices, n.Hocs.withHooks((t => {
                const {
                    viewId: s,
                    initialState: n
                } = e(t);
                return {
                    __filterViewId: s,
                    __filterInitialState: Object.assign({}, r, n)
                }
            })), n.Hocs.withObservables(["__filterViewId"], (({
                services: e,
                __filterViewId: t
            }) => ({
                __filterSavedState: n.Rx.from(e.localStorage.get(a.d.filterSettings)).pipe(n.Rx.map((e => {
                    const s = null == e ? void 0 : e[t];
                    return s ? function(e) {
                        const t = c(e),
                            {
                                filterDueDate: s,
                                filterDueDateStart: n,
                                filterDueDateEnd: a
                            } = e,
                            r = !!e.filterDueDateRelative;
                        return Object.assign({}, t, {
                            filterDueDate: (0, o.uI)(s, r),
                            filterDueDateStart: (0, o.uI)(n),
                            filterDueDateEnd: (0, o.uI)(a)
                        })
                    }(s) : null
                })))
            }))), n.Hocs.withHooks((e => {
                const {
                    __filterSavedState: t,
                    __filterViewId: s,
                    __filterInitialState: r,
                    services: i
                } = e, [l, d] = n.Hooks.useStateResettable(Object.assign({}, r, t), [s]);
                return {
                    filterState: l,
                    setFilterState: async e => {
                        const t = function(e, t) {
                                const s = {};
                                return Object.keys(e).forEach((n => {
                                    e[n] !== t[n] && (s[n] = e[n])
                                })), s
                            }(e, r),
                            l = await i.localStorage.get(a.d.filterSettings),
                            u = Object.assign({}, l);
                        0 < Object.keys(t).length ? u[s] = function(e) {
                            const t = c(e),
                                {
                                    filterDueDateRelative: s,
                                    filterDueDate: n,
                                    filterDueDateStart: a,
                                    filterDueDateEnd: r
                                } = e;
                            return Object.assign({}, t, {
                                filterDueDate: (0, o.L0)(n, !!s),
                                filterDueDateStart: (0, o.L0)(a),
                                filterDueDateEnd: (0, o.L0)(r)
                            })
                        }(t) : delete u[s], await i.localStorage.set(a.d.filterSettings, u), n.ReactUtils.animateNext(), d(e)
                    }
                }
            })), n.Hocs.withObservables(["filterState"], (({
                filterState: e
            }) => ({
                filterState: e.filterDueDateRelative ? n.Rx.nowAndEveryDay().pipe(n.Rx.map((() => Object.assign({}, e)))) : n.Rx.of(e)
            })))),
            c = n.FP.omit(["disabledOptions"]);
        var l = s(1530),
            d = s(494);
        const u = ({
            filterName: e,
            filterProject: t,
            filterProjects: s,
            filterSection: n,
            filterResponsibles: a,
            filterTags: r,
            filterDueDateOverdue: i,
            filterDueDateRelative: c,
            filterDueDate: l,
            filterDueDateStart: d,
            filterDueDateEnd: u,
            filterTimeNeeded: m,
            filterPriority: h,
            filterGroups: p,
            filterIsShared: g
        }) => {
            const f = (0, o.US)(l, !!c);
            return {
                teamId: void 0,
                projectGroupIds: p || void 0,
                recurrence: void 0,
                projectId: t || void 0,
                projectIds: s || void 0,
                projectSectionId: null === n ? null : n,
                responsibleIds: null === a ? null : a,
                tagIds: r || void 0,
                dueDateStart: d || f,
                dueDateEnd: u || f,
                isOverdue: !!i,
                inexactDueDate: !0,
                hasTimeNeeded: null != m ? m : void 0,
                isPriority: h,
                isShared: g,
                nameMatches: e || void 0
            }
        };
        var m = s(1531)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(113);
        s(2), s(3);
        const o = s(434);
        var r = s(1);
        const i = n.ReactUtils.lazy((() => s(918))),
            c = {
                top: 0,
                left: 0,
                position: "top",
                arrowOffset: "50%"
            },
            l = (e, t, s) => {
                const {
                    top: n,
                    left: a,
                    height: o,
                    width: r
                } = e.getBoundingClientRect(), {
                    width: i,
                    height: c
                } = t.getBoundingClientRect(), l = t.ownerDocument.defaultView, {
                    innerHeight: d,
                    innerWidth: u
                } = l, m = () => {
                    const e = n + o / 2,
                        t = Math.max(8, e - c / 2),
                        s = a + r + 8,
                        l = e - t - 3 + "px";
                    return s + i > u ? {
                        left: a - i - 8,
                        top: t,
                        position: "left",
                        arrowOffset: l
                    } : {
                        left: s,
                        top: t,
                        position: "right",
                        arrowOffset: l
                    }
                };
                return "vertical" === s ? (() => {
                    const e = a + r / 2,
                        t = Math.max(8, e - i / 2),
                        s = n + o,
                        l = e - t - 3 + "px";
                    return t + i > u || 0 > t - i ? m() : s + c > d ? {
                        left: t,
                        top: n - c,
                        position: "bottom",
                        arrowOffset: l
                    } : {
                        left: t,
                        top: s,
                        position: "top",
                        arrowOffset: l
                    }
                })() : m()
            },
            d = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["renderLabel"], (({
                renderLabel: e
            }) => ({
                label: "string" == typeof e ? n.Rx.of(e) : e
            }))))((e => {
                const {
                    label: t,
                    triggerRef: s,
                    keyboardShortcutID: d,
                    arrowPosition: u,
                    onMouseEnter: m,
                    onMouseLeave: h
                } = e, [p, g] = n.React.useState(c), f = n.Hooks.useIsMounted(), b = n.React.useCallback((e => {
                    const {
                        current: t
                    } = s;
                    f.current && g(t && e ? l(t, e, u) : c)
                }), [f, s, u]), y = n.Hooks.useServices(), v = d ? y.shortcuts.findActionById(d) : null;
                return t.length ? (0, r.jsx)(a.GR, {
                    name: "Tooltip",
                    children: (0, r.jsx)("div", {
                        className: o.tooltip + ("bottom" === p.position ? " " + o.bottomArrow : "") + ("left" === p.position ? " " + o.leftArrow : "") + ("right" === p.position ? " " + o.rightArrow : ""),
                        style: {
                            top: p.top,
                            left: p.left,
                            "--arrow-offset": p.arrowOffset
                        },
                        onMouseEnter: m,
                        onMouseLeave: h,
                        ref: b,
                        children: (0, r.jsxs)("div", {
                            className: o.labelWrapper,
                            children: [(0, r.jsx)("span", {
                                className: o.label,
                                children: t
                            }), v ? (0, r.jsx)(i, {
                                item: v
                            }) : null]
                        })
                    })
                }) : null
            })),
            u = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    children: t,
                    renderLabel: s,
                    timeToActivite: a = 250,
                    keyboardShortcutID: o,
                    arrowPosition: i = "vertical"
                } = e, c = n.Hooks.useIsMounted(), l = n.React.Children.only(t), u = l.ref, m = n.React.useRef(null), h = null != u ? u : m, [p, g] = n.React.useState(!1), f = n.React.useRef(null), b = n.React.useCallback((() => {
                    f.current && clearTimeout(f.current), f.current = setTimeout((() => {
                        c.current && g(!0)
                    }), a)
                }), [c, a]), y = n.React.useCallback((() => {
                    clearTimeout(f.current), c.current && g(!1)
                }), [c]);
                return n.React.useEffect((() => {
                    const e = h.current,
                        t = {
                            passive: !0
                        };
                    return null == e || e.addEventListener("mouseenter", b, t), null == e || e.addEventListener("mouseleave", y, t), null == e || e.addEventListener("mousewheel", y, t), () => {
                        null == e || e.removeEventListener("mouseenter", b, t), null == e || e.removeEventListener("mouseleave", y, t), null == e || e.removeEventListener("mousewheel", y, t)
                    }
                }), [b, y, h]), n.React.useEffect((() => () => {
                    f.current && clearTimeout(f.current), g(!1)
                }), []), (0, r.jsxs)(r.Fragment, {
                    children: [n.React.cloneElement(l, {
                        ref: h
                    }), p ? (0, r.jsx)(d, {
                        onMouseEnter: y,
                        arrowPosition: i,
                        triggerRef: h,
                        renderLabel: s,
                        keyboardShortcutID: o
                    }) : null]
                })
            }))
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => D
        });
        var n = s(0),
            a = s(113),
            o = s(35),
            r = s(86),
            i = s(482),
            c = (s(11), s(167)),
            l = s(1550),
            d = s(22),
            u = s(161),
            m = s(44),
            h = s(66),
            p = s(88),
            g = s(70);
        const f = e => [e - 1, e + 1],
            b = (e, t) => {
                return n.FP.piped(t, n.FP.findIndex(n.FP.identical(e)), f, n.FP.map(n.FP.ifElse((s = t, e => 0 > e || e >= s.length), n.FP.always(null), (e => t => n.FP.nth(t, e))(t))));
                var s
            };

        function y(e, t) {
            const s = n.Hooks.useServices(),
                {
                    currentTeam: a
                } = n.Hooks.useIdentity(),
                o = n.React.useMemo((() => {
                    const [s, n] = b(e, t);
                    return {
                        previous: s,
                        next: n
                    }
                }), [e, t]);
            return n.React.useEffect((() => {
                    s.uiState.forTeam(a).adjacentTasks.next(o)
                }), [o, a, s.uiState]),
                function(e, t) {
                    const s = n.Hooks.useServices(),
                        {
                            previous: a,
                            next: o
                        } = e,
                        r = w(a || t[t.length - 1]),
                        i = w(o || t[0]);
                    n.Hooks.useShortcutProviders([{
                        id: "task.next",
                        action: () => {
                            i && s.router.goTo(i)
                        }
                    }, {
                        id: "task.previous",
                        action: () => {
                            r && s.router.goTo(r)
                        }
                    }])
                }(o, t), o
        }
        const v = /\/tasks\/\w+$/g;

        function w(e) {
            const t = n.Hooks.useLocation().pathname.replace(v, "");
            return e ? {
                path: t + "/tasks/" + e.id
            } : null
        }
        var k, x = s(1541),
            j = s(1336),
            T = s(48),
            S = s(1);
        const P = s(42).wx,
            _ = s(105).wx,
            C = s(158).wx,
            R = n.ReactUtils.lazy((() => s(492))),
            A = n.ReactUtils.lazy((() => s(479))),
            I = n.ReactUtils.lazy((() => s(1551))),
            N = n.ReactUtils.lazy((() => s(733))),
            E = n.FP.pipe(n.FP.split("/tasks/"), n.FP.last),
            O = e => t => n.FP.piped(t, E, (e => t => n.FP.find((e => e.id === t), e))(e)),
            M = e => {
                const {
                    routeToTaskDetails: t
                } = e;
                if (n.Hooks.useDesktopLayout()) {
                    const {
                        Route: e
                    } = s(80);
                    return (0, S.jsx)(e, {
                        path: t,
                        component: I
                    })
                }
                return null
            },
            D = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isTaskListCollapsed: e.layout.areTaskDetailsMaximized
            }))), n.Hocs.withObservables(["activeTasksCounter"], (({
                activeTasksCounter: e
            }) => ({
                activeTasks: e
            }))), n.Hocs.withObservables(["sortedTasks"], (({
                services: e,
                sortedTasks: t
            }) => ({
                currentTask: e.history.currentPath.pipe(n.Rx.map(O(t)))
            }))))((e => {
                var t;
                const {
                    rootRecord: s,
                    children: f,
                    title: b,
                    color: v,
                    taskDetailsProps: w,
                    taskDetailsProps: {
                        routeToTaskDetails: I,
                        areTaskDetailsOpen: E
                    },
                    activeTasks: O,
                    openViewMenu: D,
                    menuTarget: H,
                    renderExtraMasterButtons: F,
                    leftIcon: Z,
                    onDragEnd: L,
                    masterPlusIcon: B = "plus",
                    displayMasterPlusButtonIcon: z = !0,
                    isEnded: U,
                    masterPlusLabel: W,
                    currentTask: G,
                    sortedTasks: V,
                    newTaskFormVisibility: q,
                    project: Q,
                    newTaskFormProps: Y,
                    filterState: J,
                    setFilterState: K,
                    isTaskListCollapsed: $,
                    masterPlusButtonStyle: X = "normal",
                    underNavbar: ee,
                    masterPlusRef: te,
                    menuBadge: se
                } = e, ne = n.Hooks.useIntl(), ae = n.Hooks.useServices(), {
                    currentMember: oe,
                    isLimitedAccount: re,
                    currentTeam: ie
                } = n.Hooks.useIdentity(), ce = n.Hooks.useLayoutBottomInset(), le = (n.Hooks.useDesktopLayout(), n.Hooks.useModalState()), de = n.Hooks.useRemindExpired(n.FP.noop), {
                    isNewTaskFormShown: ue,
                    onNewTaskFormShow: me
                } = q || {}, {
                    setPositionGroup: he,
                    onSubmit: pe
                } = Y || {}, [ge, fe] = (0, h.H8)(s), be = n.React.useMemo((() => [ge, fe]), [fe, ge]), ye = (0, h.p5)(ge, n.FP.pluckIds(V)), {
                    isSelecting: ve
                } = ge, we = !ve && (null != (t = e.displayMasterPlusButton) ? t : q && !ue), ke = Boolean(F) && !ve, xe = Boolean(F) && !ue;
                n.React.useEffect((() => {
                    U && ve && fe({
                        type: "reset"
                    })
                }), [U, ve, fe]);
                const je = (0, m.aO)(me, w),
                    Te = de((() => {
                        je(), null == e.onMasterPlusPress || e.onMasterPlusPress()
                    }));
                y(G, V);
                const Se = n.Hooks.useLocation();
                n.React.useEffect((() => {
                        var e;
                        null != (e = Se.state) && e.shouldOpenNewTask && (null == me || me())
                    }), [Se, me]), n.Hooks.useShortcutProviders([{
                        id: "list.new_task",
                        action: Te
                    }]),
                    function(e, t, s, {
                        taskDetailsId: a,
                        areTaskDetailsOpen: o,
                        dismissTaskDetails: r
                    }) {
                        n.React.useEffect((() => {
                            const {
                                requestedToggleRangeToId: o,
                                lastSelectedId: r
                            } = e;
                            if (o) {
                                const e = s.findIndex((e => e.id === (r || a))),
                                    i = s.findIndex((e => e.id === o));
                                if (-1 < i) {
                                    const a = -1 < e ? e : 0,
                                        o = s.slice(Math.min(a, i), Math.max(a, i) + 1);
                                    t({
                                        type: "select",
                                        ids: n.FP.pluckIds(o)
                                    })
                                }
                            }
                        })), n.React.useEffect((() => {
                            o && e.isSelecting && (t({
                                type: "select",
                                ids: [a]
                            }), r())
                        }))
                    }(ge, fe, V, w);
                n.Hooks.useDebugRenderCount();
                n.Hooks.useDocumentTitle(b);
                const [Pe, _e] = n.React.useState(!1), Ce = n.React.useCallback((() => {
                    _e(!0)
                }), []), Re = n.React.useCallback((() => {
                    _e(!1)
                }), []), Ae = n.Hooks.useModalState(), Ie = async () => {
                    Q && await ae.payments.invokeActionOrProposeUpgrade({
                        name: "create-section",
                        project: Q
                    }, (() => {
                        Ae.open()
                    })), Re()
                }, Ne = n.React.useCallback((e => {
                    he && me && (he({
                        position: "top",
                        section: e
                    }), me())
                }), [he, me]), Ee = n.Hooks.useModalState(), Oe = n.Hooks.useModalState(), Me = async e => {
                    if (!e) return;
                    const {
                        files: t,
                        error: s
                    } = await (0, p.ox)(e, ie);
                    "file_size_exceeded" === s && Oe.open(), Re(), (async e => {
                        if (pe) {
                            const t = e[0];
                            t && (await pe({
                                name: t.name,
                                comment: (0, o.mL)({
                                    body: ne.g("gY", {
                                        attachmentCount: e.length
                                    }),
                                    inputFiles: e
                                }, ne)
                            }, !1), ae.uploader.performUpload(oe))
                        }
                    })(t.map((e => (0, p.M8)({
                        source: "local",
                        file: e
                    }))))
                }, De = e => {
                    ae.nativeScene.pickFile(Me, {
                        type: e || "files",
                        multiple: !0,
                        mimeType: "*/*"
                    })
                }, He = n.Hooks.useHasDroppableFiles() && !!pe, Fe = n.Hooks.useDroppedFiles(de((e => {
                    Me(e)
                }))), Ze = (0, S.jsx)("div", {
                    ref: le.target,
                    children: (0, S.jsx)(d.default, {
                        name: "¯",
                        accessibilityLabel: ne.f.Im,
                        color: n.Styling.theme.isLight() ? v && "white" !== v ? "white" : "gray6" : v || "onBackground3",
                        onPress: le.open,
                        withHover: !0,
                        androidRippleRadius: 20
                    })
                }), Le = !re && !!J && !!K && (0, g.MF)(J), Be = n.Styling.theme.isLight() && v, ze = (0, T.h$)(), Ue = () => {
                    null == ze || ze.showForList()
                };
                return (0, S.jsx)("div", {
                    className: j.Z.root,
                    children: (0, S.jsxs)(h.dq.Provider, {
                        value: be,
                        children: [(0, S.jsxs)("div", {
                            className: j.Z.left + ($ ? " " + j.Z.leftCollapsed : ""),
                            children: [(0, S.jsx)(i.Z, {
                                title: b,
                                isEnded: U,
                                onLeftIconPress: n.ReactUtils.dismissKeyboard,
                                color: v,
                                extraText: O ? "message" === X ? ne.g("ra", {
                                    taskCount: O
                                }) : ne.g("F_", {
                                    taskCount: O
                                }) : "",
                                onExtraTextPress: Ue,
                                onCountersPress: Ue,
                                menuTarget: H,
                                menuBadge: se,
                                onTitlePress: re ? void 0 : D,
                                leftIcon: Z,
                                right: !re && J && K ? Ze : void 0,
                                left: ge.isSelecting && V.length ? (0, S.jsx)(u.Z, {
                                    isChecked: ye,
                                    isLarge: !0,
                                    color: Be ? "white" : v || "purple",
                                    inactiveColor: Be ? "white" : void 0,
                                    onPress: () => {
                                        const e = n.FP.pluckIds(V);
                                        fe(ye ? {
                                            type: "deselect",
                                            ids: e
                                        } : {
                                            type: "select",
                                            ids: e
                                        })
                                    },
                                    style: {
                                        marginLeft: -4,
                                        height: 28
                                    }
                                }) : null
                            }), ee, Le && J && K ? (0, S.jsx)(R, {
                                filterState: J,
                                setFilterState: K,
                                color: v
                            }) : null, (0, S.jsx)(r.Z, {
                                onDragEnd: L,
                                children: (0, S.jsx)(x.Z, {
                                    areFiltersActive: Le,
                                    children: f
                                })
                            }), He && !ue ? (0, S.jsx)(A, {
                                onDrop: Fe,
                                header: ne.f.eL,
                                description: ne.f.HZ
                            }) : null, !re && le.isOpen && J && K ? (0, S.jsx)(C.FiltersMenu, {
                                bundle$close: le.close,
                                onClose: le.close,
                                target: le.target,
                                isDesktopModal: !1,
                                hasArrow: !0,
                                placement: "bottom",
                                filterState: J,
                                setFilterState: K,
                                tasks: V
                            }) : null, null, re || !(we || xe || ve) || U || $ ? null : (0, S.jsxs)("div", {
                                className: j.Z.masterButtonContainer,
                                style: {
                                    bottom: 12 + ce
                                },
                                children: [we ? (0, S.jsx)(S.Fragment, {
                                    children: (0, S.jsxs)("div", {
                                        className: j.Z.masterPlusButtonActions,
                                        onMouseEnter: Ce,
                                        onMouseLeave: Re,
                                        children: [Q ? (0, S.jsx)(l.Z, {
                                            isMounted: Pe,
                                            timeout: ".25s",
                                            children: ({
                                                status: e
                                            }) => (0, S.jsx)(c.Z, {
                                                className: j.Z.masterPlusButton + ("entering" === e || "entered" === e ? " " + j.Z.masterPlusButtonVisible : "") + " " + j.Z.masterPlusButtonAnimated,
                                                style: {
                                                    transitionDelay: "entering" === e ? "100ms" : void 0
                                                },
                                                onPress: Ie,
                                                color: v,
                                                icon: "q",
                                                accessibilityLabel: ne.f.mt
                                            })
                                        }) : null, pe ? (0, S.jsx)(l.Z, {
                                            isMounted: Pe,
                                            timeout: ".25s",
                                            children: ({
                                                status: e
                                            }) => (0, S.jsx)(c.Z, {
                                                className: j.Z.masterPlusButton + ("entering" === e || "entered" === e ? " " + j.Z.masterPlusButtonVisible : "") + " " + j.Z.masterPlusButtonAnimated,
                                                style: {
                                                    transitionDelay: "leaving" === e ? "100ms" : void 0
                                                },
                                                onPress: de((() => {
                                                    De()
                                                })),
                                                color: v,
                                                icon: "=",
                                                accessibilityLabel: ne.f.ms
                                            })
                                        }) : null, (0, S.jsx)(c.Z, {
                                            className: j.Z.masterPlusButton,
                                            style: {
                                                quickAdd: {
                                                    borderRadius: 20
                                                },
                                                message: {
                                                    borderRadius: 56,
                                                    borderBottomLeftRadius: 10
                                                }
                                            } [X],
                                            onPress: () => {
                                                Re(), Te()
                                            },
                                            onLongPress: () => {},
                                            color: "quickAdd" === X ? "singleTasks" : v,
                                            contentRef: te,
                                            icon: z ? B : void 0,
                                            accessibilityLabel: {
                                                quickAdd: ne.f.Ce,
                                                message: ne.f.m4,
                                                normal: ne.f.mF
                                            } [X],
                                            keyboardShortcutID: "quickAdd" === X ? "global.quickAdd" : "list.new_task",
                                            testId: n.Misc.testIds.taskList_masterPlusButton,
                                            children: W
                                        })]
                                    })
                                }) : null, F && ke ? F() : null, ve ? (0, S.jsx)(C.SelectModeButtons, {
                                    bundle$close: () => fe({
                                        type: "reset"
                                    }),
                                    color: v,
                                    visibleTasks: V
                                }) : null]
                            }), null]
                        }), Ae.isOpen && Q ? (0, S.jsx)(_.Section, {
                            bundle$close: Ae.close,
                            project: Q,
                            onClose: Ae.close,
                            onAddSection: Ne
                        }) : null, Ee.isOpen ? (0, S.jsx)(P.FileType, {
                            bundle$close: Ee.close,
                            onSelect: De,
                            onClose: Ee.close
                        }) : null, Oe.isOpen ? (0, S.jsx)(N, {
                            onClose: Oe.close,
                            team: ie
                        }) : null, k || (k = (0, S.jsx)(a.$J, {
                            name: "SyncIndicator"
                        })), (0, S.jsx)(M, {
                            routeToTaskDetails: I
                        })]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0);
        const a = ({
            children: e
        }) => e;
        var o = s(1);
        const r = n.ReactUtils.lazy((() => s(1365))),
            i = n.ReactUtils.lazy((() => s(570))),
            c = n.Hocs.compose(n.React.memo)((e => {
                const {
                    taskGroups: t,
                    newTaskFormProps: s,
                    onSetEndedTasksState: n,
                    renderSectionHeader: c,
                    renderSectionItemsContainer: l,
                    renderListHeader: d,
                    rootRecord: u,
                    viewColor: m,
                    getSectionHeaderLength: h,
                    isProjectVisible: p,
                    isSectionVisible: g,
                    renderListFooter: f,
                    isDndEnabled: b,
                    hasMasterPlus: y,
                    showReviewIcon: v,
                    shouldHighlightUnreadComments: w,
                    markAsType: k,
                    onMarkAsSwipe: x,
                    withSwipeLeft: j,
                    showEmptyState: T = !0,
                    emptyListTitle: S,
                    emptyListMessage: P,
                    emptyListButtonText: _,
                    emptyListOnPress: C,
                    ContentWrapperWeb: R,
                    extraDistanceFromScreenTop: A,
                    filterState: I,
                    listHandleRef: N
                } = e, E = 1 < t.length || t[0] && t[0].items.length || !!k && t.length, O = s && s.isShown;
                return (0, o.jsx)(a, {
                    propTriggeringTransition: t,
                    children: !T || E || O ? (0, o.jsx)(i, {
                        taskGroups: t,
                        filterState: I,
                        onSetEndedTasksState: n,
                        newTaskFormProps: s,
                        renderSectionHeader: c,
                        renderSectionItemsContainer: l,
                        renderListHeader: d,
                        rootRecord: u,
                        viewColor: m,
                        getSectionHeaderLength: h,
                        isProjectVisible: p,
                        isSectionVisible: g,
                        renderListFooter: f,
                        isDndEnabled: b,
                        hasMasterPlus: y,
                        showReviewIcon: v,
                        shouldHighlightUnreadComments: w,
                        markAsType: k,
                        onMarkAsSwipe: x,
                        withSwipeLeft: j,
                        ContentWrapperWeb: R,
                        extraDistanceFromScreenTop: A,
                        hasTasksOrSections: !!E,
                        listHandleRef: N
                    }) : (0, o.jsx)(r, {
                        title: S,
                        message: P,
                        buttonText: _,
                        onPress: C,
                        color: m,
                        rootRecord: u,
                        renderListHeader: d
                    })
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(20),
            o = s(875);
        s(2), s(3);
        const r = s(548);
        var i = s(1);
        const c = n.FP.omit(["isActive", "onChange"]),
            l = ({
                isActive: e,
                isDisabled: t,
                onChange: s,
                colorActive: n,
                colorInactive: a,
                badge: c
            }) => {
                var l;
                return () => "premium" !== (null == c ? void 0 : c.type) ? (0, i.jsx)("div", {
                    className: r.switchContainer,
                    children: l || (l = (0, i.jsx)(o.Z, {
                        onChange: s,
                        isActive: e,
                        isDisabled: t,
                        colorActive: n,
                        colorInactive: a
                    }))
                }) : null
            },
            d = n.Hocs.compose(n.Hocs.memo)((e => n.React.createElement(a.Z, Object.assign({}, c(e), {
                renderRight: l(e),
                onPress: e.onChange
            }))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Bj: () => p,
            ES: () => v,
            Fv: () => k,
            Ic: () => w,
            Ne: () => y,
            im: () => h,
            lM: () => m,
            lt: () => g,
            nd: () => u,
            zK: () => b
        });
        var n = s(5),
            a = s(4),
            o = s(41),
            r = s(281),
            i = s(1450),
            c = s(279),
            l = s(1451),
            d = s(21);
        const u = (e, t) => e.at && t.at ? (0, d.dateTimeEquals)(e.at, t.at) : e.dueDateOffset === t.dueDateOffset,
            m = (e, t) => {
                if (e.at) return e.at.local;
                t || n.logError(n.PROD_CONSOLE_REASON.SAFE_LITERAL, "Task has relative reminder but no due date");
                const {
                    dueDateOffset: s
                } = e, a = t ? t.local : (0, o.Z)(new Date);
                return new Date(a.getTime() + s)
            },
            h = -6e4,
            p = 60 * h,
            g = 24 * p,
            f = ({
                offsetedDate: e,
                intl: t,
                format: s = "short"
            }) => {
                const n = new Date,
                    a = (0, r.Z)(e, n);
                if (0 < a) return "short" === s ? t.g("Kg", {
                    value: a
                }) : t.g("Kd", {
                    value: a
                });
                const o = (0, i.Z)(e, n);
                if (0 < o) return "short" === s ? t.g("Kh", {
                    value: o
                }) : t.g("Ke", {
                    value: o
                });
                const l = (0, c.Z)(e, n);
                return 0 < l ? "short" === s ? t.g("Ki", {
                    value: l
                }) : t.g("Kf", {
                    value: l
                }) : ""
            },
            b = ({
                reminderDate: e,
                intl: t,
                format: s = "long"
            }) => {
                if (e.at) return (0, d.formatDateTimeRelative)({
                    dateTime: e.at,
                    intl: t,
                    format: s
                });
                const n = new Date;
                if (0 === e.dueDateOffset) return t.f.y4;
                const a = (0, l.Z)(n, e.dueDateOffset || 0);
                return "long" === s ? t.g("y3", {
                    formattedTime: f({
                        offsetedDate: a,
                        intl: t,
                        format: "long"
                    })
                }) : t.g("y5", {
                    formattedTime: f({
                        offsetedDate: a,
                        intl: t,
                        format: "short"
                    })
                })
            },
            y = ({
                taskReminders: e,
                taskHasDueDate: t,
                intl: s,
                format: n = "short"
            }) => {
                const a = e.filter((e => t || e.isAbsolute || !1)),
                    o = a.length;
                return 0 !== o ? b({
                    reminderDate: a[0].remindAt,
                    intl: s,
                    format: n
                }) + (1 < o ? ", +" + (o - 1) : "") : ""
            },
            v = (e, t) => t.some((t => u(t, e))),
            w = (e, t) => e.at && !e.at.isAllDay ? t(e.at.local, {
                timeZone: (0, d.getTimeZone)()
            }) : null;

        function k(e, t) {
            return a.sort(a.ascend((e => m(e.remindAt, t))), e)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(487),
            o = s(242),
            r = s(40),
            i = s(359);
        s(2), s(3);
        const c = s(533);
        var l = s(1);
        const d = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withPersonalUI, (e => n.Hocs.memo(e, ((e, t) => !Object.keys(e).some((s => "currentTeam" !== s && "currentMember" !== s && e[s] !== t[s]))))), n.Hocs.withObservables(["linkTo"], (({
            linkTo: e,
            services: t
        }) => ({
            isActive: e ? t.history.matchesPath(e) : n.Rx.of(!1)
        }))))((e => {
            const {
                title: t,
                formattedTitle: s = t,
                counter: d,
                linkTo: u,
                icon: m,
                statusIcon: h,
                statusIconColor: p = "onBackground3",
                isEnded: g,
                testId: f,
                description: b,
                hasHairline: y,
                onPressExtraParam: v,
                isFavorite: w,
                isFollowed: k,
                showFavFollowIcon: x,
                isEnabledOnProduction: j = !0,
                isActive: T,
                shouldRenderPersonalUI: S,
                children: P,
                textColor: _,
                hasUnreadDot: C,
                badge: R,
                onLongPress: A
            } = e, I = e.onPress ? (t, s) => {
                null == e.onPress || e.onPress(t, s), null == R || null == R.dismiss || R.dismiss()
            } : void 0, N = (0, l.jsxs)(i.fC, {
                webComponent: "div",
                title: t,
                onPress: I,
                onPressExtraParam: v,
                onLongPress: A,
                disableLongPressHaptics: !0,
                testId: f,
                children: [(0, l.jsx)(a.Z, {
                    isEnabledOnProduction: j
                }), (0, l.jsxs)(i.VY, {
                    isActive: T,
                    hasHairline: !!y,
                    hasDot: !!C,
                    hasDescription: !!b,
                    children: [C ? (0, l.jsx)("div", {
                        className: c.unreadDotContainer,
                        children: (0, l.jsx)("div", {
                            className: c.unreadDot
                        })
                    }) : null, (0, l.jsx)(i.iJ, {
                        children: Array.isArray(m) ? (0, l.jsx)(r.default, {
                            layers: m
                        }) : (0, l.jsx)(i.JO, {
                            name: m,
                            color: e.iconColor || "onBackground3",
                            size: 22,
                            isActive: T,
                            isEnded: g
                        })
                    }), (0, l.jsxs)(i.lU, {
                        children: [(0, l.jsx)(i.c7, {
                            children: (0, l.jsx)(i.VG, {
                                isActive: T,
                                isEnded: g,
                                maxLines: 999,
                                style: _ ? {
                                    color: n.Styling.factoryColor(_)
                                } : void 0,
                                children: s
                            })
                        }), b ? (0, l.jsx)(i.dk, {
                            children: b
                        }) : null]
                    }), R ? (0, l.jsx)(o.Z, {
                        badge: R
                    }) : null, h ? (0, l.jsx)(i.zx, {
                        children: (0, l.jsx)(i.JO, {
                            name: h,
                            color: p,
                            size: 18
                        })
                    }) : null, (w || k && !S) && x ? (0, l.jsx)(i.zx, {
                        children: (0, l.jsx)(i.JO, {
                            name: w ? "Á" : "±",
                            color: w ? "red" : "blue",
                            size: 18,
                            isActive: T,
                            isEnded: g
                        })
                    }) : null, d ? (0, l.jsx)(i.Br, {
                        source: d,
                        isEnded: g
                    }) : null, P]
                })]
            });
            return u ? (0, l.jsx)(i.rU, {
                to: u,
                force: !0,
                children: N
            }) : N
        }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            a: () => n
        });
        s(36);
        const n = Object.freeze({
            Incoming: {
                type: "incoming",
                color: "incoming",
                icon: "H",
                isDotStyle: !0
            },
            Activity: {
                type: "activity",
                color: "activity",
                icon: "H",
                isDotStyle: !0
            },
            New: {
                type: "new",
                color: "activity",
                icon: "ŏ",
                isDotStyle: !1
            },
            Premium: {
                type: "premium",
                color: "yellow",
                icon: "r",
                isDotStyle: !1
            }
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(128),
            o = s(1);
        const r = e => {
            const {
                children: t,
                testId: s,
                force: r,
                isDisabled: i
            } = e, c = n.Hooks.useServices();
            if ("string" == typeof e.to) {
                const s = (0, a.Nm)(e.to);
                return (0, o.jsx)("a", {
                    href: s,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: t
                })
            }
            const l = Object.assign({}, e.to, {
                path: (0, a.Nm)(e.to.path)
            });
            return (0, o.jsx)("a", {
                href: l.path,
                onClick: e => {
                    e.preventDefault(), i || c.router.goTo(l, void 0, r)
                },
                "data-testid": s,
                children: t
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Ej: () => r,
            T: () => c,
            ZP: () => d
        });
        s(9);
        var n = s(61),
            a = s(4);
        const o = (0, s(1).jsx)(n.Z, {
                id: "KG"
            }, "validation.email.message"),
            r = /(?:(?:[^<>\(\)\[\]\\.,;:\s@"]+(?:\.[^<>\(\)\[\]\\.,;:\s@"]+)*)|(?:".+"))@(?:(?:\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(?:(?:[a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))(\?(?:(?:subject|body)=[.*!()\w-%]+&?){1,2})?/,
            i = new RegExp("^" + r.source + "$"),
            c = e => (0, a.test)(i, e),
            l = (0, a.either)(a.isEmpty, c),
            d = e => ({
                error: o,
                isValid: l(e)
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(20),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                isShowingThePast: t,
                onPress: s,
                onPressExtraParam: r,
                label: i
            } = e, c = n.Hooks.useIntl();
            return (0, o.jsx)(a.Z, {
                icon: "Ť",
                label: i || (t ? c.f.hr : c.f.hs),
                onPress: s,
                onPressExtraParam: r
            })
        }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n = s(0),
            a = s(1456),
            o = s(250),
            r = s(4),
            i = s(50);
        const c = r.values(i.M),
            l = e => r.reduce(((e, t) => r.startsWith(t, e) ? r.replace(t, "", e) : e), e, c);
        var d = s(1);
        const u = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                children: t,
                onDragEnd: s
            } = e, r = n.Hooks.useServices(), i = n.React.useContext(o.w), c = n.React.useCallback((e => {
                s && s((e => {
                    const {
                        draggableId: t,
                        destination: s,
                        source: n
                    } = e;
                    return Object.assign({}, e, {
                        draggableId: l(t),
                        destination: s ? Object.assign({}, s, {
                            droppableId: l(s.droppableId)
                        }) : null,
                        source: Object.assign({}, n, {
                            droppableId: l(n.droppableId)
                        })
                    })
                })(e))
            }), [s]);
            return (0, d.jsx)(a.Z, {
                nonce: i,
                onDragEnd: c,
                window: r.scene.webWindow,
                children: t
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            markTaskAsReviewed: () => o,
            markTaskAsReviewedWithSnackbar: () => r,
            markTasksAsReviewedWithSnackbar: () => i
        });
        s(0);
        var n = s(168),
            a = s(1);
        const o = async (e, t, s) => {
            await e.uiState.forTeam(s).addJustReviewedTasks([t]), await t.do.markAsReviewed()
        }, r = async (e, t, s, n, a = !0) => {
            s.doesNeedReview && i({
                intl: t,
                services: e,
                team: n,
                tasks: [s],
                shouldMarkAsJustReviewed: a
            })
        };
        async function i({
            tasks: e,
            team: t,
            intl: s,
            services: o,
            shouldMarkAsJustReviewed: r = !0
        }) {
            o.native.haptics.success(), r ? o.uiState.forTeam(t).addJustReviewedTasks(e) : o.uiState.forTeam(t).removeJustReviewedTasks(e), await t.do.markTasksAsReviewed(e);
            const i = 1 === e.length ? s.g("Jj", {
                taskName: (0, a.jsx)(n.Z, {
                    task: e[0]
                })
            }) : s.g("Jk", {
                numberOfTasks: e.length
            });
            o.uiState.pushSnackbar({
                message: i,
                buttonColor: "incoming",
                onButtonPress: async () => {
                    await t.do.markTasksAsNotReviewed(e)
                },
                onHideSnackbar: async () => {
                    await t.do.clearTasksPreviousReviews(e)
                }
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            M8: () => a,
            zK: () => o,
            wD: () => u,
            up: () => c,
            ox: () => d
        });
        var n = s(5);
        s(474);

        function a(e) {
            const {
                file: t
            } = e;
            return {
                id: (0, n.randomId)(),
                name: i(t.name),
                size: t.size,
                content: e,
                version: null
            }
        }

        function o(e) {
            const {
                id: t,
                size: s,
                name: n
            } = e, a = e.asExternalAttachment, o = a ? {
                source: "external",
                file: a
            } : {
                source: "local",
                file: null
            };
            return {
                id: t,
                name: i(n),
                size: s,
                content: o,
                version: e
            }
        }
        const r = new RegExp("‮", "gu");

        function i(e) {
            return e.replace(r, "")
        }

        function c(e) {
            const t = [],
                s = [];
            return e.forEach((e => {
                e.version ? s.push(e) : t.push(e)
            })), {
                pending: t,
                uploaded: s
            }
        }
        var l = s(4);
        async function d(e, t) {
            const s = (await async function(e) {
                return (await (0, l.allPromises)((async e => {
                    try {
                        const t = e.slice(0, 1);
                        return await t.text(), e
                    } catch (e) {
                        return console.error("Could not attach file"), (0, n.logError)("diagnostic error", e), null
                    }
                }), e)).filter(Boolean).filter((e => 0 < e.size))
            }(e)).filter((e => e.size < t.limits.maxAttachmentSize));
            return {
                files: s,
                error: s.length < e.length ? "file_size_exceeded" : null
            }
        }
        async function u(e, t) {
            const s = await e.attachments.fetch(),
                n = await (0, l.allPromises)((e => e.versions.fetch()), s).then((e => e.flat())),
                a = c(t).pending,
                o = (0, l.pluckIds)(t),
                r = n.filter((e => !o.includes(e.id))),
                i = s.filter((e => {
                    const t = r.some((t => t.attachment.id === e.id)),
                        s = n.filter((t => t.attachment.id === e.id)).length;
                    return t && 1 === s || 0 === s
                }));
            return {
                newAttachmentVersions: a,
                removedAttachmentVersions: r,
                removedAttachments: i
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n = s(41),
            a = s(5),
            o = (s(4), s(8), s(21), s(39)),
            r = s(19),
            i = s(16);
        const c = i.o.tasks;

        function l(e) {
            const {
                teamId: t,
                projectId: s,
                projectIds: l,
                projectSectionId: d,
                projectGroupIds: u,
                responsibleIds: m,
                tagIds: h,
                dueDateStart: p,
                dueDateEnd: g,
                inexactDueDate: f,
                isOverdue: b,
                recurrence: y,
                hasTimeNeeded: v,
                isPriority: w,
                isShared: k,
                nameMatches: x
            } = e, j = [];
            return t && j.push(r.Q.on(i.w.projects, i.o.projects.teamId, t)), s && j.push(r.Q.where(c.projectId, s)), l && l.length && j.push(r.Q.where(c.projectId, r.Q.oneOf(l))), void 0 !== d && j.push(r.Q.where(c.projectSectionId, d)), u && u.length && j.push(r.Q.experimentalNestedJoin(i.w.projects, i.w.groupAssignments), r.Q.on(i.w.projects, r.Q.on(i.w.groupAssignments, r.Q.or(u.map((e => r.Q.where(i.o.groupAssignments.groupId, e || null))))))), m && j.push(r.Q.or(m.map((e => r.Q.where(c.responsibleId, e || null))))), j.push(... function(e) {
                    if (e && e.length) return e.includes(null) ? [r.Q.experimentalJoinTables([i.w.tagAssignments]), r.Q.unsafeLokiTransform(((t, s) => t.filter((t => {
                        const n = s.getCollection(i.w.tagAssignments).count({
                                $and: [{
                                    [i.o.tagAssignments.taskId]: t.id
                                }, {
                                    _status: {
                                        $ne: "deleted"
                                    }
                                }]
                            }),
                            a = s.getCollection(i.w.tagAssignments).count({
                                $and: [{
                                    [i.o.tagAssignments.taskId]: t.id
                                }, {
                                    [i.o.tagAssignments.tagId]: {
                                        $in: e
                                    }
                                }, {
                                    _status: {
                                        $ne: "deleted"
                                    }
                                }]
                            });
                        return 0 === n || 0 < a
                    }))))] : [r.Q.on(i.w.tagAssignments, r.Q.or(e.map((e => r.Q.where(i.o.tagAssignments.tagId, e || null)))))];
                    return []
                }(h)), b ? j.push(r.Q.or(r.Q.and(r.Q.where(c.isAllDay, !0), r.Q.where(c.dueAt, r.Q.lt((0, n.Z)(new Date).getTime()))), r.Q.and(r.Q.where(c.isAllDay, !1), r.Q.where(c.dueAt, r.Q.lt(Date.now()))))) : j.push(... function(e, t, s) {
                    if (void 0 === e && void 0 === t) return [];
                    if (null === e && null === t) return [r.Q.where(c.dueAt, null)];
                    return s ? e && !e.isAllDay || t && !t.isAllDay ? (a.logError(a.PROD_CONSOLE_REASON.SAFE_LITERAL, "Broken due dates for tasks query - should be all day"), []) : [(0, o.queryBetweenDays)({
                        start: e,
                        end: t,
                        isAllDayColumn: c.isAllDay,
                        timestampColumn: c.dueAt
                    })] : []
                }(p, g, f)), void 0 !== y && (y ? j.push(r.Q.on(i.w.taskRecurrences, i.o.taskRecurrences.pattern, y)) : j.push(r.Q.where(c.recurrenceId, null))), void 0 !== w && j.push(r.Q.where(c.priorityPosition, w ? r.Q.notEq(null) : null)), void 0 !== v && j.push(r.Q.where(c.timeNeeded, v ? r.Q.notEq(0) : 0)), j.push(... function(e) {
                    if (void 0 === e) return [];
                    if (e) return [r.Q.on(i.w.taskAccesses, r.Q.where(i.o.id, r.Q.notEq(null)))];
                    return [r.Q.experimentalJoinTables([i.w.taskAccesses]), r.Q.unsafeLokiTransform(((e, t) => e.filter((e => 0 === t.getCollection(i.w.taskAccesses).count({
                        $and: [{
                            [i.o.taskAccesses.taskId]: e.id
                        }, {
                            _status: {
                                $ne: "deleted"
                            }
                        }]
                    })))))]
                }(k)), void 0 !== x && j.push((0, o.whereIncludesNormalized)(c.name, x)),
                function(e) {
                    const t = [],
                        s = [];
                    e.forEach((e => {
                        "lokiTransform" === e.type ? s.push(e.function) : t.push(e)
                    })), s.length && t.push(r.Q.unsafeLokiTransform(((e, t) => {
                        let n = e;
                        return s.forEach((e => {
                            n = e(n, t)
                        })), n
                    })));
                    return t
                }(j)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n = s(0);
        const a = {
                off: "off",
                username: "username",
                "current-password": "current-password",
                "new-password": "new-password",
                name: "name",
                email: "email",
                organization: "organization",
                tel: "tel",
                oneTimeCode: "one-time-code"
            },
            o = {
                off: "off",
                username: "username",
                "current-password": "password",
                "new-password": "password-new",
                email: "email",
                name: "name",
                tel: "tel"
            },
            r = {
                off: "none",
                username: "username",
                "current-password": "password",
                "new-password": "newPassword",
                name: "name",
                email: "emailAddress",
                organization: "organizationName",
                tel: "telephoneNumber",
                oneTimeCode: "oneTimeCode"
            },
            i = n.Hocs.compose(n.Hocs.withHooks((({
                autoComplete: e,
                textContentType: t,
                onSubmit: s,
                onSubmitExtraParam: i,
                type: c = "text"
            }) => ({
                type: c,
                onSubmit: n.React.useCallback((e => {
                    s && s(e, i)
                }), [s, i]),
                autoCompleteWeb: a[e] || "off",
                autoCompleteAndroid: o[e] || "off",
                textContentType: t || r[e]
            }))));
        s(2), s(3);
        const c = s(431);
        var l = s(1);
        const d = n.Hocs.compose(i)((e => {
                const {
                    className: t,
                    style: s,
                    onChange: a,
                    onFocus: o,
                    onBlur: r,
                    onKeyDown: i,
                    onKeyUp: d,
                    onKeyPress: u,
                    onMouseEnter: m,
                    onMouseLeave: h,
                    value: p,
                    placeholder: g,
                    type: f,
                    isDisabled: b,
                    autoFocus: y,
                    maxLength: v,
                    autoCompleteWeb: w,
                    __forwardedRef: k,
                    testId: x,
                    initialValue: j,
                    onSubmit: T,
                    blurOnSubmit: S
                } = e, P = n.React.useRef(null);
                return n.React.useEffect((() => {
                    P.current && k && ("function" == typeof k ? k(P.current) : k.current = P.current)
                })), n.React.useEffect((() => {
                    if (P.current && y) {
                        const e = setTimeout((() => {
                            P.current.focus()
                        }), 30);
                        return () => {
                            clearTimeout(e)
                        }
                    }
                    return n.FP.noop
                }), []), n.React.useLayoutEffect((() => {
                    P.current && void 0 !== j && (P.current.value = j)
                }), []), (0, l.jsx)("input", {
                    ref: P,
                    style: s,
                    className: t || c.textInput,
                    onChange: e => {
                        a && a(n.ReactUtils.getTargetValue(e))
                    },
                    onFocus: o,
                    onBlur: r,
                    onKeyDown: e => {
                        i && i(e), "Enter" !== e.key || e.defaultPrevented || b || n.ReactUtils.isImeEvent(e) || (T && T(e), S && r && r())
                    },
                    onKeyUp: d,
                    onKeyPress: u,
                    onMouseEnter: m,
                    onMouseLeave: h,
                    type: f,
                    value: p,
                    disabled: b,
                    placeholder: g,
                    maxLength: v,
                    autoComplete: w,
                    "data-testid": x
                })
            })),
            u = n.React.forwardRef(((e, t) => (0, l.jsx)(d, Object.assign({
                __forwardedRef: e.__forwardedRef || t
            }, e))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(5);
        var n = s(240),
            a = s(534);
        const o = (0, n.createHighlightComponent)({}, a.Z.highlight)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(176),
            o = s(13);
        s(2), s(3);
        const r = s(556);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                label: t,
                size: s = "normal",
                iconName: c,
                color: l,
                isOpaque: d,
                isDisabled: u,
                onPress: m,
                textColor: h,
                isFullWidth: p,
                innerRef: g
            } = e, f = "compact" === s, b = d ? "opaque" : "standard", y = h || (0, a.uu)(l || "onBackground3", b);
            return (0, i.jsxs)(a.ej, {
                className: r.touchable + (f ? " " + r.touchableCompact : "") + ("tinyPadding" === s ? " " + r.tinyPadding : "") + " " + (e.className || ""),
                style: e.style,
                color: l,
                isDisabled: u,
                variant: b,
                onPress: m,
                isFullWidth: p,
                ref: g,
                children: [(0, i.jsx)(a.oD, {
                    className: r.text + (f ? " " + r.textCompact : ""),
                    label: n.FP.toUpper(t),
                    color: y,
                    isDisabled: u
                }), c ? (0, i.jsx)(o.default, {
                    name: c,
                    color: y
                }) : null]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(94),
            o = s(1286),
            r = s(536),
            i = s(1);
        const c = e => {
            const {
                children: t,
                source: s,
                dotColor: c,
                isTeam: l
            } = e, {
                initials: d,
                size: u,
                fontSize: m,
                color: h,
                isImageLoaded: p,
                onLoad: g,
                onError: f
            } = (0, o.GN)(e), b = s && p;
            return (0, i.jsxs)("div", {
                className: r.Z.root + " " + (e.className || ""),
                style: Object.assign({
                    width: u,
                    height: u,
                    backgroundColor: b ? "transparent" : h,
                    borderRadius: l ? n.Styling.vars.avatar.teamRadius[e.size] : void 0
                }, e.style),
                children: [s ? (0, i.jsx)(a.Z, {
                    className: r.Z.image,
                    source: s,
                    cache: !0,
                    onLoad: g,
                    onError: f
                }) : null, b ? null : (0, i.jsx)("span", {
                    className: r.Z.initials,
                    style: {
                        fontSize: m
                    },
                    children: d
                }), c ? (0, i.jsx)(o.oT, {
                    size: e.size,
                    color: c,
                    isTeam: l
                }) : null, t]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l,
            n: () => i
        });
        var n = s(0);
        const a = () => {
                const [e, t] = n.React.useState(!1), [s, a] = n.React.useState(0);
                return n.React.useEffect((() => {
                    if (e) {
                        const e = n.Rx.merge(n.ReactUtils.onOnline, n.ReactUtils.appBecameActive.pipe(n.Rx.mapTo(void 0), n.Rx.skip(1))).pipe(n.Rx.take(1)).subscribe((() => {
                            a((e => e + 1)), t(!1)
                        }));
                        return () => {
                            e.unsubscribe()
                        }
                    }
                    return n.FP.noop
                }), [e]), [s, t]
            },
            o = e => {
                if ("string" == typeof e) return {
                    uri: e
                };
                invariant(n.FP.isObject(e), "Expected ImageSource to be an object");
                const {
                    uri: t,
                    headers: s
                } = e;
                return {
                    uri: t,
                    headers: s
                }
            };
        var r = s(1);

        function i(e) {
            const t = n.React.useMemo((() => e && e.type.includes("image") ? URL.createObjectURL(e) : null), [e]);
            return n.React.useEffect((() => () => {
                t && URL.revokeObjectURL(t)
            }), [t]), t
        }
        const c = e => {
                switch (e) {
                    case "contain":
                        return "contain";
                    case "stretch":
                        return "fill";
                    case "center":
                        return "none";
                    default:
                        return "cover"
                }
            },
            l = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withHooks((({
                source: e
            }) => {
                const [t, s] = a();
                return {
                    attempt: t,
                    setHasUnhandledError: s,
                    source: o(e),
                    sourceRetryOn: JSON.stringify(e)
                }
            })), n.Hocs.withObservables(["sourceRetryOn", "attempt"], (({
                services: e,
                source: {
                    uri: t,
                    headers: s
                }
            }) => ({
                downloadedImage: s ? n.Rx.defer((() => e.resources.image.observe(t, s))).pipe(n.Rx.catchError((() => n.Rx.of("error"))), n.Rx.startWith(null)) : n.Rx.of(null)
            }))))((e => {
                const {
                    services: t,
                    source: s,
                    setHasUnhandledError: a,
                    downloadedImage: o,
                    priority: i = "auto",
                    title: l = "",
                    className: d,
                    resizeMode: u,
                    style: m = {},
                    onLoad: h,
                    onError: p
                } = e, {
                    uri: g,
                    headers: f
                } = s, b = !!f, y = !f, v = b ? "error" === o ? "error" : o ? "loaded" : "loading" : null, w = b ? o && "loaded" === v ? o : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" : g;
                ((e, t, s, a) => {
                    const o = n.React.useRef(null);
                    n.React.useEffect((() => {
                        const n = t !== o.current;
                        e && n && ("loaded" === t ? s() : "error" === t && a()), o.current = t
                    }))
                })(b, v, (() => {
                    a(!1), h && h()
                }), (() => {
                    a(!0), p && p()
                })), n.React.useEffect((() => () => {
                    b && t.resources.image.abort(g)
                }), []);
                const k = {
                    objectFit: c(u)
                };
                return (0, r.jsx)("img", {
                    src: w,
                    alt: l,
                    title: l,
                    className: d,
                    style: Object.assign({}, k, m),
                    onLoad: y ? h : void 0,
                    onError: y ? p : void 0,
                    draggable: !1,
                    fetchpriority: i
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r,
            p: () => o
        });
        s(210);
        let n;
        class a {
            static install() {
                if (n) return;
                n = console;
                const e = {};
                Object.keys(n).forEach((t => {
                    e[t] = function(...e) {}
                })), console = e
            }
            static log(...e) {
                n.log(...e)
            }
            static warn(...e) {
                n.warn(...e)
            }
            static error(...e) {
                n.error(...e)
            }
        }
        const o = Object.freeze({
                SAFE_LITERAL: "safe literal",
                API_ERROR: "API error",
                NATIVE_ERROR: "Native error",
                DIAGNOSTIC_ERROR: "diagnostic error",
                NO_PRIVATE: "no private info",
                SAFE_ID: "id is safe"
            }),
            r = function() {
                return a
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        s(0);
        var n = s(297);
        s(2), s(3);
        const a = s(542);
        var o = s(1);
        const r = e => {
            const {
                id: t,
                position: s,
                children: r,
                isDisabled: i,
                type: c,
                useCustomDragHandle: l
            } = e;
            return (0, o.jsx)(n.u, {
                draggableId: t,
                index: s,
                isDragDisabled: i,
                type: c,
                children: (e, t) => {
                    const s = Object.assign({}, e.draggableProps, !l && e.dragHandleProps),
                        n = l ? e.dragHandleProps : {};
                    return (0, o.jsx)("div", Object.assign({
                        className: a.draggable,
                        ref: e.innerRef
                    }, s, {
                        children: r({
                            isDragging: t.isDragging,
                            dragHandleProps: n
                        })
                    }))
                }
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => g
        });
        var n = s(0),
            a = s(138),
            o = s(246),
            r = s(60),
            i = s(18),
            c = s(329),
            l = s(11),
            d = s(161),
            u = s(81),
            m = s(66);
        s(2), s(3);
        const h = s(738);
        var p = s(1);
        const g = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                left: t,
                right: s,
                children: g,
                hasThreeDots: f,
                onMenuPress: b,
                menuTarget: y,
                description: v,
                hasHairline: w,
                isEnded: k,
                isCapitalized: x,
                onCollapsePress: j,
                isCollapsed: T,
                adjustsFontSizeToFit: S,
                needsReview: P,
                hasActivity: _,
                headerRef: C,
                testId: R,
                counters: A,
                tasks: I,
                viewColor: N,
                onCountersPress: E
            } = e, O = n.Hooks.useIntl(), [M, D] = (0, m.Uq)(), H = !!M.isSelecting && (0, m.p5)(M, n.FP.pluckIds(I)), F = !!j, Z = f && !0, L = f && !Z, B = f ? (0, p.jsx)(a.Z, {
                color: "onBackground3",
                onPress: e => {
                    b && (n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), b(e))
                }
            }) : null, z = s || L ? (0, p.jsxs)("div", {
                className: h.right,
                children: [s, L ? B : null]
            }) : null, U = v ? (0, p.jsx)(i.default, {
                className: h.description,
                children: v
            }) : null, W = A ? (0, p.jsx)(o.Z, {
                className: h.counters + (U ? " " + h.countersWithLeftSpacing : ""),
                counters: A,
                taskLabel: O.f.t7,
                onPress: E ? e => {
                    n.ReactUtils.stopPropagation(e), n.ReactUtils.preventDefault(e), E()
                } : void 0
            }) : null, G = !!U || !!W, V = G ? (0, p.jsxs)(r.gq, {
                children: [U, W]
            }) : null, q = _ ? u.a.Activity : P ? u.a.Incoming : void 0;
            return (0, p.jsxs)("div", {
                className: h.root + (G ? " " + h.hasDescription : ""),
                ref: C,
                children: [M.isSelecting && I.length ? (0, p.jsx)(d.Z, {
                    isChecked: H,
                    isLarge: !0,
                    color: N || "purple",
                    onPress: () => {
                        const e = n.FP.pluckIds(I);
                        D(H ? {
                            type: "deselect",
                            ids: e
                        } : {
                            type: "select",
                            ids: e
                        })
                    },
                    style: {
                        paddingLeft: 8
                    }
                }) : null, F ? (0, p.jsx)("div", {
                    className: h.collapse,
                    children: (0, p.jsx)(c.Z, {
                        toggleSection: j,
                        isCollapsed: !!T,
                        iconSize: 20,
                        size: 24,
                        badge: q
                    })
                }) : null, t ? (0, p.jsx)("div", {
                    className: h.left + (F ? " " + h.leftWithCollapse : ""),
                    children: t
                }) : null, (0, p.jsxs)(l.Z, {
                    className: h.mainContainer + (t || F ? " " + h.textToIcon : "") + (z ? " " + h.textToButtons : "") + (G ? " " + h.textHoverable : ""),
                    webComponent: "div",
                    onPress: j,
                    isDisabled: !j,
                    androidNoRipple: !0,
                    children: [y ? (0, p.jsx)("div", {
                        className: h.menuTarget,
                        ref: y
                    }) : null, (0, p.jsxs)("div", {
                        className: h.headerContainer + "",
                        children: [(0, p.jsx)(i.default, {
                            className: h.text + (k ? " " + h.headerCrossed : "") + (x ? " " + h.capitalized : ""),
                            adjustsFontSizeToFit: S,
                            children: g
                        }), Z ? B : null]
                    }), V]
                }), w ? (0, p.jsx)("div", {
                    className: h.hairline
                }) : null, z]
            })
        }))
    }, , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            VY: () => _,
            pF: () => c.Z,
            h4: () => m,
            Ov: () => g,
            z6: () => A,
            z: () => R,
            MT: () => C,
            SH: () => P,
            fC: () => S,
            lK: () => T.l,
            Hz: () => j,
            ND: () => y
        });
        var n = s(0),
            a = s(68),
            o = s(18);
        s(2), s(3);
        const r = s(518);
        var i = s(1),
            c = s(873);
        const l = () => null,
            d = s(521);
        var u;
        const m = e => {
            const {
                children: t,
                menuTarget: s
            } = e, a = n.Hooks.useLayoutTopInset();
            return (0, i.jsxs)("div", {
                className: d.root,
                style: {
                    paddingTop: a
                },
                children: [(0, i.jsx)("div", {
                    className: d.container + " " + (e.className || ""),
                    style: e.style,
                    children: t
                }), u || (u = (0, i.jsx)(l, {})), (0, i.jsx)("div", {
                    className: d.menuTarget,
                    ref: s
                })]
            })
        };
        var h = s(22);
        const p = s(522),
            g = e => {
                const {
                    icon: t,
                    accessibilityLabel: s,
                    testId: a,
                    onPress: o,
                    keyboardShortcutID: r,
                    isDisabled: c,
                    badge: l
                } = e;
                return (0, i.jsx)(h.default, {
                    className: p.iconButton + " " + p.iconButtonBackground + " " + (e.className || ""),
                    style: e.style,
                    name: t,
                    isDisabled: c,
                    accessibilityLabel: s,
                    size: 28,
                    iconSize: 24,
                    color: "onBackground3",
                    keyboardShortcutID: r,
                    hitSlop: undefined,
                    testId: a,
                    badge: l,
                    onPress: o ? n.ReactUtils.callBoth(o, n.ReactUtils.dismissKeyboard) : void 0
                })
            };
        const f = s(37).d.sidebarGroupCollapsed,
            b = (e, t = !1, s = !1) => {
                const a = n.Hooks.useFastLocalStorage(),
                    [o, r] = n.React.useState((() => {
                        var n;
                        if (s) return t;
                        const o = a.get(f);
                        return null != (n = null == o ? void 0 : o[e]) ? n : t
                    }));
                return [o, async () => {
                    n.ReactUtils.animateNext();
                    const t = !o,
                        s = a.get(f);
                    r(t), a.set(f, Object.assign({}, s, {
                        [e]: t
                    }))
                }]
            },
            y = b;
        var v = s(206),
            w = s(62),
            k = s(50),
            x = s(86);
        const j = n.Hocs.compose()((e => {
            const {
                name: t,
                id: s,
                items: a,
                onPlusIconPress: o,
                initialNumToRender: r,
                renderItem: l,
                icon: d,
                iconColor: u,
                onThreeDotsPress: m,
                targetRef: h,
                isPrivate: p,
                plusA11yLabel: g,
                initiallyCollapsed: f,
                forceInitialState: y,
                groupDragHandle: j
            } = e, [T, S] = b(s, f, y), {
                onDragEnd: P
            } = n.Hooks.useDnd((() => ({
                getDroppedSection: () => ({
                    items: a
                }),
                mapToModel: ([e, t]) => t,
                updatePosition: async ([e, t], s) => {
                    await t.updateSidebarPosition(s)
                },
                updater: (e, t) => {
                    e.sidebarPosition = t
                },
                getItemDraggableId: ([, e]) => e.id,
                selector: e => e.sidebarPosition || 0
            })));
            return (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(c.Z, {
                    isCollapsed: T,
                    toggleSection: S,
                    title: t,
                    onPlusIconPress: o,
                    plusA11yLabel: g,
                    leftIcon: d,
                    leftIconColor: u,
                    onThreeDotPress: m,
                    targetRef: h,
                    isPrivate: p,
                    groupDragHandle: j
                }), T ? null : (0, i.jsx)(x.Z, {
                    onDragEnd: P,
                    children: (0, i.jsx)(w.Z, {
                        id: "" + k.M.droppable + s,
                        type: k.x.SIDEBAR_GROUP_ITEM,
                        children: r ? (0, i.jsxs)(i.Fragment, {
                            children: [a.slice(0, r).map(l), (0, i.jsx)(v.Z, {
                                children: a.slice(r).map(l)
                            })]
                        }) : a.map(l)
                    }, "droppable-" + s)
                })]
            })
        }));
        var T = s(130);
        const S = e => (0, i.jsx)("div", {
                className: r.root,
                children: e.children
            }),
            P = e => (0, i.jsx)(a.Z, Object.assign({
                className: r.scroll,
                indicatorStyle: "default",
                isAbsoluteFilled: !1,
                topBarInset: 0,
                reachesTopOfScreen: !1,
                isKeyboardAware: !0
            }, e)),
            _ = e => (0, i.jsx)("div", {
                className: e.hasMasterPlusPadding ? r.masterPlusSpace : "",
                children: e.children
            }),
            C = e => (0, i.jsx)("div", {
                className: r.masterButtonContainer,
                children: e.children
            }),
            R = e => (0, i.jsx)(o.default, {
                className: r.headerText + " " + (e.className || ""),
                style: e.style,
                children: e.children
            }),
            A = e => (0, i.jsx)("div", {
                className: r.headerButtons,
                children: e.children
            })
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(53),
            o = s(6),
            r = s(45);
        s(2), s(3);
        const i = s(546);
        var c = s(1);
        const l = n.Hocs.compose(n.Hocs.memo)((e => {
                var t;
                const {
                    currentValue: s = "",
                    validators: l = [],
                    onClose: d,
                    target: u,
                    placeholder: m,
                    title: h,
                    confirmButtonLabel: p,
                    children: g,
                    maxLength: f,
                    blurOnSubmit: b,
                    type: y,
                    autoComplete: v,
                    closeOnConfirm: w = !0,
                    isDisabled: k,
                    onConfirm: x,
                    onNext: j,
                    level: T,
                    description: S,
                    isSingleLine: P,
                    __forwardedRef: _
                } = e, C = n.Hooks.useIntl(), [R, A] = n.React.useState(s || ""), [I, N] = n.React.useState(!1), E = n.Hooks.useValidation({
                    value: [R, l]
                }), O = n.React.useCallback((e => {
                    A(e), N(!0)
                }), []), M = async e => {
                    await x(e, R), j && j()
                }, D = I ? R : s || "", [{
                    closeAnimated: H
                }, F] = (0, o.P9)(_), Z = w ? H : n.FP.noop;
                return (0, c.jsxs)(o.u_, {
                    ref: F,
                    target: u,
                    onClose: d,
                    size: "content",
                    level: T,
                    children: [(0, c.jsx)(o.u_.Header, {
                        right: null,
                        children: h
                    }), (0, c.jsx)(o.u_.Content, {
                        isStatic: !0,
                        children: (0, c.jsxs)("div", {
                            className: i.root + (g ? "" : " " + i.bottomMargin),
                            children: [S ? (0, c.jsx)(o.u_.Paragraph, {
                                children: S
                            }) : null, (0, c.jsx)(r.default, {
                                onChange: O,
                                autoFocus: !0,
                                type: y,
                                multiline: null != (t = !P) ? t : !["email", "password"].includes(y),
                                autoComplete: v,
                                value: D,
                                placeholder: m,
                                onSubmit: D && E.isValid && !k ? n.ReactUtils.callBoth(M, Z) : n.FP.noop,
                                maxLength: f,
                                errors: E.value.errors,
                                blurOnSubmit: b
                            }), g ? (0, c.jsx)("div", {
                                className: i.childrenContainer,
                                children: g
                            }) : null]
                        })
                    }), (0, c.jsxs)("div", {
                        className: i.createButtonContainer,
                        children: [(0, c.jsx)(a.default, {
                            onPress: d,
                            type: "cancel",
                            label: C.f.fe
                        }), (0, c.jsx)(a.default, {
                            onPress: n.ReactUtils.callBoth(M, Z),
                            type: "defaultAction",
                            isDisabled: !E.isValid || k,
                            label: p
                        })]
                    })]
                })
            })),
            d = n.React.forwardRef(((e, t) => (0, c.jsx)(l, Object.assign({}, e, {
                __forwardedRef: t
            }))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(537)]).then(s.bind(s, 1497))))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(155),
            o = s(335);

        function r(e) {
            const t = n.Rx.of(null),
                s = i("priority", e.activePriorityTasksCounter, t),
                a = i("activity", e.activityTasksCounter, s);
            return i("incoming", e.incomingTasksCounter, a)
        }

        function i(e, t, s) {
            return t.pipe(n.Rx.switchMap((t => 0 < t ? n.Rx.of(e) : s)))
        }
        var c = s(1);
        const l = n.Hocs.compose(n.Hocs.withObservables(["team"], (({
            team: e
        }) => ({
            team: e
        }))), n.Hocs.withObservables(["team", "showDots"], (({
            team: e,
            showDots: t
        }) => ({
            dotType: t ? r(e) : n.Rx.of(null)
        }))), (0, a.Z)((({
            team: e
        }) => ({
            avatarId: e.avatarId,
            teamId: e.id
        }))))((e => {
            const {
                team: {
                    name: t,
                    color: s
                },
                business: n,
                size: a = "normal",
                dotType: r,
                avatarSource: i
            } = e, l = r ? {
                incoming: "incoming",
                activity: "activity",
                priority: "priority"
            } [r] : void 0;
            return (0, c.jsx)(o.Z, {
                name: t,
                color: s,
                dotColor: l,
                avatarSource: i,
                size: a,
                business: n,
                className: e.className,
                style: e.style
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            sY: () => o,
            tl: () => a,
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(216), s.e(266)]).then(s.bind(s, 1494))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            B6: () => i,
            D5: () => u,
            Dq: () => l,
            GD: () => p,
            L$: () => r,
            NV: () => m,
            OO: () => h,
            S1: () => c,
            WN: () => g,
            bb: () => v,
            c0: () => k,
            ke: () => x,
            s: () => w,
            zP: () => d
        });
        var n = s(4),
            a = s(19),
            o = s(16);
        const r = [o.o.projects.sidebarPosition, o.o.projects.isFavorite],
            i = (e, t) => n.sortBy((e => e.asSidebarFavoritable(t).sidebarPosition), e);

        function c(e, t) {
            return null !== e.asSidebarFavoritable(t).sidebarPosition
        }

        function l(e, t) {
            return e.asSidebarFavoritable(t).isFavorite
        }

        function d(e, t) {
            return n.getLastPosition(e, (e => e.asSidebarFavoritable(t).sidebarPosition))
        }
        async function u(e, t, s) {
            const n = e.asSidebarFavoritable(t);
            n.sidebarPosition !== s && await e.update((() => {
                n.sidebarPosition = s
            }))
        }
        async function m(e, t, s, {
            maxOpen: n
        } = {}) {
            if (!c(e, s)) {
                const a = d(t, s),
                    o = n && Math.max(0, t.length + 1 - n),
                    r = o ? i(t, s).slice(0, o) : [];
                await e.batch(e.prepareUpdate((() => {
                    e.asSidebarFavoritable(s).sidebarPosition = a
                })), ...r.map((e => e.prepareUpdate((() => {
                    const t = e.asSidebarFavoritable(s);
                    t.sidebarPosition = null, t.isFavorite = !1
                })))))
            }
        }
        async function h(e, t) {
            await e.update((() => {
                const s = e.asSidebarFavoritable(t);
                s.sidebarPosition = null, s.isFavorite = !1
            }))
        }
        async function p(e, t) {
            const s = e.asSidebarFavoritable(t);
            if (!s.isFavorite) {
                const n = d(await t.getAllFavorites(), t);
                await e.update((() => {
                    s.sidebarPosition = n, s.isFavorite = !0
                }))
            }
        }
        async function g(e, t, s) {
            const n = e.asSidebarFavoritable(s);
            if (n.isFavorite) {
                const a = d(t, s);
                await e.update((() => {
                    n.isFavorite = !1, n.sidebarPosition = a
                }))
            }
        }
        const f = a.Q.where(o.o.projects.isFavorite, !0),
            b = a.Q.where(o.o.projects.isFavorite, !1),
            y = a.Q.where(o.o.projects.sidebarPosition, a.Q.notEq(null));
        a.Q.where(o.o.projects.sidebarPosition, null);

        function v(e) {
            return e.extend(y)
        }

        function w(e) {
            return e.extend(y, b)
        }

        function k(e) {
            return e.extend(y, f)
        }
        class x {
            constructor() {
                this.sidebarPosition = void 0, this.isFavorite = !1
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            md: () => o.m,
            $T: () => r.$,
            lG: () => n.lG,
            dK: () => n.dK,
            nT: () => n.nT,
            gm: () => n.gm,
            lE: () => r.l,
            xv: () => a
        });
        var n = s(1229);

        function a(e) {
            return [...e].sort(((e, t) => e.createdAt.getTime() - t.createdAt.getTime()))
        }
        var o = s(243),
            r = s(473)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            PD: () => u,
            UP: () => h,
            b: () => p,
            e3: () => c,
            hJ: () => i,
            q7: () => m,
            tC: () => o,
            uV: () => d,
            x6: () => a
        });
        var n = s(4);

        function a(e) {
            const t = n.keys(e)[0];
            return invariant(t, "Event type shouldn't be null"), t
        }

        function o(e) {
            return e[a(e)]
        }
        const r = n.when(n.isEmpty, n.always(null));

        function i(e) {
            const t = o(e);
            return !0 === t ? void 0 : t.from || r(t.removed)
        }

        function c(e) {
            const t = o(e);
            return !0 === t ? void 0 : t.to || r(t.added)
        }
        const l = n.either(n.isNil, n.isEmpty),
            d = e => {
                const t = i(e),
                    s = c(e);
                return l(t) || l(s) ? l(t) ? "set" : "removed" : "changed"
            },
            u = e => e ? (({
                date: e,
                isAllDay: t
            }) => ({
                date: e.getTime(),
                isAllDay: t
            }))(e) : null,
            m = e => ({
                date: new Date(e.date),
                isAllDay: e.isAllDay
            }),
            h = e => e ? m(e) : null,
            p = n.pipe(n.unless(n.isObject, n.always({})))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(14),
            o = s(20),
            r = s(1);
        const i = e => {
            const {
                type: t,
                item: s,
                onPress: i
            } = e, c = n.Hooks.useIntl(), {
                currentTeam: l
            } = n.Hooks.useIdentity();
            return (0, r.jsx)(o.Z, {
                icon: "ľ",
                label: c.f.In,
                onPress: async e => {
                    const o = {
                            type: t,
                            item: s
                        },
                        {
                            path: r
                        } = await async function(e, t) {
                            switch (t.type) {
                                case "activity":
                                    return (0, a.pathToActivity)(e);
                                case "incoming":
                                    return (0, a.pathToIncoming)(e);
                                case "priority":
                                    return (0, a.pathToPriority)(e);
                                case "single_tasks":
                                    return (0, a.pathToSingleTasks)(e);
                                case "project":
                                    return (0, a.pathToProject)(e, t.item);
                                case "tag":
                                    return (0, a.pathToTag)(e, t.item);
                                case "member":
                                    return (0, a.smartPathToMember)(e, t.item);
                                case "messages":
                                    return (0, a.pathToMessages)(e)
                            }
                            throw new Error("Unexpeced list type")
                        }(l, o), d = "" + n.ReactUtils.webAppUrl + r, u = await async function(e, t) {
                            switch (e.type) {
                                case "activity":
                                    return t.f.y;
                                case "incoming":
                                    return t.f.ny;
                                case "priority":
                                    return t.f.zV;
                                case "single_tasks":
                                    return t.f.EO;
                                case "project":
                                    return n.Styling.getProjectName(e.item, t);
                                case "tag":
                                    return e.item.name;
                                case "member":
                                    return n.Rx.takeFirst(e.item.preferredName);
                                case "messages":
                                    return "Messages";
                                default:
                                    throw new Error("Unexpected list type")
                            }
                        }(o, c);
                    n.ReactUtils.share({
                        message: d,
                        url: d,
                        title: u,
                        formatMessage: c.formatMessage
                    }), i && i(e)
                }
            })
        }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            U3: () => a,
            VH: () => n,
            lf: () => o
        });
        s(0), s(21);
        const n = 10,
            a = "NEW_TASK",
            o = {
                id: a
            }
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = s(141).wW
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            HI: () => g,
            Ml: () => w,
            dd: () => p,
            j9: () => y,
            qJ: () => b,
            sL: () => f,
            uM: () => m
        });
        var n = s(19),
            a = (s(5), s(4)),
            o = s(8),
            r = s(16),
            i = s(110),
            c = s(65),
            l = s(1234);
        const d = r.o.teamMembers,
            u = a.pipe(a.map((e => [e.id, e.preferredName])), a.fromPairs, o.combineLatestObject),
            m = (e, t, s) => o.combineLatest(e.map((e => e ? e.id === s.id ? o.of(t.f.uG) : e.preferredName : o.of(t.f.zp)))),
            h = (e, t, s) => {
                const n = t => a.find((e => e.id === t), e);
                return a.pipe(a.toPairs, a.map((([e, t]) => [n(e), t])), a.sortWith([a.ascendLocale((([, e]) => e), s.locale)]), a.map((([e]) => e)))(t)
            };

        function p(e) {
            return t => t.length ? u(t).pipe(o.map((s => h(t, s, e)))) : o.of([])
        }
        const g = [d.isFavorite, d.sidebarPosition, d.alias, d.status],
            f = (e, t, s, n, o, r, c) => {
                if (6 >= t.length) return null != c && c.length ? c : null;
                const d = o.concat(r).sort(((e, t) => t.createdAt.getTime() - e.createdAt.getTime())),
                    u = a.find((e => e instanceof l.Z && "responsible" === e.type), d),
                    m = u instanceof l.Z ? [(0, i.hJ)(u.change)] : [],
                    h = d.map((e => e.author.id)),
                    p = a.unique(m.concat(h)),
                    g = e => e !== n && e !== s,
                    f = p.flatMap((e => {
                        if (!g(e)) return [];
                        const s = t.find((t => t.id === e));
                        return s ? [s] : []
                    })).slice(0, 4);
                if (4 > f.length) {
                    const s = e.map((e => e.responsible.id)),
                        n = a.reduce(((e, t) => (g(t) && t && (e[t] = (e[t] || 0) + 1), e)), {}, s),
                        o = a.sort(((e, t) => n[t.id] - n[e.id]), a.filter((e => a.keys(n).includes(e.id) && !f.includes(e)), t)),
                        r = (null != c ? c : []).concat(f.concat(o)).slice(0, 4);
                    return 1 <= r.length ? r : null
                }
                return f
            };

        function b(e) {
            const {
                database: t
            } = e;
            return e.projectAccesses.observe().pipe(o.switchMap((e => v(t, e))))
        }

        function y(e) {
            const {
                database: t
            } = e;
            return e.hasAdminPowers.pipe(o.switchMap((t => (t ? e.projectAccesses : e.projectAccesses.extend(n.Q.where(r.o.projectAccesses.isManager, !0))).observe())), o.switchMap((e => v(t, e))))
        }

        function v(e, t) {
            const s = t.map((e => e.project.id));
            return e.collections.get(r.w.projects).query(n.Q.where(r.o.id, n.Q.oneOf(s)), n.Q.where(r.o.projects.isSingleTasks, !1), c.Y3).observe()
        }

        function w(e) {
            return e && Array.isArray(e) ? e : []
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            m6: () => n.m,
            Hc: () => c,
            F1: () => l.F1,
            UB: () => l.UB,
            xv: () => i,
            c: () => n.c
        });
        var n = s(1239),
            a = s(16),
            o = s(4);
        const r = a.o.teams,
            i = [r.sidebarPosition, r.name];

        function c(e) {
            return o.sortWith([o.ascend(o.prop("sidebarPosition")), o.ascendLocale(o.prop("name"), e.locale)])
        }
        var l = s(328)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(13),
            o = s(11);
        s(2), s(3);
        const r = s(525);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                hint: t,
                prefix: s,
                helpPageUrl: c,
                iconColor: l
            } = e, [d, u] = n.React.useState(!1), m = n.Hooks.useIntl();
            return (0, i.jsxs)(o.Z, {
                className: r.root + " " + (e.className || ""),
                style: e.style,
                onPress: () => {
                    n.ReactUtils.openUrl(c)
                },
                webComponent: "div",
                onMouseEnter: () => u(!0),
                onMouseLeave: () => u(!1),
                children: [(0, i.jsxs)("span", {
                    className: r.content,
                    children: [(0, i.jsx)("span", {
                        className: r.prefix,
                        children: s || m.f.l3
                    }), t]
                }), (0, i.jsx)(a.default, {
                    className: r.icon,
                    style: d ? {
                        transform: "scale(1.1)"
                    } : void 0,
                    name: "Ų",
                    accessibilityLabel: m.f.mr,
                    color: l
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            CM: () => m,
            Dk: () => p,
            E5: () => g,
            Ks: () => y,
            Pw: () => f,
            v5: () => b
        });
        var n = s(0),
            a = s(108),
            o = s(207);
        const r = n.Model.Columns.projects,
            i = [r.name, r.createdAt, r.endedAt, r.teamColor, r.userColor, r.isOpen, r.preferences, ...a.L$],
            c = n.Model.Columns.tags,
            l = [c.name, c.userColor, c.teamColor, c.teamId, c.archivedAt, c.icon, ...a.L$];

        function d(e, t, s = !1) {
            const a = s ? [n.FP.descend((e => e.endedAt)), t] : [t, n.FP.descend((e => e.endedAt))];
            return n.FP.sortWith([n.FP.descend((e => e.isActive)), ...a])(e)
        }

        function u(e, t, s, a) {
            switch (t.by) {
                case n.Model.SidebarGroupsSortBy.Name:
                    return d(e, n.FP.inOrderLocale((e => n.Styling.getProjectName(e, s)), t.order, s.locale));
                case n.Model.SidebarGroupsSortBy.CreatedAt:
                    return d(e, n.FP.inOrder((e => e.createdAt), t.order));
                case n.Model.SidebarGroupsSortBy.Custom:
                    return d(e, a, !0);
                default:
                    return e
            }
        }
        const m = (e, t, s, a) => u(e, t, s, n.FP.ascend((e => {
                var t;
                const s = a[e.id];
                return null != (t = null == s ? void 0 : s.position) ? t : 0
            }))),
            h = (e, t, s, a) => u(e, t, s, n.FP.ascend((e => {
                var t;
                const s = a[e.id];
                return null != (t = null == s ? void 0 : s.sidebarPosition) ? t : 0
            })));

        function p({
            group: e,
            query: t,
            sort: s,
            intl: a
        }) {
            return n.Rx.combineLatest(t.observeWithColumns(i), e.assignments.observeWithColumns([n.Model.Columns.groupAssignments.sidebarPosition])).pipe(n.Rx.map((([e, t]) => {
                const n = t.reduce(((e, t) => (e[t.object.id] = t, e)), {});
                return h(e, s, a, n)
            })))
        }

        function g({
            query: e,
            sort: t,
            intl: s
        }) {
            return e.observeWithColumns(i).pipe(n.Rx.map((e => u(e, t, s, n.FP.ascend((e => {
                var t;
                return null != (t = e.sidebarPosition) ? t : Number.NEGATIVE_INFINITY
            }))))))
        }

        function f({
            team: e,
            sort: t,
            services: s,
            intl: a
        }) {
            return n.Rx.combineLatest(e.activeProjectsWithoutTemplates.observeWithColumns([n.Model.Columns.projects.name, n.Model.Columns.projects.createdAt, n.Model.Columns.projects.endedAt]), t.by === n.Model.SidebarGroupsSortBy.Custom ? (0, o.n)(e.id + "/active_projects", s.collections) : n.Rx.of({})).pipe(n.Rx.map((([e, s]) => m(e, t, a, s))))
        }

        function b({
            team: e,
            sort: t,
            intl: s
        }) {
            return n.Rx.combineLatest(e.favoriteProjects.observeWithColumns(i), e.favoriteMembers.observeWithColumns(a.L$).pipe(n.Rx.switchMap((e => n.Rx.combineLatestTuples(e.map((e => [e, e.preferredName])))))), e.getAllFavoriteTagsObservable(l)).pipe(n.Rx.map((([o, r, i]) => {
                if (t.by === n.Model.SidebarGroupsSortBy.Name) {
                    const e = [...o.map((e => [e, n.Styling.getProjectName(e, s)])), ...i.map((e => [e, e.name])), ...r],
                        a = "descending" === t.order ? n.FP.descendLocale : n.FP.ascendLocale;
                    return n.FP.sort(a((([e, t]) => t), s.locale), e).map((([e]) => e))
                } {
                    const t = r.map((([e]) => e));
                    return (0, a.B6)([...o, ...t, ...i], e)
                }
            })))
        }

        function y(e) {
            return n.Rx.combineLatest(e.map((e => e.assignments.observe()))).pipe(n.Rx.map((e => e.reduce(((e, t) => (t.forEach((t => {
                const s = t.group.id,
                    n = t.object.id,
                    a = e[s] || {};
                a[n] = t, e[s] = a
            })), e)), {}))))
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(45),
            o = s(1);
        const r = e => {
                const {
                    className: t,
                    style: s,
                    children: n
                } = e;
                return (0, o.jsx)("form", {
                    className: t,
                    style: s,
                    onSubmit: e => {
                        e.preventDefault()
                    },
                    children: n
                })
            },
            i = e => {
                const {
                    children: t,
                    onSubmit: s
                } = e, i = n.ReactUtils.flattenChildren(t), c = n.React.useRef((e => {
                    const t = [];
                    return n.React.Children.forEach(e, ((e, s) => {
                        e && e.type === a.default && t.push({
                            childIndex: s,
                            ref: n.React.createRef()
                        })
                    })), t
                })(i));
                return (0, o.jsx)(r, {
                    className: e.className,
                    style: e.style,
                    children: n.React.Children.map(i, ((e, t) => {
                        if (e && e.type === a.default) {
                            const a = ((e, t) => n.FP.findIndex((t => t.childIndex === e), t))(t, c.current),
                                o = e.props.blurOnSubmit;
                            return n.React.cloneElement(e, {
                                onSubmit: e => {
                                    e.preventDefault(), e.stopPropagation(), ((e, t) => {
                                        if (e === c.current.length - 1) {
                                            var n;
                                            t && (null == (n = c.current[e].ref.current) || n.blur()), null == s || s()
                                        } else {
                                            var a;
                                            null == (a = c.current[e + 1].ref.current) || a.focus()
                                        }
                                    })(a, o)
                                },
                                blurOnSubmit: !1,
                                inputRef: c.current[a].ref
                            })
                        }
                        return e
                    }))
                })
            }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            l: () => n
        });
        const n = s(0).React.createContext(!1);
        n.displayName = "SidebarDarkContext"
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Cl: () => i,
            DC: () => l,
            MB: () => a,
            fS: () => r,
            i4: () => o,
            sr: () => c
        });
        var n = s(1212);
        s(1156);
        const a = 1048576,
            o = 5 * a,
            r = 3,
            i = "MENU_SEPARATOR",
            c = {
                down: "ArrowDown",
                up: "ArrowUp",
                left: "ArrowLeft",
                right: "ArrowRight",
                return: "Enter",
                esc: "Escape",
                tab: "Tab",
                backspace: "Backspace",
                space: "Space",
                slash: "Slash",
                one: "Digit1",
                two: "Digit2",
                three: "Digit3",
                four: "Digit4",
                five: "Digit5",
                six: "Digit6",
                seven: "Digit7",
                eight: "Digit8",
                nine: "Digit9",
                zero: "Digit0",
                period: "Period",
                comma: "Comma"
            },
            l = {
                cmdOrCtrl: n.Z ? "cmd" : "ctrl",
                alwaysCtrl: "ctrl",
                alt: "alt",
                shift: "shift"
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            S: () => o,
            v: () => a
        });
        var n = s(0);

        function a(e, t) {
            return r(e, (e => n.Styling.getMemberGroupName(e, t)))
        }

        function o(e) {
            return r(e, (e => e.name))
        }

        function r(e, t) {
            return e.map(t).filter(Boolean).join(", ")
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n = s(0),
            a = s(11),
            o = s(13);
        s(2), s(3);
        const r = s(620);
        var i = s(1);
        const c = {
                top: 12,
                bottom: 12,
                left: 20,
                right: 20
            },
            l = n.Hocs.compose()((e => {
                const {
                    iconName: t,
                    accessibilityLabel: s,
                    onPress: l,
                    modalWebTarget: d,
                    testId: u,
                    isActive: m,
                    iconStyle: h = {}
                } = e;
                return (0, i.jsx)(a.Z, {
                    className: r.root,
                    style: {
                        backgroundColor: m ? n.Styling.rgba(n.Styling.factoryColor("purple"), .3) : void 0
                    },
                    testId: u,
                    webComponent: "div",
                    androidBorderless: !0,
                    hitSlop: c,
                    onPress: l,
                    ref: d,
                    children: (0, i.jsx)(o.default, {
                        className: r.icon + " " + (h.className || ""),
                        style: h.style,
                        name: t,
                        color: m ? "purple" : "onBackground3",
                        accessibilityLabel: s
                    })
                })
            }));
        var d = s(71);
        n.Hocs.compose()((e => {
            const {
                iconName: t,
                accessibilityLabel: s,
                onPress: c,
                modalWebTarget: l,
                testId: u,
                isActive: m,
                iconColor: h,
                iconHoverColor: p,
                iconActiveColor: g,
                backgroundColor: f,
                backgroundHoverColor: b,
                backgroundActiveColor: y,
                borderRadius: v,
                label: w,
                keyboardShortcutID: k,
                tooltipActivationTime: x = 500,
                iconStyle: j = {}
            } = e, {
                isHovering: T,
                onMouseEnter: S,
                onMouseLeave: P
            } = n.Hooks.useHover(), _ = n.React.useMemo((() => f ? m && (y || b) ? null != y ? y : b : T && (b || y) ? null != b ? b : y : f : "transparent"), [T, f, b, y, m]), C = n.React.useMemo((() => {
                var e, t;
                return m ? null != (e = null != g ? g : p) ? e : "purple" : T ? null != (t = null != p ? p : g) ? t : "purple" : null != h ? h : "onBackground4"
            }), [m, T, h, p, g]);
            return (0, i.jsx)(d.default, {
                keyboardShortcutID: k,
                renderLabel: s,
                timeToActivite: x,
                children: (0, i.jsxs)(a.Z, {
                    className: r.rootNew + " " + (e.className || ""),
                    style: e.style,
                    testId: u,
                    webComponent: "button",
                    androidBorderless: !0,
                    onPress: c,
                    onMouseEnter: S,
                    onMouseLeave: P,
                    ref: l,
                    children: [(0, i.jsx)("div", {
                        className: r.iconContainer,
                        children: (0, i.jsx)("div", {
                            className: r.background,
                            style: {
                                backgroundColor: n.Styling.factoryColorOrLiteral(_),
                                borderRadius: null != v ? v : 0
                            },
                            children: (0, i.jsx)(o.default, {
                                className: r.icon + " " + (j.className || ""),
                                style: j.style,
                                name: t,
                                color: C,
                                accessibilityLabel: s,
                                size: 28
                            })
                        })
                    }), w ? (0, i.jsx)("span", {
                        className: r.label,
                        children: w
                    }) : null]
                })
            })
        }));
        const u = l
    }, , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(22);
        s(2), s(3);
        const o = s(504);
        var r = s(1);
        const i = e => {
            const {
                color: t = "onBackground3",
                onPress: s,
                badge: i,
                hitSlop: c
            } = e, l = n.Hooks.useIntl();
            return (0, r.jsx)("div", {
                className: o.menuButton,
                children: (0, r.jsx)(a.default, {
                    name: "Ʀ",
                    iconSize: 24,
                    withHover: !1,
                    color: t,
                    badge: i,
                    accessibilityLabel: l.f.mu,
                    hitSlop: c,
                    androidRippleRadius: 20,
                    onPress: s ? n.ReactUtils.callBoth(s, n.ReactUtils.dismissKeyboard) : void 0
                })
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(11);
        s(2), s(3);
        const o = s(541);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                onPress: t,
                onPressExtraParam: s,
                title: n,
                count: i
            } = e;
            return (0, r.jsx)(a.Z, {
                className: o.root,
                webComponent: "div",
                title: n,
                onPress: t,
                onPressExtraParam: s,
                children: (0, r.jsxs)("div", {
                    className: o.background,
                    children: [(0, r.jsx)("div", {
                        className: o.counter,
                        children: (0, r.jsx)("span", {
                            className: o.counterText,
                            children: i
                        })
                    }), (0, r.jsx)("span", {
                        className: o.text,
                        children: n
                    })]
                })
            })
        }))
    }, , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            H: () => a,
            Z: () => o
        });
        var n = s(9);
        const a = (0, n.createContext)(void 0);

        function o() {
            return (0, n.useContext)(a)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            r1: () => u,
            MB: () => m,
            oe: () => h,
            Wr: () => l,
            NW: () => d,
            y6: () => g,
            eN: () => p
        });
        s(9), s(36);
        var n = s(6),
            a = s(20),
            o = s(152),
            r = s(894);
        s(2), s(3);
        const i = s(712);
        var c = s(1);
        const l = e => (0, c.jsx)(n.u_.Section, {
                className: i.list,
                children: e.children
            }),
            d = e => (0, c.jsx)(a.Z, {
                className: i.listItem + " " + i.summaryItem,
                contentRef: e.contentRef,
                label: e.label,
                topDescription: e.topDescription,
                icon: e.icon,
                contentHeight: e.contentHeight,
                onPress: e.onPress,
                renderRight: e.renderRight,
                modalWebTarget: e.modalWebTarget,
                iconColor: e.iconColor,
                hasArrow: e.hasArrow,
                children: e.children
            }),
            u = e => (0, c.jsx)(n.u_.Scroll, {
                className: i.list + " " + i.memberList,
                children: e.children
            }),
            m = e => (0, c.jsx)(o.Z, {
                className: i.listItem + " " + i.memberItem,
                member: e.member,
                contentHeight: e.contentHeight,
                shouldRenderYou: e.shouldRenderYou,
                children: e.children
            }),
            h = e => (0, c.jsx)(r.Z, {
                className: i.listItem + " " + i.memberItem,
                member: e.member,
                isActive: e.isActive,
                onPress: e.onPress,
                contentHeight: e.contentHeight,
                shouldRenderYou: e.shouldRenderYou,
                children: e.children
            }),
            p = [{
                iconName: "ê",
                color: "orange",
                opacity: 1,
                size: 150
            }, {
                iconName: "ë",
                color: "orange",
                opacity: .3,
                size: 150
            }, {
                iconName: "ì",
                color: "black",
                opacity: .4,
                size: 150
            }],
            g = [{
                iconName: "í",
                color: "orange",
                opacity: .3,
                size: 150
            }, {
                iconName: "î",
                color: "orange",
                opacity: .2,
                size: 150
            }, {
                iconName: "ï",
                color: "orange",
                opacity: .6,
                size: 150
            }, {
                iconName: "ð",
                color: "orange",
                opacity: 1,
                size: 150
            }]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => m
        });
        var n = s(0),
            a = s(18),
            o = s(11),
            r = s(487);
        const i = () => null;
        s(2), s(3);
        const c = s(489);
        var l, d = s(1);
        const u = n.ReactUtils.lazy((() => s(13))),
            m = n.Hocs.compose()((e => {
                var t, s;
                const {
                    onPress: m,
                    bottomDescription: h,
                    hasArrow: p,
                    extraValue: g,
                    isPrivate: f,
                    renderLeft: b,
                    renderRight: y,
                    renderLabel: v,
                    isActive: w,
                    isFocusedWithKeyboard: k,
                    hasHairline: x,
                    hasUnreadDot: j,
                    topDescription: T,
                    isDisabled: S,
                    isCheckboxDisabled: P,
                    testId: _,
                    contentHeight: C,
                    contentRadius: R,
                    hoverColor: A,
                    activeColor: I,
                    isEnabledOnProduction: N = !0,
                    onPressExtraParam: E,
                    children: O,
                    keyboardControls: M
                } = e, [D, H] = n.React.useState(!1), F = b(e, D), Z = w && I ? n.Styling.rgba(n.Styling.factoryColor(I), .1) : D && A ? n.Styling.rgba(n.Styling.factoryColor(A), .1) : void 0, L = !(!T && !h), B = n.Hooks.useDense(), z = null != (t = e.isDense) ? t : B, U = n.Hooks.useMultipleRefs(e.contentRef, null == M ? void 0 : M.focusedItemRef);
                return (0, d.jsx)(o.Z, {
                    className: c.root + (z ? " " + c.rootDense : "") + (S || P ? "" : " " + c.rootHovered) + (w ? " " + c.rootIsActive : "") + ((null != (s = null == M ? void 0 : M.isFocusedWithKeyboard) ? s : k) ? " " + c.rootIsFocusedWithKeyboard : "") + (m ? "" : " " + c.rootWithoutPointer) + " " + (e.className || ""),
                    style: e.style,
                    ref: e.modalWebTarget,
                    onPress: e => {
                        S && P || !m || m(e, E)
                    },
                    webComponent: "div",
                    iosUseHighlight: !0,
                    isDisabled: S,
                    testId: _,
                    onMouseEnter: () => H(!0),
                    onMouseLeave: () => H(!1),
                    children: (0, d.jsxs)(d.Fragment, {
                        children: [(0, d.jsx)(r.Z, {
                            isEnabledOnProduction: N
                        }), j ? (0, d.jsx)("div", {
                            className: c.unreadDotContainer,
                            children: (0, d.jsx)("div", {
                                className: c.unreadDot
                            })
                        }) : null, (0, d.jsxs)("div", {
                            className: c.content + (L ? " " + c.contentWithDescription : ""),
                            style: {
                                height: C,
                                backgroundColor: Z,
                                borderRadius: R
                            },
                            ref: U,
                            children: [F ? (0, d.jsx)("div", {
                                className: c.iconContainer,
                                children: F
                            }) : null, (0, d.jsxs)("div", {
                                className: c.textContainer + (L ? " " + c.textContainerWithDescription : ""),
                                children: [T ? (0, d.jsx)(a.default, {
                                    className: c.description,
                                    allowFontScaling: !1,
                                    children: T
                                }) : null, (0, d.jsxs)("div", {
                                    className: c.label,
                                    children: [v(e, D), f ? (0, d.jsx)(u, {
                                        name: "ŀ",
                                        size: 20,
                                        color: "onBackground2"
                                    }) : null]
                                }), h ? (0, d.jsx)(a.default, {
                                    className: c.description,
                                    allowFontScaling: !1,
                                    children: h
                                }) : null]
                            }), g ? (0, d.jsx)("span", {
                                className: c.extraValue,
                                children: g
                            }) : null, y ? y(e, D) : null, p ? (0, d.jsx)("div", {
                                className: c.arrow,
                                children: (0, d.jsx)(u, {
                                    name: "9",
                                    size: 22,
                                    color: "onBackground2"
                                })
                            }) : null]
                        }), x ? l || (l = (0, d.jsx)(i, {})) : null, O]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n = s(0),
            a = s(91),
            o = s(56),
            r = s(67),
            i = s(225),
            c = s(151),
            l = s(930),
            d = s(1);
        const u = ({
                member: e,
                avatarStyle: t
            }) => {
                var s;
                return () => s || (s = (0, d.jsx)(o.default, {
                    member: e,
                    size: "small",
                    avatarStyle: t
                }))
            },
            m = ({
                member: e,
                user: t,
                isTextBolded: s,
                highlightRanges: n
            }) => () => (0, d.jsxs)(d.Fragment, {
                children: [(0, d.jsx)("span", {
                    className: l.Z.prefix,
                    children: "@ "
                }), (0, d.jsx)(r.default, {
                    className: l.Z.text + (s ? " " + l.Z.textBolded : ""),
                    member: e,
                    shouldRenderYou: t.isMe,
                    highlightRanges: n
                })]
            }),
            h = n.FP.omit(["user", "groups", "member"]),
            p = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withHooks((({
                isTextBolded: e = !1,
                isActive: t = !1,
                shouldRenderDescription: s = !0
            }) => ({
                isTextBolded: e || t,
                isActive: t,
                shouldRenderDescription: s
            }))), n.Hocs.withObservables(["member"], (({
                member: e
            }) => ({
                member: e,
                user: e.user,
                secondaryName: e.secondaryName
            }))), n.Hocs.withObservables(["member", "intl", "shouldRenderDescription"], (({
                member: e,
                intl: t,
                shouldRenderDescription: s
            }) => ({
                bottomDescription: s ? (0, i.k)(e, t) : n.Rx.of(null)
            }))), n.Hocs.withHooks((({
                bottomDescription: e,
                highlightRanges: t,
                secondaryName: s
            }) => {
                let n = e;
                if (t && s && e) {
                    const o = e.split(s),
                        r = (0, d.jsx)(a.Z, {
                            text: s,
                            ranges: t.name
                        }, "highlighted");
                    n = [o[0], r, o.slice(1).join(s)]
                }
                return {
                    bottomDescription: n
                }
            })))((e => n.React.createElement(c.Z, Object.assign({
                renderLeft: u(e),
                renderLabel: m(e),
                renderRight: e.renderRight
            }, h(e)))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            A3: () => d,
            EX: () => k,
            Eq: () => w,
            Ev: () => p,
            G4: () => v,
            Hb: () => h,
            Pj: () => m,
            ST: () => u,
            jt: () => g,
            mc: () => f
        });
        var n = s(19),
            a = s(4),
            o = s(8),
            r = (s(5), s(16)),
            i = s(108);
        const c = r.o.tags,
            l = [c.sidebarPosition, c.name, c.isFavorite, c.preferences],
            d = [...i.L$, c.name],
            u = [c.preferences, c.name],
            m = (c.name, (e, t, s) => a.sortWith([a.descend((e => (0, i.Dq)(e, t))), a.descend((e => (0, i.S1)(e, t))), a.ascend((e => e.asSidebarFavoritable(t).sidebarPosition)), a.ascend(a.prop("isPrivate")), a.ascendLocale(a.prop("name"), s.locale)], e)),
            h = (a.sortBy(a.pipe(a.prop("name"), a.toLower)), (e, t) => s => s.observeWithColumns(l).pipe(o.map((s => m(s, e, t))))),
            p = (e, t) => s => g(e, t)(s).pipe(o.map(a.map((([e]) => e)))),
            g = (e, t) => s => s.observeWithColumns(l).pipe(o.switchMap((t => a.mapFastAsync((async t => {
                const s = await o.takeFirst(t.tasksInTeam(e).activeTasks.pipe(o.switchMap((e => e.fetchCount()))));
                return [t, s]
            }), t))), o.map(((e, t) => a.sortWith([a.descend((([t]) => t.asSidebarFavoritable(e).isFavorite)), a.ascend((([t]) => {
                const s = t.asSidebarFavoritable(e);
                return s.isFavorite && s.sidebarPosition
            })), a.descend((([, e]) => e)), a.ascendLocale((([e]) => e.name), t.locale)]))(e, t))),
            f = {
                teamSettings: "workspace_settings"
            },
            b = a.is(Boolean),
            y = a.is(Number);

        function v(e, t) {
            const s = {
                [f.teamSettings]: {}
            };
            if (a.isObject(e)) {
                const n = e[f.teamSettings];
                a.isObject(n) && a.toPairs(n).filter((([, e]) => a.isObject(e))).forEach((([e, n]) => {
                    const {
                        sidebar_position: a,
                        is_favorite: o
                    } = n;
                    if (t.isPrivate) {
                        const t = y(a) ? a : null;
                        s[f.teamSettings][e] = {
                            sidebar_position: t,
                            is_favorite: !(null === t || !b(o)) && o
                        }
                    }
                }))
            }
            return s
        }
        const w = n.Q.where(c.archivedAt, null),
            k = n.Q.where(c.archivedAt, n.Q.notEq(null))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            compose: () => a.Z,
            memo: () => u.memo,
            memoWith: () => N,
            withCloak: () => x,
            withCloakOnLimitedAccounts: () => j,
            withComponentKey: () => E,
            withErrorBoundary: () => k,
            withFeatureBadges: () => R,
            withHooks: () => v.Z,
            withIdentity: () => o.ZP,
            withIntl: () => i,
            withObservables: () => T.R6,
            withPersonalUI: () => S,
            withRemindExpired: () => p,
            withRouter: () => d,
            withServices: () => l,
            withWebLazyRender: () => b
        });
        var n = s(312),
            a = s(798),
            o = s(313),
            r = s(147);
        const i = e => {
            const t = (0, n.s)(e);
            return function(e) {
                const s = (0, r.Z)();
                return t(Object.assign({}, e, {
                    intl: s
                }))
            }
        };
        var c = s(149);
        const l = e => {
            const t = (0, n.s)(e);
            return function(e) {
                const s = (0, c.Z)();
                return t(Object.assign({}, e, {
                    services: s
                }))
            }
        };
        const d = s(80).withRouter;
        var u = s(9),
            m = s(200),
            h = s(1);

        function p(e) {
            return t => function(s) {
                const {
                    onExpired: n,
                    team: a
                } = e(s), o = (0, c.Z)(), {
                    currentTeam: r
                } = (0, m.Z)(), {
                    isExpired: i
                } = a || r;
                return u.useEffect((() => {
                    i && (n(), o.payments.remindExpired(r))
                }), []), i ? null : (0, h.jsx)(t, Object.assign({}, s))
            }
        }
        var g = s(350),
            f = s(323);

        function b(e) {
            return t => function(s) {
                const {
                    options: n,
                    forceShow: a,
                    forceShowAfterDelayMs: o,
                    spacerHeight: r
                } = e(s), {
                    isInViewport: i,
                    targetRef: c
                } = (0, g.Z)(n, a), [l, d] = u.useState(!1), m = (0, f.Z)();
                return u.useEffect((() => {
                    o && setTimeout((() => {
                        m.current && d(!0)
                    }), o)
                }), []), i || l ? u.createElement(t, s) : (0, h.jsx)("div", {
                    style: {
                        height: r
                    },
                    ref: c
                })
            }
        }
        var y = s(4),
            v = s(799);
        const w = (0, y.omit)(["__errorBoundary_onReset"]),
            k = ({
                name: e,
                render: t,
                onReset: o
            }) => r => {
                const i = (0, n.s)(r),
                    c = (0, a.Z)((0, v.Z)((e => ({
                        __errorBoundary_onReset: () => {
                            o && o(e)
                        }
                    })))),
                    l = s(1253).Z;
                return c((s => (0, h.jsx)(l, {
                    name: e,
                    onReset: s.__errorBoundary_onReset,
                    render: "function" == typeof t ? () => t(s) : t,
                    children: u.createElement(i, w(s))
                })))
            };

        function x(e) {
            return t => function(s) {
                return e(s) ? null : (0, h.jsx)(t, Object.assign({}, s))
            }
        }
        const j = (0, a.Z)(o.ZP, x((({
            isLimitedAccount: e
        }) => e)));
        var T = s(141);

        function S(e) {
            return (0, a.Z)(o.ZP, l, (0, T.R6)(["currentTeam"], (({
                currentTeam: e
            }) => ({
                isTeamOfOne: e.isTeamOfOne
            }))), (0, T.R6)(["services"], (({
                services: e
            }) => ({
                _prefersPersonalUI: e.modelRoot.settings.prefersPersonalUI
            }))))((t => {
                const {
                    isTeamOfOne: s,
                    _prefersPersonalUI: n
                } = t;
                return (0, h.jsx)(e, Object.assign({}, t, {
                    shouldRenderPersonalUI: s && n
                }))
            }))
        }
        var P = s(81);
        s(5);
        const _ = {
                app_menu: ["evernote_integration", "outlook_integration", "email_reports", "contact_info", "dropbox_integration", "gdrive_integration", "onedrive_integration"],
                app_settings: ["evernote_integration", "dropbox_integration", "gdrive_integration", "outlook_integration", "onedrive_integration", "email_reports", "contact_info"],
                calendar_settings: ["outlook_integration"],
                filters_menu: ["relative_due_date_filter"],
                due_date_picker: ["custom_recurrence"],
                due_date_repeat_picker: ["custom_recurrence"],
                member_menu_button: ["vacation_mode"],
                task_details_header: ["time_needed", "move_task", "share_with_anyone"],
                task_details_menu: ["priority_incoming", "move_task", "share_with_anyone"],
                member_menu: ["vacation_mode"],
                priority_menu_button: ["priority_incoming"],
                priority_menu: ["priority_incoming"],
                sidebar_menu_button: ["evernote_integration", "outlook_integration", "email_reports", "contact_info"],
                sidebar: ["messages"]
            },
            C = Object.freeze({
                NewFeatures: "__featureBadgesNewFeatures",
                SeenFeatures: "__featureBadgesSeenFeatures"
            });

        function R(e) {
            return (0, a.Z)((0, T.R6)(null, (({
                services: e
            }) => ({
                [C.NewFeatures]: e.modelRoot.settings.newFeatures,
                [C.SeenFeatures]: e.modelRoot.settings.seenNewFeatures
            }))), (0, v.Z)((t => {
                const {
                    services: s,
                    [C.NewFeatures]: n,
                    [C.SeenFeatures]: a
                } = t, {
                    placement: o
                } = e;
                return {
                    featureBadges: u.useMemo((() => {
                        const e = function({
                            placement: e,
                            newFeatures: t,
                            seenFeatures: s
                        }) {
                            const n = _[e];
                            if (!n) return null;
                            const a = Date.now(),
                                o = new Map(t.map((e => {
                                    const t = e.release_on;
                                    return [e.name, t]
                                })).filter((([, e]) => a >= e))),
                                r = new Map(s.map((({
                                    name: e,
                                    places: t
                                }) => {
                                    const s = (0, y.toPairs)(t).filter((([, t]) => {
                                        const s = o.get(e);
                                        return s && t > s
                                    })).flatMap((([e]) => e));
                                    return [e, new Set(s)]
                                })));
                            return new Map(n.map((t => {
                                var s;
                                const n = o.has(t);
                                return [t, {
                                    isReleased: n,
                                    hasBeenSeen: n && !(null == (s = r.get(t)) || !s.has(e))
                                }]
                            })))
                        }({
                            placement: o,
                            newFeatures: n,
                            seenFeatures: a
                        });
                        return e ? function({
                            services: e,
                            placement: t,
                            availableFeatures: s
                        }) {
                            const n = new Set(Array.from(s.entries()).filter((([, e]) => e.isReleased && !e.hasBeenSeen)).map((([e]) => e)));
                            return {
                                placementBadge: 0 < n.size ? Object.assign({}, P.a.New, {
                                    dismiss: async () => {
                                        await e.modelRoot.settings.markFeaturesAsSeen(t, Array.from(n))
                                    }
                                }) : void 0,
                                get: a => {
                                    if (s.has(a) && n.has(a)) return Object.assign({}, P.a.New, {
                                        dismiss: async () => {
                                            await e.modelRoot.settings.markFeaturesAsSeen(t, [a])
                                        }
                                    })
                                }
                            }
                        }({
                            services: s,
                            placement: o,
                            availableFeatures: e
                        }) : A
                    }), [s, o, n, a])
                }
            })))
        }
        const A = {
            placementBadge: void 0,
            get: () => {}
        };
        (0, y.once)((e => {
            console.warn("⚠️ No feature badges are placed in " + e + ". Maybe you forgot to define it inside of app/hocs/withFeatureBadges/badges.js, or got the name wrong?")
        })), (0, y.once)(((e, t) => {
            console.warn("⚠️ Feature " + e + " is not placed in " + t + ". Maybe you forgot to add it to the placement map inside of app/hocs/withFeatureBadges/badges.js?")
        }));

        function I(e) {
            const t = new Set(e);
            return (e, s) => {
                const n = Object.keys(e),
                    a = Object.keys(s);
                if (n.length !== a.length) return !1;
                for (const a of n) {
                    const n = e[a],
                        o = s[a];
                    if (n !== o) {
                        if (!t.has(a)) return !1;
                        if (!(n && "object" == typeof n && o && "object" == typeof o && I([])(n, o))) return !1
                    }
                }
                return !0
            }
        }

        function N(e) {
            const t = I(e);
            return e => u.memo(e, t)
        }

        function E(e) {
            return t => function(s) {
                const n = e(s);
                return (0, u.createElement)(t, Object.assign({}, s, {
                    key: n
                }))
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            O: () => o,
            Z: () => a
        });
        var n = s(0);

        function a(e) {
            return n.Hocs.compose(n.Hocs.withServices, n.Hocs.withHooks((t => {
                const {
                    avatarId: s,
                    width: a,
                    teamId: o
                } = e(t);
                return {
                    __avatarSource: n.React.useMemo((() => ({
                        avatarId: s,
                        width: a,
                        teamId: o
                    })), [s, a, o])
                }
            })), n.Hocs.withObservables(["__avatarSource", "services"], (({
                __avatarSource: e,
                services: t
            }) => ({
                avatarSource: o(t, e)
            }))))
        }

        function o(e, t) {
            const {
                avatarId: s,
                width: a = 250,
                teamId: o
            } = t;
            return s ? n.Rx.from(e.api.attachments.avatarSource(s, a, o)).pipe(n.Rx.startWith(null)) : n.Rx.of(null)
        }
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l,
            useCopyButtonState: () => r
        });
        var n = s(52),
            a = s(0),
            o = s(53);
        const r = e => {
            const t = a.Hooks.useIntl(),
                [s, n] = a.React.useState(!1),
                {
                    valueToCopy: o,
                    label: r,
                    isDisabled: i
                } = e;
            return a.React.useEffect((() => {
                if (s) {
                    const e = setTimeout((() => n(!1)), 2e3);
                    return () => clearTimeout(e)
                }
            }), [s]), {
                isCopied: s,
                isDisabled: i || !o,
                copy: () => {
                    if (o) {
                        const e = "function" == typeof o ? o() : o;
                        a.ReactUtils.copyToClipboard(e || "", t.formatMessage)
                    }
                    n(!0)
                },
                label: (() => {
                    const e = r || t.f.fm;
                    return s ? t.f.fl : e
                })()
            }
        };
        var i = s(1);
        const c = ["valueToCopy", "label", "isDisabled"],
            l = a.Hocs.compose()((e => {
                const {
                    valueToCopy: t,
                    label: s,
                    isDisabled: l
                } = e, d = (0, n.Z)(e, c), {
                    label: u,
                    isDisabled: m,
                    copy: h
                } = r({
                    valueToCopy: t,
                    label: s,
                    isDisabled: l
                });
                return (0, i.jsx)(o.default, Object.assign({}, d, {
                    hasMinWidth: !0,
                    label: u,
                    isDisabled: m,
                    onPress: a.ReactUtils.callBoth(e.onPress || a.FP.noop, h),
                    className: e.className,
                    style: e.style
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(378)]).then(s.bind(s, 1501))))
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(13),
            o = s(11);
        s(2), s(3);
        const r = s(577);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                isChecked: t,
                isIndeterminate: s,
                color: n,
                inactiveColor: c,
                hasChecklistStyle: l,
                onPress: d,
                onPressExtraParam: u,
                isDisabled: m,
                isLarge: h
            } = e;
            return (0, i.jsx)(o.Z, {
                className: r.root + (m ? " " + r.isDisabled : "") + " " + (e.className || ""),
                style: e.style,
                onPress: e => {
                    null == d || d(e, u)
                },
                isDisabled: m,
                androidBorderless: !0,
                children: (0, i.jsx)(a.default, {
                    name: t ? l ? "]" : "Y" : s ? "Z" : l ? "^" : "X",
                    color: t ? n || "purple" : c || "onBackground2",
                    size: h ? 28 : 22
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            SS: () => Ue,
            Em: () => ze,
            cK: () => Be,
            ZP: () => Le
        });
        var n = s(0),
            a = s(9),
            o = s(852),
            r = s(298),
            i = s(851),
            c = s(669),
            l = s(670),
            d = s(129),
            u = s(231),
            m = s(1335),
            h = s(671),
            p = Object.defineProperty,
            g = (e, t, s) => (((e, t, s) => {
                t in e ? p(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: s
                }) : e[t] = s
            })(e, "symbol" != typeof t ? t + "" : t, s), s),
            f = "init",
            b = "start",
            y = "stop",
            v = "reset",
            w = "prev",
            k = "next",
            x = "go",
            j = "close",
            T = "skip",
            S = "update",
            P = "tour:start",
            _ = "step:before",
            C = "beacon",
            R = "tooltip",
            A = "step:after",
            I = "tour:end",
            N = "tour:status",
            E = "error:target_not_found",
            O = {
                INIT: "init",
                READY: "ready",
                BEACON: "beacon",
                TOOLTIP: "tooltip",
                COMPLETE: "complete",
                ERROR: "error"
            },
            M = {
                IDLE: "idle",
                READY: "ready",
                WAITING: "waiting",
                RUNNING: "running",
                PAUSED: "paused",
                SKIPPED: "skipped",
                FINISHED: "finished",
                ERROR: "error"
            };

        function D() {
            return !("undefined" == typeof window || !window.document || !window.document.createElement)
        }

        function H(e) {
            return e ? e.getBoundingClientRect() : null
        }

        function F(e = !0) {
            const {
                body: t,
                documentElement: s
            } = document;
            if (!t || !s) return 0;
            if (e) {
                const e = [t.scrollHeight, t.offsetHeight, s.clientHeight, s.scrollHeight, s.offsetHeight].sort(((e, t) => e - t)),
                    n = Math.floor(e.length / 2);
                return e.length % 2 == 0 ? (e[n - 1] + e[n]) / 2 : e[n]
            }
            return Math.max(t.scrollHeight, t.offsetHeight, s.clientHeight, s.scrollHeight, s.offsetHeight)
        }

        function Z(e) {
            return "string" == typeof e ? document.querySelector(e) : e
        }

        function L(e, t, s) {
            if (!e) return W();
            const n = l(e);
            if (n) {
                if (n.isSameNode(W())) return s ? document : W();
                if (!(n.scrollHeight > n.offsetHeight) && !t) return n.style.overflow = "initial", W()
            }
            return n
        }

        function B(e, t) {
            if (!e) return !1;
            const s = L(e, t);
            return !!s && !s.isSameNode(W())
        }

        function z(e, t = "fixed") {
            if (!(e && e instanceof HTMLElement)) return !1;
            const {
                nodeName: s
            } = e, n = function(e) {
                return e && 1 === e.nodeType ? getComputedStyle(e) : null
            }(e);
            return "BODY" !== s && "HTML" !== s && (!(!n || n.position !== t) || !!e.parentNode && z(e.parentNode, t))
        }

        function U(e, t, s) {
            var n;
            if (!e) return 0;
            const {
                offsetTop: a = 0,
                scrollTop: o = 0
            } = null != (n = l(e)) ? n : {};
            let r = e.getBoundingClientRect().top + o;
            a && (B(e, s) || function(e) {
                return e.offsetParent !== document.body
            }(e)) && (r -= a);
            const i = Math.floor(r - t);
            return i < 0 ? 0 : i
        }

        function W() {
            var e;
            return null != (e = document.scrollingElement) ? e : document.documentElement
        }
        var G = void 0 !== d.createPortal;

        function V(e = navigator.userAgent) {
            let t = e;
            return "undefined" == typeof window ? t = "node" : document.documentMode ? t = "ie" : /Edge/.test(e) ? t = "edge" : Boolean(window.opera) || e.includes(" OPR/") ? t = "opera" : void 0 !== window.InstallTrigger ? t = "firefox" : window.chrome ? t = "chrome" : /(Version\/([\d._]+).*Safari|CriOS|FxiOS| Mobile\/)/.test(e) && (t = "safari"), t
        }

        function q(e) {
            const t = [],
                s = e => {
                    if ("string" == typeof e || "number" == typeof e) t.push(e);
                    else if (Array.isArray(e)) e.forEach((e => s(e)));
                    else if ((0, a.isValidElement)(e)) {
                        const {
                            children: t
                        } = e.props;
                        Array.isArray(t) ? t.forEach((e => s(e))) : s(t)
                    }
                };
            return s(e), t.join(" ").trim()
        }

        function Q(e) {
            const t = e.replace(/^#?([\da-f])([\da-f])([\da-f])$/i, ((e, t, s, n) => t + t + s + s + n + n)),
                s = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(t);
            return s ? [parseInt(s[1], 16), parseInt(s[2], 16), parseInt(s[3], 16)] : []
        }

        function Y(e) {
            return e.disableBeacon || "center" === e.placement
        }

        function J() {
            return !["chrome", "safari", "firefox", "opera"].includes(V())
        }

        function K({
            data: e,
            debug: t = !1,
            title: s,
            warn: n = !1
        }) {
            const a = n ? console.warn || console.error : console.log;
            t && (s && e ? (console.groupCollapsed(`%creact-joyride: ${s}`, "color: #ff0044; font-weight: bold; font-size: 12px;"), Array.isArray(e) ? e.forEach((e => {
                r.Z.plainObject(e) && e.key ? a.apply(console, [e.key, e.value]) : a.apply(console, [e])
            })) : a.apply(console, [e]), console.groupEnd()) : console.error("Missing title or data props"))
        }

        function $(e, ...t) {
            if (!r.Z.plainObject(e)) throw new TypeError("Expected an object");
            const s = {};
            for (const n in e)({}).hasOwnProperty.call(e, n) && (t.includes(n) || (s[n] = e[n]));
            return s
        }
        var X = {
                options: {
                    preventOverflow: {
                        boundariesElement: "scrollParent"
                    }
                },
                wrapperOptions: {
                    offset: -18,
                    position: !0
                }
            },
            ee = {
                back: "Back",
                close: "Close",
                last: "Last",
                next: "Next",
                open: "Open the dialog",
                skip: "Skip"
            },
            te = {
                event: "click",
                placement: "bottom",
                offset: 10,
                disableBeacon: !1,
                disableCloseOnEsc: !1,
                disableOverlay: !1,
                disableOverlayClose: !1,
                disableScrollParentFix: !1,
                disableScrolling: !1,
                hideBackButton: !1,
                hideCloseButton: !1,
                hideFooter: !1,
                isFixed: !1,
                locale: ee,
                showProgress: !1,
                showSkipButton: !1,
                spotlightClicks: !1,
                spotlightPadding: 10
            },
            se = {
                continuous: !1,
                debug: !1,
                disableCloseOnEsc: !1,
                disableOverlay: !1,
                disableOverlayClose: !1,
                disableScrolling: !1,
                disableScrollParentFix: !1,
                getHelpers: void 0,
                hideBackButton: !1,
                run: !0,
                scrollOffset: 20,
                scrollDuration: 300,
                scrollToFirstStep: !1,
                showSkipButton: !1,
                showProgress: !1,
                spotlightClicks: !1,
                spotlightPadding: 10,
                steps: []
            },
            ne = {
                arrowColor: "#fff",
                backgroundColor: "#fff",
                beaconSize: 36,
                overlayColor: "rgba(0, 0, 0, 0.5)",
                primaryColor: "#f04",
                spotlightShadow: "0 0 15px rgba(0, 0, 0, 0.5)",
                textColor: "#333",
                width: 380,
                zIndex: 100
            },
            ae = {
                backgroundColor: "transparent",
                border: 0,
                borderRadius: 0,
                color: "#555",
                cursor: "pointer",
                fontSize: 16,
                lineHeight: 1,
                padding: 8,
                WebkitAppearance: "none"
            },
            oe = {
                borderRadius: 4,
                position: "absolute"
            };

        function re(e) {
            return function(e, ...t) {
                if (!r.Z.plainObject(e)) throw new TypeError("Expected an object");
                if (!t.length) return e;
                const s = {};
                for (const n in e)({}).hasOwnProperty.call(e, n) && t.includes(n) && (s[n] = e[n]);
                return s
            }(e, "beaconComponent", "disableCloseOnEsc", "disableOverlay", "disableOverlayClose", "disableScrolling", "disableScrollParentFix", "floaterProps", "hideBackButton", "hideCloseButton", "locale", "showProgress", "showSkipButton", "spotlightClicks", "spotlightPadding", "styles", "tooltipComponent")
        }

        function ie(e, t) {
            var s, n, a, o, i, c;
            const l = null != t ? t : {},
                d = u.all([te, re(e), l], {
                    isMergeableObject: r.Z.plainObject
                }),
                m = function(e, t) {
                    var s, n, a, o, r;
                    const {
                        floaterProps: i,
                        styles: c
                    } = e, l = u(null != (s = t.floaterProps) ? s : {}, null != i ? i : {}), d = u(null != c ? c : {}, null != (n = t.styles) ? n : {}), m = u(ne, d.options || {}), h = "center" === t.placement || t.disableBeacon;
                    let {
                        width: p
                    } = m;
                    window.innerWidth > 480 && (p = 380), "width" in m && (p = "number" == typeof m.width && window.innerWidth < m.width ? window.innerWidth - 30 : m.width);
                    const g = {
                            bottom: 0,
                            left: 0,
                            overflow: "hidden",
                            position: "absolute",
                            right: 0,
                            top: 0,
                            zIndex: m.zIndex
                        },
                        f = {
                            beacon: {
                                ...ae,
                                display: h ? "none" : "inline-block",
                                height: m.beaconSize,
                                position: "relative",
                                width: m.beaconSize,
                                zIndex: m.zIndex
                            },
                            beaconInner: {
                                animation: "joyride-beacon-inner 1.2s infinite ease-in-out",
                                backgroundColor: m.primaryColor,
                                borderRadius: "50%",
                                display: "block",
                                height: "50%",
                                left: "50%",
                                opacity: .7,
                                position: "absolute",
                                top: "50%",
                                transform: "translate(-50%, -50%)",
                                width: "50%"
                            },
                            beaconOuter: {
                                animation: "joyride-beacon-outer 1.2s infinite ease-in-out",
                                backgroundColor: `rgba(${Q(m.primaryColor).join(",")}, 0.2)`,
                                border: `2px solid ${m.primaryColor}`,
                                borderRadius: "50%",
                                boxSizing: "border-box",
                                display: "block",
                                height: "100%",
                                left: 0,
                                opacity: .9,
                                position: "absolute",
                                top: 0,
                                transformOrigin: "center",
                                width: "100%"
                            },
                            tooltip: {
                                backgroundColor: m.backgroundColor,
                                borderRadius: 5,
                                boxSizing: "border-box",
                                color: m.textColor,
                                fontSize: 16,
                                maxWidth: "100%",
                                padding: 15,
                                position: "relative",
                                width: p
                            },
                            tooltipContainer: {
                                lineHeight: 1.4,
                                textAlign: "center"
                            },
                            tooltipTitle: {
                                fontSize: 18,
                                margin: 0
                            },
                            tooltipContent: {
                                padding: "20px 10px"
                            },
                            tooltipFooter: {
                                alignItems: "center",
                                display: "flex",
                                justifyContent: "flex-end",
                                marginTop: 15
                            },
                            tooltipFooterSpacer: {
                                flex: 1
                            },
                            buttonNext: {
                                ...ae,
                                backgroundColor: m.primaryColor,
                                borderRadius: 4,
                                color: "#fff"
                            },
                            buttonBack: {
                                ...ae,
                                color: m.primaryColor,
                                marginLeft: "auto",
                                marginRight: 5
                            },
                            buttonClose: {
                                ...ae,
                                color: m.textColor,
                                height: 14,
                                padding: 15,
                                position: "absolute",
                                right: 0,
                                top: 0,
                                width: 14
                            },
                            buttonSkip: {
                                ...ae,
                                color: m.textColor,
                                fontSize: 14
                            },
                            overlay: {
                                ...g,
                                backgroundColor: m.overlayColor,
                                mixBlendMode: "hard-light"
                            },
                            overlayLegacy: {
                                ...g
                            },
                            overlayLegacyCenter: {
                                ...g,
                                backgroundColor: m.overlayColor
                            },
                            spotlight: {
                                ...oe,
                                backgroundColor: "gray"
                            },
                            spotlightLegacy: {
                                ...oe,
                                boxShadow: `0 0 0 9999px ${m.overlayColor}, ${m.spotlightShadow}`
                            },
                            floaterStyles: {
                                arrow: {
                                    color: null != (r = null == (o = null == (a = null == l ? void 0 : l.styles) ? void 0 : a.arrow) ? void 0 : o.color) ? r : m.arrowColor
                                },
                                options: {
                                    zIndex: m.zIndex + 100
                                }
                            },
                            options: m
                        };
                    return u(f, d)
                }(e, d),
                h = B(Z(d.target), d.disableScrollParentFix),
                p = u.all([X, null != (s = e.floaterProps) ? s : {}, null != (n = d.floaterProps) ? n : {}]);
            return p.offset = d.offset, p.styles = u(null != (a = p.styles) ? a : {}, m.floaterStyles), p.offset += null != (i = null != (o = e.spotlightPadding) ? o : d.spotlightPadding) ? i : 0, d.placementBeacon && p.wrapperOptions && (p.wrapperOptions.placement = d.placementBeacon), h && p.options.preventOverflow && (p.options.preventOverflow.boundariesElement = "window"), {
                ...d,
                locale: u.all([ee, null != (c = e.locale) ? c : {}, d.locale || {}]),
                floaterProps: p,
                styles: $(m, "floaterStyles")
            }
        }

        function ce(e, t = !1) {
            return r.Z.plainObject(e) ? !!e.target || (K({
                title: "validateStep",
                data: "target is missing from the step",
                warn: !0,
                debug: t
            }), !1) : (K({
                title: "validateStep",
                data: "step must be an object",
                warn: !0,
                debug: t
            }), !1)
        }

        function le(e, t = !1) {
            return r.Z.array(e) ? e.every((e => ce(e, t))) : (K({
                title: "validateSteps",
                data: "steps must be an array",
                warn: !0,
                debug: t
            }), !1)
        }
        var de, ue = {
                action: "init",
                controlled: !1,
                index: 0,
                lifecycle: O.INIT,
                origin: null,
                size: 0,
                status: M.IDLE
            },
            me = (de = $(ue, "controlled", "size"), Object.keys(de));

        function he(e) {
            return new class {
                constructor(e) {
                    g(this, "beaconPopper"), g(this, "tooltipPopper"), g(this, "data", new Map), g(this, "listener"), g(this, "store", new Map), g(this, "addListener", (e => {
                        this.listener = e
                    })), g(this, "setSteps", (e => {
                        const {
                            size: t,
                            status: s
                        } = this.getState(), n = {
                            size: e.length,
                            status: s
                        };
                        this.data.set("steps", e), s === M.WAITING && !t && e.length && (n.status = M.RUNNING), this.setState(n)
                    })), g(this, "getPopper", (e => "beacon" === e ? this.beaconPopper : this.tooltipPopper)), g(this, "setPopper", ((e, t) => {
                        "beacon" === e ? this.beaconPopper = t : this.tooltipPopper = t
                    })), g(this, "cleanupPoppers", (() => {
                        this.beaconPopper = null, this.tooltipPopper = null
                    })), g(this, "close", ((e = null) => {
                        const {
                            index: t,
                            status: s
                        } = this.getState();
                        s === M.RUNNING && this.setState({
                            ...this.getNextState({
                                action: j,
                                index: t + 1,
                                origin: e
                            })
                        })
                    })), g(this, "go", (e => {
                        const {
                            controlled: t,
                            status: s
                        } = this.getState();
                        if (t || s !== M.RUNNING) return;
                        const n = this.getSteps()[e];
                        this.setState({
                            ...this.getNextState({
                                action: x,
                                index: e
                            }),
                            status: n ? s : M.FINISHED
                        })
                    })), g(this, "info", (() => this.getState())), g(this, "next", (() => {
                        const {
                            index: e,
                            status: t
                        } = this.getState();
                        t === M.RUNNING && this.setState(this.getNextState({
                            action: k,
                            index: e + 1
                        }))
                    })), g(this, "open", (() => {
                        const {
                            status: e
                        } = this.getState();
                        e === M.RUNNING && this.setState({
                            ...this.getNextState({
                                action: S,
                                lifecycle: O.TOOLTIP
                            })
                        })
                    })), g(this, "prev", (() => {
                        const {
                            index: e,
                            status: t
                        } = this.getState();
                        t === M.RUNNING && this.setState({
                            ...this.getNextState({
                                action: w,
                                index: e - 1
                            })
                        })
                    })), g(this, "reset", ((e = !1) => {
                        const {
                            controlled: t
                        } = this.getState();
                        t || this.setState({
                            ...this.getNextState({
                                action: v,
                                index: 0
                            }),
                            status: e ? M.RUNNING : M.READY
                        })
                    })), g(this, "skip", (() => {
                        const {
                            status: e
                        } = this.getState();
                        e === M.RUNNING && this.setState({
                            action: T,
                            lifecycle: O.INIT,
                            status: M.SKIPPED
                        })
                    })), g(this, "start", (e => {
                        const {
                            index: t,
                            size: s
                        } = this.getState();
                        this.setState({
                            ...this.getNextState({
                                action: b,
                                index: r.Z.number(e) ? e : t
                            }, !0),
                            status: s ? M.RUNNING : M.WAITING
                        })
                    })), g(this, "stop", ((e = !1) => {
                        const {
                            index: t,
                            status: s
                        } = this.getState();
                        [M.FINISHED, M.SKIPPED].includes(s) || this.setState({
                            ...this.getNextState({
                                action: y,
                                index: t + (e ? 1 : 0)
                            }),
                            status: M.PAUSED
                        })
                    })), g(this, "update", (e => {
                        var t, s, n, a;
                        if (n = e, a = me, !(r.Z.plainObject(n) && r.Z.array(a) && Object.keys(n).every((e => a.includes(e))))) throw new Error(`State is not valid. Valid keys: ${me.join(", ")}`);
                        this.setState({
                            ...this.getNextState({
                                ...this.getState(),
                                ...e,
                                action: null != (t = e.action) ? t : S,
                                origin: null != (s = e.origin) ? s : null
                            }, !0)
                        })
                    }));
                    const {
                        continuous: t = !1,
                        stepIndex: s,
                        steps: n = []
                    } = null != e ? e : {};
                    this.setState({
                        action: f,
                        controlled: r.Z.number(s),
                        continuous: t,
                        index: r.Z.number(s) ? s : 0,
                        lifecycle: O.INIT,
                        origin: null,
                        status: n.length ? M.READY : M.IDLE
                    }, !0), this.beaconPopper = null, this.tooltipPopper = null, this.listener = null, this.setSteps(n)
                }
                getState() {
                    return this.store.size ? {
                        action: this.store.get("action") || "",
                        controlled: this.store.get("controlled") || !1,
                        index: parseInt(this.store.get("index"), 10),
                        lifecycle: this.store.get("lifecycle") || "",
                        origin: this.store.get("origin") || null,
                        size: this.store.get("size") || 0,
                        status: this.store.get("status") || ""
                    } : {
                        ...ue
                    }
                }
                getNextState(e, t = !1) {
                    var s, n, a, o, i;
                    const {
                        action: c,
                        controlled: l,
                        index: d,
                        size: u,
                        status: m
                    } = this.getState(), h = r.Z.number(e.index) ? e.index : d, p = l && !t ? d : Math.min(Math.max(h, 0), u);
                    return {
                        action: null != (s = e.action) ? s : c,
                        controlled: l,
                        index: p,
                        lifecycle: null != (n = e.lifecycle) ? n : O.INIT,
                        origin: null != (a = e.origin) ? a : null,
                        size: null != (o = e.size) ? o : u,
                        status: p === u ? M.FINISHED : null != (i = e.status) ? i : m
                    }
                }
                getSteps() {
                    const e = this.data.get("steps");
                    return Array.isArray(e) ? e : []
                }
                hasUpdatedState(e) {
                    return JSON.stringify(e) !== JSON.stringify(this.getState())
                }
                setState(e, t = !1) {
                    const s = this.getState(),
                        {
                            action: n,
                            index: a,
                            lifecycle: o,
                            origin: r = null,
                            size: i,
                            status: c
                        } = {
                            ...s,
                            ...e
                        };
                    this.store.set("action", n), this.store.set("index", a), this.store.set("lifecycle", o), this.store.set("origin", r), this.store.set("size", i), this.store.set("status", c), t && (this.store.set("controlled", e.controlled), this.store.set("continuous", e.continuous)), this.listener && this.hasUpdatedState(s) && this.listener(this.getState())
                }
                getHelpers() {
                    return {
                        close: this.close,
                        go: this.go,
                        info: this.info,
                        next: this.next,
                        open: this.open,
                        prev: this.prev,
                        reset: this.reset,
                        skip: this.skip
                    }
                }
            }(e)
        }
        var pe = function({
                styles: e
            }) {
                return a.createElement("div", {
                    key: "JoyrideSpotlight",
                    className: "react-joyride__spotlight",
                    "data-test-id": "spotlight",
                    style: e
                })
            },
            ge = class extends a.Component {
                constructor() {
                    super(...arguments), g(this, "isActive", !1), g(this, "resizeTimeout"), g(this, "scrollTimeout"), g(this, "scrollParent"), g(this, "state", {
                        isScrolling: !1,
                        mouseOverSpotlight: !1,
                        showSpotlight: !0
                    }), g(this, "hideSpotlight", (() => {
                        const {
                            continuous: e,
                            disableOverlay: t,
                            lifecycle: s
                        } = this.props, n = [O.BEACON, O.COMPLETE, O.ERROR];
                        return t || (e ? n.includes(s) : s !== O.TOOLTIP)
                    })), g(this, "handleMouseMove", (e => {
                        const {
                            mouseOverSpotlight: t
                        } = this.state, {
                            height: s,
                            left: n,
                            position: a,
                            top: o,
                            width: r
                        } = this.spotlightStyles, i = "fixed" === a ? e.clientY : e.pageY, c = "fixed" === a ? e.clientX : e.pageX, l = c >= n && c <= n + r && (i >= o && i <= o + s);
                        l !== t && this.updateState({
                            mouseOverSpotlight: l
                        })
                    })), g(this, "handleScroll", (() => {
                        const {
                            target: e
                        } = this.props, t = Z(e);
                        if (this.scrollParent !== document) {
                            const {
                                isScrolling: e
                            } = this.state;
                            e || this.updateState({
                                isScrolling: !0,
                                showSpotlight: !1
                            }), clearTimeout(this.scrollTimeout), this.scrollTimeout = window.setTimeout((() => {
                                this.updateState({
                                    isScrolling: !1,
                                    showSpotlight: !0
                                })
                            }), 50)
                        } else z(t, "sticky") && this.updateState({})
                    })), g(this, "handleResize", (() => {
                        clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout((() => {
                            this.isActive && this.forceUpdate()
                        }), 100)
                    }))
                }
                componentDidMount() {
                    const {
                        debug: e,
                        disableScrolling: t,
                        disableScrollParentFix: s = !1,
                        target: n
                    } = this.props, a = Z(n);
                    this.scrollParent = L(null != a ? a : document.body, s, !0), this.isActive = !0, window.addEventListener("resize", this.handleResize)
                }
                componentDidUpdate(e) {
                    var t;
                    const {
                        lifecycle: s,
                        spotlightClicks: n
                    } = this.props, {
                        changed: a
                    } = (0, i.Z)(e, this.props);
                    a("lifecycle", O.TOOLTIP) && (null == (t = this.scrollParent) || t.addEventListener("scroll", this.handleScroll, {
                        passive: !0
                    }), setTimeout((() => {
                        const {
                            isScrolling: e
                        } = this.state;
                        e || this.updateState({
                            showSpotlight: !0
                        })
                    }), 100)), (a("spotlightClicks") || a("disableOverlay") || a("lifecycle")) && (n && s === O.TOOLTIP ? window.addEventListener("mousemove", this.handleMouseMove, !1) : s !== O.TOOLTIP && window.removeEventListener("mousemove", this.handleMouseMove))
                }
                componentWillUnmount() {
                    var e;
                    this.isActive = !1, window.removeEventListener("mousemove", this.handleMouseMove), window.removeEventListener("resize", this.handleResize), clearTimeout(this.resizeTimeout), clearTimeout(this.scrollTimeout), null == (e = this.scrollParent) || e.removeEventListener("scroll", this.handleScroll)
                }
                get overlayStyles() {
                    const {
                        mouseOverSpotlight: e
                    } = this.state, {
                        disableOverlayClose: t,
                        placement: s,
                        styles: n
                    } = this.props;
                    let a = n.overlay;
                    return J() && (a = "center" === s ? n.overlayLegacyCenter : n.overlayLegacy), {
                        cursor: t ? "default" : "pointer",
                        height: F(),
                        pointerEvents: e ? "none" : "auto",
                        ...a
                    }
                }
                get spotlightStyles() {
                    var e, t, s;
                    const {
                        showSpotlight: n
                    } = this.state, {
                        disableScrollParentFix: a = !1,
                        spotlightClicks: o,
                        spotlightPadding: r = 0,
                        styles: i,
                        target: c
                    } = this.props, l = Z(c), d = H(l), u = z(l), m = function(e, t, s) {
                        var n;
                        const a = H(e),
                            o = L(e, s),
                            r = B(e, s);
                        let i = 0,
                            c = null != (n = null == a ? void 0 : a.top) ? n : 0;
                        return o instanceof HTMLElement && (i = o.scrollTop, r || z(e) || (c += i), o.isSameNode(W()) || (c += W().scrollTop)), Math.floor(c - t)
                    }(l, r, a);
                    return {
                        ...J() ? i.spotlightLegacy : i.spotlight,
                        height: Math.round((null != (e = null == d ? void 0 : d.height) ? e : 0) + 2 * r),
                        left: Math.round((null != (t = null == d ? void 0 : d.left) ? t : 0) - r),
                        opacity: n ? 1 : 0,
                        pointerEvents: o ? "none" : "auto",
                        position: u ? "fixed" : "absolute",
                        top: m,
                        transition: "opacity 0.2s",
                        width: Math.round((null != (s = null == d ? void 0 : d.width) ? s : 0) + 2 * r)
                    }
                }
                updateState(e) {
                    this.isActive && this.setState((t => ({
                        ...t,
                        ...e
                    })))
                }
                render() {
                    const {
                        showSpotlight: e
                    } = this.state, {
                        onClickOverlay: t,
                        placement: s
                    } = this.props, {
                        hideSpotlight: n,
                        overlayStyles: o,
                        spotlightStyles: r
                    } = this;
                    if (n()) return null;
                    let i = "center" !== s && e && a.createElement(pe, {
                        styles: r
                    });
                    if ("safari" === V()) {
                        const {
                            mixBlendMode: e,
                            zIndex: t,
                            ...s
                        } = o;
                        i = a.createElement("div", {
                            style: {
                                ...s
                            }
                        }, i), delete o.backgroundColor
                    }
                    return a.createElement("div", {
                        className: "react-joyride__overlay",
                        "data-test-id": "overlay",
                        onClick: t,
                        role: "presentation",
                        style: o
                    }, i)
                }
            },
            fe = class extends a.Component {
                constructor() {
                    super(...arguments), g(this, "node", null)
                }
                componentDidMount() {
                    const {
                        id: e
                    } = this.props;
                    D() && (this.node = document.createElement("div"), this.node.id = e, document.body.appendChild(this.node), G || this.renderReact15())
                }
                componentDidUpdate() {
                    D() && (G || this.renderReact15())
                }
                componentWillUnmount() {
                    D() && this.node && (G || d.unmountComponentAtNode(this.node), this.node.parentNode === document.body && (document.body.removeChild(this.node), this.node = null))
                }
                renderReact15() {
                    if (!D()) return;
                    const {
                        children: e
                    } = this.props;
                    this.node && d.unstable_renderSubtreeIntoContainer(this, e, this.node)
                }
                renderReact16() {
                    if (!D() || !G) return null;
                    const {
                        children: e
                    } = this.props;
                    return this.node ? d.createPortal(e, this.node) : null
                }
                render() {
                    return G ? this.renderReact16() : null
                }
            },
            be = class extends a.Component {
                constructor(e) {
                    if (super(e), g(this, "beacon", null), g(this, "setBeaconRef", (e => {
                            this.beacon = e
                        })), e.beaconComponent) return;
                    const t = document.head || document.getElementsByTagName("head")[0],
                        s = document.createElement("style");
                    s.id = "joyride-beacon-animation", e.nonce && s.setAttribute("nonce", e.nonce);
                    s.appendChild(document.createTextNode("\n        @keyframes joyride-beacon-inner {\n          20% {\n            opacity: 0.9;\n          }\n        \n          90% {\n            opacity: 0.7;\n          }\n        }\n        \n        @keyframes joyride-beacon-outer {\n          0% {\n            transform: scale(1);\n          }\n        \n          45% {\n            opacity: 0.7;\n            transform: scale(0.75);\n          }\n        \n          100% {\n            opacity: 0.9;\n            transform: scale(1);\n          }\n        }\n      ")), t.appendChild(s)
                }
                componentDidMount() {
                    const {
                        shouldFocus: e
                    } = this.props;
                    setTimeout((() => {
                        r.Z.domElement(this.beacon) && e && this.beacon.focus()
                    }), 0)
                }
                componentWillUnmount() {
                    const e = document.getElementById("joyride-beacon-animation");
                    (null == e ? void 0 : e.parentNode) && e.parentNode.removeChild(e)
                }
                render() {
                    const {
                        beaconComponent: e,
                        continuous: t,
                        index: s,
                        isLastStep: n,
                        locale: o,
                        onClickOrHover: i,
                        size: c,
                        step: l,
                        styles: d
                    } = this.props, u = r.Z.string(o.open) ? o.open : h(o.open), m = {
                        "aria-label": u,
                        onClick: i,
                        onMouseEnter: i,
                        ref: this.setBeaconRef,
                        title: u
                    };
                    let p;
                    if (e) {
                        const o = e;
                        p = a.createElement(o, {
                            continuous: t,
                            index: s,
                            isLastStep: n,
                            size: c,
                            step: l,
                            ...m
                        })
                    } else p = a.createElement("button", {
                        key: "JoyrideBeacon",
                        className: "react-joyride__beacon",
                        "data-test-id": "button-beacon",
                        style: d.beacon,
                        type: "button",
                        ...m
                    }, a.createElement("span", {
                        style: d.beaconInner
                    }), a.createElement("span", {
                        style: d.beaconOuter
                    }));
                    return p
                }
            };
        var ye = function({
            styles: e,
            ...t
        }) {
            const {
                color: s,
                height: n,
                width: o,
                ...r
            } = e;
            return a.createElement("button", {
                style: r,
                type: "button",
                ...t
            }, a.createElement("svg", {
                height: "number" == typeof n ? `${n}px` : n,
                preserveAspectRatio: "xMidYMid",
                version: "1.1",
                viewBox: "0 0 18 18",
                width: "number" == typeof o ? `${o}px` : o,
                xmlns: "http://www.w3.org/2000/svg"
            }, a.createElement("g", null, a.createElement("path", {
                d: "M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z",
                fill: s
            }))))
        };
        var ve = function(e) {
                const {
                    backProps: t,
                    closeProps: s,
                    continuous: n,
                    index: o,
                    isLastStep: r,
                    primaryProps: i,
                    size: c,
                    skipProps: l,
                    step: d,
                    tooltipProps: u
                } = e, {
                    content: m,
                    hideBackButton: h,
                    hideCloseButton: p,
                    hideFooter: g,
                    locale: f,
                    showProgress: b,
                    showSkipButton: y,
                    styles: v,
                    title: w
                } = d, {
                    back: k,
                    close: x,
                    last: j,
                    next: T,
                    skip: S
                } = f, P = {
                    primary: x
                };
                return n && (P.primary = r ? j : T, b && (P.primary = a.createElement("span", null, P.primary, " (", o + 1, "/", c, ")"))), P.primary && (P.primary = a.createElement("button", {
                    "data-test-id": "button-primary",
                    style: v.buttonNext,
                    type: "button",
                    ...i
                }, P.primary)), y && !r && (P.skip = a.createElement("button", {
                    "aria-live": "off",
                    "data-test-id": "button-skip",
                    style: v.buttonSkip,
                    type: "button",
                    ...l
                }, S)), !h && o > 0 && (P.back = a.createElement("button", {
                    "data-test-id": "button-back",
                    style: v.buttonBack,
                    type: "button",
                    ...t
                }, k)), P.close = !p && a.createElement(ye, {
                    "data-test-id": "button-close",
                    styles: v.buttonClose,
                    ...s
                }), a.createElement("div", {
                    key: "JoyrideTooltip",
                    "aria-label": q(w) || q(m),
                    className: "react-joyride__tooltip",
                    style: v.tooltip,
                    ...u
                }, a.createElement("div", {
                    style: v.tooltipContainer
                }, w && a.createElement("h1", {
                    "aria-label": q(w),
                    style: v.tooltipTitle
                }, w), a.createElement("div", {
                    style: v.tooltipContent
                }, m)), !g && a.createElement("div", {
                    style: v.tooltipFooter
                }, a.createElement("div", {
                    style: v.tooltipFooterSpacer
                }, P.skip), P.back, P.primary), P.close)
            },
            we = class extends a.Component {
                constructor() {
                    super(...arguments), g(this, "handleClickBack", (e => {
                        e.preventDefault();
                        const {
                            helpers: t
                        } = this.props;
                        t.prev()
                    })), g(this, "handleClickClose", (e => {
                        e.preventDefault();
                        const {
                            helpers: t
                        } = this.props;
                        t.close("button_close")
                    })), g(this, "handleClickPrimary", (e => {
                        e.preventDefault();
                        const {
                            continuous: t,
                            helpers: s
                        } = this.props;
                        t ? s.next() : s.close("button_primary")
                    })), g(this, "handleClickSkip", (e => {
                        e.preventDefault();
                        const {
                            helpers: t
                        } = this.props;
                        t.skip()
                    })), g(this, "getElementsProps", (() => {
                        const {
                            continuous: e,
                            isLastStep: t,
                            setTooltipRef: s,
                            step: n
                        } = this.props, a = q(n.locale.back), o = q(n.locale.close), r = q(n.locale.last), i = q(n.locale.next), c = q(n.locale.skip);
                        let l = e ? i : o;
                        return t && (l = r), {
                            backProps: {
                                "aria-label": a,
                                "data-action": "back",
                                onClick: this.handleClickBack,
                                role: "button",
                                title: a
                            },
                            closeProps: {
                                "aria-label": o,
                                "data-action": "close",
                                onClick: this.handleClickClose,
                                role: "button",
                                title: o
                            },
                            primaryProps: {
                                "aria-label": l,
                                "data-action": "primary",
                                onClick: this.handleClickPrimary,
                                role: "button",
                                title: l
                            },
                            skipProps: {
                                "aria-label": c,
                                "data-action": "skip",
                                onClick: this.handleClickSkip,
                                role: "button",
                                title: c
                            },
                            tooltipProps: {
                                "aria-modal": !0,
                                ref: s,
                                role: "alertdialog"
                            }
                        }
                    }))
                }
                render() {
                    const {
                        continuous: e,
                        index: t,
                        isLastStep: s,
                        setTooltipRef: n,
                        size: o,
                        step: r
                    } = this.props, {
                        beaconComponent: i,
                        tooltipComponent: c,
                        ...l
                    } = r;
                    let d;
                    if (c) {
                        const r = {
                                ...this.getElementsProps(),
                                continuous: e,
                                index: t,
                                isLastStep: s,
                                size: o,
                                step: l,
                                setTooltipRef: n
                            },
                            i = c;
                        d = a.createElement(i, {
                            ...r
                        })
                    } else d = a.createElement(ve, {
                        ...this.getElementsProps(),
                        continuous: e,
                        index: t,
                        isLastStep: s,
                        size: o,
                        step: r
                    });
                    return d
                }
            },
            ke = class extends a.Component {
                constructor() {
                    super(...arguments), g(this, "scope", null), g(this, "tooltip", null), g(this, "handleClickHoverBeacon", (e => {
                        const {
                            step: t,
                            store: s
                        } = this.props;
                        "mouseenter" === e.type && "hover" !== t.event || s.update({
                            lifecycle: O.TOOLTIP
                        })
                    })), g(this, "setTooltipRef", (e => {
                        this.tooltip = e
                    })), g(this, "setPopper", ((e, t) => {
                        var s;
                        const {
                            action: n,
                            lifecycle: a,
                            step: o,
                            store: r
                        } = this.props;
                        "wrapper" === t ? r.setPopper("beacon", e) : r.setPopper("tooltip", e), r.getPopper("beacon") && r.getPopper("tooltip") && a === O.INIT && r.update({
                            action: n,
                            lifecycle: O.READY
                        }), (null == (s = o.floaterProps) ? void 0 : s.getPopper) && o.floaterProps.getPopper(e, t)
                    })), g(this, "renderTooltip", (e => {
                        const {
                            continuous: t,
                            helpers: s,
                            index: n,
                            size: o,
                            step: r
                        } = this.props;
                        return a.createElement(we, {
                            continuous: t,
                            helpers: s,
                            index: n,
                            isLastStep: n + 1 === o,
                            setTooltipRef: this.setTooltipRef,
                            size: o,
                            step: r,
                            ...e
                        })
                    }))
                }
                componentDidMount() {
                    const {
                        debug: e,
                        index: t
                    } = this.props;
                    K({
                        title: `step:${t}`,
                        data: [{
                            key: "props",
                            value: this.props
                        }],
                        debug: e
                    })
                }
                componentDidUpdate(e) {
                    var t;
                    const {
                        action: s,
                        callback: n,
                        continuous: a,
                        controlled: o,
                        debug: r,
                        helpers: c,
                        index: l,
                        lifecycle: d,
                        status: u,
                        step: m,
                        store: h
                    } = this.props, {
                        changed: p,
                        changedFrom: f
                    } = (0, i.Z)(e, this.props), y = c.info(), v = a && s !== j && (l > 0 || s === w), x = p("action") || p("index") || p("lifecycle") || p("status"), S = f("lifecycle", [O.TOOLTIP, O.INIT], O.INIT), P = p("action", [k, w, T, j]), I = o && l === e.index;
                    if (P && (S || I) && n({
                            ...y,
                            index: e.index,
                            lifecycle: O.COMPLETE,
                            step: e.step,
                            type: A
                        }), "center" === m.placement && u === M.RUNNING && p("index") && s !== b && d === O.INIT && h.update({
                            lifecycle: O.READY
                        }), x) {
                        const e = Z(m.target),
                            t = !!e,
                            a = t && function(e) {
                                var t;
                                if (!e) return !1;
                                let s = e;
                                for (; s && s !== document.body;) {
                                    if (s instanceof HTMLElement) {
                                        const {
                                            display: e,
                                            visibility: t
                                        } = getComputedStyle(s);
                                        if ("none" === e || "hidden" === t) return !1
                                    }
                                    s = null != (t = s.parentElement) ? t : null
                                }
                                return !0
                            }(e);
                        a ? (f("status", M.READY, M.RUNNING) || f("lifecycle", O.INIT, O.READY)) && n({
                            ...y,
                            step: m,
                            type: _
                        }) : (console.warn(t ? "Target not visible" : "Target not mounted", m), n({
                            ...y,
                            type: E,
                            step: m
                        }), o || h.update({
                            index: l + (s === w ? -1 : 1)
                        }))
                    }
                    f("lifecycle", O.INIT, O.READY) && h.update({
                        lifecycle: Y(m) || v ? O.TOOLTIP : O.BEACON
                    }), p("index") && K({
                        title: `step:${d}`,
                        data: [{
                            key: "props",
                            value: this.props
                        }],
                        debug: r
                    }), p("lifecycle", O.BEACON) && n({
                        ...y,
                        step: m,
                        type: C
                    }), p("lifecycle", O.TOOLTIP) && (n({
                        ...y,
                        step: m,
                        type: R
                    }), this.tooltip && (this.scope = new class {
                        constructor(e, t) {
                            if (g(this, "element"), g(this, "options"), g(this, "canBeTabbed", (e => {
                                    const {
                                        tabIndex: t
                                    } = e;
                                    return !(null === t || t < 0) && this.canHaveFocus(e)
                                })), g(this, "canHaveFocus", (e => {
                                    const t = e.nodeName.toLowerCase();
                                    return (/input|select|textarea|button|object/.test(t) && !e.getAttribute("disabled") || "a" === t && !!e.getAttribute("href")) && this.isVisible(e)
                                })), g(this, "findValidTabElements", (() => [].slice.call(this.element.querySelectorAll("*"), 0).filter(this.canBeTabbed))), g(this, "handleKeyDown", (e => {
                                    const {
                                        code: t = "Tab"
                                    } = this.options;
                                    e.code === t && this.interceptTab(e)
                                })), g(this, "interceptTab", (e => {
                                    e.preventDefault();
                                    const t = this.findValidTabElements(),
                                        {
                                            shiftKey: s
                                        } = e;
                                    if (!t.length) return;
                                    let n = document.activeElement ? t.indexOf(document.activeElement) : 0; - 1 === n || !s && n + 1 === t.length ? n = 0 : s && 0 === n ? n = t.length - 1 : n += s ? -1 : 1, t[n].focus()
                                })), g(this, "isHidden", (e => {
                                    const t = e.offsetWidth <= 0 && e.offsetHeight <= 0,
                                        s = window.getComputedStyle(e);
                                    return !(!t || e.innerHTML) || t && "visible" !== s.getPropertyValue("overflow") || "none" === s.getPropertyValue("display")
                                })), g(this, "isVisible", (e => {
                                    let t = e;
                                    for (; t;)
                                        if (t instanceof HTMLElement) {
                                            if (t === document.body) break;
                                            if (this.isHidden(t)) return !1;
                                            t = t.parentNode
                                        } return !0
                                })), g(this, "removeScope", (() => {
                                    window.removeEventListener("keydown", this.handleKeyDown)
                                })), g(this, "checkFocus", (e => {
                                    document.activeElement !== e && (e.focus(), window.requestAnimationFrame((() => this.checkFocus(e))))
                                })), g(this, "setFocus", (() => {
                                    const {
                                        selector: e
                                    } = this.options;
                                    if (!e) return;
                                    const t = this.element.querySelector(e);
                                    t && window.requestAnimationFrame((() => this.checkFocus(t)))
                                })), !(e instanceof HTMLElement)) throw new TypeError("Invalid parameter: element must be an HTMLElement");
                            this.element = e, this.options = t, window.addEventListener("keydown", this.handleKeyDown, !1), this.setFocus()
                        }
                    }(this.tooltip, {
                        selector: "[data-action=primary]"
                    }), this.scope.setFocus())), f("lifecycle", [O.TOOLTIP, O.INIT], O.INIT) && (null == (t = this.scope) || t.removeScope(), h.cleanupPoppers())
                }
                componentWillUnmount() {
                    var e;
                    null == (e = this.scope) || e.removeScope()
                }
                get open() {
                    const {
                        lifecycle: e,
                        step: t
                    } = this.props;
                    return Y(t) || e === O.TOOLTIP
                }
                render() {
                    const {
                        continuous: e,
                        debug: t,
                        index: s,
                        nonce: n,
                        shouldScroll: o,
                        size: i,
                        step: c
                    } = this.props, l = Z(c.target);
                    return ce(c) && r.Z.domElement(l) ? a.createElement("div", {
                        key: `JoyrideStep-${s}`,
                        className: "react-joyride__step"
                    }, a.createElement(m.Z, {
                        ...c.floaterProps,
                        component: this.renderTooltip,
                        debug: t,
                        getPopper: this.setPopper,
                        id: `react-joyride-step-${s}`,
                        open: this.open,
                        placement: c.placement,
                        target: c.target
                    }, a.createElement(be, {
                        beaconComponent: c.beaconComponent,
                        continuous: e,
                        index: s,
                        isLastStep: s + 1 === i,
                        locale: c.locale,
                        nonce: n,
                        onClickOrHover: this.handleClickHoverBeacon,
                        shouldFocus: o,
                        size: i,
                        step: c,
                        styles: c.styles
                    }))) : null
                }
            },
            xe = class extends a.Component {
                constructor(e) {
                    super(e), g(this, "helpers"), g(this, "store"), g(this, "callback", (e => {
                        const {
                            callback: t
                        } = this.props;
                        r.Z.function(t) && t(e)
                    })), g(this, "handleKeyboard", (e => {
                        const {
                            index: t,
                            lifecycle: s
                        } = this.state, {
                            steps: n
                        } = this.props, a = n[t];
                        s === O.TOOLTIP && "Escape" === e.code && a && !a.disableCloseOnEsc && this.store.close("keyboard")
                    })), g(this, "handleClickOverlay", (() => {
                        const {
                            index: e
                        } = this.state, {
                            steps: t
                        } = this.props;
                        ie(this.props, t[e]).disableOverlayClose || this.helpers.close("overlay")
                    })), g(this, "syncState", (e => {
                        this.setState(e)
                    }));
                    const {
                        debug: t,
                        getHelpers: s,
                        run: n,
                        stepIndex: a
                    } = e;
                    this.store = he({
                        ...e,
                        controlled: n && r.Z.number(a)
                    }), this.helpers = this.store.getHelpers();
                    const {
                        addListener: o
                    } = this.store;
                    K({
                        title: "init",
                        data: [{
                            key: "props",
                            value: this.props
                        }, {
                            key: "state",
                            value: this.state
                        }],
                        debug: t
                    }), o(this.syncState), s && s(this.helpers), this.state = this.store.getState()
                }
                componentDidMount() {
                    if (!D()) return;
                    const {
                        debug: e,
                        disableCloseOnEsc: t,
                        run: s,
                        steps: n
                    } = this.props, {
                        start: a
                    } = this.store;
                    le(n, e) && s && a(), t || document.body.addEventListener("keydown", this.handleKeyboard, {
                        passive: !0
                    })
                }
                componentDidUpdate(e, t) {
                    if (!D()) return;
                    const {
                        action: s,
                        controlled: n,
                        index: a,
                        lifecycle: c,
                        status: l
                    } = this.state, {
                        debug: d,
                        run: u,
                        stepIndex: m,
                        steps: h
                    } = this.props, {
                        stepIndex: p,
                        steps: g
                    } = e, {
                        reset: f,
                        setSteps: x,
                        start: S,
                        stop: _,
                        update: C
                    } = this.store, {
                        changed: R
                    } = (0, i.Z)(e, this.props), {
                        changed: H,
                        changedFrom: F
                    } = (0, i.Z)(t, this.state), L = ie(this.props, h[a]), B = !(0, o.Z)(g, h), z = r.Z.number(m) && R("stepIndex"), U = Z(L.target);
                    if (B && (le(h, d) ? x(h) : console.warn("Steps are not valid", h)), R("run") && (u ? S(m) : _()), z) {
                        let e = r.Z.number(p) && p < m ? k : w;
                        s === y && (e = b), [M.FINISHED, M.SKIPPED].includes(l) || C({
                            action: s === j ? j : e,
                            index: m,
                            lifecycle: O.INIT
                        })
                    }
                    n || l !== M.RUNNING || 0 !== a || U || (this.store.update({
                        index: a + 1
                    }), this.callback({
                        ...this.state,
                        type: E,
                        step: L
                    }));
                    const W = {
                        ...this.state,
                        index: a,
                        step: L
                    };
                    if (H("action", [k, w, T, j]) && H("status", M.PAUSED)) {
                        const e = ie(this.props, h[t.index]);
                        this.callback({
                            ...W,
                            index: t.index,
                            lifecycle: O.COMPLETE,
                            step: e,
                            type: A
                        })
                    }
                    if (H("status", [M.FINISHED, M.SKIPPED])) {
                        const e = ie(this.props, h[t.index]);
                        n || this.callback({
                            ...W,
                            index: t.index,
                            lifecycle: O.COMPLETE,
                            step: e,
                            type: A
                        }), this.callback({
                            ...W,
                            type: I,
                            step: e,
                            index: t.index
                        }), f()
                    } else F("status", [M.IDLE, M.READY], M.RUNNING) ? this.callback({
                        ...W,
                        type: P
                    }) : (H("status") || H("action", v)) && this.callback({
                        ...W,
                        type: N
                    });
                    this.scrollToStep(t), "center" === L.placement && l === M.RUNNING && c === O.INIT && this.store.update({
                        lifecycle: O.READY
                    })
                }
                componentWillUnmount() {
                    const {
                        disableCloseOnEsc: e
                    } = this.props;
                    e || document.body.removeEventListener("keydown", this.handleKeyboard)
                }
                scrollToStep(e) {
                    const {
                        index: t,
                        lifecycle: s,
                        status: n
                    } = this.state, {
                        debug: a,
                        disableScrollParentFix: o = !1,
                        scrollDuration: r,
                        scrollOffset: i = 20,
                        scrollToFirstStep: l = !1,
                        steps: d
                    } = this.props, u = ie(this.props, d[t]), m = Z(u.target), h = function(e) {
                        const {
                            isFirstStep: t,
                            lifecycle: s,
                            previousLifecycle: n,
                            scrollToFirstStep: a,
                            step: o,
                            target: r
                        } = e;
                        return !o.disableScrolling && (!t || a || s === O.TOOLTIP) && "center" !== o.placement && (!o.isFixed || !z(r)) && n !== s && [O.BEACON, O.TOOLTIP].includes(s)
                    }({
                        isFirstStep: 0 === t,
                        lifecycle: s,
                        previousLifecycle: e.lifecycle,
                        scrollToFirstStep: l,
                        step: u,
                        target: m
                    });
                    if (n === M.RUNNING && h) {
                        const e = B(m, o),
                            l = L(m, o);
                        let d = Math.floor(U(m, i, o)) || 0;
                        K({
                            title: "scrollToStep",
                            data: [{
                                key: "index",
                                value: t
                            }, {
                                key: "lifecycle",
                                value: s
                            }, {
                                key: "status",
                                value: n
                            }],
                            debug: a
                        });
                        const h = this.store.getPopper("beacon"),
                            p = this.store.getPopper("tooltip");
                        if (s === O.BEACON && h) {
                            const {
                                offsets: t,
                                placement: s
                            } = h;
                            ["bottom"].includes(s) || e || (d = Math.floor(t.popper.top - i))
                        } else if (s === O.TOOLTIP && p) {
                            const {
                                flipped: t,
                                offsets: s,
                                placement: n
                            } = p;
                            !["top", "right", "left"].includes(n) || t || e ? d -= u.spotlightPadding : d = Math.floor(s.popper.top - i)
                        }
                        d = d >= 0 ? d : 0, n === M.RUNNING && function(e, t) {
                            const {
                                duration: s,
                                element: n
                            } = t;
                            return new Promise(((t, a) => {
                                const {
                                    scrollTop: o
                                } = n, r = e > o ? e - o : o - e;
                                c.top(n, e, {
                                    duration: r < 100 ? 50 : s
                                }, (e => e && "Element already at target scroll position" !== e.message ? a(e) : t()))
                            }))
                        }(d, {
                            element: l,
                            duration: r
                        }).then((() => {
                            setTimeout((() => {
                                var e;
                                null == (e = this.store.getPopper("tooltip")) || e.instance.update()
                            }), 10)
                        }))
                    }
                }
                render() {
                    if (!D()) return null;
                    const {
                        index: e,
                        lifecycle: t,
                        status: s
                    } = this.state, {
                        continuous: n = !1,
                        debug: o = !1,
                        nonce: r,
                        scrollToFirstStep: i = !1,
                        steps: c
                    } = this.props, l = {};
                    if (s === M.RUNNING && c[e]) {
                        const s = ie(this.props, c[e]);
                        l.step = a.createElement(ke, {
                            ...this.state,
                            callback: this.callback,
                            continuous: n,
                            debug: o,
                            helpers: this.helpers,
                            nonce: r,
                            shouldScroll: !s.disableScrolling && (0 !== e || i),
                            step: s,
                            store: this.store
                        }), l.overlay = a.createElement(fe, {
                            id: "react-joyride-portal"
                        }, a.createElement(ge, {
                            ...s,
                            continuous: n,
                            debug: o,
                            lifecycle: t,
                            onClickOverlay: this.handleClickOverlay
                        }))
                    }
                    return a.createElement("div", {
                        className: "react-joyride"
                    }, l.step, l.overlay)
                }
            };
        g(xe, "defaultProps", se);
        var je = xe,
            Te = s(250),
            Se = s(36);
        const {
            vars: Pe,
            mixins: _e,
            zcolor: Ce,
            rgba: Re
        } = Se, {
            size: Ae,
            spacing: Ie,
            radius: Ne,
            color: Ee,
            layer: Oe,
            fontWeight: Me
        } = Pe, De = {
            options: {
                arrowColor: Ee.backgroundPrimary,
                backgroundColor: Ee.backgroundPrimary,
                textColor: Ee.textPrimary
            },
            tooltip: {
                borderRadius: 22,
                padding: 10
            },
            tooltipContainer: {
                textAlign: "left",
                padding: 14
            },
            tooltipTitle: Object.assign({}, {
                fontSize: 16,
                lineHeight: 1.5,
                letterSpacing: 0
            }, {
                marginBottom: 10
            }),
            tooltipContent: Object.assign({}, {
                fontSize: 14,
                lineHeight: 1.4285714285714286,
                letterSpacing: -.01
            }, {
                padding: 0
            }),
            buttonNext: Object.assign({}, {
                fontSize: 16,
                lineHeight: 1.75,
                letterSpacing: -.016
            }, {
                backgroundColor: Re("#1C82FB", .1),
                color: "#1C82FB",
                width: 160,
                height: 44,
                textAlign: "center",
                borderRadius: 12,
                fontWeight: "600"
            }),
            buttonBack: Object.assign({}, {
                fontSize: 16,
                lineHeight: 1.75,
                letterSpacing: -.016
            }, {
                color: "#1C82FB",
                width: 160,
                height: 44,
                textAlign: "center",
                fontWeight: "600"
            }),
            overlay: {
                backgroundColor: "rgba(0,0,0,.6)"
            },
            spotlight: {
                borderRadius: 20
            }
        };
        var He, Fe, Ze = s(1);
        const Le = n.Hocs.compose()((e => {
                const {
                    steps: t,
                    onFinish: s
                } = e, a = n.Hooks.useIntl(), o = n.React.useContext(Te.w), r = t.map((({
                    testId: e,
                    title: t,
                    content: s,
                    disableScrolling: n = !0
                }, a) => ({
                    target: '[data-testid="' + e + '"]',
                    title: t,
                    content: s,
                    disableScrolling: n,
                    disableScrollParentFix: n,
                    disableBeacon: 0 === a
                }))), [i, c] = n.React.useState(!1);
                return n.Hooks.useEventListener({
                    eventName: "keydown",
                    handler: e => {
                        i && (e.preventDefault(), e.stopPropagation())
                    },
                    shouldCapture: !0
                }), (0, Ze.jsx)(je, {
                    stepIndex: e._stepIndex,
                    steps: r,
                    locale: {
                        back: a.f.fd,
                        close: a.f.fh,
                        last: a.f.fy,
                        next: a.f.fD,
                        open: a.f.fC,
                        skip: a.f.f3
                    },
                    continuous: !0,
                    spotlightPadding: 8,
                    styles: De,
                    disableScrolling: !0,
                    disableScrollParentFix: !0,
                    callback: e => {
                        const {
                            action: t,
                            status: n,
                            lifecycle: a
                        } = e;
                        c("init" !== a), "next" === t && "finished" === n ? s && s(!0) : "close" === t && "complete" === a && s && s(!1)
                    },
                    disableOverlayClose: !0,
                    disableCloseOnEsc: !0,
                    nonce: o
                })
            })),
            Be = e => (0, Ze.jsx)("strong", {
                children: e.children
            }),
            ze = e => (0, Ze.jsx)("em", {
                children: e.children
            }),
            Ue = () => (0, Ze.jsxs)(Ze.Fragment, {
                children: [He || (He = (0, Ze.jsx)("br", {})), Fe || (Fe = (0, Ze.jsx)("br", {}))]
            })
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => n
        });
        const n = new Proxy({}, {
            get: (e, t) => t
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            R: () => r,
            d: () => i
        });
        var n = s(95);
        let a = !1,
            o = [];

        function r(e) {
            a ? e() : o.push(e)
        }

        function i() {
            a || (a = !0, o.forEach((e => e())), o = [])
        }
        setTimeout((() => {
            a || ((0, n.Z)(n.p.SAFE_LITERAL).warn("utils/react.afterLaunch timeout"), i())
        }), 4e3)
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(13),
            o = s(11),
            r = s(18);
        s(2), s(3);
        const i = s(517);
        var c = s(1);
        const l = n.ReactUtils.lazy((() => s(71))),
            d = e => {
                const {
                    onPress: t,
                    onLongPress: s,
                    children: d,
                    icon: u,
                    fullWidth: m,
                    testId: h,
                    accessibilityLabel: p,
                    keyboardShortcutID: g,
                    contentRef: f
                } = e, b = n.Styling.factoryColor(e.color || "purple");
                return (0, c.jsx)(l, {
                    keyboardShortcutID: g,
                    renderLabel: p,
                    arrowPosition: "horizontal",
                    timeToActivite: 500,
                    children: (0, c.jsxs)("div", {
                        className: i.root + (!d && u ? " " + i.iconOnly : "") + " " + (e.className || ""),
                        style: Object.assign({
                            backgroundColor: b
                        }, e.style),
                        children: [(0, c.jsx)("div", {
                            className: i.shadow,
                            style: {
                                boxShadow: "0 2px 12px " + b,
                                shadowColor: b,
                                backgroundColor: null
                            }
                        }), (0, c.jsxs)(o.Z, {
                            className: i.touchable + (u && d ? " " + i.touchableWithIconAndText : "") + (m ? " " + i.fullWidth : ""),
                            ref: f,
                            onPress: t,
                            onLongPress: s,
                            androidBorderless: !0,
                            accessibilityLabel: p,
                            testId: h,
                            children: [d ? (0, c.jsx)(r.default, {
                                className: i.text,
                                children: d
                            }) : null, u ? (0, c.jsx)(a.default, {
                                name: u,
                                color: "surface",
                                size: 30
                            }) : null]
                        })]
                    })
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(11);
        s(2), s(3);
        const o = s(576);
        var r = s(1);
        const i = e => (0, r.jsx)(a.Z, {
                className: o.linkWrapper,
                onPress: e.onPress,
                children: e.children
            }),
            c = n.Hocs.compose()((e => {
                const {
                    task: t
                } = e, s = n.Hooks.useGoToTask(), a = t.name.length > 40 ? t.name.substring(0, 40) + "…" : t.name;
                return (0, r.jsx)(i, {
                    onPress: () => s(t),
                    children: a
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => g
        });
        var n = s(0),
            a = s(823),
            o = s(853),
            r = s(1462),
            i = s(1461),
            c = s(1);
        const l = ["second", "minute", "hour"],
            d = e => {
                const {
                    unit: t,
                    value: s
                } = e;
                return (0, c.jsx)(i.Z, {
                    unit: t,
                    value: s,
                    style: "short",
                    updateIntervalInSeconds: 60,
                    numeric: "auto"
                })
            };
        s(2), s(3);
        const u = s(674),
            m = n.FP.omit(["year"]),
            h = {
                day: "numeric",
                month: "short",
                year: "2-digit"
            },
            p = {
                day: "numeric",
                month: "2-digit",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
            },
            g = n.Hocs.compose(n.Hocs.withIntl)((e => {
                const {
                    intl: t,
                    date: s,
                    showTime: n,
                    showCurrentYear: i,
                    format: g = h
                } = e, f = i || (0, a.Z)(s, Date.now()) ? g : m(g), {
                    value: b,
                    unit: y
                } = (0, r.W)(s.getTime());
                return (0, c.jsx)("span", {
                    className: u.textWithTitle + " " + (e.className || ""),
                    style: e.style,
                    title: t.formatDate(s, p),
                    children: l.includes(y) ? (0, c.jsx)(d, {
                        value: b,
                        unit: y
                    }) : (0, c.jsxs)(c.Fragment, {
                        children: [(0, c.jsx)(o.Ji, Object.assign({
                            value: s
                        }, f)), n ? (0, c.jsxs)(c.Fragment, {
                            children: [" ", (0, c.jsx)(o.qN, {
                                value: s
                            })]
                        }) : null]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(52),
            a = s(0),
            o = s(77),
            r = s(1);
        const i = ["variant"],
            c = a.Hocs.compose()((e => {
                const {
                    variant: t
                } = e, s = (0, n.Z)(e, i), c = a.Hooks.useIntl(), [l, d, u] = "follow" === t ? ["±", "activity", c.f.fx] : ["Á", "red", c.f.AK];
                return (0, r.jsx)(o.Z, Object.assign({
                    label: u,
                    icon: l,
                    iconColor: d,
                    colorActive: "purple"
                }, s))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            A: () => i,
            C: () => c
        });
        var n = s(19),
            a = s(16),
            o = s(39),
            r = s(8);

        function i(e, t, s, n, a) {
            return Array.from((0, o.calculateReorders)(e, t, s, (e => {
                const t = n[e.id];
                return null == t ? void 0 : t.position
            }))).map((([e, t]) => {
                const s = n[e.id];
                return s ? s.preparePositionUpdate(t) : e.do.createTaskPosition(a, t)
            }))
        }

        function c(e, t) {
            return t.get(a.w.taskPositions).query(n.Q.where(a.o.taskPositions.listId, e)).observeWithColumns([a.o.taskPositions.position]).pipe((0, r.map)((e => e.reduce(((e, t) => (e[t.task.id] = t, e)), {}))))
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            uT: () => o,
            v: () => r,
            zt: () => a
        });
        var n = s(377);

        function a(e, t) {
            (0, n.O7)(e, {
                data: t
            })
        }

        function o(e, t = "error") {
            (0, n.O7)(e, {
                data: {
                    level: t
                }
            })
        }

        function r(e, t, s) {
            (0, n.bO)((n => Object.assign({}, n, {
                tags: {
                    launch_id: e,
                    workspaces: s.map((e => e.id)).join(", ")
                },
                user: {
                    id: null == t ? void 0 : t.id
                }
            })))
        }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            ej: () => c,
            oD: () => d,
            uu: () => l
        });
        var n = s(0),
            a = s(11),
            o = s(18),
            r = s(428),
            i = s(1);
        const c = e => {
                const {
                    color: t,
                    variant: s = "standard",
                    isDisabled: o,
                    isFullWidth: c = !0,
                    onPress: l,
                    children: d,
                    accessibilityLabel: u,
                    modalWebTarget: m,
                    type: h
                } = e;
                return (0, i.jsx)(a.Z, {
                    className: r.Z.root + (c ? " " + r.Z.fullWidth : "") + " " + (e.className || ""),
                    style: Object.assign({}, (() => {
                        if (t) {
                            const e = n.Styling.factoryColorOrLiteral(t);
                            return Object.assign({
                                backgroundColor: (() => {
                                    switch (s) {
                                        case "standard":
                                            return n.Styling.rgba(e, .06);
                                        case "opaque":
                                            return e;
                                        case "text":
                                            return "transparent";
                                        default:
                                            throw new Error("Unknown EntryButton variant: " + s)
                                    }
                                })(),
                                borderColor: n.Styling.factoryColor("transparent"),
                                opacity: o ? .7 : 1
                            }, {
                                boxShadow: "unset"
                            })
                        }
                        return {}
                    })(), e.style),
                    ref: m,
                    isDisabled: o,
                    onPress: l,
                    accessibilityLabel: u,
                    type: h,
                    children: d
                })
            },
            l = (e, t = "standard") => "opaque" === t ? "backgroundPrimary" : e || "textPrimary",
            d = e => {
                const {
                    label: t,
                    color: s,
                    isDisabled: a
                } = e;
                return (0, i.jsx)(o.default, {
                    className: r.Z.text + (a ? " " + r.Z.disabledText : "") + " " + (e.className || ""),
                    style: Object.assign({
                        color: n.Styling.factoryColorOrLiteral(s)
                    }, e.style),
                    children: t
                })
            }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            R: () => l
        });
        var n = s(0),
            a = s(12),
            o = s(6),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                team: t,
                onConfirm: s,
                onClose: i,
                isDisabling: c
            } = e, l = n.Hooks.useIntl(), d = e => {
                s(e), i()
            }, u = (0, r.jsx)(o.u_.Emphasis, {
                children: t.name
            }, "teamName");
            return (0, r.jsxs)(o.u_, {
                onClose: i,
                level: 20,
                children: [(0, r.jsx)(o.u_.Header, {
                    children: c ? l.f.n5 : l.f.nD
                }), (0, r.jsxs)(o.u_.Content, {
                    children: [(0, r.jsx)(o.u_.Paragraph, {
                        children: c ? l.g("n4", {
                            teamName: u
                        }) : l.g("nC", {
                            teamName: u
                        })
                    }), (0, r.jsxs)(o.u_.Buttons, {
                        children: [(0, r.jsx)(a.default, {
                            label: l.f.nA,
                            onPress: () => d(!0)
                        }), (0, r.jsx)(a.default, {
                            label: l.f.nB,
                            onPress: () => d(!1)
                        })]
                    })]
                })]
            })
        }));
        var c = s(1555);

        function l({
            team: e,
            state: t,
            connectUrl: s,
            disconnect: a
        }) {
            const o = n.Hooks.useServices(),
                l = n.Hooks.useRemindExpired(n.FP.noop, e),
                d = n.Hooks.useAsyncState(),
                u = n.Hooks.useAsyncFetcherWithParams(d, (async ({
                    params: {
                        isForAllSpaces: e
                    },
                    isPending: t
                }) => {
                    const a = await s(e);
                    t() && n.ReactUtils.openUrl(a, n.Misc.isElectron ? "_blank" : "_self")
                })),
                m = n.Hooks.useAsyncFetcherWithParams(d, (async ({
                    params: {
                        isForAllSpaces: e
                    }
                }) => {
                    await a(e), await o.sync.synchronize()
                })),
                [h, p] = n.Hooks.useStateMachine(),
                g = p(null);
            return {
                request: d,
                connect: l((async () => {
                    invariant(!(null != t && t.enabled), "Can't connect integration if already connected"), await n.Rx.takeFirst(o.modelRoot.hasManyActiveTeams) ? p("connecting_spaces")() : u({
                        params: {
                            isForAllSpaces: !1
                        }
                    })
                })),
                disconnect: async () => {
                    invariant(null == t ? void 0 : t.enabled, "Can't disconnect integration if not connected"), t.is_for_all_spaces ? p("disconnecting_spaces")() : p("disconnecting_finalConfirm", !1)()
                },
                render: () => h.map({
                    connecting_spaces: () => (0, r.jsx)(i, {
                        team: e,
                        isDisabling: !1,
                        onConfirm: async e => {
                            await u({
                                params: {
                                    isForAllSpaces: e
                                }
                            })
                        },
                        onClose: g
                    }),
                    disconnecting_spaces: () => (0, r.jsx)(i, {
                        team: e,
                        isDisabling: !0,
                        onConfirm: e => {
                            p("disconnecting_finalConfirm", e)()
                        },
                        onCancel: g,
                        onClose: n.FP.noop
                    }),
                    disconnecting_finalConfirm: t => (0, r.jsx)(c.Z, {
                        team: t ? null : e,
                        onConfirm: async () => {
                            await m({
                                params: {
                                    isForAllSpaces: t
                                }
                            })
                        },
                        onCancel: g,
                        onClose: g
                    })
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(13),
            o = s(741);
        s(2), s(3);
        const r = s(746);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                text: t,
                icon: s = "Ų",
                color: c = "darkgreen",
                right: l
            } = e, {
                isNarrowerThan: d
            } = n.Hooks.useLayoutVariant(), u = n.Hooks.useDesktopLayout();
            return (0, i.jsxs)(o.Z, {
                className: r.root + "",
                isDesktop: u,
                children: [(0, i.jsxs)("div", {
                    className: r.content + " " + r.contentFullWidth,
                    children: [(0, i.jsx)(a.default, {
                        className: r.icon,
                        name: s,
                        color: c,
                        size: 28
                    }), (0, i.jsx)("span", {
                        className: r.text,
                        children: t
                    })]
                }), l ? (0, i.jsx)("div", {
                    className: r.rightContent + "",
                    children: l
                }) : null]
            })
        }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(191);

        function a(e) {
            return new Promise((t => {
                (0, n.Z)().alert(e), t()
            }))
        }
    }, , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            C: () => o,
            Z: () => a
        });
        let n = null;

        function a() {
            return n || globalThis
        }

        function o(e) {
            e.addEventListener("focus", (() => {
                n = e
            }))
        }
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(52),
            a = s(0),
            o = s(90),
            r = s(45),
            i = s(356),
            c = s(13);
        s(2), s(3);
        const l = s(528);
        var d = s(1);
        const u = ["accentColor", "hoverIcon", "isSaved", "errors", "selectionColor", "leftIcon"],
            m = a.React.forwardRef(((e, t) => {
                const {
                    accentColor: s = "purple",
                    hoverIcon: m = "Ƥ",
                    isSaved: h = !1,
                    errors: p,
                    selectionColor: g,
                    leftIcon: f
                } = e, b = (0, n.Z)(e, u), {
                    isDisabled: y
                } = b, {
                    isFocused: v,
                    hasErrors: w,
                    onFocus: k,
                    onBlur: x
                } = (0, i.m)(p), [j, T] = a.React.useState(!1), [S, P] = a.React.useState(), _ = a.React.useRef();
                a.React.useEffect((() => h ? (P(!0), _.current = setTimeout((() => P(!1)), 5e3), () => clearTimeout(_.current)) : (P(!1), a.FP.noop)), [h]);
                const C = (() => {
                        if ((w || v) && !y) {
                            if (w) return "red";
                            if (v) return s
                        }
                        return null
                    })(),
                    R = C ? {
                        borderColor: a.Styling.factoryColor(C)
                    } : void 0;
                return (0, d.jsxs)("div", {
                    className: l.root,
                    children: [(0, d.jsxs)("div", {
                        className: l.wrapper + (e.isDisabled ? " " + l.disabled : ""),
                        style: R,
                        children: [f ? (0, d.jsx)(c.default, {
                            name: f,
                            color: "onBackground3",
                            size: 22
                        }) : null, (0, d.jsx)(o.Z, Object.assign({
                            className: l.input
                        }, b, {
                            ref: t,
                            selectionColor: null != g ? g : s,
                            onChange: t => {
                                P(!1), null == e.onChange || e.onChange(t)
                            },
                            onFocus: t => {
                                k(), null == e.onFocus || e.onFocus(t)
                            },
                            onBlur: async () => {
                                x(), await (null == e.onBlur ? void 0 : e.onBlur())
                            },
                            onMouseEnter: t => {
                                T(!0), null == e.onMouseEnter || e.onMouseEnter(t)
                            },
                            onMouseLeave: t => {
                                T(!1), null == e.onMouseLeave || e.onMouseLeave(t)
                            }
                        })), (0, d.jsx)(c.default, {
                            className: l.icon + (y || v || !j || S ? "" : " " + l.iconVisible),
                            name: m,
                            color: "textSecondary",
                            size: 24
                        }), (0, d.jsx)(c.default, {
                            className: l.icon + (S ? " " + l.iconVisible : ""),
                            name: "]",
                            color: s,
                            size: 24
                        })]
                    }), p ? (0, d.jsx)(r.InputErrors, {
                        messages: p
                    }) : null]
                })
            })),
            h = a.Hocs.compose()(m)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            B: () => d,
            G5: () => i,
            Ny: () => h,
            bg: () => u,
            tw: () => l,
            vJ: () => c
        });
        var n = s(0),
            a = s(1);
        const o = s(105).wx,
            r = (e, t) => {
                const s = n.Hooks.useServices(),
                    a = n.Hooks.useModalState(),
                    o = n.Hooks.useDisplayTeam(),
                    r = a.open;
                return {
                    modal: a,
                    open: n.React.useCallback((async n => {
                        await s.payments.invokeActionOrProposeUpgrade({
                            name: t,
                            currentTeam: e
                        }, (() => {
                            r(n)
                        })) || o(e)
                    }), [t, r, o, s.payments, e])
                }
            };

        function i(e, t) {
            const {
                modal: s,
                open: i
            } = r(e, null != t && t.isTemplate ? "create-project-template" : "create-projects");
            return {
                open: i,
                render: n.Hooks.useModalRenderer(s, (n => {
                    var r, i;
                    const c = null != (r = null == (i = n.context) ? void 0 : i.initialProjectGroups) ? r : null == t ? void 0 : t.initialProjectGroups;
                    return (0, a.jsx)(o.Project, {
                        bundle$close: s.close,
                        team: e,
                        onClose: s.close,
                        shouldRedirectToNewProject: !0,
                        isCreatingTemplate: null == t ? void 0 : t.isTemplate,
                        initialGroups: c
                    })
                }))
            }
        }

        function c(e) {
            const {
                modal: t,
                open: s
            } = r(e, "create-project-group");
            return {
                render: n.Hooks.useModalRenderer(t, (() => (0, a.jsx)(o.Group, {
                    bundle$close: t.close,
                    team: e,
                    onClose: t.close,
                    groupType: "project"
                }))),
                open: s
            }
        }

        function l(e) {
            const {
                modal: t,
                open: s
            } = r(e, "create-member-group");
            return {
                render: n.Hooks.useModalRenderer(t, (() => (0, a.jsx)(o.Group, {
                    bundle$close: t.close,
                    team: e,
                    onClose: t.close,
                    groupType: "member"
                }))),
                open: s
            }
        }

        function d(e) {
            const {
                modal: t,
                open: s
            } = r(e, "create-any-tag");
            return {
                render: n.Hooks.useModalRenderer(t, (() => (0, a.jsx)(o.Tag, {
                    bundle$close: t.close,
                    team: e,
                    shouldRedirectToNewTag: !0,
                    onClose: t.close
                }))),
                open: s
            }
        }

        function u(e, t) {
            const o = n.Hooks.useModalState();
            return {
                render: n.Hooks.useModalRenderer(o, ((n, r) => {
                    const i = s(223).default;
                    return (0, a.jsx)(i, {
                        team: e,
                        onClose: o.close,
                        level: null == r ? void 0 : r.level,
                        onBeforeDone: t
                    })
                })),
                open: o.open
            }
        }
        const m = (e, t) => {
            const s = n.Hooks.useServices(),
                a = n.Hooks.useModalState(),
                o = a.open;
            return {
                modal: a,
                open: n.React.useCallback((async n => {
                    await s.payments.invokeActionOrProposeUpgrade({
                        name: t,
                        currentTeam: e
                    }, (() => {
                        o(n)
                    }))
                }), [t, o, s.payments, e])
            }
        };

        function h(e, t) {
            const {
                modal: s,
                open: r
            } = m(e, null != t && t.isTemplate ? "create-project-template" : "create-projects");
            return {
                open: r,
                render: n.Hooks.useModalRenderer(s, (s => {
                    var n;
                    const {
                        context: r
                    } = s;
                    return (0, a.jsx)(o.Project, {
                        bundle$close: s.close,
                        team: e,
                        onClose: s.close,
                        shouldRedirectToNewProject: !0,
                        isCreatingTemplate: null == t ? void 0 : t.isTemplate,
                        initialGroups: null != (n = null == r ? void 0 : r.initialProjectGroups) ? n : null == t ? void 0 : t.initialProjectGroups
                    })
                }))
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o,
            x: () => a
        });
        var n = s(9);
        const a = (0, n.createContext)(void 0);

        function o() {
            return (0, n.useContext)(a)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n = s(0);
        s(9), s(2), s(3);
        const a = s(451);
        var o = s(1);
        const r = e => (0, o.jsx)("div", {
                className: a.background,
                style: e.style,
                children: e.children
            }),
            i = e => {
                const {
                    left: t,
                    width: s
                } = e;
                return (0, o.jsx)(r, {
                    style: {
                        left: t,
                        width: s
                    }
                })
            },
            c = s(452),
            l = n.ReactUtils.lazy((() => s(1225))),
            d = n.ReactUtils.lazy((() => s(1226))),
            u = e => {
                const {
                    selectedOptionId: t,
                    options: s,
                    selectOption: n,
                    isDisabled: a = !1,
                    buttonStyle: r = "small",
                    activeColor: u,
                    __webFixBlurEventOrder: m
                } = e, h = s.findIndex((e => e.id === t)), p = h / s.length * 100, g = "small" === r ? l : d;
                return (0, o.jsxs)("div", {
                    className: c.root + " " + (e.className || ""),
                    style: e.style,
                    children: [s.map((({
                        id: e,
                        label: t,
                        subLabel: s,
                        color: r,
                        icon: i,
                        customIconComponent: c,
                        badge: l
                    }, d) => {
                        const p = h === d;
                        return (0, o.jsx)(g, {
                            onPress: (e, t) => {
                                n(e, t), null == l || null == l.dismiss || l.dismiss()
                            },
                            onPressExtraParam: e,
                            label: t,
                            subLabel: s,
                            color: null != r ? r : p && u || "purple",
                            icon: i,
                            badge: l,
                            customIconComponent: c,
                            isActive: p,
                            isDisabled: a,
                            __webFixBlurEventOrder: m
                        }, e)
                    })), (0, o.jsx)(i, {
                        left: p + "%",
                        width: 100 / s.length + "%"
                    })]
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            j: () => r
        });
        s(0);
        var n = s(161);
        s(2), s(3);
        const a = s(711);
        var o = s(1);
        const r = ({
            isActive: e,
            isIndeterminate: t,
            isDisabled: s,
            isCheckboxDisabled: r,
            onPress: i,
            onPressExtraParam: c,
            color: l,
            hasChecklistStyle: d
        }, {
            isOnRight: u
        }) => () => (0, o.jsx)("div", {
            className: a.checkboxContainer + (u ? " " + a.isOnRight : ""),
            children: (0, o.jsx)(n.Z, {
                isChecked: e,
                isIndeterminate: t,
                isDisabled: s || r,
                onPress: i,
                color: l,
                onPressExtraParam: c,
                hasChecklistStyle: d
            })
        })
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(14),
            o = s(79),
            r = s(132),
            i = s(91),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.withWebLazyRender((({
            isBelowTheFold: e
        }) => ({
            forceShow: !e,
            spacerHeight: 40
        }))), n.Hocs.memo, n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            project: e,
            team: e.currentTeam,
            isPrivate: e.permissions.isPrivate,
            groups: e.groups
        }))))((e => {
            const {
                project: t,
                isPrivate: s,
                team: l,
                showCounter: d,
                hasDescription: u,
                hasHairline: m,
                onPress: h,
                groups: p,
                showFavFollowIcon: g = !0,
                highlightRanges: f,
                onLongPress: b
            } = e, y = n.Hooks.useIntl(), v = u ? ((e, t, s) => e.endedAt ? s.g("Ee", {
                date: s.formatDate(e.endedAt)
            }) : (0, r.S)(t))(t, p, y) : null, {
                isShared: w,
                hasPendingInvitation: k,
                isFavorite: x,
                isFollowed: j
            } = t, T = w || k ? "Ĺ" : s ? "ŀ" : null, S = n.Styling.getProjectName(t, y);
            return (0, c.jsx)(o.Z, {
                linkTo: (0, a.smartPathToProject)(l, t),
                title: S,
                formattedTitle: f ? (0, c.jsx)(i.Z, {
                    text: S,
                    ranges: f
                }) : S,
                onPress: h,
                isEnded: t.isEnded,
                icon: n.Styling.getProjectIcon(t),
                isFavorite: x,
                isFollowed: j,
                showFavFollowIcon: g,
                iconColor: n.Styling.getProjectIconColor(t),
                counter: d ? t.activeTasks.observeCount() : null,
                description: v,
                hasHairline: m,
                statusIcon: T,
                statusIconColor: k && !w ? "onBackground2" : void 0,
                hasUnreadDot: !t.lastSeenEventAt,
                onLongPress: b
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Ve: () => i,
            yL: () => c,
            P$: () => l,
            Hn: () => m,
            Rw: () => u
        });
        var n = s(0),
            a = s(131),
            o = s(1306),
            r = s(109);
        const i = async (e, t) => {
            if (globalThis.electron && await globalThis.electron.revealIfDownloaded(e.name, e.size)) return [Promise.resolve(), n.Rx.of(1)];
            const [s, a] = t.api.attachments.downloadAttachmentAsBlob(e);
            return s.then((t => {
                n.ReactUtils.downloadBlob(t, e.name)
            })), [s.then(n.FP.noop), a]
        };

        function c(e, t) {
            const s = e.asExternalAttachment;
            if (!s) return [];
            const [a, o] = l(s);
            switch (s.integration) {
                case r.md.Evernote: {
                    const {
                        metadata: e
                    } = s;
                    return [{
                        label: t.f.eV,
                        icon: a,
                        color: o,
                        trigger: () => n.ReactUtils.openUrl(e.app_link, n.Misc.isElectron ? "_blank" : "_self")
                    }, {
                        label: t.f.eT,
                        icon: "Ş",
                        trigger: () => n.ReactUtils.openUrl(e.link, "_blank")
                    }]
                }
                case r.md.Dropbox: {
                    const {
                        metadata: {
                            link: e
                        }
                    } = s;
                    return e ? [{
                        label: t.f.eU,
                        icon: a,
                        color: o,
                        trigger: () => n.ReactUtils.openUrl(e)
                    }] : []
                }
                case r.md.GoogleDrive: {
                    const {
                        metadata: {
                            webview_link: e
                        }
                    } = s;
                    return [{
                        label: t.f.eW,
                        icon: a,
                        color: o,
                        trigger: () => n.ReactUtils.openUrl(e)
                    }]
                }
                case r.md.OneDrive: {
                    const {
                        metadata: {
                            link: e
                        }
                    } = s;
                    return e ? [{
                        label: t.f.eX,
                        icon: a,
                        color: o,
                        trigger: () => n.ReactUtils.openUrl(e)
                    }] : []
                }
                default:
                    throw new Error('Unsupported integration "' + s.integration + '"')
            }
        }

        function l(e) {
            switch (e.integration) {
                case r.md.Evernote:
                    return ["©", "avatarColor4"];
                case r.md.Dropbox:
                    return ["¢", "blue"];
                case r.md.GoogleDrive:
                    return ["º", "brown"];
                case r.md.OneDrive:
                    return ["ŝ", "lightblue"];
                default:
                    throw new Error('Unsupported integration "' + e.integration + '"')
            }
        }
        const d = 100 * a.MB;

        function u(e) {
            if (!(0, o.X)(e.mimeType)) return !1;
            if (0 >= e.size) return !1;
            const t = e.asExternalAttachment;
            if (t) switch (t.integration) {
                case r.md.Evernote:
                    return !0;
                case r.md.Dropbox:
                case r.md.OneDrive:
                    return t.size <= d;
                default:
                    return !1
            }
            return !0
        }

        function m(e) {
            return !e.asExternalAttachment || !1
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(0);
        const a = n.Hocs.compose()((e => {
            const {
                children: t
            } = e, s = 850 < n.Hooks.useServices().performance.bundleLaunchTime, [a, o] = n.React.useState(!s);
            return n.React.useEffect((() => {
                s && setTimeout((() => {
                    o(!0)
                }), 10)
            }), []), a ? t : null
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            A: () => d,
            n: () => l
        });
        var n = s(19),
            a = s(16),
            o = s(8),
            r = s(39),
            i = s(5),
            c = s(477);

        function l(e, t) {
            return t.get(a.w.projectPositions).query(n.Q.where(a.o.projectPositions.listId, e)).observeWithColumns([a.o.projectPositions.position]).pipe((0, o.map)((e => e.reduce(((e, t) => (e[t.project.id] = t, e)), {}))))
        }

        function d({
            draggedItem: e,
            items: t,
            destinationIdx: s,
            projectsPositionMap: n,
            viewId: a
        }) {
            return Array.from((0, r.calculateReorders)(e, (0, i.toWritableArray)(t), s, (e => {
                if (e instanceof c.Z) {
                    const t = n[e.id];
                    return null == t ? void 0 : t.position
                }
                return null
            }))).reduce(((e, [t, s]) => {
                if (!(t instanceof c.Z)) return e;
                const o = n[t.id];
                return o ? e.push(o.preparePositionUpdate(s)) : e.push(t.do.createProjectPosition(a, s)), e
            }), [])
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(509)]).then(s.bind(s, 1499))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            PA: () => l,
            ZP: () => r,
            _O: () => c
        });
        var n = s(9),
            a = s(54),
            o = s(5);
        s(4);

        function r(e) {
            var t, s, r;
            const c = a.useServices(),
                l = a.useIsMounted(),
                [m, h] = function({
                    registerId: e,
                    inviteId: t,
                    joinCode: s,
                    projectInvitationToken: n,
                    taskInvitationToken: a,
                    loginProviderToken: o,
                    teamCodeToken: r,
                    teamInvitationToken: i,
                    accountUpgradeToken: c
                }) {
                    if (s) return [s, "team_code"];
                    if (t) return [t, "team_invitations"];
                    if (e) return [e, "signup_invitations"];
                    if (n) return [n, "project_invitations"];
                    if (a) return [a, "task_invitations"];
                    if (o) return [o, "login_providers"];
                    if (r) return [r.id, "team_code"];
                    if (i) return [i.id, "team_invitations"];
                    if (c) return [c.id, "account_upgrade"];
                    return null
                }(e) || [],
                p = !m || !h,
                g = !p && d(h),
                [f, b] = a.useStateResettable(g ? {
                    status: "not_checked",
                    payload: void 0
                } : {
                    status: "valid",
                    payload: void 0
                }, [g]),
                y = n.useMemo((() => p ? null : Object.assign({
                    id: m,
                    type: h
                }, f)), [m, h, p, f]),
                v = n.useCallback((async () => {
                    try {
                        if (p || !d(h)) return;
                        const t = await (async () => {
                            switch (h) {
                                case "project_invitations":
                                    return c.api.share.fetchProjectInvitation(m);
                                case "task_invitations":
                                    return c.api.share.getTaskInvitation(m);
                                case "account_upgrade": {
                                    var t;
                                    const s = null == (t = e.accountUpgradeToken) ? void 0 : t.payload;
                                    return invariant(s, "Missing account upgrade token payload"), s
                                }
                                case "team_code":
                                    var s;
                                    return null == (s = e.teamCodeToken) ? void 0 : s.payload;
                                case "team_invitations": {
                                    var n;
                                    const t = null == (n = e.teamInvitationToken) ? void 0 : n.payload;
                                    try {
                                        const e = await c.api.account.getAccountToken({
                                            tokenId: m,
                                            tokenType: h
                                        });
                                        return Object.assign({}, e, {
                                            existingInvitationPayload: t
                                        })
                                    } catch (e) {
                                        var a;
                                        if (443 !== (null == (a = e.originalResponse) ? void 0 : a.status)) throw e;
                                        const s = Object.assign({}, i(e), t);
                                        if (null != t && t.apiToken) return s;
                                        throw new u(s)
                                    }
                                }
                                default:
                                    try {
                                        return await c.api.account.getAccountToken({
                                            tokenId: m,
                                            tokenType: h
                                        })
                                    } catch (e) {
                                        var o;
                                        throw 443 === (null == (o = e.originalResponse) ? void 0 : o.status) ? new u(i(e)) : e
                                    }
                            }
                        })();
                        l.current && b({
                            status: "valid",
                            payload: t
                        })
                    } catch (e) {
                        if (!l.current) return;
                        b(e instanceof u ? {
                            status: "conflict",
                            payload: e.payload
                        } : {
                            status: "invalid",
                            error: o.wrapError(e)
                        })
                    }
                }), [p, h, l, b, c.api.share, c.api.account, m, null == (t = e.accountUpgradeToken) ? void 0 : t.payload, null == (s = e.teamCodeToken) ? void 0 : s.payload, null == (r = e.teamInvitationToken) ? void 0 : r.payload]);
            return n.useEffect((() => {
                g && v()
            }), [g, v]), [y, v]
        }

        function i(e) {
            return {
                email: e.json.email,
                teamName: e.json.team_name,
                teamId: e.json.team_id,
                inviterName: e.json.inviter_name,
                inviterEmail: e.json.inviter_email,
                inviterAvatarUrl: e.json.inviter_avatar_url,
                teamAvatarUrl: e.json.team_avatar_url,
                providers: e.json.providers
            }
        }

        function c(e) {
            return "team_code" === e.type || "team_invitations" === e.type || "signup_invitations" === e.type
        }

        function l(e) {
            return "team_code" === e.type || "team_invitations" === e.type || "task_invitations" === e.type || "project_invitations" === e.type
        }

        function d(e) {
            return "login_providers" !== e
        }
        class u extends Error {
            constructor(e) {
                super(), this.payload = e
            }
        }
    }, (e, t, s) => {
        "use strict";
        let n, a;
        if (s.d(t, {
                Z: () => o,
                i: () => a
            }), "undefined" != typeof Proxy) {
            const e = e => new Proxy({}, {
                get: (t, s) => {
                    throw new Error(e + "." + s + " checked at runtime (bad)")
                }
            });
            n = e("hasFeature"), a = e("hasFeatureOnProd")
        }
        const o = n
    }, , (e, t, s) => {
        let n = s(422);
        const a = n;
        n = JSON.parse(JSON.stringify(n)), n.color = a.color, n.theme = a.theme, n.theme.dark.backgroundPrimary = "#171717", n.theme.dark.backgroundSecondary = "#171717", n.font.size.body = 14, n.font.size.caption = 12, n.font.lineHeight.body = 20, n.font.size.teamSwitchNew = 11, n.font.lineHeight.teamSwitchNew = 14, n.avatar.size.teamSwitch = 36, n.avatar.size.small = 26, n.avatar.size.entry = 144, n.avatar.fontSize.teamSwitch = 14, n.avatar.fontSize.entry = 47, n.avatar.dotSize.teamSwitch = 12, n.avatar.dotSize.entry = 24, n.avatar.teamRadius.teamSwitch = 12, n.size.teamSwitch = 80, n.size.sidebar.width = 314, n.size.sidebar.teamSwitch.width = 80, n.size.sidebar.teamSwitch.height = 66, n.size.sidebar.teamSwitch.highlight = 44, n.size.sidebar.teamSwitch.highlightNew = 44, n.size.sidebar.item.height = 40, n.size.sidebar.item.content = 32, n.size.sidebar.item.icon = 22, n.size.sidebar.item.rightContainer = 32, n.size.sidebar.item.iconContainer = 20, n.size.sidebar.group.title = 36, n.size.sidebar.box.height = 75, n.size.sidebar.box.heightDense = 66, n.size.sidebar.box.icon = 22, n.size.sidebar.banner.closeButton.size = 28, n.size.sidebar.banner.closeButton.icon = 22, n.size.header = 56, n.size.task = 64, n.size.modal.handleHeight = 4, n.size.modal.handleWidth = 32, n.size.modal.search = 40, n.size.search.height = 30, n.size.taskDetails.iconMarkDetailsIcon = 77, n.size.taskDetails.attributeIcon = 22, n.size.taskDetails.footer = 0, n.size.tick.icon = 32, n.size.listItem.icon = 22, n.size.internalLink.icon = 14, n.size.emptyList.buttonHeight = 40, n.size.progressBar.paddingTop = 70, n.size.termsLink.marginTop = 40, n.size.termsLink.marginBottom = 70, n.size.emailVerificationIcon = 200, n.size.copyButton = 32, n.size.filtersBar.height = 0, n.size.stats.pace.entryHeight = 52, e.exports = n
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0);
        s(2), s(3);
        const a = s(500);
        var o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                direction: t = "column",
                spacing: s = 12,
                flexChildren: r,
                children: i
            } = e, c = t.startsWith("column") ? {
                marginTop: s
            } : {
                marginLeft: s
            }, l = t.endsWith("reverse");
            return (0, o.jsx)("div", {
                className: a.flexContainer + " " + (e.className || ""),
                style: Object.assign({
                    flexDirection: t
                }, e.style),
                children: n.ReactUtils.flattenChildren(i).map(((e, t, s) => {
                    const i = String(e.key || "flex_child_" + t),
                        d = s.length - 1,
                        u = l ? d : 0;
                    return (0, o.jsx)("div", {
                        className: a.flexContainer + (r ? " " + a.flexed : ""),
                        style: t !== u ? c : void 0,
                        children: n.React.cloneElement(e)
                    }, i)
                }))
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(6),
            o = s(861),
            r = s(17),
            i = s(1);
        const c = n.Hocs.compose((0, a.LU)({
            isDesktopModal: !1,
            hasArrow: !1
        }))((e => {
            const {
                sort: t,
                disabled: s = [],
                onChange: c
            } = e, l = n.Hooks.useIntl(), {
                closeAnimated: d
            } = (0, a.vR)(), u = (e, s) => t.by === e && t.order === s, m = (e, t) => {
                switch (e) {
                    case r.SidebarGroupsSortBy.Name:
                        return l.g("EW", {
                            order: t
                        });
                    case r.SidebarGroupsSortBy.CreatedAt:
                        return l.g("ES", {
                            order: t
                        });
                    case r.SidebarGroupsSortBy.Custom:
                        return l.f.ET;
                    default:
                        throw new Error("Cannot format sort label for: " + e)
                }
            }, h = e => t => {
                c(t, e), d(t)
            }, p = e => s.includes(e) ? null : (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(o.Z, {
                    label: m(e, "ascending"),
                    isSelected: u(e, "ascending"),
                    onPress: h({
                        by: e,
                        order: "ascending"
                    })
                }), (0, i.jsx)(o.Z, {
                    label: m(e, "descending"),
                    isSelected: u(e, "descending"),
                    onPress: h({
                        by: e,
                        order: "descending"
                    })
                })]
            });
            return (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(a.u_.Header, {
                    isPickerHeader: !0,
                    children: l.f.EZ
                }), (0, i.jsxs)(a.u_.Content, {
                    children: [p(r.SidebarGroupsSortBy.Name), p(r.SidebarGroupsSortBy.CreatedAt), (g = r.SidebarGroupsSortBy.Custom, s.includes(g) ? null : (0, i.jsx)(o.Z, {
                        label: m(g),
                        isSelected: u(g),
                        onPress: h({
                            by: g
                        })
                    }))]
                })]
            });
            var g
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0);
        s(2), s(3);
        const a = s(617);
        var o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                business: t,
                size: s = 6
            } = e, r = n.Styling.factoryColor(t.color);
            return (0, o.jsx)("div", {
                className: a.root + " " + (e.className || ""),
                style: Object.assign({
                    backgroundColor: r,
                    width: s,
                    height: s,
                    minWidth: s,
                    minHeight: s
                }, e.style)
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(19);
        const o = (e, t) => e.get(t).query(a.Q.where((0, a.columnName)("_status"), a.Q.notEq("synced"))).fetchCount(),
            r = async (e, t) => {
                const s = await o(e.db, n.Model.Tables.projects),
                    a = await o(e.db, n.Model.Tables.tasks),
                    r = await o(e.db, n.Model.Tables.comments),
                    i = [s && t.g("cX", {
                        count: s
                    }), a && t.g("cY", {
                        count: a
                    }), r && t.g("cW", {
                        count: r
                    })].filter(Boolean).join("\n");
                return t.f.cV + (i ? "\n\n" + i : "")
            }, i = async ({
                services: e,
                intl: t,
                shouldPushHistory: a = !0,
                onBeforeLogout: o = n.FP.noop,
                onLoggedOut: i = n.FP.noop
            }) => {
                await (async () => {
                    const {
                        hasUnsyncedChanges: a
                    } = s(166);
                    return !await a({
                        database: e.database
                    }) || n.ReactUtils.devConfirm(await r(e, t))
                })() && (await o(), await new Promise((t => {
                    setTimeout((async () => {
                        await e.app.logOut(a), t()
                    }), 0)
                })), await i())
            }
    }, , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Gu: () => p,
            Ni: () => c,
            Vz: () => l
        });
        s(131), s(4), s(5);
        var n = s(83),
            a = s(1142),
            o = s(1232);
        const r = new RegExp(a.BV.source + "|(?:mailto:)?(" + n.Ej.source + ")|(" + /tel:\+?[0-9]{3,12}/.source + ")|(" + /(?:nozbe4|calshow|message|shortcuts|obsidian|evernote):\/\/[^\s]*/.source + ")", "mi"),
            i = new RegExp("^" + r.source + "$", "mi"),
            c = /\[([^\]]+)\]\(([^\s]*)\)/;

        function l(e) {
            var t;
            const s = null != (t = d(e)) ? t : function(e) {
                const t = r.exec(e);
                if (!t) return null;
                const [s, n] = g(e, t), [a, o] = u(t);
                return {
                    type: a,
                    url: o,
                    precedingText: s,
                    restOfText: n
                }
            }(e);
            if (!s) return null;
            const [n, a, i] = function(e, t, s) {
                const n = t.slice(-1),
                    a = t.slice(0, -1);
                if ("." === n || ")" === n && f.test(e) && b.test(a)) return [e, a, n + s];
                return [e, t, s]
            }(s.precedingText, s.url, s.restOfText);
            return {
                label: m(a, s),
                url: h(a, s),
                richContent: (0, o.A)(a),
                precedingText: n,
                restOfText: i
            }
        }

        function d(e) {
            const t = c.exec(e);
            if (!t) return null;
            const [, s, n] = t, a = i.exec(n);
            if (!a) {
                const [s] = t, n = d(e.slice(t.index + s.length));
                return n ? Object.assign({}, n, {
                    precedingText: e.slice(0, t.index + s.length) + n.precedingText
                }) : null
            }
            const [o, r] = g(e, t), [l, m] = u(a);
            return {
                type: l,
                label: s,
                url: m,
                precedingText: o,
                restOfText: r
            }
        }

        function u(e) {
            const [, t, , , , , , s, , n, a] = e;
            if (s) return ["email", s];
            if (n) return ["phone", n];
            {
                const e = a || t;
                return invariant(e, "Expected URL to be captured"), ["link", e]
            }
        }

        function m(e, t) {
            if (t.label) return t.label;
            switch (t.type) {
                case "email":
                    if (e.includes("?")) {
                        const [t] = e.split("?", 1);
                        return t
                    }
                    return e;
                case "phone":
                    return e.replace("tel:", "");
                default:
                    return e
            }
        }

        function h(e, t) {
            switch (t.type) {
                case "email":
                    return e.startsWith("mailto:") ? e : "mailto:" + e;
                case "link":
                    return p(e);
                default:
                    return e
            }
        }

        function p(e) {
            return e.startsWith("www.") ? "http://" + e : e
        }

        function g(e, t) {
            const [s] = t;
            return [e.slice(0, t.index), e.slice(t.index + s.length)]
        }
        const f = /(?:\b|\s)\((?!\))/,
            b = /^[^()]*(?:\([^()]*\)[^()]*)*$/
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n = s(0),
            a = s(1493);
        const {
            Tables: o,
            Columns: r,
            Q: i
        } = n.Model;
        async function c(e, t, s) {
            const a = await async function(e) {
                return e.collections.get(o.users).query(i.on(o.teamMembers, [i.where(r.teamMembers.teamId, e.id), i.where(r.teamMembers.status, i.notEq("archived"))])).fetch()
            }(e), [c, d] = n.FP.partition((e => !s[t.indexOf(e)].isValid || !!l(e, a)), t);
            if (!await e.canInviteBusinessMembers()) return {
                email: d,
                business: [],
                rejected: c
            };
            const u = await e.business.fetch();
            invariant(u, "Member can invite to business but the team isn't a part of one");
            const m = await u.users.fetch(),
                h = [],
                p = [];
            if (t.forEach((e => {
                    const t = l(e, m);
                    t ? p.push([e, t]) : h.push(e)
                })), !p.length) return {
                email: h,
                business: [],
                rejected: c
            };
            const g = await async function(e, t) {
                const s = await e.members.extend(i.where(r.businessMembers.userId, i.oneOf(n.FP.pluckIds(t)))).fetch();
                invariant(t.length === s.length, "Missing business members for some users");
                const a = s.map((e => [e.user.id, e]));
                return new Map(a)
            }(u, p.map((([, e]) => e))), f = p.map((([e, t]) => {
                const s = g.get(t.id);
                return invariant(s, "No business member found for user"), [e, s]
            }));
            return {
                email: h,
                business: f,
                rejected: c
            }
        }

        function l(e, t) {
            return t.find((t => {
                if (t.isMe) return t.myEmail === e;
                if (t.isPlaceholder) return t.invitationEmail === e;
                {
                    const n = s(247)(t.id + e.toLowerCase());
                    return t.emailHash === n
                }
            }))
        }
        var d = s(1);
        const u = n.ReactUtils.lazy((() => s(25))),
            m = n.Hocs.compose()((e => {
                var t;
                const {
                    onClose: s,
                    onBeforeDone: o,
                    onCancel: r,
                    team: i,
                    startAtEmail: l,
                    initialEmail: m,
                    cancelButtonLabel: h,
                    saveButtonLabel: p,
                    saveEmptyButtonLabel: g,
                    level: f
                } = e, b = n.Hooks.useServices(), y = n.Hooks.useIntl(), v = n.Hooks.useDisplayTeam(), [w, k] = n.Hooks.useStateMachine("main"), [x, j] = n.React.useState([null != m ? m : ""]), T = async ({
                    e,
                    emails: t,
                    validation: s,
                    closeCallback: n
                }) => {
                    const a = t.map((e => e.trim())).filter(Boolean),
                        r = await c(i, a, s);
                    await b.payments.invokeActionOrProposeUpgrade({
                        name: "invite-to-team",
                        currentTeam: i,
                        membersCount: r.email.length
                    }, (async () => {
                        const t = r.email.length + r.business.length;
                        if (t && (null == o || o(e), r.email.length && await Promise.all(r.email.map((e => i.do.inviteMember({
                                email: e,
                                description: null
                            })))), r.business.length)) {
                            const e = r.business.map((([, e]) => e));
                            await i.do.addMembersFromBusiness(e)
                        }
                        r.rejected.length ? k("badEmails", r.rejected)() : (t && b.uiState.pushSnackbar({
                            message: y.g("JS", {
                                numberOfEmails: t,
                                email: ((e, t) => {
                                    const s = null != (e = r.email[0]) ? e : null == (t = r.business[0]) ? void 0 : t[0];
                                    return null != s ? s : ""
                                })()
                            })
                        }), n(e))
                    })) || v(i)
                };
                return (0, d.jsx)(d.Fragment, {
                    children: w.map({
                        main: () => t || (t = (0, d.jsx)(a.Z, {
                            onClose: s,
                            onConfirm: T,
                            item: i,
                            onCancel: r,
                            cancelButtonLabel: h,
                            saveButtonLabel: p,
                            saveEmptyButtonLabel: g,
                            startAtEmail: l,
                            initialEmails: x,
                            level: f
                        })),
                        badEmails: e => (0, d.jsx)(u, {
                            type: "confirm",
                            onConfirmPress: s,
                            onBackPress: () => {
                                j(e), k("main")()
                            },
                            confirmButtonMessage: y.f.fF,
                            secondaryButtonMessage: y.f.f4,
                            secondaryButtonIcon: null,
                            onClose: s,
                            children: (0, d.jsxs)("span", {
                                children: [y.f.JH, e ? e.map((e => "\n " + e)) : null]
                            })
                        })
                    })
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            X: () => r,
            k: () => c
        });
        var n = s(0),
            a = s(132),
            o = s(21);
        const r = e => e.filter(Boolean).join(" • "),
            i = (e, t) => "archived" === t ? e.f.qZ : "pending" === t ? e.f.q3 : "expired" === t ? e.f.q1 : "";

        function c(e, t) {
            return n.Rx.combineLatestObject({
                member: e.observe(),
                awayOnVacationUntil: e.awayOnVacationUntil,
                user: e.user.observe(),
                team: e.team.observe(),
                groups: e.groups.observe(),
                secondaryName: e.secondaryName
            }).pipe(n.Rx.map((({
                user: s,
                team: n,
                groups: c,
                secondaryName: l,
                awayOnVacationUntil: d
            }) => s.isLimited ? "" : n.isShared ? r([l, n.name]) : r([d ? t.g("q0", {
                awayUntil: (0, o.formatVacationDateTime)({
                    dateTime: d.to,
                    timeZone: d.timeZone || s.timeZone,
                    intl: t
                })
            }) : "", s.invitationEmail, l, i(t, e.status), c.length ? t.f.q2 + " " + (0, a.v)(c, t) : ""]))))
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(11),
            o = s(13);
        s(2), s(3);
        const r = s(584);
        var i = s(1);
        const c = e => {
            const {
                onPress: t,
                onPressExtraParam: s,
                initialColor: c,
                type: l
            } = e, d = n.Hooks.useIntl(), u = n.Hooks.useRemindExpired(n.FP.noop), [m, h] = n.React.useState(!1), p = m ? l : c || l, g = n.React.useRef(null), f = m && g.current ? g.current.offsetWidth : 0, b = "translate3d(" + (m ? -(f + 12 + 8) : 0) + "px, 0, 0)";
            return (0, i.jsxs)(a.Z, {
                className: r.root,
                style: {
                    backgroundColor: m ? n.Styling.rgba(n.Styling.factoryColor(p), .1) : "transparent",
                    minWidth: m ? f + 34 + 24 : 34
                },
                onPress: u(t),
                onPressExtraParam: s,
                onMouseEnter: () => h(!0),
                onMouseLeave: () => h(!1),
                children: [(0, i.jsx)(o.default, {
                    className: r.icon,
                    style: {
                        transform: b
                    },
                    name: "incoming" === l ? "ſ" : ")",
                    color: p,
                    size: 28
                }), (0, i.jsx)("span", {
                    className: r.text + (m ? " " + r.textExpand : ""),
                    style: {
                        color: n.Styling.factoryColor(m ? p : "transparent")
                    },
                    ref: g,
                    children: "incoming" === l ? d.f.fR : d.f.fI
                })]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => b
        });
        var n = s(0),
            a = s(13),
            o = s(22),
            r = s(18),
            i = s(11),
            c = s(94),
            l = s(57),
            d = s(228);
        const u = n.ReactUtils.identityElement;
        s(2), s(3);
        const m = s(588);
        var h, p = s(1);
        const g = e => {
                const {
                    file: t,
                    title: s
                } = e, n = (0, c.n)(t);
                return invariant(n, "Missing source for local thumbnail"), (0, p.jsx)(c.Z, {
                    className: m.thumbnailImage,
                    source: n,
                    title: s,
                    resizeMode: "contain"
                })
            },
            f = e => {
                const {
                    source: t,
                    title: s
                } = e;
                return (0, p.jsx)(c.Z, {
                    className: m.thumbnailImage,
                    source: t,
                    cache: !0,
                    title: s,
                    resizeMode: "contain"
                })
            },
            b = n.Hocs.compose()((e => {
                const {
                    name: t,
                    statusText: s,
                    infoText: c,
                    thumbnail: b,
                    contentButton: y,
                    removeButton: v
                } = e, w = Object.assign({
                    name: n.Styling.getAttachmentIcon(),
                    color: "onBackground3",
                    isSpinning: !1
                }, e.icon), k = (w.isSpinning, 0), x = (() => {
                    switch (null == b ? void 0 : b.state) {
                        case "loading":
                            return h || (h = (0, p.jsx)(l.default, {}));
                        case "loaded":
                            if (b.file) {
                                const {
                                    file: e
                                } = b;
                                return (0, d.TO)(e) ? (0, p.jsx)(g, {
                                    file: e,
                                    title: t
                                }) : null
                            } {
                                const {
                                    source: e
                                } = b;
                                return (0, p.jsx)(f, {
                                    source: e,
                                    title: t
                                })
                            }
                        case "error":
                            return (0, p.jsx)(a.default, {
                                name: "Œ",
                                size: 75,
                                color: "onBackground3"
                            });
                        default:
                            return null
                    }
                })();
                return (0, p.jsxs)("div", {
                    className: m.root + (x ? " " + m.rootWithThumbnail : ""),
                    style: e,
                    children: [s ? (0, p.jsx)("div", {
                        className: m.status,
                        children: (0, p.jsx)("span", {
                            className: m.statusText,
                            children: s
                        })
                    }) : null, (0, p.jsxs)(i.Z, {
                        className: m.rootButton,
                        style: null == y ? void 0 : y.style,
                        webComponent: "div",
                        isDisabled: !(null != y && y.onPress),
                        onPress: null == y ? void 0 : y.onPress,
                        accessibilityLabel: null == y ? void 0 : y.accessibilityLabel,
                        children: [x ? (0, p.jsx)("div", {
                            className: m.thumbnailContainer,
                            children: x
                        }) : null, (0, p.jsxs)("div", {
                            className: m.infoBar,
                            children: [(0, p.jsx)(u, {
                                transform: [{
                                    rotate: k
                                }],
                                children: (0, p.jsx)(a.default, {
                                    className: w.isSpinning ? m.iconSpinning : "",
                                    name: w.name,
                                    color: w.color
                                })
                            }), (0, p.jsx)(r.default, {
                                className: m.name,
                                children: t
                            }), c ? (0, p.jsx)("span", {
                                className: m.infoText,
                                children: c
                            }) : null, v ? (0, p.jsx)(o.default, {
                                className: m.removeButton,
                                style: v.style,
                                name: "Ʊ",
                                color: "onBackground3",
                                onPress: e => {
                                    n.ReactUtils.stopPropagation(e), null == v.onPress || v.onPress(e)
                                },
                                accessibilityLabel: v.accessibilityLabel
                            }) : null]
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            TO: () => c,
            WG: () => i,
            mQ: () => r
        });
        var n = s(0),
            a = s(109),
            o = s(204);

        function r(e, t) {
            return "number" == typeof t ? Math.round(100 * t) + "%" : "local" === e.content.source && e.size ? n.FP.formatBytes(e.size) : ""
        }

        function i(e) {
            var t;
            if ("external" === e.content.source) {
                const [t, s] = (0, o.P$)(e.content.file);
                return {
                    name: t,
                    color: s
                }
            }
            const s = e.version ? e.version.mimeType : null == (t = e.content.file) ? void 0 : t.type;
            return {
                name: n.Styling.getAttachmentIcon(s)
            }
        }

        function c(e) {
            const t = e.type;
            return t.startsWith("image/") && (0, a.$T)(t)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            MW: () => l,
            tL: () => i,
            iA: () => d,
            GT: () => c
        });
        var n = s(0),
            a = s(11);
        s(2), s(3);
        const o = s(618);
        var r = s(1);
        const i = e => (0, r.jsx)("div", {
                className: o.item + " " + (e.className || ""),
                style: e.style,
                children: e.children
            }),
            c = e => (0, r.jsx)(a.Z, {
                className: o.touchable + (e.isActive ? " " + o.touchableActive : ""),
                onPress: e.onPress,
                webComponent: e.webComponent,
                testId: e.testId,
                androidBorderless: e.androidBorderless,
                children: e.children
            }),
            l = e => (0, r.jsx)("div", {
                className: o.highlight + (e.isActive ? " " + o.highlightActive : ""),
                children: e.children
            }),
            d = e => {
                const {
                    isActive: t,
                    children: s
                } = e;
                n.Hooks.useLayoutBottomInset();
                return (0, r.jsx)("span", {
                    className: o.label + (t ? " " + o.labelActive : "") + " " + (e.className || ""),
                    style: e.style,
                    children: s
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(210)]).then(s.bind(s, 1502))))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            A3: () => a,
            S3: () => o,
            oE: () => r
        });
        var n = s(4);
        class a extends Error {
            constructor(...e) {
                super(...e), this.originalError = null, this.originalResponse = null, this.originalXHRResponse = null, this.isNetworkErrorLikely = !1, this.isServerError = !1, this.isServerTimeoutLikely = !1, this.userMessages = [], this.errorType = null, this.forceRelogin = !1, this.forceLogOut = !1, this.expectedApiVersion = null, this.json = {}
            }
        }
        const o = (e, t) => {
                const s = Date.now() - t.getTime(),
                    n = new a(e.message);
                return n.originalError = e, n.isNetworkErrorLikely = !0, 5e4 <= s && (n.isServerTimeoutLikely = !0), n
            },
            r = async e => {
                const t = await e.text(),
                    s = (e => {
                        try {
                            const t = JSON.parse(e);
                            return (0, n.isObject)(t) ? t : {}
                        } catch (e) {
                            return {}
                        }
                    })(t),
                    o = new a("[API] Error: " + t);
                return e.isXHRResposne ? o.originalXHRResponse = e : o.originalResponse = e, o.isServerError = 500 <= e.status, o.isServerTimeoutLikely = 503 === e.status, o.errorType = s.error_type || null, o.userMessages = s.messages || [], o.forceLogOut = (e => e.force_log_out || 401 === e.code && 104 === e.errno && "Unauthorized" === e.error)(s), o.forceRelogin = !!s.force_relogin, o.expectedApiVersion = (e => "number" == typeof e.expected_api_version ? e.expected_api_version : null)(s), o.json = s, o
            }
    }, , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => gt
        });
        var n = s(69),
            a = s(24),
            o = s(5),
            r = s(4),
            i = s(8),
            c = s(19),
            l = s(33),
            d = s(39),
            u = s(16),
            m = s(303);
        const h = r.sortBy((e => e.id)),
            p = r.pipe(h, r.head),
            g = e => r.isObject(e) ? e : {},
            f = e => r.isObject(e) ? e : null,
            b = e => (e => "string" == typeof e ? e : "")(e) || null,
            y = e => "number" == typeof e ? e : 0,
            v = e => y(e) || null,
            w = e => !0 === e,
            k = e => "boolean" == typeof e ? e : null,
            x = e => t => "boolean" == typeof t ? t : e,
            j = e => Array.isArray(e) ? e : [],
            T = {
                [m.Cc.Favorites]: {
                    position: -300,
                    sort: {
                        by: m.qV.Custom
                    }
                },
                [m.Cc.ProjectsFollowed]: {
                    position: -200,
                    sort: {
                        by: m.qV.Custom
                    }
                },
                [m.Cc.ProjectsActive]: {
                    position: -100,
                    sort: {
                        by: m.qV.Name,
                        order: "ascending"
                    }
                }
            },
            S = r.values(m.Cc);

        function P(e) {
            if (!r.isObject(e)) return T;
            const t = Object.entries(e).map((([e, t]) => {
                    if (!S.includes(e)) return null;
                    const s = e,
                        n = function(e, t) {
                            var s, n;
                            if (!r.isObject(t) || !t) return T[e];
                            const a = "number" == typeof t.position || null === t.position ? t.position : null != (s = T[e].position) ? s : 300,
                                o = null != (n = R(t.sort)) ? n : T[e].sort;
                            return {
                                position: a,
                                sort: o
                            }
                        }(s, t);
                    return n ? [s, n] : null
                })).filter(Boolean),
                s = Object.fromEntries(t);
            return s[m.Cc.Favorites] || (s[m.Cc.Favorites] = T[m.Cc.Favorites]), s
        }

        function _(e) {
            if (!r.isObject(e)) return {};
            const t = Object.entries(e).map((([e, t]) => {
                const s = function(e) {
                    if (!r.isObject(e) || !e) return null;
                    const t = R(e.sort);
                    return t ? {
                        sort: t
                    } : null
                }(t);
                return s ? [e, s] : null
            })).filter(Boolean);
            return Object.fromEntries(t)
        }

        function C(e) {
            return r.isObject(e) ? {
                trigger_report_at: "number" == typeof e.trigger_report_at ? e.trigger_report_at : null,
                is_enabled: !!e.is_enabled
            } : {
                trigger_report_at: null,
                is_enabled: !1
            }
        }

        function R(e) {
            if (!e || !r.isObject(e)) return null;
            const {
                by: t,
                order: s
            } = e;
            return "string" != typeof t ? null : {
                by: t,
                order: "ascending" === s || "descending" === s ? s : void 0
            }
        }

        function A(e) {
            if (!Array.isArray(e)) return [];
            const t = Date.now() - 864e5,
                s = [];
            return e.forEach((e => {
                if (!r.isObject(e)) return;
                const {
                    id: n,
                    collection: a,
                    created_at: o
                } = e;
                "string" == typeof n && "string" == typeof a && "number" == typeof o && (o < t || s.push({
                    id: n,
                    collection: a,
                    created_at: o
                }))
            })), s
        }

        function I(e) {
            if (!e || "object" != typeof e) return null;
            const {
                enabled: t,
                reminders_enabled: s
            } = e;
            return "boolean" == typeof t ? "boolean" == typeof s ? {
                enabled: t,
                reminders_enabled: s
            } : {
                enabled: t
            } : null
        }
        var N;
        const E = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            O = u.o.settings;
        let M = (N = class e {
            get database() {
                return this.settings.database
            }
            constructor(e, t, s, n) {
                this.settings = e, this.name = t, this.sanitizer = s, void 0 !== n ? (this.team = n, this.query = this.settings._allSettings.extend(c.Q.where(O.name, this.name), c.Q.where(O.teamId, n ? n.id : null))) : this.query = this.settings._allSettings.extend(c.Q.where(O.name, t))
            }
            forTeam(t) {
                return new e(this.settings, this.name, this.sanitizer, t)
            }
            fetchSettings() {
                return this.query.fetch().then(h)
            }
            observe() {
                return this.query.observeWithColumns([O.value]).pipe(i.map(p), i.map((e => this.sanitizer(null == e ? void 0 : e._value))))
            }
            observeAll() {
                return this.query.observeWithColumns([O.value]).pipe(i.map(h), i.map((e => e.map((e => this.sanitizer(e._value))))))
            }
            async fetch() {
                const [e] = await this.fetchSettings();
                return this.sanitizer(null == e ? void 0 : e._value)
            }
            async fetchAll() {
                return (await this.fetchSettings()).map((e => this.sanitizer(e._value)))
            }
            async set(e) {
                const [t] = await this.fetchSettings();
                await this._createOrUpdate(t, e)
            }
            async setWith(e) {
                const [t] = await this.fetchSettings();
                await this._createOrUpdate(t, e(this.sanitizer(null == t ? void 0 : t._value)))
            }
            prepareSet(e, t) {
                return this._prepareCreateOrUpdate(e, t(this.sanitizer(null == e ? void 0 : e._value)))
            }
            prepareSetAll(e, t) {
                return e.map((e => this.prepareSet(e, t)))
            }
            _populateNewSetting(e, t) {
                t.name = this.name, t._value = e, t.team.set(this.team)
            }
            _create(e) {
                return this.settings.collections.get(u.w.settings).create((t => this._populateNewSetting(e, t)))
            }
            _createOrUpdate(e, t) {
                return e ? e.updateValue(t) : this._create(t)
            }
            _prepareCreate(e) {
                return this.settings.collections.get(u.w.settings).prepareCreate((t => this._populateNewSetting(e, t)))
            }
            _prepareCreateOrUpdate(e, t) {
                return e ? e.prepareUpdateValue(t) : this._prepareCreate(t)
            }
        }, E(N, "set", [l.writer]), E(N, "setWith", [l.writer]), N);
        var D, H, F, Z, L, B, z, U, W, G, V, q, Q, Y, J, K, $, X, ee, te, se, ne, ae, oe, re, ie, ce, le, de, ue, me, he, pe, ge, fe, be, ye, ve, we, ke, xe, je, Te, Se, Pe, _e, Ce, Re, Ae, Ie, Ne, Ee, Oe, Me, De, He, Fe, Ze, Le, Be, ze, Ue, We;
        const Ge = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            Ve = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            qe = u.o.settings,
            Qe = e => {
                return r.pipe(r.pluck("asObject"), h, r.filter((t => t.type === e)), r.head, (t = "hasRead", r.ifElse(Boolean, r.prop(t), r.F)));
                var t
            };
        let Ye = (H = Ve(D = class {
            get collections() {
                return this.database.collections
            }
            constructor(e) {
                (0, n.Z)(this, "_allSettings", H, this), (0, n.Z)(this, "pushTokens", F, this), (0, n.Z)(this, "onboarding", Z, this), (0, n.Z)(this, "declaredUseCase", L, this), (0, n.Z)(this, "prefersPersonalUI", B, this), (0, n.Z)(this, "requiresNewOnboarding", z, this), (0, n.Z)(this, "sawGeneralPersonalOnboarding", U, this), (0, n.Z)(this, "sawGeneralOnboarding", W, this), (0, n.Z)(this, "sawTeamSetup", G, this), (0, n.Z)(this, "sawTaskDetailsOnboarding", V, this), (0, n.Z)(this, "sawProjectFollowOnboarding", q, this), (0, n.Z)(this, "sawMessagesOnboarding", Q, this), (0, n.Z)(this, "hasNPAccount", Y, this), (0, n.Z)(this, "signedUpAt", J, this), (0, n.Z)(this, "accountMerge", K, this), (0, n.Z)(this, "lastSeenSurveyAt", $, this), (0, n.Z)(this, "didAnswerSourceSurvey", X, this), (0, n.Z)(this, "locale", ee, this), (0, n.Z)(this, "xCallbackUrlSecret", te, this), (0, n.Z)(this, "teamWelcomingModal", se, this), (0, n.Z)(this, "isSyncButtonEnabled", ne, this), (0, n.Z)(this, "isDarkSidebarEnabled", ae, this), (0, n.Z)(this, "isSidebarShowingCounters", oe, this), (0, n.Z)(this, "isTrayEnabled", re, this), (0, n.Z)(this, "isCalendarShowingWeekNumbers", ie, this), (0, n.Z)(this, "isFuzzySearchEnabled", ce, this), (0, n.Z)(this, "hasSkippedTeamSetup", le, this), (0, n.Z)(this, "lastNewsActivity", de, this), (0, n.Z)(this, "lastSeenNewsActivity", ue, this), (0, n.Z)(this, "backendBanners", me, this), (0, n.Z)(this, "backendBannersPersonalized", he, this), (0, n.Z)(this, "hiddenBackendBanners", pe, this), (0, n.Z)(this, "hiddenAppBanners", ge, this), (0, n.Z)(this, "newFeatures", fe, this), (0, n.Z)(this, "seenNewFeatures", be, this), (0, n.Z)(this, "incomingPrioritization", ye, this), (0, n.Z)(this, "joinRequests", ve, this), (0, n.Z)(this, "teamInvitations", we, this), (0, n.Z)(this, "projectInvitations", ke, this), (0, n.Z)(this, "taskInvitations", xe, this), (0, n.Z)(this, "creditsGranted", je, this), (0, n.Z)(this, "emailNotifications", Te, this), (0, n.Z)(this, "pushNotifications", Se, this), (0, n.Z)(this, "dailyReport", Pe, this), (0, n.Z)(this, "dailyTeamReport", _e, this), (0, n.Z)(this, "weeklyProductivity", Ce, this), (0, n.Z)(this, "weeklyProductivityAdmin", Re, this), (0, n.Z)(this, "lastUsedMobileAt", Ae, this), (0, n.Z)(this, "lastUsedDesktopAt", Ie, this), (0, n.Z)(this, "npsRatingSetting", Ne, this), (0, n.Z)(this, "challenges", Ee, this), (0, n.Z)(this, "isCalendarViewMonth", Oe, this), (0, n.Z)(this, "isGlobalTaskMeEnabled", Me, this), (0, n.Z)(this, "seenTaskActionEvents", De, this), (0, n.Z)(this, "gcalSettings", He, this), (0, n.Z)(this, "mcalSettings", Fe, this), (0, n.Z)(this, "hasRequestedBackup", Ze, this), (0, n.Z)(this, "sidebarBuiltinGroups", Le, this), (0, n.Z)(this, "sidebarProjectGroups", Be, this), (0, n.Z)(this, "contactInformations", ze, this), (0, n.Z)(this, "contactInformationsVisibility", Ue, this), (0, n.Z)(this, "objectsRecentlyCreatedByMe", We, this), this._onboardingSettingsCache = {}, this.database = e
            }
            integrationSettingQuery(e, t) {
                return new M(this, t, I, e)
            }
            observeIntegrationState(e, t) {
                return i.combineLatest(this.integrationSettingQuery(e, t).observe(), this.integrationSettingQuery(null, t).observe()).pipe(i.map((([e, t]) => e ? Object.assign({}, e, {
                    is_for_all_spaces: !1
                }) : t ? Object.assign({}, t, {
                    is_for_all_spaces: !0
                }) : null)))
            }
            promoBannerQuery(e) {
                return new M(this, "promo_banner", g, e)
            }
            importSubscription(e) {
                return new M(this, "import", g, e)
            }
            abSentOnce(e, t) {
                return new M(this, "ab_sent_once_" + e + ":" + t, w)
            }
            observePromoBannerSetting(e) {
                return i.combineLatest(e ? this.promoBannerQuery(e).query.observeWithColumns([qe.value]) : i.of([]), this.promoBannerQuery(null).query.observeWithColumns([qe.value])).pipe(i.map((([e, t]) => 0 < e.length ? e : t)), i.map(p), i.map((e => null == e ? void 0 : e.asObject)))
            }
            observeTeamWelcomingModalSetting() {
                return this.teamWelcomingModal.query.observeWithColumns([qe.value]).pipe(i.map(p), i.map((e => null == e ? void 0 : e.asArray)))
            }
            observeOnboardingSettingHasRead(e) {
                const t = this._onboardingSettingsCache[e];
                if (t) return t;
                const s = this.onboarding.query.observeWithColumns([qe.value]).pipe(i.map(Qe(e)));
                return this._onboardingSettingsCache[e] = s, s
            }
            observeLocaleSetting() {
                return this.locale.query.observeWithColumns([qe.value]).pipe(i.map(p), i.map((e => null == e ? void 0 : e.asObject)))
            }
            observeImportSubscriptionSetting(e) {
                return this.importSubscription(e).query.observeWithColumns([qe.value]).pipe(i.map(p), i.map((e => null == e ? void 0 : e.asObject)))
            }
            observeCreditsGrantedSetting() {
                return this.creditsGranted.query.observeWithColumns([qe.value]).pipe(i.map(p), i.map((e => {
                    if (e) {
                        const t = e.asObject;
                        return {
                            lastCreditsGrantedAt: t.last_granted_at,
                            lastCreditsSeenAt: t.last_seen_at || 0,
                            creditsAvailable: t.credits_available || 0,
                            creditsPending: t.credits_pending || 0,
                            creditsTotal: t.credits_total || 0,
                            currency: t.currency
                        }
                    }
                    return null
                })))
            }
            _observeLastNewsActivitySetting(e) {
                return this.lastNewsActivity.query.observeWithColumns([qe.value]).pipe(i.map(p), i.map((e => null == e ? void 0 : e.asArray)), i.map((t => {
                    var s;
                    return t ? null == (s = t.find((({
                        lang: t
                    }) => t === (0, d.localeToBlogLanguage)(e)))) ? void 0 : s.last_news_at : null
                })))
            }
            _observeLastSeenNewsActivitySetting(e) {
                return this.lastSeenNewsActivity.query.observeWithColumns([qe.value]).pipe(i.map(p), i.map((e => null == e ? void 0 : e.asArray)), i.map((t => {
                    var s;
                    return t ? null == (s = t.find((({
                        lang: t
                    }) => t === (0, d.localeToBlogLanguage)(e)))) ? void 0 : s.last_news_at : null
                })))
            }
            observeNewsActivitySettings(e) {
                return i.combineLatest(this._observeLastNewsActivitySetting(e), this._observeLastSeenNewsActivitySetting(e)).pipe(i.map((([e, t]) => ({
                    lastNewsAt: e || 0,
                    lastSeenNewsAt: t || 0
                }))))
            }
            async updateLastSeenNewsActivitySetting(e) {
                const [t] = await this.lastSeenNewsActivity.fetchSettings(), s = (0, d.localeToBlogLanguage)(e), n = null != t && t.asArray.find((({
                    lang: e
                }) => e === s)) ? t.asArray.map((({
                    lang: e,
                    last_news_at: t
                }) => e === s ? {
                    lang: e,
                    last_news_at: (new Date).getTime()
                } : {
                    lang: e,
                    last_news_at: t
                })) : [...(null == t ? void 0 : t.asArray) || [], {
                    lang: s,
                    last_news_at: (new Date).getTime()
                }];
                await this.lastSeenNewsActivity._createOrUpdate(t, n)
            }
            async updateOnboardingSetting(e, t = !0) {
                const s = (await this.onboarding.fetchSettings()).find((t => t.asObject.type === e));
                await this.onboarding._createOrUpdate(s, {
                    type: e,
                    hasRead: t
                })
            }
            async addPushToken({
                token: e,
                locale: t,
                isSandbox: n
            }) {
                const a = (await this.pushTokens.fetchSettings()).find((t => "string" == typeof e ? t.asObject.token === e : t.asObject.token.endpoint === (null == e ? void 0 : e.endpoint))),
                    r = s(348).Z,
                    i = await r(),
                    c = Object.assign({}, (null == a ? void 0 : a.asObject) || {}, {
                        token: e,
                        platform: globalThis.electron ? globalThis.electron.platform : o.platformName,
                        appVersion: o.appVersion,
                        name: i,
                        locale: t,
                        dev: !1,
                        sandbox: n
                    });
                await this.pushTokens._createOrUpdate(a, c)
            }
            updateLocale(e, t) {
                return this.locale.setWith((s => Object.assign({}, s, {
                    locale: e,
                    use_system_locale: t
                })))
            }
            async updatePromoBanner({
                team: e,
                isVisible: t,
                imageUrl: s,
                monthsFreeYearly: n,
                monthsFreeMonthly: a,
                monthsFreeTrimonthly: o,
                businessMonthsFreeYearly: r,
                businessMonthsFreeMonthly: i,
                businessMonthsFreeTrimonthly: c,
                freeCredits: l,
                action: d,
                currency: u,
                url: m
            }) {
                if (s || n || a || o || r || i || c || l || d || u || m) throw new Error("Changing promo banner settings is not allowed");
                await this.promoBannerQuery(e).setWith((e => Object.assign({}, e, {
                    is_visible: t
                }, void 0 !== s && {
                    image_url: s
                }, void 0 !== n && {
                    months_free: n
                }, void 0 !== a && {
                    months_free_monthly: a
                }, void 0 !== o && {
                    months_free_trimonthly: o
                }, void 0 !== r && {
                    business_months_free: r
                }, void 0 !== i && {
                    business_months_free_monthly: i
                }, void 0 !== c && {
                    business_months_free_trimonthly: c
                }, void 0 !== d && {
                    action: d
                }, void 0 !== l && {
                    free_credits: l
                }, void 0 !== u && {
                    currency: u
                }, void 0 !== m && {
                    url: m
                })))
            }
            async setXCallbackUrlEnabled(e) {
                const [t] = await this.xCallbackUrlSecret.fetchSettings();
                if (e) {
                    const e = o.randomId().slice(0, 6);
                    await this.xCallbackUrlSecret._createOrUpdate(t, e)
                } else await t.markAsDeleted()
            }
            async markTeamAsWelcomed(e) {
                const [t] = await this.teamWelcomingModal.fetchSettings(), s = t ? t.asArray.map((({
                    visible: t,
                    team_id: s
                }) => s === e ? {
                    visible: !1,
                    team_id: s
                } : {
                    visible: t,
                    team_id: s
                })) : [{
                    visible: !1,
                    team_id: e
                }];
                await this.teamWelcomingModal._createOrUpdate(t, s)
            }
            markSubscriptionAsImported(e) {
                return this.importSubscription(e).setWith((e => Object.assign({}, e, {
                    is_subscription_imported: !0
                })))
            }
            async dismissJoinRequest(e) {
                const t = (await this.joinRequests.fetchSettings()).find((t => t.asObject.invite_code === e.invite_code));
                t && await t.markAsDeleted()
            }
            async dismissTeamInvitation(e) {
                const t = (await this.teamInvitations.fetchSettings()).find((t => t.asObject.invitation_id === e.invitation_id));
                t && await t.markAsDeleted()
            }
            async changeRating(e) {
                return this.npsRatingSetting.set({
                    rating: e,
                    ratedAt: Date.now()
                })
            }
            updateLastUsedMobileAt() {
                return this.lastUsedMobileAt.set(Date.now())
            }
            updateLastUsedDesktopAt() {
                return this.lastUsedDesktopAt.set(Date.now())
            }
            markCreditsAsSeen() {
                return this.creditsGranted.setWith((e => Object.assign({}, e, {
                    last_seen_at: Date.now()
                })))
            }
            async toggleEmailNotifications(e, t) {
                const [s] = await this.emailNotifications.forTeam(t).fetchSettings(), n = s && s.asArray.find((({
                    id: t
                }) => t === e)) ? s.asArray.map((t => t.id === e ? {
                    id: t.id,
                    isEnabled: !t.isEnabled
                } : t)) : [...s ? s.asArray : [], {
                    id: e,
                    isEnabled: !1
                }];
                await this.emailNotifications.forTeam(t)._createOrUpdate(s, n)
            }
            async togglePushNotifications(e, t) {
                const [s] = await this.pushNotifications.forTeam(t).fetchSettings(), n = s && s.asArray.find((({
                    id: t
                }) => t === e)) ? s.asArray.map((t => t.id === e ? {
                    id: t.id,
                    isEnabled: !t.isEnabled
                } : t)) : [...s ? s.asArray : [], {
                    id: e,
                    isEnabled: !1
                }];
                await this.pushNotifications.forTeam(t)._createOrUpdate(s, n)
            }
            async markTaskActionEventAsSeen(e) {
                const t = await this.seenTaskActionEvents.fetch();
                await this.seenTaskActionEvents.set(Object.assign({}, t, {
                    [e]: !0
                }))
            }
            async hideBackendBanner(e, t) {
                const s = await this.backendBanners.fetch(),
                    n = await this.backendBannersPersonalized.forTeam(t).fetch(),
                    a = s.concat(n).map((({
                        name: e
                    }) => e));
                await this.hiddenBackendBanners.forTeam(t).setWith((t => [...t.filter((({
                    name: t
                }) => a.includes(t) && t !== e)), {
                    name: e,
                    hiddenOn: Date.now()
                }]))
            }
            async hideAppBanner(e, t) {
                await this.hiddenAppBanners.forTeam(t).setWith((t => {
                    var s, n;
                    const a = null != (s = null == (n = t.find((t => t.name === e))) ? void 0 : n.hiddenCount) ? s : 0;
                    return t.filter((t => t.name !== e)).concat({
                        name: e,
                        hiddenOn: Date.now(),
                        hiddenCount: a + 1
                    })
                }))
            }
            async markFeaturesAsSeen(e, t) {
                const s = await this.newFeatures.fetch(),
                    n = new Set(s.map((e => e.name)));
                await this.seenNewFeatures.setWith((s => {
                    const a = new Map;
                    return s.forEach((e => {
                        n.has(e.name) && a.set(e.name, e)
                    })), t.forEach((t => {
                        if (!n.has(t)) return;
                        let s = a.get(t);
                        s || (s = {
                            name: t,
                            places: {}
                        }, a.set(t, s)), s.places[e] = Date.now()
                    })), Array.from(a.values())
                }))
            }
            async resetOnboarding() {
                await this.sawGeneralPersonalOnboarding.set(!1), await this.sawGeneralOnboarding.set(!1), await this.sawTaskDetailsOnboarding.set(!1), await this.sawProjectFollowOnboarding.set(!1), await this.sawMessagesOnboarding.set(!1), await this.requiresNewOnboarding.set(!0)
            }
            async reorderSidebarBuiltinGroups(e, t) {
                await this.sidebarBuiltinGroups.forTeam(t).setWith((t => {
                    const s = Object.assign({}, t);
                    return Object.entries(e).forEach((([e, t]) => {
                        invariant(s[e], "Cannot reorder group outside of sidebar"), s[e].position = t
                    })), s
                }))
            }
            async addContactInformation(e, t) {
                await this.contactInformations.setWith((s => [...s, {
                    value: e,
                    type: t,
                    id: o.randomId()
                }]))
            }
            async updateContactInformation(e, t, s) {
                await this.contactInformations.setWith((n => n.map((n => n.id === e.id ? Object.assign({}, n, {
                    value: t,
                    type: s
                }) : n))))
            }
            async removeContactInformation(e) {
                const [
                    [t], s
                ] = await Promise.all([await this.contactInformations.fetchSettings(), await this.contactInformationsVisibility.fetchSettings()]), n = this.contactInformations.prepareSet(t, (t => t.filter((t => t.id !== e.id)))), a = this.contactInformationsVisibility.prepareSetAll(s, (t => t.filter((t => t.contact_info_id !== e.id))));
                return this.database.batch([n, ...a])
            }
            async updateContactInformationVisibility({
                contact: e,
                shouldBeVisible: t,
                team: s
            }) {
                await this.contactInformationsVisibility.forTeam(s).setWith((s => [...s.filter((t => t.contact_info_id !== e.id)), {
                    contact_info_id: e.id,
                    is_hidden: !t
                }]))
            }
            async toggleSidebarBuiltinGroup(e, t) {
                invariant(e !== m.Cc.Favorites, "Favorites group cannot be toggled");
                const s = (await t.projectGroupsOnSidebar.fetch()).map((e => {
                    var t;
                    return null != (t = e.sidebarPosition) ? t : Number.POSITIVE_INFINITY
                }));
                await this.sidebarBuiltinGroups.forTeam(t).setWith((t => {
                    var n, a;
                    const o = Object.assign({}, t);
                    if ("number" == typeof(null == (n = o[e]) ? void 0 : n.position)) return Object.assign({}, o, {
                        [e]: Object.assign({}, o[e], {
                            position: null
                        })
                    });
                    const r = null != (a = [...Object.values(t).map((e => e.position)), ...s].sort(((e, t) => (null != e ? e : 0) - (null != t ? t : 0))).pop()) ? a : 0;
                    return Object.assign({}, o, {
                        [e]: Object.assign({}, o[e], {
                            position: r + 1
                        })
                    })
                }))
            }
            async setSidebarBuiltinGroupSort(e, t, s) {
                await this.sidebarBuiltinGroups.forTeam(s).setWith((s => {
                    var n;
                    const a = Object.assign({}, s),
                        o = null != (n = a[e]) ? n : {};
                    return Object.assign({}, a, {
                        [e]: Object.assign({}, o, {
                            sort: t
                        })
                    })
                }))
            }
            async setSidebarProjectGroupSort(e, t, s) {
                await this.sidebarProjectGroups.forTeam(s).setWith((s => {
                    const n = Object.assign({}, s);
                    return n[e] = {
                        sort: t
                    }, n
                }))
            }
        }, "_allSettings", [l.lazy], (function() {
            return this.collections.get(u.w.settings).query()
        })), F = Ve(D, "pushTokens", [l.lazy], (function() {
            return new M(this, "push_token", g)
        })), Z = Ve(D, "onboarding", [l.lazy], (function() {
            return new M(this, "onboarding", g)
        })), L = Ve(D, "declaredUseCase", [l.lazy], (function() {
            return new M(this, "onboarding_use_case", b)
        })), B = Ve(D, "prefersPersonalUI", [l.lazy], (function() {
            return new M(this, "prefers_personal_ui", w)
        })), z = Ve(D, "requiresNewOnboarding", [l.lazy], (function() {
            return new M(this, "onboarding_requires_new", w)
        })), U = Ve(D, "sawGeneralPersonalOnboarding", [l.lazy], (function() {
            return new M(this, "onboarding_saw_general_personal", w)
        })), W = Ve(D, "sawGeneralOnboarding", [l.lazy], (function() {
            return new M(this, "onboarding_saw_general", w)
        })), G = Ve(D, "sawTeamSetup", [l.lazy], (function() {
            return new M(this, "onboarding_saw_team_setup", w)
        })), V = Ve(D, "sawTaskDetailsOnboarding", [l.lazy], (function() {
            return new M(this, "onboarding_saw_task_details", w)
        })), q = Ve(D, "sawProjectFollowOnboarding", [l.lazy], (function() {
            return new M(this, "onboarding_saw_project_follow", w)
        })), Q = Ve(D, "sawMessagesOnboarding", [l.lazy], (function() {
            return new M(this, "onboarding_saw_messages_modal", w)
        })), Y = Ve(D, "hasNPAccount", [l.lazy], (function() {
            return new M(this, "has_np_account", w)
        })), J = Ve(D, "signedUpAt", [l.lazy], (function() {
            return new M(this, "signed_up_at", v)
        })), K = Ve(D, "accountMerge", [l.lazy], (function() {
            return new M(this, "account_merge", f)
        })), $ = Ve(D, "lastSeenSurveyAt", [l.lazy], (function() {
            return new M(this, "survey_last_seen_at", y)
        })), X = Ve(D, "didAnswerSourceSurvey", [l.lazy], (function() {
            return new M(this, "survey_did_answer_source", w)
        })), ee = Ve(D, "locale", [l.lazy], (function() {
            return new M(this, "locale", g)
        })), te = Ve(D, "xCallbackUrlSecret", [l.lazy], (function() {
            return new M(this, "x_callback_url_secret", b)
        })), se = Ve(D, "teamWelcomingModal", [l.lazy], (function() {
            return new M(this, "team_welcoming_modal", j)
        })), ne = Ve(D, "isSyncButtonEnabled", [l.lazy], (function() {
            return new M(this, "is_sync_button_enabled", k)
        })), ae = Ve(D, "isDarkSidebarEnabled", [l.lazy], (function() {
            return new M(this, "is_dark_sidebar_enabled", w)
        })), oe = Ve(D, "isSidebarShowingCounters", [l.lazy], (function() {
            return new M(this, "is_sidebar_showing_counters", w)
        })), re = Ve(D, "isTrayEnabled", [l.lazy], (function() {
            return new M(this, "is_tray_enabled", x(!0))
        })), ie = Ve(D, "isCalendarShowingWeekNumbers", [l.lazy], (function() {
            return new M(this, "is_calendar_showing_week_numbers", w)
        })), ce = Ve(D, "isFuzzySearchEnabled", [l.lazy], (function() {
            return new M(this, "is_fuzzy_search_enabled", x(!0))
        })), le = Ve(D, "hasSkippedTeamSetup", [l.lazy], (function() {
            return new M(this, "signup_skipped_team_setup", w)
        })), de = Ve(D, "lastNewsActivity", [l.lazy], (function() {
            return new M(this, "news_activity_at", j)
        })), ue = Ve(D, "lastSeenNewsActivity", [l.lazy], (function() {
            return new M(this, "news_last_seen_activity_at", j)
        })), me = Ve(D, "backendBanners", [l.lazy], (function() {
            return new M(this, "backend_banners", j)
        })), he = Ve(D, "backendBannersPersonalized", [l.lazy], (function() {
            return new M(this, "backend_banners_personalized", j)
        })), pe = Ve(D, "hiddenBackendBanners", [l.lazy], (function() {
            return new M(this, "hidden_banners", j)
        })), ge = Ve(D, "hiddenAppBanners", [l.lazy], (function() {
            return new M(this, "hidden_app_banners", j)
        })), fe = Ve(D, "newFeatures", [l.lazy], (function() {
            return new M(this, "new_features", j)
        })), be = Ve(D, "seenNewFeatures", [l.lazy], (function() {
            return new M(this, "seen_new_features", j)
        })), ye = Ve(D, "incomingPrioritization", [l.lazy], (function() {
            return new M(this, "incoming_priority", g)
        })), ve = Ve(D, "joinRequests", [l.lazy], (function() {
            return new M(this, "join_request", g)
        })), we = Ve(D, "teamInvitations", [l.lazy], (function() {
            return new M(this, "team_invitation", g)
        })), ke = Ve(D, "projectInvitations", [l.lazy], (function() {
            return new M(this, "project_invitation", g)
        })), xe = Ve(D, "taskInvitations", [l.lazy], (function() {
            return new M(this, "task_invitation", g)
        })), je = Ve(D, "creditsGranted", [l.lazy], (function() {
            return new M(this, "credits_granted", g)
        })), Te = Ve(D, "emailNotifications", [l.lazy], (function() {
            return new M(this, "email_notifications", j)
        })), Se = Ve(D, "pushNotifications", [l.lazy], (function() {
            return new M(this, "push_notifications", j)
        })), Pe = Ve(D, "dailyReport", [l.lazy], (function() {
            return new M(this, "daily_report", C)
        })), _e = Ve(D, "dailyTeamReport", [l.lazy], (function() {
            return new M(this, "daily_team_report", C)
        })), Ce = Ve(D, "weeklyProductivity", [l.lazy], (function() {
            return new M(this, "weekly_productivity", C)
        })), Re = Ve(D, "weeklyProductivityAdmin", [l.lazy], (function() {
            return new M(this, "weekly_productivity_admin", C)
        })), Ae = Ve(D, "lastUsedMobileAt", [l.lazy], (function() {
            return new M(this, "last_used_mobile_at", v)
        })), Ie = Ve(D, "lastUsedDesktopAt", [l.lazy], (function() {
            return new M(this, "last_used_desktop_at", v)
        })), Ne = Ve(D, "npsRatingSetting", [l.lazy], (function() {
            return new M(this, "in_app_rating", g)
        })), Ee = Ve(D, "challenges", [l.lazy], (function() {
            return new M(this, "challenges", j)
        })), Oe = Ve(D, "isCalendarViewMonth", [l.lazy], (function() {
            return new M(this, "is_calendar_view_months", w)
        })), Me = Ve(D, "isGlobalTaskMeEnabled", [l.lazy], (function() {
            return new M(this, "is_gtm_enabled", w)
        })), De = Ve(D, "seenTaskActionEvents", [l.lazy], (function() {
            return new M(this, "seen_task_action_events", g)
        })), He = Ve(D, "gcalSettings", [l.lazy], (function() {
            return new M(this, "gcal_settings", g)
        })), Fe = Ve(D, "mcalSettings", [l.lazy], (function() {
            return new M(this, "mcal_settings", f)
        })), Ze = Ve(D, "hasRequestedBackup", [l.lazy], (function() {
            return new M(this, "has_requested_backup", w)
        })), Le = Ve(D, "sidebarBuiltinGroups", [l.lazy], (function() {
            return new M(this, "sidebar_groups_builtin", P)
        })), Be = Ve(D, "sidebarProjectGroups", [l.lazy], (function() {
            return new M(this, "sidebar_groups_project", _)
        })), ze = Ve(D, "contactInformations", [l.lazy], (function() {
            return new M(this, "contact_info", j)
        })), Ue = Ve(D, "contactInformationsVisibility", [l.lazy], (function() {
            return new M(this, "contact_info_visibility", j)
        })), We = Ve(D, "objectsRecentlyCreatedByMe", [l.lazy], (function() {
            return new M(this, "objects_recently_created_by_me", A)
        })), Ge(D, "updateLastSeenNewsActivitySetting", [l.writer]), Ge(D, "updateOnboardingSetting", [l.writer]), Ge(D, "addPushToken", [l.writer]), Ge(D, "setXCallbackUrlEnabled", [l.writer]), Ge(D, "markTeamAsWelcomed", [l.writer]), Ge(D, "dismissJoinRequest", [l.writer]), Ge(D, "dismissTeamInvitation", [l.writer]), Ge(D, "toggleEmailNotifications", [l.writer]), Ge(D, "togglePushNotifications", [l.writer]), Ge(D, "removeContactInformation", [l.writer]), D);
        var Je, Ke, $e, Xe, et, tt, st, nt, at, ot, rt, it, ct, lt, dt, ut, mt, ht;
        const pt = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let gt = (Je = o.lazy, Ke = class {
            get collections() {
                return this.database.collections
            }
            constructor(e) {
                (0, n.Z)(this, "do", $e, this), (0, n.Z)(this, "settings", Xe, this), (0, n.Z)(this, "allTeams", et, this), (0, n.Z)(this, "teams", tt, this), (0, n.Z)(this, "activeTeams", st, this), (0, n.Z)(this, "ownedTeams", nt, this), (0, n.Z)(this, "pendingTeams", at, this), (0, n.Z)(this, "sharedTeams", ot, this), (0, n.Z)(this, "ownedBusinesses", rt, this), (0, n.Z)(this, "_currentUserQuery", it, this), (0, n.Z)(this, "currentUser", ct, this), (0, n.Z)(this, "personalTags", lt, this), (0, n.Z)(this, "manageableBusinesses", dt, this), (0, n.Z)(this, "manageableTeams", ut, this), (0, n.Z)(this, "manageableStandaloneTeams", mt, this), (0, n.Z)(this, "hasManyActiveTeams", ht, this), this.database = e
            }
            async canCreateTeam() {
                if (!await i.takeFirst(this.currentUser)) return !1;
                const e = [...await i.takeFirst(this.ownedBusinesses), ...[...await i.takeFirst(this.ownedTeams), ...await i.takeFirst(this.pendingTeams)].filter((e => !e.planInfo.isBusiness))].filter((e => e.isFreeOrTrial || e.isExpired));
                return 2 > e.length
            }
        }, $e = pt(Ke, "do", [Je], (function() {
            return (() => new(0, s(1210).Z)(this))()
        })), Xe = pt(Ke, "settings", [l.lazy], (function() {
            return new Ye(this.database)
        })), et = pt(Ke, "allTeams", [l.lazy], (function() {
            return this.collections.get(u.w.teams).query()
        })), tt = pt(Ke, "teams", [l.lazy], (function() {
            return this.allTeams.extend(c.Q.where(u.o.teams.isShared, !1))
        })), st = pt(Ke, "activeTeams", [l.lazy], (function() {
            return this.teams.observe().pipe(i.switchMap((e => i.combineLatest(e.map((e => e.isPending)))), ((e, t) => e.filter(((e, s) => !t[s])))))
        })), nt = pt(Ke, "ownedTeams", [l.lazy], (function() {
            return this.currentUser.pipe(i.switchMap((e => e ? e.ownedTeams.observe() : i.of([]))))
        })), at = pt(Ke, "pendingTeams", [l.lazy], (function() {
            return this.teams.observe().pipe(i.switchMap((e => i.combineLatest(e.map((e => e.isPending)))), ((e, t) => e.filter(((e, s) => t[s])))))
        })), ot = pt(Ke, "sharedTeams", [l.lazy], (function() {
            return this.allTeams.extend(c.Q.where(u.o.teams.isShared, !0))
        })), rt = pt(Ke, "ownedBusinesses", [l.lazy], (function() {
            return this.currentUser.pipe(i.switchMap((e => e ? e.ownedBusinesses.observe() : i.of([]))))
        })), it = pt(Ke, "_currentUserQuery", [l.lazy], (function() {
            return this.collections.get(u.w.users).query(c.Q.where(u.o.users.isMe, !0))
        })), ct = pt(Ke, "currentUser", [l.lazy], (function() {
            return this._currentUserQuery.observe().pipe(i.switchMap((([e]) => e ? e.observe() : i.of(null))))
        })), lt = pt(Ke, "personalTags", [l.lazy], (function() {
            return this.collections.get(u.w.tags).query(c.Q.where(u.o.tags.teamId, null))
        })), dt = pt(Ke, "manageableBusinesses", [l.lazy], (function() {
            return this.currentUser.pipe(i.switchMap((e => e ? e.manageableBusinesses.observe() : i.of([]))))
        })), ut = pt(Ke, "manageableTeams", [l.lazy], (function() {
            return this.currentUser.pipe(i.switchMap((e => e ? e.manageableTeams.observe() : i.of([]))))
        })), mt = pt(Ke, "manageableStandaloneTeams", [l.lazy], (function() {
            return this.currentUser.pipe(i.switchMap((e => e ? e.manageableStandaloneTeams.observe() : i.of([]))))
        })), ht = pt(Ke, "hasManyActiveTeams", [l.lazy], (function() {
            return this.activeTeams.pipe(i.map((e => 1 < e.length)))
        })), Ke)
    }, , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(13);
        s(2), s(3);
        const o = s(454);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                badge: t,
                size: s
            } = e;
            return (0, r.jsx)("div", {
                className: o.root + " " + (e.className || ""),
                style: Object.assign({
                    backgroundColor: n.Styling.rgba(n.Styling.factoryColor(t.color), .2)
                }, e.style),
                children: (0, r.jsx)(a.default, {
                    name: t.icon,
                    color: t.color,
                    size: s
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            m: () => n
        });
        const n = Object.freeze({
            Evernote: "evernote",
            Dropbox: "dropbox",
            GoogleDrive: "gdrive",
            OneDrive: "onedrive"
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            k: () => o,
            u: () => r
        });
        var n = s(4),
            a = s(243);
        const o = {
            integrationMetadata: "integration_metadata"
        };

        function r(e, t) {
            const s = {};
            if (n.isObject(e)) {
                const r = e[o.integrationMetadata];
                n.isObject(r) && (s[o.integrationMetadata] = function(e, t) {
                    if (t._integrationType === a.m.Evernote) {
                        const {
                            note_id: t,
                            link: s,
                            app_link: n
                        } = e;
                        if (i(t) && i(s) && i(n)) return {
                            note_id: t,
                            link: s,
                            app_link: n
                        }
                    }
                    if (t._integrationType === a.m.Dropbox) {
                        const {
                            file_id: t,
                            path_lower: s,
                            link: n,
                            is_thumbnail_available: a
                        } = e;
                        if (i(t) && i(s) && (!n || i(n))) return {
                            file_id: t,
                            path_lower: s,
                            link: n,
                            is_thumbnail_available: Boolean(a)
                        }
                    }
                    if (t._integrationType === a.m.GoogleDrive) {
                        const {
                            file_id: t,
                            webview_link: s,
                            thumbnail_link: n
                        } = e;
                        if (i(t) && i(s) && (!n || i(n))) return {
                            file_id: t,
                            webview_link: s,
                            thumbnail_link: n
                        }
                    }
                    if (t._integrationType === a.m.OneDrive) {
                        const {
                            item_id: t,
                            link: s,
                            is_thumbnail_available: n
                        } = e;
                        if (i(t) && (!s || i(s))) return {
                            item_id: t,
                            link: s,
                            is_thumbnail_available: Boolean(n)
                        }
                    }
                    return
                }(r, t))
            }
            return s
        }
        const i = e => n.isString(e) && n.isNotEmpty(e)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            W: () => l,
            n: () => c
        });
        var n = s(4);
        const a = "https://(?:nozbe.app|(?:(?:teams|dev4).nozbe.com)|master.nozbeteams.workers.dev|dev.nozbe.app)/(?:(?:teams/(\\w+)/(\\w+))|(?:personal/(\\w+)))(?:/(\\w+)(?:/(\\w+)(?:/(\\w+))?)?)?(#[\\w=\\-]*)?",
            o = new RegExp("^" + a + "$", "i"),
            r = new RegExp("\\b" + a + "\\b", "gi"),
            i = /[?#]section=([^#]*)&?/;

        function c(e, t) {
            if (!e.length) return null;
            const [, s, a, r, c, l, d, u] = o.exec(t) || [];
            if (!(!!r || n.pluckIds(e).includes(s))) return null;
            const [, m] = i.exec(u) || [], h = r || a, p = "task_id" === h, g = d || (p ? c : l), f = "projects" === h && m ? m : void 0;
            return {
                url: t,
                hash: u,
                taskId: g,
                tagId: "tags" !== h || g ? void 0 : c,
                projectId: "projects" !== h || g || f ? void 0 : c,
                sectionId: f,
                memberId: "members" !== h || g ? void 0 : c,
                isTaskRefRoute: p
            }
        }

        function l(e, t) {
            return (e.match(r) || []).map((e => c(t, e))).filter(Boolean)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(0),
            a = s(213),
            o = s(21),
            r = s(13),
            i = s(18),
            c = s(11),
            l = s(71);
        s(2), s(3);
        const d = s(501);
        var u = s(1);
        const m = n.Hocs.compose()((e => {
                const {
                    icon: t,
                    value: s,
                    color: a,
                    label: o,
                    onPress: m,
                    allowFontScaling: h
                } = e;
                return (0, u.jsx)(l.default, {
                    renderLabel: o,
                    timeToActivite: 500,
                    children: (0, u.jsxs)(c.Z, {
                        className: d.root + " " + (e.className || ""),
                        style: e.style,
                        onPress: m,
                        children: [(0, u.jsx)(r.default, {
                            className: d.icon,
                            name: t,
                            size: 18,
                            color: a,
                            accessibilityLabel: o
                        }), "object" != typeof s ? (0, u.jsx)(i.default, {
                            className: d.text,
                            style: {
                                color: n.Styling.factoryColor(a)
                            },
                            allowFontScaling: h,
                            children: s
                        }) : s]
                    })
                })
            })),
            h = n.Hocs.compose()((e => {
                const t = n.Hooks.useIntl(),
                    {
                        counters: s,
                        variant: r,
                        onPress: i,
                        color: c = "textSecondary",
                        taskLabel: l = t.f.uA,
                        taskIcon: d = "{",
                        allowFontScaling: h = !0
                    } = e,
                    p = "timeAttributesOnly" !== r && !!s.count,
                    g = !!s.timeNeeded || !!s.timeSpent;
                return p || g ? (0, u.jsxs)(a.Z, {
                    direction: "row",
                    spacing: 4,
                    className: e.className,
                    style: e.style,
                    children: [p ? (0, u.jsx)(m, {
                        label: l,
                        value: s.count,
                        icon: d,
                        color: c,
                        allowFontScaling: h,
                        onPress: i
                    }) : null, g ? (0, u.jsxs)(u.Fragment, {
                        children: [(0, u.jsx)(m, {
                            label: t.f.uE,
                            value: (0, o.formatTimeAttribute)(s.timeNeeded, t, {
                                format: "short"
                            }),
                            icon: "Ƭ",
                            color: c,
                            allowFontScaling: h,
                            onPress: i
                        }), (0, u.jsx)(m, {
                            label: t.f.uF,
                            value: (0, o.formatTimeAttribute)(s.timeSpent, t, {
                                format: "short"
                            }),
                            icon: "Ư",
                            color: c,
                            allowFontScaling: h,
                            onPress: i
                        })]
                    }) : null]
                }) : null
            }))
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i,
            w: () => r
        });
        var n = s(0),
            a = s(1);
        const o = (() => {
                const e = globalThis.document.querySelector("script[data-id='main-script']");
                return (null == e ? void 0 : e.dataset.nonce) || ""
            })(),
            r = n.React.createContext(o),
            i = ({
                children: e
            }) => (0, a.jsx)(r.Provider, {
                value: o,
                children: e
            })
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            W2: () => l,
            dk: () => u,
            $I: () => m,
            hj: () => c,
            Fk: () => i,
            Dx: () => d
        });
        s(0);
        var n = s(11),
            a = s(40);
        s(2), s(3);
        const o = s(524);
        var r = s(1);
        const i = e => (0, r.jsx)("span", {
                className: o.textInTouchable + (e.isDisabled ? " " + o.textInTouchableDisabled : ""),
                children: e.children
            }),
            c = e => (0, r.jsx)(n.Z, {
                className: o.touchable + (e.disabledStyle ? " " + o.touchableDisabled : "") + (e.withLeftMargin ? " " + o.addNextTouchable : "") + (e.withMarginTop ? " " + o.marginTop : ""),
                onPress: e.onPress,
                isDisabled: e.isDisabled,
                children: e.children
            }),
            l = e => (0, r.jsx)("div", {
                className: o.container,
                children: e.children
            }),
            d = e => (0, r.jsx)("span", {
                className: o.title,
                children: e.children
            }),
            u = e => (0, r.jsx)("span", {
                className: o.description,
                children: e.children
            }),
            m = e => (0, r.jsx)(a.default, {
                className: o.iconstack,
                layers: e.layers,
                children: e.children
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.resolve().then(s.bind(s, 260))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0);
        const a = n.Hocs.compose((e => n.Hocs.memo(e, ((e, t) => {
            var s;
            return !(e.style && e.style.background !== (null == (s = t.style) ? void 0 : s.background))
        }))), n.Hocs.withHooks((({
            gradientColors: e = [n.Styling.rgba(n.Styling.vars.color.surface, 0), n.Styling.vars.color.surface],
            gradientStartPoint: t = {
                x: 0,
                y: .5
            },
            gradientEndPoint: s = {
                x: 1,
                y: .5
            }
        }) => ({
            gradientColors: e,
            gradientStartPoint: t,
            gradientEndPoint: s
        }))));
        var o = s(1);
        const r = a((e => (0, o.jsx)("div", {
            className: e.className,
            style: e.style
        })))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => $,
            U: () => K
        });
        var n = s(0);

        function a(e, t) {
            const {
                url: s,
                id: a,
                service: o
            } = e, {
                thumbnailMinHeight: r
            } = t || {}, {
                resources: {
                    externalVideo: i
                }
            } = n.Hooks.useServices(), [c, l] = n.React.useState((() => i.has(o, a) ? {
                isLoaded: !0,
                metadata: i.get(o, a)
            } : {
                isLoaded: !1
            }));
            return n.React.useEffect((() => {
                if (c.isLoaded) return n.FP.noop;
                const e = i.observe(o, a, {
                    videoUrl: s
                }).subscribe((e => {
                    l({
                        isLoaded: !0,
                        metadata: e
                    })
                }));
                return () => {
                    e.unsubscribe()
                }
            }), [i, o, a, s, c.isLoaded]), n.React.useMemo((() => {
                const e = c.isLoaded ? c.metadata : null,
                    t = function(e, t) {
                        return (null == t ? void 0 : t.title) || e
                    }(s, e),
                    [i, l] = function(e) {
                        switch (e) {
                            case "youtube":
                                return ["ǁ", n.Styling.factoryColorLiteral("#FF5534")];
                            case "vimeo":
                                return ["ƺ", n.Styling.factoryColorLiteral("#24B1F2")];
                            default:
                                return e
                        }
                    }(o),
                    d = function(e, t, s) {
                        const a = encodeURIComponent(t);
                        switch (e) {
                            case "vimeo":
                                if (null != s && s.previewUrl) try {
                                    const e = n.FP.parseUrl(s.previewUrl);
                                    return e.searchParams.autoplay = "1", e.searchParams.playsinline = "1", n.FP.encodeUrl(e)
                                } catch (e) {}
                                return "https://player.vimeo.com/video/" + a + "?autoplay=1&playsinline=1";
                            case "youtube":
                                return "https://www.youtube-nocookie.com/embed/" + a + "?autoplay=1&playsinline=1";
                            default:
                                return e
                        }
                    }(o, a, e),
                    u = e ? function(e, t) {
                        if (!e.thumbnails.length) return null;
                        const s = [...e.thumbnails].sort(((e, t) => e.height - t.height)),
                            n = s[s.length - 1];
                        if (!t) return n.url;
                        return (s.find((e => e.height >= t)) || n).url
                    }(e, r) : null;
                return {
                    service: o,
                    id: a,
                    url: s,
                    title: t,
                    icon: i,
                    color: l,
                    previewUrl: d,
                    thumbnailUrl: u,
                    isMetadataLoaded: c.isLoaded
                }
            }), [o, a, s, r, c])
        }
        var o = s(1);
        const r = n.ReactUtils.lazy((() => s(227))),
            i = n.ReactUtils.lazy((() => s(1307))),
            c = n.Hocs.compose()((e => {
                const {
                    videoUrl: t,
                    videoId: s,
                    service: c
                } = e, l = n.Hooks.useIntl(), d = a({
                    service: c,
                    id: s,
                    url: t
                }, {
                    thumbnailMinHeight: 200
                }), {
                    title: u,
                    icon: m,
                    color: h,
                    thumbnailUrl: p,
                    isMetadataLoaded: g
                } = d, f = g ? p ? {
                    state: "loaded",
                    source: p
                } : null : {
                    state: "loading"
                }, b = n.Hooks.useModal((({
                    close: e
                }) => (0, o.jsx)(i, {
                    video: d,
                    onClose: e
                })));
                return (0, o.jsxs)(o.Fragment, {
                    children: [(0, o.jsx)(r, {
                        name: u,
                        icon: {
                            name: m,
                            color: h
                        },
                        thumbnail: f,
                        contentButton: {
                            accessibilityLabel: l.f.f9,
                            onPress: () => b.open()
                        }
                    }), b.render()]
                })
            }));
        s(2), s(3);
        const l = s(593),
            d = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("blockquote", {
                    className: l.root,
                    style: s,
                    children: t
                })
            },
            u = s(594),
            m = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("ul", {
                    className: u.root,
                    style: s,
                    children: t
                })
            },
            h = s(595),
            p = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("h1", {
                    className: h.root,
                    style: s,
                    children: t
                })
            },
            g = s(596),
            f = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("h2", {
                    className: g.root,
                    style: s,
                    children: t
                })
            },
            b = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("li", {
                    children: t
                })
            },
            y = s(597),
            v = e => {
                const {
                    children: t,
                    lastStyle: s,
                    start: n
                } = e;
                return (0, o.jsx)("ol", {
                    start: n,
                    className: y.root,
                    style: s,
                    children: t
                })
            },
            w = s(598),
            k = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("div", {
                    className: w.root,
                    style: s,
                    children: t
                })
            },
            x = s(599),
            j = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("div", {
                    className: x.root,
                    style: s,
                    children: t
                })
            };
        var T = s(35),
            S = s(13);
        const P = s(600),
            _ = e => (0, o.jsx)("span", {
                className: P.text + (e.isCompleted ? " " + P.completedText : ""),
                children: e.children
            }),
            C = n.Hocs.compose()((e => {
                const {
                    children: t,
                    isCompleted: s,
                    id: a,
                    comment: r
                } = e, i = n.React.useRef(!1), c = n.React.useRef(!1), l = n.React.useRef(0), d = n.React.useRef(0);
                return (0, o.jsxs)("div", {
                    className: P.root + ("disposable" === (null == r ? void 0 : r.syncStatus) ? " " + P.disabled : ""),
                    onClick: e => {
                        i.current = !1, l.current = 0, d.current = 0, c.current ? c.current = !1 : (c.current = !1, e.preventDefault(), a && r && r.do.updateBody((0, T.Tu)(r, a), !1))
                    },
                    onMouseDown: () => {
                        i.current = !0
                    },
                    onMouseMove: e => {
                        i.current ? (l.current += e.movementY, d.current += e.movementX, c.current = d.current > 2 || d.current < -2 || l.current < -2 || l.current > 2) : c.current = !1
                    },
                    children: [(0, o.jsx)("div", {
                        className: P.icon,
                        contentEditable: !1,
                        suppressContentEditableWarning: !0,
                        children: (0, o.jsx)(S.default, {
                            name: s ? "]" : "^",
                            size: 28,
                            color: s ? "purple" : "onBackground2"
                        })
                    }), (0, o.jsx)(_, {
                        isCompleted: s,
                        children: t
                    })]
                })
            }));
        var R = s(601);
        const A = s(603),
            I = e => {
                const {
                    lastStyle: t
                } = e;
                return (0, o.jsx)("hr", {
                    className: A.root,
                    style: t
                })
            },
            N = s(604),
            E = e => {
                const {
                    children: t,
                    lastStyle: s
                } = e;
                return (0, o.jsx)("pre", {
                    className: N.root,
                    style: s,
                    children: t
                })
            },
            O = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("strong", {
                    children: t
                })
            },
            M = s(605),
            D = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("code", {
                    className: M.root,
                    children: t
                })
            },
            H = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("em", {
                    children: t
                })
            },
            F = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("u", {
                    children: t
                })
            },
            Z = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("s", {
                    children: t
                })
            };
        var L = s(534);
        const B = e => {
                const {
                    children: t
                } = e;
                return (0, o.jsx)("span", {
                    className: L.Z.highlight,
                    children: t
                })
            },
            z = ({
                children: e
            }) => (0, o.jsx)("span", {
                children: e
            }),
            U = ({
                children: e
            }) => (0, o.jsx)("div", {
                children: e
            });
        var W;
        const G = () => W || (W = (0, o.jsx)("br", {})),
            V = ({
                children: e
            }) => (0, o.jsx)("span", {
                children: e
            });

        function q(e, t, s) {
            var a;
            const o = e.document.nodes,
                r = (null == (a = e.document.data) ? void 0 : a.richContent) || [],
                i = [],
                c = (e, t) => {
                    if (e && t) {
                        const t = e;
                        i.push(n.React.cloneElement(t, Object.assign({}, t.props, {
                            lastStyle: {
                                marginBottom: 0
                            }
                        })))
                    } else i.push(e)
                };
            if (s) {
                if (!o[0]) return [];
                const e = Q(o[0], t);
                return c(e, !0), i
            }
            return o.forEach(((e, s) => {
                const a = Q(e, t),
                    i = n.FP.isLastOnList(s, o) && !r.length;
                c(a, i)
            })), r.forEach(((e, s) => {
                const a = Y(t(e)),
                    o = n.FP.isLastOnList(s, r);
                c(a, o)
            })), i
        }

        function Q(e, t) {
            if ("text" === e.object) return e.leaves.map((e => function(e, t) {
                if ("" === e.text) return [];
                const s = {
                        object: "string",
                        text: e.text
                    },
                    n = function(e, t) {
                        const s = t(e, e.text);
                        return Y(s)
                    }(s, t);
                return e.marks.reduce(((e, s) => Y(t(s, e))), n)
            }(e, t)));
            const {
                nodes: s
            } = e, n = null == s ? void 0 : s.map((e => Q(e, t)));
            return Y(t(e, n))
        }

        function Y(e) {
            return e ? n.React.cloneElement(e, {
                key: n.Misc.nextTag()
            }) : e
        }
        var J;

        function K(e, t) {
            return q(e.getBodyForCheapoWysiwyg(t), X(e, !0), !0)
        }

        function $(e, t) {
            return q(e.getBodyForCheapoWysiwyg(t), X(e))
        }

        function X(e, t = !1) {
            return (n, a) => {
                if ("rich-content" === n.object) return "video" === n.type ? (0, o.jsx)(c, {
                    service: n.data.service,
                    videoId: n.data.videoId,
                    videoUrl: n.data.videoUrl
                }) : null;
                if ("block" === n.object) {
                    if (t) return (0, o.jsx)(o.Fragment, {
                        children: a
                    });
                    switch (n.type) {
                        case "paragraph":
                            return (0, o.jsx)(k, {
                                children: a
                            });
                        case "blockquote":
                            return (0, o.jsx)(d, {
                                children: a
                            });
                        case "heading-one":
                            return (0, o.jsx)(p, {
                                children: a
                            });
                        case "heading-two":
                            return (0, o.jsx)(f, {
                                children: a
                            });
                        case "list-item":
                            return (0, o.jsx)(b, {
                                children: a
                            });
                        case "bullet-list":
                            return (0, o.jsx)(m, {
                                children: a
                            });
                        case "numbered-list":
                            return (0, o.jsx)(v, {
                                start: n.data.start,
                                children: a
                            });
                        case "checklist":
                            return (0, o.jsx)(j, {
                                children: a
                            });
                        case "checklist-item":
                            return (0, o.jsx)(C, {
                                isCompleted: n.data.isCompleted,
                                id: n.data.id,
                                comment: e,
                                children: a
                            });
                        case "horizontal-rule":
                            return J || (J = (0, o.jsx)(I, {}));
                        case "code-block":
                            return (0, o.jsx)(E, {
                                children: a
                            });
                        default:
                            return (0, o.jsx)(U, {
                                children: a
                            })
                    }
                }
                if ("mark" === n.object) switch (n.type) {
                    case "bold":
                        return (0, o.jsx)(O, {
                            children: a
                        });
                    case "italic":
                        return (0, o.jsx)(H, {
                            children: a
                        });
                    case "underline":
                        return (0, o.jsx)(F, {
                            children: a
                        });
                    case "code":
                        return (0, o.jsx)(D, {
                            children: a
                        });
                    case "strikethrough":
                        return (0, o.jsx)(Z, {
                            children: a
                        });
                    case "highlight":
                    case "highlightSearch":
                        return (0, o.jsx)(B, {
                            children: a
                        });
                    default:
                        return (0, o.jsx)(z, {
                            children: a
                        })
                }
                if ("inline" === n.object) switch (n.type) {
                    case "image":
                        return (0, o.jsx)(z, {
                            children: n.data.url
                        });
                    case "link":
                        return (0, o.jsx)(R.Z, {
                            url: n.data.url,
                            children: a
                        });
                    case "internal-link": {
                        const e = s(1312).Z;
                        return (0, o.jsx)(e, {
                            url: n.data.url,
                            model: n.data.model,
                            hash: n.data.hash
                        })
                    }
                    case "mention": {
                        const t = s(607).Z;
                        return (0, o.jsx)(t, {
                            memberId: n.data.memberId,
                            groupMentionId: n.data.groupMentionId,
                            comment: e
                        })
                    }
                    default:
                        return (0, o.jsx)(V, {
                            children: a
                        })
                }
                if ("string" === n.object) {
                    const e = a.split("\n").map(((e, t) => [0 === t && e ? null : (0, o.jsx)(G, {}, t), e])).flat().filter(Boolean);
                    return (0, o.jsx)(V, {
                        children: e
                    })
                }
                return null
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(40),
            o = s(32);
        s(2), s(3);
        const r = s(609);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                closeMenu: t,
                target: s,
                minHeight: n,
                level: c,
                placement: l,
                boundTo: d = "center",
                iconStack: u,
                title: m,
                message: h,
                children: p,
                isDesktopModal: g
            } = e, [{
                closeAnimated: f
            }, b] = (0, o.XH)();
            return (0, i.jsx)(o.ZP, {
                ref: b,
                onClose: t,
                target: s,
                boundTo: d,
                level: c,
                placement: l,
                minHeight: n || 400,
                isDesktopModal: g,
                children: (0, i.jsxs)("div", {
                    className: r.root,
                    children: [(0, i.jsx)(a.default, {
                        layers: u
                    }), (0, i.jsx)("span", {
                        className: r.title,
                        children: m
                    }), (0, i.jsx)("span", {
                        className: r.description,
                        children: h
                    }), p(f)]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            SJ: () => y,
            c2: () => P,
            vZ: () => v,
            Ix: () => A,
            zg: () => R,
            Sn: () => T,
            Ar: () => C
        });
        var n = s(0),
            a = s(14),
            o = s(365);

        function r(e) {
            return t => {
                const {
                    location: s,
                    match: o
                } = t, r = n.Hooks.useServices(), i = e();
                return n.Hooks.useAsyncEffect((async () => {
                    const e = await (async () => {
                            const e = await r.history._getLastRoute();
                            return e ? {
                                path: e
                            } : a.pathToRoot
                        })(),
                        t = await i({
                            lastRoute: e,
                            location: s,
                            match: o
                        });
                    t && !0 !== t.redirect ? t.redirect && r.router.goTo(t.redirect) : r.router.goTo(e)
                }), []), null
            }
        }
        const i = r((() => {
                const e = n.Hooks.useServices(),
                    {
                        currentTeam: t
                    } = n.Hooks.useIdentity();
                return async ({
                    lastRoute: s,
                    location: {
                        search: o
                    }
                }) => {
                    if (o) {
                        const t = n.ReactUtils.parseQueryParam("project", o),
                            s = n.ReactUtils.parseQueryParam("is_priority", o),
                            a = n.ReactUtils.parseQueryParam("tag", o);
                        e.uiState.quickAddModal.open(t || s || a ? {
                            projectId: t,
                            isPriority: !!s,
                            tagId: a
                        } : void 0)
                    } else e.uiState.quickAddModal.open();
                    return s.path.includes(t.id) ? {
                        redirect: s
                    } : {
                        redirect: a.pathToRoot
                    }
                }
            })),
            c = r((() => {
                const e = n.Hooks.useServices(),
                    {
                        currentTeam: t
                    } = n.Hooks.useIdentity();
                return async ({
                    lastRoute: s
                }) => (e.uiState.jumpToModal.open(), s.path.includes(t.id) ? {
                    redirect: s
                } : {
                    redirect: a.pathToRoot
                })
            })),
            l = r((() => {
                const e = n.Hooks.useServices();
                return async ({
                    location: t,
                    match: s
                }) => {
                    const {
                        inviteId: n,
                        joinCode: a
                    } = s.params, r = (0, o.Z)(t.search);
                    n ? e.appState.startAcceptingTeamInvitation({
                        inviteId: n,
                        teamName: r
                    }) : a && e.appState.startAcceptingTeamInvitation({
                        joinCode: a,
                        teamName: r
                    })
                }
            })),
            d = r((() => {
                const e = n.Hooks.useServices();
                return async ({
                    match: t
                }) => {
                    const {
                        projectInvitationToken: s
                    } = t.params;
                    s && e.appState.startAcceptingProjectInvitation(s)
                }
            })),
            u = r((() => {
                const e = n.Hooks.useServices();
                return async ({
                    match: t
                }) => {
                    const {
                        taskInvitationToken: s
                    } = t.params;
                    s && e.appState.startAcceptingTaskInvitation(s)
                }
            })),
            m = r((() => {
                const e = n.Hooks.useServices();
                return async ({
                    lastRoute: t,
                    match: s
                }) => {
                    const {
                        tokenId: n
                    } = s.params;
                    return n ? (e.appState.startClaimPurchase(n), t.path.startsWith("claim_purchase") ? {
                        redirect: a.pathToRoot
                    } : {
                        redirect: t
                    }) : {
                        redirect: !0
                    }
                }
            })),
            h = r((() => {
                const e = n.Hooks.useServices(),
                    {
                        currentTeam: t
                    } = n.Hooks.useIdentity();
                return async ({
                    location: {
                        hash: s
                    }
                }) => {
                    if ("#buy_premium" === s || "#buy_business" === s) {
                        const n = t.planInfo.canBeExtended && !t.isExpired ? "plan-extending" : "plan-changing";
                        e.payments.requirements.set(t, n, {
                            withPromotion: !0,
                            shouldDisplayBusinessOffer: "#buy_business" === s
                        })
                    } else "#create_new_team" === s && e.uiState.addTeamModal.open()
                }
            }));
        var p, g = s(1);
        s(1328).wx, s(1329).wx, s(253).wx;
        const f = () => {
                const e = n.Hooks.useServices();
                return () => {
                    e.native.reload()
                }
            },
            b = e => {
                f();
                const {
                    message: t,
                    preFilledEmail: a,
                    preFilledPassword: o,
                    token: r
                } = e.location.state || {}, i = Object.assign({
                    message: t,
                    preFilledEmail: a,
                    preFilledPassword: o,
                    token: r
                }, e);
                return n.React.createElement(s(883).Z, i)
            },
            y = e => (f(), n.React.createElement(s(884).Z, e)),
            v = e => (f(), n.React.createElement(s(886).Z, e)),
            w = e => (f(), n.React.createElement(s(1480).Z, e)),
            k = e => {
                const {
                    thirdPartyName: t
                } = e.match.params;
                return n.React.createElement(s(651).default, Object.assign({
                    thirdPartyName: t
                }, e))
            },
            x = e => {
                const {
                    registerId: t,
                    inviteId: a,
                    joinCode: o,
                    projectInvitationToken: r,
                    taskInvitationToken: i,
                    loginProviderToken: c
                } = e.match.params, {
                    accountUpgradeToken: l
                } = e.location.state || {}, d = Object.assign({
                    registerId: t,
                    inviteId: a,
                    joinCode: o,
                    projectInvitationToken: r,
                    taskInvitationToken: i,
                    loginProviderToken: c,
                    accountUpgradeToken: l
                }, e);
                return f(), n.React.createElement(s(887).Z, d)
            },
            j = e => {
                const t = Object.assign({
                    isDirectFromURL: !0
                }, e);
                return f(), n.React.createElement(s(891).Z, t)
            };

        function T() {
            const {
                router: e
            } = n.Hooks.useServices(), {
                currentTeam: t,
                isLimitedAccount: s
            } = n.Hooks.useIdentity();
            return () => {
                setTimeout((() => {
                    e.goTo(s ? (0, a.pathToSingleTasks)(t) : (0, a.pathToPriority)(t))
                }), 0)
            }
        }
        const S = n.ReactUtils.lazy((() => s(1334))),
            P = () => {
                const e = T();
                return n.React.useEffect((() => e()), []), null
            },
            _ = n.ReactUtils.lazy((() => s(1395))),
            C = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withErrorBoundary({
                name: "TaskList",
                render: "screen",
                onReset: ({
                    services: e
                }) => {
                    e.router.goTo(a.pathToRoot)
                }
            }), n.Hocs.memo),
            R = (a.routeToDevTools, a.routeToTaskList, a.routeToProject, a.routeToTag, a.routeToMember, a.routeToTaskListTask, a.routeToProjectTask, a.routeToTagTask, a.routeToMemberTask, a.routeToPromotion, a.routeToQuickAdd, a.routeToJumpTo, a.routeToRegisterConfirm, a.routeToResetPassword, a.routeToResetPasswordRequest, a.routeToLoginProvider, a.routeToLogin, a.routeToSignup, a.routeToMigrateNP, [
                [a.routeToInvite, l],
                [a.routeToJoin, l],
                [a.routeToClaimPurchase, m],
                [a.routeToPromotion, h],
                [a.routeToQuickAdd, i],
                [a.routeToJumpTo, c],
                [a.routeToJoinProject, d],
                [a.routeToTaskInvite, u],
                [a.routeToTaskId, _],
                [a.routeToTaskList, e => {
                    const {
                        match: {
                            params: {
                                taskListName: t
                            }
                        }
                    } = e;
                    switch (T(), t) {
                        case "priority":
                            return n.React.createElement(s(1377).Z, {});
                        case "incoming":
                            return n.React.createElement(s(900).Z, {});
                        case "activity":
                            return n.React.createElement(s(901).Z, {});
                        case "single_tasks":
                            return n.React.createElement(s(1382).Z, {});
                        case "calendar":
                            return n.React.createElement(s(902).Z, {});
                        case "search":
                            return n.React.createElement(s(904).Z, {});
                        case "messages":
                            return n.React.createElement(s(905).Z, e);
                        default:
                            return p || (p = (0, g.jsx)(P, {}))
                    }
                }],
                [a.routeToProject, S],
                [a.routeToTag, e => (T(), n.React.createElement(s(1481).Z, e))],
                [a.routeToMember, e => (T(), n.React.createElement(s(898).Z, e))],
                [a.routeToThirdParty, k],
                [a.routeToRoot, P]
            ]),
            A = [
                [a.routeToTaskId, e => {
                    const {
                        history: t
                    } = n.Hooks.useServices(), s = t.currentPath.getValue();
                    return n.React.useEffect((() => {
                        n.Misc.isElectron || n.ReactUtils.openUrl("nozbe4://goto" + s, "_self")
                    }), [s]), x(e)
                }],
                [a.routeToInvite, x],
                [a.routeToJoin, x],
                [a.routeToFinishCreateTeam, x],
                [a.routeToJoinProject, x],
                [a.routeToTaskInvite, x],
                [a.routeToLoginProvider, x],
                [a.routeToRegisterConfirm, e => {
                    const {
                        confirmId: t
                    } = e.match.params, a = Object.assign({
                        confirmId: t
                    }, e);
                    return f(), n.React.createElement(s(889).Z, a)
                }],
                [a.routeToResetPassword, e => {
                    const {
                        tokenId: t
                    } = e.match.params, a = Object.assign({
                        tokenId: t
                    }, e);
                    return f(), n.React.createElement(s(890).Z, a)
                }],
                [a.routeToResetPasswordRequest, j],
                [a.routeToWellKnownChangePassword, j],
                [a.routeToEmailChangeConfirm, y],
                [a.routeToAppleSignInRedirect, w],
                [a.routeToGoogleSignInRedirect, w],
                [a.routeToNozbeSignInRedirect, w],
                [a.routeToSignup, e => {
                    const {
                        token: t,
                        preFilledEmail: a
                    } = e.location.state || {}, o = Object.assign({
                        token: t,
                        preFilledEmail: a
                    }, e);
                    return f(), n.React.createElement(s(888).Z, o)
                }],
                [a.routeToLogin, b],
                [a.routeToThirdParty, k],
                [a.routeToMigrateNP, e => {
                    f();
                    const {
                        preFilledEmail: t
                    } = e.location.state || {};
                    return Object.assign({
                        preFilledEmail: t
                    }, e), n.React.createElement(s(885).Z, e)
                }],
                [a.routeToRoot, x]
            ]
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(12),
            o = s(20),
            r = s(25);
        s(2), s(3);
        const i = s(650);
        var c = s(1);
        const l = n.Hocs.compose()((e => {
            const {
                goToNext: t,
                goBack: s,
                setMarketingConsent: l
            } = e, d = n.Hooks.useIntl(), u = n.Hooks.useModalState(), m = e => {
                l(e), t(e)
            }, h = () => m(!0);
            return n.Hooks.useEventListener({
                eventName: "keydown",
                handler: e => {
                    "Enter" === e.key && h()
                }
            }), (0, c.jsxs)(c.Fragment, {
                children: [(0, c.jsxs)("div", {
                    className: i.textContainer,
                    children: [(0, c.jsx)("span", {
                        className: i.text,
                        children: d.f.kt
                    }), (0, c.jsx)("span", {
                        className: i.text,
                        children: d.f.kv
                    })]
                }), (0, c.jsx)(o.Z, {
                    icon: "Ɲ",
                    label: d.f.ky,
                    onPress: () => {
                        n.ReactUtils.openUrl(d.f.kz)
                    },
                    hasHairline: !1
                }), (0, c.jsx)(o.Z, {
                    icon: "Ɲ",
                    label: d.f.kw,
                    onPress: () => {
                        n.ReactUtils.openUrl(d.f.kx)
                    },
                    hasHairline: !1
                }), (0, c.jsx)(a.default, {
                    marginTop: "big",
                    onPress: () => {
                        u.open()
                    },
                    color: "orange",
                    label: d.f.ks
                }), (0, c.jsx)(a.default, {
                    marginTop: "big",
                    onPress: h,
                    variant: "opaque",
                    color: "orange",
                    label: d.f.kr
                }), s ? (0, c.jsx)(a.default, {
                    label: d.f.fd,
                    marginTop: "big",
                    onPress: s
                }) : null, u.isOpen ? (0, c.jsx)(r.default, {
                    type: "confirm",
                    onConfirmPress: h,
                    onClose: u.close,
                    confirmButtonMessage: d.f.e_,
                    secondaryButtonMessage: d.f.fK,
                    secondaryButtonIcon: null,
                    onBackPress: () => m(!1),
                    children: d.f.ku
                }) : null]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => s.e(886).then(s.bind(s, 1505))))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            CommentEdit: () => Is.default,
            PreviewButton: () => Ns.Z,
            TaskDetails: () => As
        });
        var n = s(0),
            a = s(14),
            o = s(21),
            r = s(17),
            i = s(88),
            c = s(35),
            l = s(1);
        s(259).wx;
        const d = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "TaskDetailsTour",
            render: "alert"
        }), n.Hocs.withServices, n.Hocs.withObservables(["services"], (({
            services: e
        }) => ({
            requiresNewOnboarding: e.modelRoot.settings.requiresNewOnboarding.observe(),
            sawGeneralOnboarding: e.modelRoot.settings.sawGeneralOnboarding.observe(),
            sawGeneralPersonalOnboarding: e.modelRoot.settings.sawGeneralPersonalOnboarding.observe(),
            sawTaskDetailsOnboarding: e.modelRoot.settings.sawTaskDetailsOnboarding.observe()
        }))))((e => {
            const {
                requiresNewOnboarding: t,
                sawTaskDetailsOnboarding: a,
                sawGeneralOnboarding: o,
                sawGeneralPersonalOnboarding: r,
                onDidRequestTour: i,
                isReady: c,
                onBeforeBegin: d
            } = e, {
                isLimitedAccount: u
            } = n.Hooks.useIdentity();
            if (!u && t && (o || r) && !a) {
                const e = s(893).Z;
                return (0, l.jsx)(e, {
                    onDidRequestTour: i,
                    isReady: c,
                    onBeforeBegin: d
                })
            }
            return null
        }));
        var u = s(68),
            m = s(16),
            h = s(11),
            p = s(18),
            g = s(254),
            f = s(13),
            b = s(673),
            y = s(299);
        s(2), s(3);
        const v = s(677),
            w = (e, t) => "string" == typeof e ? (0, y.t)(e, t) : (0, c.Ds)(e, !0),
            k = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    onPress: t,
                    value: s,
                    isInitiallyRendered: a,
                    avatarStyle: o
                } = e, {
                    currentMember: r
                } = n.Hooks.useIdentity(), i = n.Hooks.useIntl(), {
                    isInViewport: c,
                    targetRef: d
                } = n.Hooks.useShownInViewport({}, a);
                return (0, l.jsx)("div", {
                    className: v.root,
                    ref: d,
                    "data-testid": n.Misc.testIds.task_commentPrompt,
                    children: c ? (0, l.jsx)(b.Z, {
                        author: r,
                        shouldShowUserCard: !1,
                        isEditingDisabled: !0,
                        isAvatarPressDisabled: !0,
                        isInitiallyRendered: !0,
                        avatarStyle: o,
                        children: (0, l.jsxs)(h.Z, {
                            className: v.touchable,
                            onPress: t,
                            children: [(0, l.jsx)(f.default, {
                                name: "ƽ",
                                color: "onBackground3",
                                size: 22
                            }), (0, l.jsx)(p.default, {
                                className: v.text,
                                children: w(s, i)
                            }), (0, l.jsx)(g.Z, {
                                className: v.gradient,
                                gradientColors: [n.Styling.rgba(n.Styling.vars.color.surface, 0), n.Styling.vars.color.surface]
                            })]
                        })
                    }) : null
                })
            }));
        var x = s(678),
            j = s(110),
            T = s(67),
            S = s(169),
            P = s(301);
        const _ = s(692),
            C = e => {
                const {
                    children: t,
                    isValueRemoved: s,
                    isMultiline: n
                } = e;
                return (0, l.jsx)("div", {
                    className: _.root,
                    children: n ? (0, l.jsx)("span", {
                        className: _.multiLine + (s ? " " + _.valueRemoved : ""),
                        children: t
                    }) : (0, l.jsx)(p.default, {
                        className: _.text + (s ? " " + _.valueRemoved : ""),
                        children: t
                    })
                })
            },
            R = (e, t, s, n) => {
                switch (e) {
                    case "reminder":
                        return "";
                    case "renewed":
                    case "due_date": {
                        const e = (0, j.q7)(t);
                        return s ? (0, o.formatDateTimeRelativeFromNow)({
                            dateTime: (0, o.toAbsoluteDateTime)(o.DateTime.fromLegacyDueDate(e)),
                            intl: n
                        }) : (0, o.formatDateTime)({
                            dateTime: o.DateTime.fromLegacyDueDate(e),
                            intl: n
                        })
                    }
                    case "name":
                        return t;
                    case "recurrence":
                        return t ? (0, P.rs)(t, n) : null;
                    case "time_needed":
                    case "time_spent":
                        return (0, o.formatTimeAttribute)(t, n);
                    default:
                        return null
                }
            },
            A = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    isValueRemoved: t,
                    type: s,
                    value: a,
                    isDueDateRelative: o
                } = e, r = n.Hooks.useIntl(), i = R(s, a, o, r);
                return i ? (0, l.jsx)(C, {
                    isValueRemoved: t,
                    children: i
                }) : null
            }));
        var I = s(19),
            N = s(83);
        const E = (e, t) => n.Rx.catchError((() => t ? n.Rx.of(t) : n.Rx.of(e.f.HT))),
            O = n.Hocs.compose(n.Hocs.withObservables(["value"], (({
                value: e,
                services: t,
                intl: s
            }) => ({
                observedValue: t.collections.get(r.Tables.projects).findAndObserve(e).pipe(n.Rx.map((e => n.Styling.getProjectName(e, s))), E(s))
            })))),
            M = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["value", "currentMember"], (({
                value: e,
                services: t,
                intl: s,
                type: a,
                currentMember: o
            }) => {
                const i = "access" === a && "string" == typeof e && N.Ej.test(e) ? e : void 0;
                return {
                    observedValue: e ? t.collections.get(r.Tables.teamMembers).findAndObserve(e).pipe(n.Rx.switchMap((e => e.preferredName.pipe(n.Rx.map((t => n.Styling.createMemberName(t, s, {
                        shouldRenderYou: e.id === o.id
                    })))))), E(s, i)) : n.Rx.of(null)
                }
            }))),
            D = n.Hocs.compose(n.Hocs.withObservables(["value"], (({
                value: e,
                services: t,
                intl: s
            }) => ({
                observedValue: e ? t.collections.get(r.Tables.projectSections).findAndObserve(e).pipe(n.Rx.map((e => e.name)), E(s)) : n.Rx.of(null)
            })))),
            H = n.FP.pipe(n.FP.pluck("name"), n.FP.join(", ")),
            F = n.Hocs.compose(n.Hocs.withObservables(["value"], (({
                value: e,
                services: t
            }) => ({
                observedValue: e ? t.collections.get(r.Tables.tags).query(I.Q.where((0, I.columnName)("id"), I.Q.oneOf(e))).observe().pipe(n.Rx.map(H)) : n.Rx.of(null)
            })))),
            Z = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIntl, (e => t => {
                const s = (() => {
                    switch (t.type) {
                        case "section":
                            return D;
                        case "responsible":
                        case "access":
                            return M;
                        case "project":
                            return O;
                        case "tag":
                            return F;
                        default:
                            return n.FP.identity
                    }
                })();
                return n.React.createElement(s(e), t)
            }))((e => {
                const {
                    observedValue: t,
                    isValueRemoved: s,
                    isMultiline: n
                } = e;
                return t ? (0, l.jsx)(C, {
                    isValueRemoved: s,
                    isMultiline: n,
                    children: t
                }) : null
            }));
        var L, B, z, U, W, G, V, q, Q, Y, J, K, $, X, ee, te, se, ne, ae, oe, re, ie, ce, le, de, ue, me, he, pe, ge, fe, be, ye, ve, we, ke, xe, je, Te, Se, Pe, _e, Ce, Re, Ae, Ie, Ne, Ee, Oe, Me, De, He, Fe, Ze, Le, Be, ze, Ue, We, Ge, Ve, qe, Qe, Ye, Je, Ke = s(61);
        const $e = {
                reminder: () => L || (L = (0, l.jsx)(Ke.Z, {
                    id: "Hd"
                })),
                due_date: () => B || (B = (0, l.jsx)(Ke.Z, {
                    id: "GU"
                })),
                renewed: () => z || (z = (0, l.jsx)(Ke.Z, {
                    id: "Hk"
                })),
                responsible: () => U || (U = (0, l.jsx)(Ke.Z, {
                    id: "Hn"
                })),
                section: () => W || (W = (0, l.jsx)(Ke.Z, {
                    id: "Hu"
                })),
                tag: () => G || (G = (0, l.jsx)(Ke.Z, {
                    id: "HE"
                })),
                recurrence: () => V || (V = (0, l.jsx)(Ke.Z, {
                    id: "G$"
                })),
                access: () => q || (q = (0, l.jsx)(Ke.Z, {
                    id: "GM"
                })),
                time: () => Q || (Q = (0, l.jsx)(Ke.Z, {
                    id: "HQ"
                }))
            },
            Xe = {
                reminder: () => Y || (Y = (0, l.jsx)(Ke.Z, {
                    id: "Hi"
                })),
                due_date: () => J || (J = (0, l.jsx)(Ke.Z, {
                    id: "GZ"
                })),
                renewed: () => K || (K = (0, l.jsx)(Ke.Z, {
                    id: "Hm"
                })),
                responsible: () => $ || ($ = (0, l.jsx)(Ke.Z, {
                    id: "Hs"
                })),
                section: () => X || (X = (0, l.jsx)(Ke.Z, {
                    id: "Hz"
                })),
                tag: () => ee || (ee = (0, l.jsx)(Ke.Z, {
                    id: "HB"
                })),
                recurrence: () => te || (te = (0, l.jsx)(Ke.Z, {
                    id: "Hc"
                })),
                access: () => se || (se = (0, l.jsx)(Ke.Z, {
                    id: "GQ"
                })),
                time: () => ne || (ne = (0, l.jsx)(Ke.Z, {
                    id: "HR"
                }))
            },
            et = {
                labelFrom: null,
                labelTo: null
            },
            tt = (e, t) => ({
                labelFrom: "changed" === t ? $e[e] : null,
                labelTo: "changed" === t ? Xe[e] : null
            }),
            st = Object.assign({
                labelHeader: () => ae || (ae = (0, l.jsx)(Ke.Z, {
                    id: "GS"
                }))
            }, et),
            nt = Object.assign({
                labelHeader: () => oe || (oe = (0, l.jsx)(Ke.Z, {
                    id: "GR"
                }))
            }, et),
            at = Object.assign({
                labelHeader: () => re || (re = (0, l.jsx)(Ke.Z, {
                    id: "GL"
                }))
            }, et),
            ot = Object.assign({
                labelHeader: () => ie || (ie = (0, l.jsx)(Ke.Z, {
                    id: "Ht"
                }))
            }, et),
            rt = {
                labelHeader: () => ce || (ce = (0, l.jsx)(Ke.Z, {
                    id: "G3"
                })),
                labelFrom: () => le || (le = (0, l.jsx)(Ke.Z, {
                    id: "G2"
                })),
                labelTo: () => de || (de = (0, l.jsx)(Ke.Z, {
                    id: "G4"
                }))
            },
            it = {
                labelHeader: ({
                    isOpen: e
                }) => e ? ue || (ue = (0, l.jsx)(Ke.Z, {
                    id: "G7"
                })) : me || (me = (0, l.jsx)(Ke.Z, {
                    id: "G6"
                })),
                labelFrom: () => he || (he = (0, l.jsx)(Ke.Z, {
                    id: "G5"
                })),
                labelTo: () => pe || (pe = (0, l.jsx)(Ke.Z, {
                    id: "G8"
                }))
            },
            ct = {
                changed: ({
                    isOpen: e
                }) => e ? ge || (ge = (0, l.jsx)(Ke.Z, {
                    id: "Ha"
                })) : fe || (fe = (0, l.jsx)(Ke.Z, {
                    id: "G_"
                })),
                removed: () => be || (be = (0, l.jsx)(Ke.Z, {
                    id: "Hb"
                })),
                set: () => ye || (ye = (0, l.jsx)(Ke.Z, {
                    id: "G9"
                }))
            },
            lt = {
                changed: () => ve || (ve = (0, l.jsx)(Ke.Z, {
                    id: "Hl"
                })),
                set: () => we || (we = (0, l.jsx)(Ke.Z, {
                    id: "Hj"
                })),
                removed: () => ke || (ke = (0, l.jsx)(Ke.Z, {
                    id: "Hl"
                }))
            },
            dt = ({
                added: e = [],
                removed: t = []
            }) => ({
                tagsCount: e.length + t.length
            }),
            ut = {
                removed: ({
                    details: e
                }) => (0, l.jsx)(Ke.Z, {
                    id: "HD",
                    values: dt(e)
                }),
                set: ({
                    details: e
                }) => (0, l.jsx)(Ke.Z, {
                    id: "HA",
                    values: dt(e)
                }),
                changed: ({
                    details: e
                }) => (0, l.jsx)(Ke.Z, {
                    id: "HC",
                    values: dt(e)
                })
            },
            mt = {
                changed: ({
                    isOpen: e
                }) => e ? xe || (xe = (0, l.jsx)(Ke.Z, {
                    id: "Hw"
                })) : je || (je = (0, l.jsx)(Ke.Z, {
                    id: "Hv"
                })),
                set: () => Te || (Te = (0, l.jsx)(Ke.Z, {
                    id: "Hy"
                })),
                removed: () => Se || (Se = (0, l.jsx)(Ke.Z, {
                    id: "Hx"
                }))
            },
            ht = {
                changed: ({
                    isOpen: e
                }) => e ? Pe || (Pe = (0, l.jsx)(Ke.Z, {
                    id: "Hp"
                })) : _e || (_e = (0, l.jsx)(Ke.Z, {
                    id: "Ho"
                })),
                set: () => Ce || (Ce = (0, l.jsx)(Ke.Z, {
                    id: "Hr"
                })),
                removed: () => Re || (Re = (0, l.jsx)(Ke.Z, {
                    id: "Hq"
                }))
            },
            pt = {
                changed: ({
                    isOpen: e
                }) => e ? Ae || (Ae = (0, l.jsx)(Ke.Z, {
                    id: "Hf"
                })) : Ie || (Ie = (0, l.jsx)(Ke.Z, {
                    id: "He"
                })),
                set: () => Ne || (Ne = (0, l.jsx)(Ke.Z, {
                    id: "Hh"
                })),
                removed: () => Ee || (Ee = (0, l.jsx)(Ke.Z, {
                    id: "Hg"
                }))
            },
            gt = {
                changed: ({
                    isOpen: e
                }) => e ? Oe || (Oe = (0, l.jsx)(Ke.Z, {
                    id: "GW"
                })) : Me || (Me = (0, l.jsx)(Ke.Z, {
                    id: "GV"
                })),
                set: () => De || (De = (0, l.jsx)(Ke.Z, {
                    id: "GY"
                })),
                removed: () => He || (He = (0, l.jsx)(Ke.Z, {
                    id: "GX"
                }))
            },
            ft = {
                changed: () => Fe || (Fe = (0, l.jsx)(Ke.Z, {
                    id: "GN"
                })),
                set: () => Ze || (Ze = (0, l.jsx)(Ke.Z, {
                    id: "GP"
                })),
                removed: () => Le || (Le = (0, l.jsx)(Ke.Z, {
                    id: "GO"
                }))
            },
            bt = {
                changed: () => Be || (Be = (0, l.jsx)(Ke.Z, {
                    id: "HG"
                })),
                set: () => ze || (ze = (0, l.jsx)(Ke.Z, {
                    id: "HH"
                })),
                removed: () => null
            },
            yt = {
                changed: ({
                    isOpen: e
                }) => e ? Ue || (Ue = (0, l.jsx)(Ke.Z, {
                    id: "HJ"
                })) : We || (We = (0, l.jsx)(Ke.Z, {
                    id: "HI"
                })),
                set: () => Ge || (Ge = (0, l.jsx)(Ke.Z, {
                    id: "HL"
                })),
                removed: () => Ve || (Ve = (0, l.jsx)(Ke.Z, {
                    id: "HK"
                }))
            },
            vt = {
                changed: ({
                    isOpen: e
                }) => e ? qe || (qe = (0, l.jsx)(Ke.Z, {
                    id: "HN"
                })) : Qe || (Qe = (0, l.jsx)(Ke.Z, {
                    id: "HM"
                })),
                set: () => Ye || (Ye = (0, l.jsx)(Ke.Z, {
                    id: "HP"
                })),
                removed: () => Je || (Je = (0, l.jsx)(Ke.Z, {
                    id: "HO"
                }))
            };
        var wt = s(693);
        const kt = ({
                onPress: e
            }) => {
                const t = n.Hooks.useIntl();
                return (0, l.jsx)(wt.Z, {
                    icon: "k",
                    accessibilityLabel: t.f.HF,
                    color: "pinnedBorder",
                    onPress: e
                })
            },
            xt = ({
                details: e,
                actions: t
            }) => {
                const s = n.FP.isObject(e) ? e.to : null;
                return s ? (0, l.jsx)(kt, {
                    onPress: () => t.highlightComment(s)
                }) : null
            },
            jt = ({
                type: e,
                changeDirection: t
            }) => {
                switch (e) {
                    case "created":
                        return st;
                    case "completed":
                        return nt;
                    case "abandoned":
                        return at;
                    case "restored":
                        return ot;
                    case "name":
                        return rt;
                    case "project":
                        return it;
                    case "renewed":
                        return s = t, Object.assign({
                            labelHeader: lt[s]
                        }, tt("renewed", s));
                    case "recurrence":
                        return (e => Object.assign({
                            labelHeader: ct[e]
                        }, tt("recurrence", e)))(t);
                    case "section":
                        return (e => Object.assign({
                            labelHeader: mt[e]
                        }, tt("section", e)))(t);
                    case "responsible":
                        return (e => Object.assign({
                            labelHeader: ht[e]
                        }, tt("responsible", e)))(t);
                    case "reminder":
                        return (e => Object.assign({
                            labelHeader: pt[e]
                        }, tt("reminder", e)))(t);
                    case "due_date":
                        return (e => Object.assign({
                            labelHeader: gt[e]
                        }, tt("due_date", e)))(t);
                    case "tag":
                        return (e => Object.assign({
                            labelHeader: ut[e]
                        }, tt("tag", e)))(t);
                    case "access":
                        return (e => Object.assign({
                            labelHeader: ft[e]
                        }, tt("access", e)))(t);
                    case "team_comment":
                        return (e => Object.assign({
                            labelHeader: bt[e]
                        }, et))(t);
                    case "time_needed":
                        return (e => Object.assign({
                            labelHeader: yt[e]
                        }, tt("time", e)))(t);
                    case "time_spent":
                        return (e => Object.assign({
                            labelHeader: vt[e]
                        }, tt("time", e)))(t);
                    default:
                        throw new Error("unexpected type: " + e)
                }
                var s
            };
        var Tt, St = s(694),
            Pt = s(368);
        const _t = ["responsible", "due_date", "reminder", "recurrence"],
            Ct = async e => {
                const t = await e.task.fetch(),
                    s = (await t.timeline.events.fetch()).sort(((e, t) => t.createdAt.getTime() - e.createdAt.getTime()));
                return "team_comment" !== e.type ? s[0].id === e.id : !t.lastSeenActivityAt || t.lastSeenActivityAt.getTime() < e.createdAt.getTime()
            }, Rt = () => {
                const e = n.Hooks.useIntl();
                return (0, l.jsx)("div", {
                    className: Pt.Z.root,
                    children: (0, l.jsx)(h.Z, {
                        className: Pt.Z.labels,
                        children: (0, l.jsxs)("span", {
                            className: Pt.Z.text,
                            children: [e.f.HS, null]
                        })
                    })
                })
            }, At = n.Hocs.compose(n.Hocs.withErrorBoundary({
                name: "TaskEvent",
                render: () => Tt || (Tt = (0, l.jsx)(Rt, {}))
            }), n.Hocs.withObservables(["event"], (({
                event: e
            }) => ({
                author: e.author,
                isDueDateRelative: e.task.observe().pipe(n.Rx.switchMap((e => n.Rx.from(e.dates.isDueDateRelative())))),
                isOpenByDefault: n.Rx.from(Ct(e))
            }))))((e => {
                const {
                    author: t,
                    event: s,
                    isDueDateRelative: a,
                    isOpenByDefault: o
                } = e, {
                    currentMember: r
                } = n.Hooks.useIdentity(), i = n.Hooks.useIntl(), [c, d] = n.Hooks.useToggle(o), [u, m] = n.React.useState(!1), {
                    change: g,
                    integration: b
                } = s, y = (0, j.hJ)(g), v = (0, j.e3)(g), w = (0, j.uV)(g), k = (0, j.tC)(g), x = jt({
                    type: s.type,
                    changeDirection: w
                }), P = x.labelHeader, _ = x.labelFrom, C = x.labelTo, R = (({
                    type: e
                }) => "team_comment" === e ? xt : null)({
                    type: s.type,
                    changeDirection: w
                }), I = c && R ? R({
                    details: k,
                    actions: e.actions
                }) : null, N = (e => {
                    return "project" === (t = e.type) || "section" === t || "responsible" === t || "tag" === t || "access" === t ? ({
                        value: t,
                        isValueRemoved: s = !1,
                        isMultiline: n = !0
                    }) => (0, l.jsx)(Z, {
                        value: t,
                        type: e.type,
                        isValueRemoved: s,
                        isMultiline: n
                    }) : ({
                        value: t,
                        isValueRemoved: s = !1,
                        isDueDateRelative: n
                    }) => (0, l.jsx)(A, {
                        value: t,
                        type: e.type,
                        isValueRemoved: s,
                        isDueDateRelative: !!n
                    });
                    var t
                })(s), E = "reminder" === s.type, O = "removed" === w && (M = s.type, _t.includes(M));
                var M;
                const {
                    createdAt: D
                } = s, H = ((e, t) => Array.isArray(e) && Array.isArray(t) ? n.FP.concat(e, t) : e || t)(v, y);
                return (0, l.jsx)(St.i, {
                    children: (0, l.jsxs)("div", {
                        className: Pt.Z.root,
                        children: [(0, l.jsxs)(h.Z, {
                            className: Pt.Z.labels,
                            onPress: d,
                            webComponent: "div",
                            onMouseEnter: () => m(!0),
                            onMouseLeave: () => m(!1),
                            children: [(0, l.jsxs)("div", {
                                className: Pt.Z.headerContainer,
                                children: [E ? (0, l.jsx)(f.default, {
                                    name: "ŀ",
                                    color: "textSecondary",
                                    size: 16
                                }) : null, (0, l.jsxs)("div", {
                                    className: Pt.Z.textContainer + (c ? " " + Pt.Z.openedTextContainer : ""),
                                    children: [(0, l.jsx)(p.default, {
                                        className: Pt.Z.text,
                                        style: {
                                            color: n.Styling.factoryColor(u ? "textPrimary" : "textSecondary")
                                        },
                                        children: P({
                                            isOpen: c,
                                            details: k
                                        })
                                    }), !H || c && _ ? null : N({
                                        value: H,
                                        isValueRemoved: O,
                                        isMultiline: c,
                                        isDueDateRelative: a
                                    })]
                                })]
                            }), c ? (0, l.jsxs)(l.Fragment, {
                                children: [(0, l.jsxs)("div", {
                                    className: Pt.Z.content,
                                    children: [_ && y ? (0, l.jsxs)("div", {
                                        className: Pt.Z.wrapper,
                                        children: [(0, l.jsx)(p.default, {
                                            className: Pt.Z.text,
                                            style: {
                                                color: n.Styling.factoryColor(u ? "textPrimary" : "textSecondary")
                                            },
                                            children: _({
                                                isOpen: c,
                                                details: k
                                            })
                                        }), N({
                                            value: y,
                                            isDueDateRelative: a
                                        })]
                                    }) : null, C && v ? (0, l.jsxs)("div", {
                                        className: Pt.Z.wrapper,
                                        children: [(0, l.jsx)(p.default, {
                                            className: Pt.Z.text,
                                            style: {
                                                color: n.Styling.factoryColor(u ? "textPrimary" : "textSecondary")
                                            },
                                            children: C({
                                                isOpen: c,
                                                details: k
                                            })
                                        }), N({
                                            value: v,
                                            isDueDateRelative: a
                                        })]
                                    }) : null]
                                }), (0, l.jsx)("div", {
                                    className: Pt.Z.footer,
                                    children: (0, l.jsxs)("span", {
                                        className: Pt.Z.text,
                                        style: {
                                            color: n.Styling.factoryColor(u ? "textPrimary" : "textSecondary")
                                        },
                                        children: [(0, l.jsx)(T.default, {
                                            className: Pt.Z.footerText + " " + Pt.Z.member,
                                            member: t,
                                            shouldRenderYou: (null == t ? void 0 : t.id) === r.id
                                        }), ", ", (0, l.jsx)(S.Z, {
                                            className: Pt.Z.footerText,
                                            date: D,
                                            showTime: !0
                                        }), b ? (0, l.jsxs)(l.Fragment, {
                                            children: [", ", (0, l.jsx)("span", {
                                                className: Pt.Z.footerText,
                                                children: i.g("G1", {
                                                    integration: b
                                                })
                                            })]
                                        }) : null]
                                    })
                                })]
                            }) : null]
                        }), I ? (0, l.jsx)("div", {
                            className: Pt.Z.actions,
                            children: I
                        }) : null]
                    })
                })
            })), It = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    event: t,
                    actions: s,
                    isInitiallyRendered: a
                } = e, {
                    isInViewport: o,
                    targetRef: r
                } = n.Hooks.useShownInViewport({}, a);
                return n.React.useEffect((() => {
                    t.isIncomplete && n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_ID, "TaskEvent is incomplete - should never be rendered (" + t.id + ")")
                })), t.isIncomplete ? null : (0, l.jsx)("div", {
                    className: Pt.Z.rootWrapper,
                    ref: r,
                    children: o ? (0, l.jsx)(At, {
                        isInitiallyRendered: a,
                        event: t,
                        actions: s
                    }) : null
                })
            })), Nt = e => {
                const {
                    events: t,
                    actions: s
                } = e, [a, o] = n.React.useState(!0);
                return a ? (0, l.jsx)("div", {
                    className: Pt.Z.root,
                    children: (0, l.jsx)(h.Z, {
                        className: Pt.Z.labels,
                        onPress: () => o(!1),
                        webComponent: "div",
                        children: (0, l.jsx)("div", {
                            className: Pt.Z.headerContainer,
                            children: (0, l.jsx)("div", {
                                className: Pt.Z.textContainer,
                                children: (0, l.jsx)(p.default, {
                                    className: Pt.Z.text,
                                    children: (0, l.jsx)(Ke.Z, {
                                        id: "G0",
                                        values: {
                                            eventsCount: t.length
                                        }
                                    })
                                })
                            })
                        })
                    })
                }) : t.map((e => (0, l.jsx)(It, {
                    event: e,
                    actions: s,
                    isInitiallyRendered: !0
                }, e.id)))
            }, Et = s(696), Ot = n.Hocs.compose()((e => {
                const {
                    newCommentsIndicatorRef: t,
                    isVisible: s,
                    type: a = "comment"
                } = e, o = n.Hooks.useIntl(), r = n.Styling.factoryColor("thread" === a ? "darkgreen" : "activity"), i = {
                    comment: o.f.Gt,
                    thread: o.f.Gv,
                    reaction: o.f.Gu
                } [a];
                return (0, l.jsxs)("div", {
                    className: Et.root + (s ? "" : " " + Et.hidden),
                    ref: t,
                    children: [(0, l.jsx)("div", {
                        className: Et.line,
                        style: {
                            borderColor: r
                        }
                    }), (0, l.jsx)("span", {
                        className: Et.text,
                        style: {
                            color: r
                        },
                        children: i
                    })]
                })
            }));
        s(36);
        const Mt = e => {
                const {
                    scrollTop: t,
                    scrollHeight: s,
                    offsetHeight: n
                } = e;
                return s - (t + n)
            },
            Dt = e => Mt(e) <= 10,
            Ht = s(697),
            Ft = n.Hocs.compose()((e => {
                const {
                    incrementLimit: t,
                    scrollRef: s
                } = e, {
                    isInViewport: a,
                    targetRef: o
                } = n.Hooks.useShownInViewport(), r = n.Hooks.useIntl(), i = () => {
                    invariant(s.current, "missing scrollRef in LoadMore");
                    const e = s.current,
                        n = Mt(e);
                    t(), requestAnimationFrame((() => {
                        const t = Mt(e);
                        e.scrollTop += t - n
                    }))
                };
                return n.React.useEffect((() => {
                    a && i()
                })), (0, l.jsx)(h.Z, {
                    className: Ht.root,
                    ref: o,
                    onPress: i,
                    webComponent: "div",
                    children: (0, l.jsx)("span", {
                        className: Ht.text,
                        children: r.f.GI
                    })
                })
            })),
            Zt = e => ({
                type: "folded_task_events",
                events: e
            }),
            Lt = (e, t) => ((e, t) => !e.some((e => ((e, t) => {
                var s, n;
                return "team_comment" === e.type && (null != (s = null == (n = t.lastSeenActivityAt) ? void 0 : n.getTime()) ? s : 0) < e.createdAt.getTime()
            })(e, t))) && e.length >= 3)(e, t) ? [Zt(e)] : e,
            Bt = (e, t) => n.FP.piped(e, n.FP.reduce(((e, s) => {
                const {
                    renderables: n,
                    pendingEvents: a
                } = e;
                return s instanceof r.Models.Comment ? {
                    renderables: [...n, ...Lt(a, t), s],
                    pendingEvents: []
                } : {
                    renderables: n,
                    pendingEvents: [...a, s]
                }
            }), {
                renderables: [],
                pendingEvents: []
            }), (e => {
                const {
                    renderables: s,
                    pendingEvents: n
                } = e;
                return [...s, ...Lt(n, t)]
            }));

        function zt(e) {
            return !!e && e instanceof r.Models.Comment
        }

        function Ut(e, t, s) {
            const {
                isShowingPinnedOnly: a,
                areTimeAttributesEnabled: o
            } = s, r = n.Hooks.useServices(), i = n.React.useMemo((() => a ? (0, c.mO)(e.filter((e => e.isPinned))) : (0, c.mO)([...e, ...t])), [a, e, t]), {
                app: {
                    isServiceMode: l
                }
            } = r, {
                isLimitedAccount: d
            } = n.Hooks.useIdentity();
            return n.React.useMemo((() => function(e, t) {
                const {
                    isServiceMode: s,
                    isLimitedAccount: a,
                    areTimeAttributesEnabled: o
                } = t, r = [];
                a && r.push(Gt);
                o || r.push(Vt);
                if (!r.length) return e;
                return n.FP.filter(n.FP.allPass(r))(e)
            }(i, {
                isServiceMode: l,
                isLimitedAccount: d,
                areTimeAttributesEnabled: o
            })), [o, d, l, i])
        }

        function Wt(e) {
            return t => {
                return !((s = t) && s instanceof r.Models.TaskEvent) || !!e && !e.includes(t.type);
                var s
            }
        }
        Wt();
        const Gt = Wt(["project", "section", "tag"]),
            Vt = Wt(["time_needed", "time_spent"]),
            qt = (n.FP.once((() => {})), 7);

        function Qt({
            task: e,
            newItems: t,
            oldItems: s,
            highlightedCommentId: a
        }) {
            const [o, r] = n.Hooks.useStateResettable(15, [e]), i = n.React.useMemo((() => function({
                currentLimit: e,
                highlightedCommentId: t,
                newItems: s,
                oldItems: n
            }) {
                const a = e => zt(e) && e.id === t;
                if (t && !s.find(a)) {
                    const t = n.findIndex(a),
                        s = -1 < t ? n.length - t : e;
                    if (s > e) return s + qt
                }
                return e
            }({
                currentLimit: o,
                highlightedCommentId: a,
                oldItems: s,
                newItems: t
            })), [o, a, t, s]);
            return {
                oldItemLimit: i,
                incrementOldItemLimit: () => {
                    r(i + qt)
                }
            }
        }
        const Yt = s(698);
        var Jt, Kt;
        const $t = n.ReactUtils.lazy((() => s(1344))),
            Xt = n.ReactUtils.lazy((() => s(1345))),
            es = n.ReactUtils.lazy((() => s(1346))),
            ts = n.ReactUtils.lazy((() => s(1347))),
            ss = n.FP.filter((e => zt(e))),
            ns = (e, t, {
                makeKey: s,
                isInitiallyRendered: n,
                highlightedCommentId: a,
                highlightedCommentRef: o,
                taskEventActions: i
            }) => {
                const {
                    openEditMode: d,
                    editedComment: u,
                    isEditingDisabled: m,
                    markCommentAsUnread: h,
                    commentParserContext: p,
                    currentTaskLastSeenActivityAt: g,
                    openReply: f
                } = t;
                if (e instanceof r.Models.Comment) {
                    if (e.isDeleted) return (0, l.jsx)(ts, {
                        comment: e,
                        onRestore: async e => {
                            await e.do.restore()
                        }
                    }, e.id);
                    const t = !g || (0, c.tJ)(e, g.getTime()),
                        s = e.id === a;
                    return (0, l.jsx)(x.Z, {
                        comment: e,
                        isHighlighted: s,
                        ref: s ? o : void 0,
                        onTriggerEdit: d,
                        onTriggerReply: f,
                        isBeingEdited: e === u,
                        isEditingDisabled: m,
                        isUnread: t,
                        markAsUnread: h,
                        parserContext: p,
                        isInitiallyRendered: n
                    }, e.id)
                }
                if (e instanceof r.Models.TaskEvent) return (0, l.jsx)(It, {
                    event: e,
                    actions: i,
                    isInitiallyRendered: n
                }, e.id);
                if ("folded_task_events" === e.type) {
                    var b;
                    const {
                        events: t
                    } = e;
                    return (0, l.jsx)(Nt, {
                        events: t,
                        actions: i
                    }, s("folded-" + (null == (b = t[0]) ? void 0 : b.id)))
                }
                return null
            },
            as = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withServices, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                taskEvents: e.timeline.events,
                project: e.observeCurrentProject(),
                comments: e.timeline.comments.observeWithColumns([m.o.comments.body, m.o.comments.isPinned, m.o.comments.isTeam])
            }))), n.Hocs.withObservables(["task", "comments", "project"], (({
                services: e,
                task: t,
                comments: s,
                project: n
            }) => ({
                commentParserContext: (0, c.bo)({
                    services: e,
                    task: t,
                    comments: s,
                    project: n
                })
            }))), n.Hocs.withIdentity, n.Hocs.withObservables(["task", "currentTeam"], (({
                task: e,
                currentTeam: t
            }) => ({
                isHistoryRestricted: e.observeCurrentProject().pipe(n.Rx.switchMap((e => n.Rx.from(e.isGuestSharedProject))), n.Rx.map((s => !(!t.isFree || s || e.isGranted) && e.isEndedMoreThan7DaysAgo)))
            })))),
            os = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                timeAttributes: e.timeAttributes
            }))), n.Hocs.withHooks((({
                task: e,
                taskEvents: t,
                comments: s,
                isShowingPinnedOnly: a,
                newLastSeenActivityAt: o,
                timeAttributes: r
            }) => {
                const i = Ut(s, t, {
                        isShowingPinnedOnly: a,
                        areTimeAttributesEnabled: !!r
                    }),
                    l = o,
                    {
                        isIndicatorVisible: d,
                        newItems: u,
                        oldItems: m,
                        newComments: h
                    } = n.React.useMemo((() => {
                        const [t, s] = ((e, t) => n.FP.splitWhen((t => zt(t) && (!e || (0, c.tJ)(t, e))), t))(l, i), a = ss(s), o = ss(t);
                        return {
                            isIndicatorVisible: !!s.length && !!o.length,
                            newItems: Bt(s, e),
                            oldItems: Bt(t, e),
                            newComments: a
                        }
                    }), [i, l, e]);
                return {
                    timeline: i,
                    isIndicatorVisible: d,
                    commentCount: s.length,
                    newComments: h,
                    newItems: u,
                    oldItems: m
                }
            })), n.Hocs.withObservables(["task", "shouldShowPrompt"], (({
                shouldShowPrompt: e,
                task: t
            }) => ({
                newCommentDraft: e ? t.timeline.newCommentDraft : n.Rx.of("")
            }))))((e => {
                var t, s, a;
                const {
                    openNewComment: o,
                    task: r,
                    timeline: i,
                    newItems: c,
                    oldItems: d,
                    onTaskChangedAndCommentListRendered: u,
                    isIndicatorVisible: m,
                    newCommentsIndicatorRef: h,
                    shouldShowPrompt: p,
                    newCommentDraft: g,
                    scrollRef: f,
                    scrollContentRef: b,
                    onDidReachTopRef: y,
                    isLimitedAccount: v
                } = e, w = n.Hooks.useIntl(), x = n.Hooks.useServices(), j = n.Hooks.useKeyMapper(r), {
                    highlightedCommentId: T,
                    highlightedCommentRef: S,
                    highlightComment: P
                } = function(e) {
                    const t = n.Hooks.useServices(),
                        s = n.React.useRef(!0),
                        [a, o] = n.Hooks.useStateResettable({
                            commentId: e,
                            highlightedAt: Date.now()
                        }, [e]),
                        r = n.React.useRef();
                    n.React.useLayoutEffect((() => {
                        s.current ? s.current = !1 : a.commentId && requestAnimationFrame((() => {
                            invariant(r.current, "Missing highlightedCommentRef"), n.ReactUtils.scrollIntoView({
                                element: r.current,
                                alignment: "nearest"
                            })
                        }))
                    }), [t, a]);
                    const i = n.React.useCallback((e => {
                        o({
                            commentId: e,
                            highlightedAt: Date.now()
                        })
                    }), [o]);
                    return {
                        highlightedCommentId: a.commentId,
                        highlightedCommentRef: r,
                        highlightComment: i
                    }
                }(e.highlightedCommentId), _ = (e => {
                    {
                        const t = e.webWindow.innerHeight - 0 - 40;
                        return Math.ceil(t / 150)
                    }
                })(x.scene), C = Math.min(c.length, _), R = Math.min(d.length, _ - C), {
                    oldItemLimit: A,
                    incrementOldItemLimit: I
                } = Qt({
                    task: r,
                    highlightedCommentId: T,
                    oldItems: d,
                    newItems: c
                }), N = d.slice(-A), E = A < d.length;
                n.React.useLayoutEffect((() => {
                    m && r.isRead && 1582622647e3 < r.lastActivityAt.getTime() && n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_ID, "Task has broken lastActivityAt " + r.id);
                    const e = !!T && !!i.find((e => e.id === T));
                    u(e ? S : h)
                }), [r]);
                const O = n.React.useMemo((() => ({
                        highlightComment: P
                    })), [P]),
                    M = (D = c, H = null != (t = null == (s = r.lastSeenActivityAt) ? void 0 : s.getTime()) ? t : 0, 0 < D.length && zt(D[0]) && D[0].createdAt.getTime() === H + 1);
                var D, H;
                return (0, l.jsxs)(l.Fragment, {
                    children: [!r.isThread || c.length || d.length ? (0, l.jsxs)(l.Fragment, {
                        children: [(0, l.jsx)("div", {
                            className: Yt.placeholder
                        }), E ? (0, l.jsx)(Ft, {
                            incrementLimit: I,
                            scrollRef: f,
                            scrollContentRef: b,
                            onDidReachTopRef: y
                        }, "loadMore-" + A) : null, N.map(((t, s) => ns(t, e, {
                            makeKey: j,
                            isInitiallyRendered: N.length - s <= R,
                            highlightedCommentId: T,
                            highlightedCommentRef: S,
                            taskEventActions: O
                        }))), (0, l.jsx)(Ot, {
                            type: M ? "reaction" : null != (a = r.type) ? a : "comment",
                            newCommentsIndicatorRef: h,
                            isVisible: m && !r.isRead
                        }, r.id), c.map(((t, s) => ns(t, e, {
                            makeKey: j,
                            isInitiallyRendered: s < C,
                            highlightedCommentId: T,
                            highlightedCommentRef: S,
                            taskEventActions: O
                        })))]
                    }) : (0, l.jsx)($t, {
                        task: r
                    }), v ? Jt || (Jt = (0, l.jsx)(es, {})) : null, p ? (0, l.jsx)(k, {
                        avatarStyle: r.isThread ? "message" : "round",
                        onPress: o,
                        value: null != g ? g : r.isThread ? w.f.gW : w.f.gU,
                        isInitiallyRendered: c.length < _
                    }) : null]
                })
            })),
            rs = as((e => {
                const {
                    taskEvents: t,
                    comments: s,
                    task: a,
                    intl: o,
                    isHistoryRestricted: r
                } = e, i = n.Hooks.useServices(), c = a.timeline.hasIncompleteTimeline(s, t), [d, u] = n.React.useState("loading"), m = n.React.useRef(null);
                if (n.React.useEffect((() => {
                        if (c) {
                            const e = async () => {
                                m.current = a, u("loading");
                                try {
                                    const e = await i.api.sync.getTaskTimeline(a.id);
                                    await a.timeline.do.updateIncompleteTimeline(e), m.current === a && u("loaded")
                                } catch (e) {
                                    m.current === a && u(e.isNetworkErrorLikely ? "offline" : "error"), e.isNetworkErrorLikely || n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, e)
                                }
                            };
                            e();
                            const t = n.ReactUtils.onOnline.subscribe((() => {
                                e()
                            }));
                            return () => t.unsubscribe()
                        }
                        return n.FP.noop
                    }), [c, i.api, a]), r) return Kt || (Kt = (0, l.jsx)(Xt, {}));
                if (c) {
                    const {
                        message: e,
                        information: t,
                        color: s,
                        icon: a
                    } = ((e, t) => {
                        switch (e) {
                            case "loading":
                                return {
                                    message: t.f.GH, information: t.f.GJ, color: "onBackground3", icon: "Ɯ"
                                };
                            case "offline":
                                return {
                                    message: t.f.GG, information: t.f.GE, color: "onBackground3", icon: "%"
                                };
                            default:
                                return {
                                    message: t.f.GF, information: t.f.GE, color: "red", icon: "%"
                                }
                        }
                    })(d, o);
                    return (0, l.jsxs)("div", {
                        className: Yt.loadingBox,
                        children: [(0, l.jsx)("div", {
                            className: Yt.loadingIcon + ("loading" === d ? " " + Yt.withSpin : ""),
                            children: (0, l.jsx)(f.default, {
                                name: a,
                                size: 20,
                                color: s
                            })
                        }), (0, l.jsx)("span", {
                            className: Yt.loadingText + " " + Yt.loadingTextBold,
                            style: {
                                color: n.Styling.factoryColor(s)
                            },
                            children: e
                        }), (0, l.jsx)("span", {
                            className: Yt.loadingText,
                            style: {
                                color: n.Styling.factoryColor(s)
                            },
                            children: t
                        })]
                    })
                }
                return (0, l.jsx)(os, Object.assign({}, e))
            }));
        var is = s(369);
        s(261);
        const cs = n.ReactUtils.lazy((() => s(1349))),
            ls = n.ReactUtils.lazy((() => s(1355))),
            ds = n.Hocs.compose()((e => {
                const {
                    task: {
                        isThread: t
                    }
                } = e;
                return t ? (0, l.jsx)(ls, Object.assign({}, e)) : (0, l.jsx)(cs, Object.assign({}, e))
            }));
        s(54);
        const us = s(724),
            ms = e => (0, l.jsx)("div", {
                className: us.root,
                children: e.children
            }),
            hs = n.FP.identity,
            ps = is.j + 0;

        function gs(e) {
            const [t, s] = n.React.useState(e), {
                wantsToExpand: a,
                wantsToContract: o,
                setWantsToExpand: r,
                setWantsToContract: i
            } = {
                wantsToExpand: n.React.useRef(void 0),
                wantsToContract: n.React.useRef(void 0),
                setWantsToExpand: n.FP.noop,
                setWantsToContract: n.FP.noop
            }, c = n.React.useCallback((e => {
                s(e)
            }), [i, r]), l = n.React.useCallback((() => c(!0)), [c]), d = n.React.useCallback((() => c(!1)), [c]);
            return {
                areAttributesMinimized: t,
                setAreAttributesMinimized: c,
                setAreAttributesMinimizedWithoutNativeAnimation: s,
                contractAttributes: l,
                expandAttributes: d,
                wantsToExpand: a,
                wantsToContract: o
            }
        }
        const fs = /[?#]comment=([^#]*)&?/;
        var bs = s(30),
            ys = s(12);
        const vs = s(725),
            ws = e => {
                const {
                    children: t,
                    buttonLabel: s,
                    onButtonPress: n
                } = e;
                return (0, l.jsxs)("div", {
                    className: vs.root,
                    children: [(0, l.jsx)("span", {
                        className: vs.text,
                        children: t
                    }), (0, l.jsx)(ys.default, {
                        label: s,
                        onPress: n,
                        color: "blue",
                        variant: "opaque",
                        marginTop: "medium"
                    })]
                })
            },
            ks = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                project: e.observeCurrentProject(),
                recurrence: e.dates.recurrence,
                isCurrentRecurringInstance: n.Rx.from(e.dates.isCurrentRecurringInstance())
            }))), n.Hocs.withObservables(["recurrence", "task"], (({
                recurrence: e,
                task: t
            }) => ({
                newestTaskInstance: e ? e.currentTask : t
            }))))((e => {
                const {
                    project: t,
                    task: s,
                    recurrence: r,
                    newestTaskInstance: i
                } = e, {
                    currentTeam: c
                } = n.Hooks.useIdentity(), d = n.Hooks.useServices(), u = n.Hooks.useIntl(), {
                    ghostInfo: m
                } = s, h = i.dates.dueDate, p = h ? (0, o.formatDateTimeRelative)({
                    dateTime: h,
                    intl: u,
                    format: h.isAllDay ? "long" : "short"
                }) : null, g = (() => {
                    if (m) {
                        const e = m.instanceDueDate;
                        return (0, o.formatDateTimeRelative)({
                            dateTime: e,
                            intl: u,
                            format: e.isAllDay ? "long" : "short"
                        })
                    }
                    const {
                        endedAt: e
                    } = s;
                    return e ? (0, o.formatDateTimeRelative)({
                        dateTime: o.DateTime.onDay(e),
                        intl: u,
                        format: "long"
                    }) : null
                })();
                return (s.id !== i.id || m) && g && p ? (0, l.jsx)(ws, {
                    buttonLabel: u.f.f9,
                    onButtonPress: () => {
                        d.router.goTo((0, a.smartPathToTask)(c, t, i.id))
                    },
                    children: m ? u.g("Gd", {
                        pattern: (0, l.jsx)(bs.fy, {
                            children: (0, P.rs)(r.rawPattern, u)
                        }, 0),
                        ghostDate: (0, l.jsx)(bs.fy, {
                            children: g
                        }, 1),
                        originalDate: (0, l.jsx)(bs.fy, {
                            children: p
                        }, 2)
                    }) : u.g("Ge", {
                        pattern: (0, l.jsx)(bs.fy, {
                            children: (0, P.rs)(r.rawPattern, u)
                        }, 0),
                        completeDate: (0, l.jsx)(bs.fy, {
                            children: g
                        }, 1),
                        newDate: (0, l.jsx)(bs.fy, {
                            children: p
                        }, 2)
                    })
                }) : null
            })),
            xs = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                task: e.observe(),
                project: e.observeCurrentProject()
            }))), n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                endedByMember: e.events.extend(I.Q.where(m.o.projectEvents.type, "ended"), I.Q.sortBy(m.o.projectEvents.createdAt, I.Q.desc), I.Q.take(1)).observeWithColumns([m.o.projectEvents.authorId]).pipe(n.Rx.switchMap((e => {
                    if (0 < e.length) {
                        return e[0].author.observe()
                    }
                    return n.Rx.of(null)
                })))
            }))), n.Hocs.withObservables(["endedByMember"], (({
                endedByMember: e
            }) => ({
                memberPreferredName: e ? e.preferredName : n.Rx.of(null)
            }))))((e => {
                const {
                    task: t,
                    endedByMember: s,
                    memberPreferredName: a
                } = e, o = n.Hooks.useIntl(), {
                    currentMember: r
                } = n.Hooks.useIdentity(), i = n.Styling.createMemberName(a, o, {
                    shouldRenderYou: (null == s ? void 0 : s.id) === r.id
                });
                return (0, l.jsx)(ws, {
                    buttonLabel: o.f.mU,
                    onButtonPress: async () => {
                        await t.do.complete()
                    },
                    children: o.g("Gc", {
                        memberName: i ? (0, l.jsx)(bs.fy, {
                            children: i
                        }, 0) : ""
                    })
                })
            })),
            js = s(726),
            Ts = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                recurrence: e.dates.recurrence,
                project: e.observeCurrentProject()
            }))), n.Hocs.withObservables(["recurrence", "task"], (({
                recurrence: e,
                task: t
            }) => ({
                newestTaskInstance: e ? e.currentTask : t
            }))))((e => {
                const {
                    task: t,
                    newestTaskInstance: s,
                    project: n
                } = e, a = t.id !== s.id || t.ghostInfo, o = t.isActive && n.isEnded;
                return a ? (0, l.jsx)("div", {
                    className: js.root,
                    children: (0, l.jsx)("div", {
                        className: js.content,
                        children: (0, l.jsx)(ks, {
                            task: t
                        })
                    })
                }) : o ? (0, l.jsx)("div", {
                    className: js.root,
                    children: (0, l.jsx)("div", {
                        className: js.content,
                        children: (0, l.jsx)(xs, {
                            task: t
                        })
                    })
                }) : null
            })),
            Ss = e => e ? e.getTime() : null;

        function Ps({
            task: e
        }) {
            const t = n.Hooks.useServices(),
                {
                    currentTeam: s
                } = n.Hooks.useIdentity(),
                a = Ss(e.lastSeenActivityAt),
                [o, r] = n.React.useState(a),
                i = n.React.useRef(!1);
            n.React.useEffect((() => {
                i.current = !1, r(Ss(e.lastSeenActivityAt))
            }), [e]);
            const c = e.isRead,
                l = n.React.useRef(a),
                d = n.React.useRef(c);
            n.React.useEffect((() => {
                a !== l.current && c && d.current && r(a), l.current = a, d.current = c
            }), [a, c, o]);
            const u = async () => {
                e.isUnread && t.uiState.forTeam(s).addJustReadTask(e), await e.do.markAsRead()
            }, m = n.React.useCallback((async () => {
                i.current = !0, o === Ss(e.lastSeenActivityAt) ? await e.do.markAsUnread(null) : await e.do.markAsUnread(o ? new Date(o) : null)
            }), [o, e]), h = n.React.useCallback((async t => {
                i.current = !0, await e.do.markCommentAsUnread(t), r(Ss(e.lastSeenActivityAt))
            }), [e]);
            return {
                newLastSeenActivityAt: o,
                newMarkAsRead: u,
                newMarkAsUnread: m,
                newMarkCommentAsUnread: h,
                onDidReachBottom: () => {
                    e.isUnread && !i.current && u(), e.isThread && !i.current && (async () => {
                        e.isUnread && t.uiState.forTeam(s).addJustReviewedTasks([e]), await e.do.markAsReviewed()
                    })()
                }
            }
        }
        const _s = s(37).d.tasksWithPinnedCommentsView,
            Cs = (e, t, s) => {
                const a = n.Hooks.useFastLocalStorage(),
                    [o, r] = n.React.useState(a.get(_s) || []),
                    i = n.React.useMemo((() => o.includes(e)), [o, e]),
                    c = n.React.useCallback((async () => {
                        const t = a.get(_s) || [],
                            s = t.includes(e) ? t.filter((t => t !== e)) : t.concat(e);
                        r(s), await a.set(_s, s)
                    }), [a, e]);
                return n.React.useEffect((() => {
                    !i || !t && s || c()
                }), [e, s]), {
                    isShowingPinnedOnly: i,
                    togglePinnedCommentView: c
                }
            };
        const Rs = n.ReactUtils.lazy((() => s(896))),
            As = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withHooks((({
                match: e
            }) => {
                const [t, s] = function(e) {
                    const t = e.taskId;
                    invariant(t, "Missing :taskId");
                    const [s, n] = t.split("_recurr:"), a = n ? Number(n) : null;
                    return [s, Number.isNaN(a) ? null : a]
                }(e.params);
                return {
                    taskId: t,
                    ghostDateTimestamp: s,
                    linkToTaskList: (0, a.getPathToTaskList)(e.params)
                }
            })), n.Hocs.withErrorBoundary({
                name: "Task",
                onReset: ({
                    services: e,
                    linkToTaskList: t
                }) => {
                    e.router.goTo(t)
                }
            }), n.Hocs.withObservables(["taskId"], (({
                taskId: e,
                services: t,
                linkToTaskList: s
            }) => ({
                task: t.collections.get(r.Tables.tasks).findAndObserve(e).pipe(n.Rx.doOnErrorComplete((() => t.router.goTo(s))))
            }))), n.Hocs.withHooks((({
                task: e,
                ghostDateTimestamp: t
            }) => {
                if (t) {
                    var s;
                    const n = null != (s = e.dates.dueDate) && s.isAllDay ? o.DateTime.onDay(new Date(t)) : o.DateTime.at(t);
                    return {
                        task: e.makeGhost(n)
                    }
                }
                return {
                    task: e
                }
            })), n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                commentCount: e.timeline.comments.observeCount(),
                numberOfPinnedComments: e.timeline.pinnedComments.observeCount()
            }))), n.Hocs.withHooks((({
                task: e,
                location: t
            }) => {
                const s = n.React.useRef(),
                    a = n.React.useRef(),
                    o = n.React.useRef(),
                    [r, i] = n.React.useState(null),
                    {
                        openEditor: c
                    } = t.state || {},
                    {
                        isEditMode: l,
                        editedComment: d,
                        open: u,
                        close: m
                    } = function(e = !1) {
                        const [t, s] = n.React.useState(e), [a, o] = n.React.useState(void 0);
                        return {
                            isEditMode: t,
                            editedComment: a,
                            open: n.React.useCallback(((e, t) => {
                                o(t), s(!0)
                            }), []),
                            close: n.React.useCallback((() => {
                                s(!1), o(void 0)
                            }), [])
                        }
                    }(c),
                    h = e.lastSeenActivityAt,
                    p = (g = t.hash, n.React.useMemo((() => {
                        const e = fs.exec(g);
                        return e ? e[1] : null
                    }), [g]));
                var g;
                return {
                    newCommentsIndicatorRef: s,
                    scrollRef: a,
                    scrollContentRef: o,
                    isEditMode: l,
                    editedComment: d,
                    openEditMode: u,
                    closeEditMode: m,
                    setReplyComment: i,
                    replyComment: r,
                    clearReply: () => {
                        i(null)
                    },
                    currentTaskLastSeenActivityAt: h,
                    highlightedCommentId: p
                }
            })), n.Hocs.withObservables(["editedComment"], (({
                editedComment: e
            }) => ({
                uploadedFiles: n.Rx.wrap((null == e ? void 0 : e.latestAttachmentVersions) || [])
            }))))((e => {
                const {
                    services: t,
                    task: s,
                    scrollRef: a,
                    scrollContentRef: o,
                    newCommentsIndicatorRef: r,
                    linkToTaskList: m,
                    uploadedFiles: h,
                    isEditMode: p,
                    editedComment: g,
                    openEditMode: f,
                    closeEditMode: b,
                    replyComment: y,
                    clearReply: v,
                    setReplyComment: w,
                    currentTaskLastSeenActivityAt: k,
                    commentCount: x,
                    numberOfPinnedComments: j,
                    highlightedCommentId: T,
                    match: S
                } = e, {
                    currentMember: P,
                    currentTeam: _,
                    isLimitedAccount: C
                } = n.Hooks.useIdentity(), R = n.Hooks.useIntl(), A = n.Hooks.useDesktopLayout(), {
                    topInset: I,
                    bottomInset: N
                } = n.Hooks.useLayoutInsets(), {
                    isThread: E
                } = s, O = n.Hooks.useAttachments({
                    uploadedFiles: h,
                    onDropCallback: () => {
                        p || oe()
                    },
                    team: _
                }), M = s.isUnread && 0 < x, {
                    areAttributesMinimized: D,
                    setAreAttributesMinimized: H,
                    setAreAttributesMinimizedWithoutNativeAnimation: F,
                    contractAttributes: Z,
                    expandAttributes: L,
                    wantsToExpand: B,
                    wantsToContract: z
                } = gs(M), [U, W] = n.React.useState(0), {
                    isShowingPinnedOnly: G,
                    togglePinnedCommentView: V
                } = Cs(s.id, s.isUnread, j), q = n.React.useRef(!1), {
                    newLastSeenActivityAt: Q,
                    newMarkAsUnread: Y,
                    newMarkCommentAsUnread: J,
                    onDidReachBottom: K
                } = Ps({
                    task: s
                }), [$, X] = n.React.useState(null), ee = () => {
                    X("ready")
                }, te = () => {
                    invariant(a.current, "missing scroll ref");
                    const e = a.current;
                    requestAnimationFrame((() => {
                        q.current = !0, n.ReactUtils.scrollToBottom(e), setTimeout((() => n.ReactUtils.scrollToBottom(e)), 100)
                    }))
                }, se = () => {
                    O.clearAttachedFiles(), v(), ge && fe(), b()
                }, ne = n.Hooks.useLocation(), {
                    openEditor: ae
                } = ne.state || {};
                n.React.useEffect((() => {
                    ae || se(), O.clearAttachedFiles(), H(s.isUnread && 0 < x)
                }), [s]), n.React.useEffect((() => {
                    q.current = !0
                }), [q, G]);
                const oe = n.React.useCallback(((e, t) => {
                        f(e, t), Z()
                    }), [f, Z]),
                    re = n.React.useCallback((() => {
                        t.payments.remindExpired(_) || oe()
                    }), [oe, _, t.payments]);
                n.Hooks.useShortcutProviders([{
                    id: "task.add_comment",
                    action: re
                }]);
                hs(),
                    function(e) {
                        const t = n.React.useRef(e);
                        t.current = e
                    }(K);
                const ie = n.React.useRef(void 0),
                    ce = (B.current, z.current, {
                        colorStyle: {},
                        elevationStyle: {},
                        hairlineWidthStyle: {},
                        expandedOpacityStyle: {},
                        attributesOpacityStyle: {},
                        translateYStyle: {},
                        blurViewTranslateYStyle: {},
                        translateY: 0,
                        attributesGesture: {},
                        onScrollEvent: () => {}
                    }),
                    {
                        onScrollEvent: le
                    } = ce,
                    {
                        handleOnScrollWeb: de,
                        scrollMargin: ue,
                        contentMargin: me,
                        isAtTop: he
                    } = function({
                        aboutToScrollProgramatically: e,
                        scrollRef: t,
                        areAttributesMinimized: s,
                        setAreAttributesMinimized: a,
                        headerHeight: o
                    }) {
                        const [r, i] = n.React.useState(!1), c = n.React.useRef(void 0), l = n.React.useRef({
                            areAttributesMinimized: s,
                            headerHeight: o
                        });
                        return n.React.useLayoutEffect((() => {
                            invariant(t.current, "unexpected scrollRef null");
                            const n = t.current;
                            if (!s && 0 === o) return;
                            const a = l.current;
                            if (l.current = {
                                    areAttributesMinimized: s,
                                    headerHeight: o
                                }, o !== a.headerHeight || s !== a.areAttributesMinimized) {
                                const t = a.areAttributesMinimized ? ps : a.headerHeight,
                                    r = s ? ps : o;
                                e.current = !0, n.scrollTop += r - t
                            }
                        }), [s, o]), {
                            scrollMargin: s ? is.j : o,
                            contentMargin: 0,
                            isAtTop: r,
                            handleOnScrollWeb: () => {
                                invariant(t.current, "unexpected scrollRef null");
                                const n = t.current;
                                i(0 === n.scrollTop), e.current ? e.current = !1 : s && n.scrollTop <= 30 ? c.current || (c.current = setTimeout((() => {
                                    c.current = void 0, a(!1)
                                }), 500)) : !s && n.scrollTop >= o - ps + 31 && !Dt(n) && a(!0)
                            }
                        }
                    }({
                        aboutToScrollProgramatically: q,
                        scrollRef: a,
                        headerHeight: U,
                        areAttributesMinimized: D,
                        setAreAttributesMinimized: H
                    }),
                    pe = n.React.useCallback((async e => {
                        if (C || s.isGranted) return !1;
                        const {
                            projectId: t,
                            taskListName: a
                        } = S.params;
                        if (t) return t !== e.id;
                        if ("single_tasks" !== a) return !0;
                        return (await n.Rx.takeFirst(_.singleTasks)).id !== e.id
                    }), [S, s, _, C]),
                    [ge, fe] = n.Hooks.useToggle(!1);
                return (0, l.jsxs)(ms, {
                    isDesktop: A,
                    children: [(0, l.jsx)(ds, {
                        task: s,
                        markAsUnread: Y,
                        linkToTaskList: m,
                        animatedValues: ce,
                        headerHeight: U,
                        setHeaderHeight: W,
                        areAttributesMinimized: D,
                        setAreAttributesMinimized: H,
                        isAtTop: he,
                        blockExpandOnHover: p,
                        toggleShowPinnedOnly: V,
                        isShowingPinnedOnly: G,
                        canNavigateToProject: pe
                    }), (0, l.jsx)(u.Z, {
                        className: us.scroll,
                        style: {
                            marginTop: E ? void 0 : ue
                        },
                        topBarInset: U || is.j,
                        bottomBarInset: 0,
                        scrollEventThrottle: 16,
                        reachesBottomOfScreen: !1,
                        isAbsoluteFilled: !1,
                        scrollRef: a,
                        nativeViewRef: o,
                        contentContainerStyle: {
                            height: "100%",
                            marginTop: me
                        },
                        nativeMaintainVisibleContentPosition: void 0,
                        onScroll: n.ReactUtils.callBoth((async e => {
                            const t = e.target;
                            Dt(t) && K()
                        }), de),
                        children: (0, l.jsx)("div", {
                            className: us.content,
                            children: (0, l.jsx)(rs, {
                                task: s,
                                openEditMode: oe,
                                openReply: (e, t) => {
                                    w(t), oe()
                                },
                                openNewComment: re,
                                editedComment: g,
                                isEditingDisabled: p,
                                currentTaskLastSeenActivityAt: k,
                                newLastSeenActivityAt: Q,
                                newCommentsIndicatorRef: r,
                                markCommentAsUnread: J,
                                isShowingPinnedOnly: G,
                                onTaskChangedAndCommentListRendered: e => {
                                    (s.isUnread || T) && e.current ? setTimeout((() => {
                                        q.current = !0;
                                        const t = a.current;
                                        invariant(t, "missing scroll ref"), invariant(e.current, "missing targetRef");
                                        const s = e.current.getBoundingClientRect().top + (null == t ? void 0 : t.scrollTop);
                                        t.scrollTo({
                                            top: s - (I + is.j + 4)
                                        }), Dt(t) && K(), ee()
                                    }), 0) : (te(), ee())
                                },
                                shouldShowPrompt: !p && !s.isGhost && (!s.isThread || s.isActive),
                                scrollRef: a,
                                scrollContentRef: o,
                                onDidReachTopRef: ie,
                                highlightedCommentId: T
                            })
                        })
                    }), (0, l.jsx)(Ts, {
                        task: s,
                        linkToTaskList: m
                    }), p ? (0, l.jsx)(Rs, {
                        onClose: se,
                        task: s,
                        editedComment: g,
                        replyComment: y,
                        onSave: async (e, o = []) => {
                            g ? await s.timeline.do.updateComment(g, e, o) : (await s.timeline.do.addComment((0, c.mL)({
                                body: e,
                                inputFiles: (0, i.up)(o).pending
                            }, R)), G && await V(), setTimeout((() => {
                                q.current = !0, a.current && n.ReactUtils.scrollToBottom(a.current)
                            }), 50)), L(), O.clearAttachedFiles(), t.uploader.performUpload(P)
                        },
                        attachmentProps: O,
                        isPreviewModeEnabled: ge,
                        togglePreviewMode: fe
                    }) : null, O.renderDropZone(), s.isThread ? null : (0, l.jsx)(d, {
                        onDidRequestTour: () => {
                            $ || X("requested")
                        },
                        isReady: "ready" === $,
                        onBeforeBegin: async () => {
                            H(!1), te(), await n.FP.delay(150)
                        }
                    })]
                })
            }));
        var Is = s(896),
            Ns = s(374)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            x: () => c
        });
        var n = s(0),
            a = s(22);
        s(2), s(3);
        const o = s(702);
        var r = s(1348),
            i = s(1);
        const c = e => {
            const {
                topInset: t,
                areTaskDetailsMaximized: s,
                onPress: c,
                color: l = "onBackground3",
                isAboveContent: d = !0
            } = e, u = n.Hooks.useIntl(), m = n.Hooks.useServices(), {
                isNarrowLayout: h
            } = n.Hooks.useLayoutVariant(), p = n.Hooks.useDesktopLayout() ? "c" : n.Styling.backIcon;
            return (0, i.jsx)(r.nq, {
                className: o.backButtonContainer,
                style: {
                    top: t,
                    position: d ? "absolute" : "unset",
                    padding: d ? void 0 : 0,
                    left: d ? 8 : 0
                },
                children: s && !h ? (0, i.jsx)(a.default, {
                    color: l,
                    iconSize: 28,
                    name: "b",
                    keyboardShortcutID: "task.toggle_fullscreen",
                    accessibilityLabel: u.f.mV,
                    onPress: () => m.layout.minimizeTaskDetails(),
                    androidBorderless: !0
                }) : (0, i.jsx)(a.default, {
                    color: l,
                    iconSize: 28,
                    name: p,
                    keyboardShortcutID: "task.close",
                    accessibilityLabel: u.f.mT,
                    onPress: c,
                    androidBorderless: !0
                })
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n = s(0),
            a = (s(53), s(6)),
            o = s(20),
            r = s(863),
            i = s(198),
            c = s(109);
        s(2), s(3);
        const l = s(732);
        var d = s(1);
        const u = a.u_.Section;

        function m(e, t) {
            return n.FP.sortWith([n.FP.descend((e => !e.is_file)), n.FP.ascendLocale((e => e.name), t.locale)], e)
        }

        function h(e) {
            var t, s;
            const {
                title: o,
                accentColor: r,
                level: i,
                onLoad: c,
                onConfirm: u,
                onClose: m
            } = e, h = n.Hooks.useIntl(), [{
                closeAnimated: p
            }, g] = (0, a.P9)(), [y, v] = n.React.useState([]), [w, k] = n.React.useState([]), [x] = w, j = n.Hooks.useErrorHandler(), T = n.Hooks.useAsyncState(), S = n.Hooks.useAsyncFetcher(T, (() => c(x)));
            n.Hooks.useAsyncEffect(S, [x]);
            const P = e => {
                    switch (e) {
                        case "root":
                            x && k([]);
                            break;
                        case "parent":
                            x && k(w.slice(1));
                            break;
                        default:
                            w.some((t => t.id === e.id)) || k([e].concat(w))
                    }
                },
                _ = e => Boolean(y.find((t => t.id === e.id))),
                C = e => {
                    _(e) ? v(y.filter((t => t.id !== e.id))) : v(y.concat(e))
                },
                R = Boolean(y.length),
                [A, I] = n.React.useState("all"),
                N = n.React.useRef();
            return (0, d.jsxs)(a.u_, {
                ref: g,
                level: i,
                size: "fullscreen",
                minWidth: 600,
                maxWidth: 600,
                topPaletteStyle: !0,
                onClose: m,
                children: [(0, d.jsx)(a.u_.Header, {
                    right: null,
                    children: o
                }), (0, d.jsxs)(a.u_.Content, {
                    className: T.hasSucceeded ? l.sizedContent : "",
                    scrollRef: N,
                    children: [(0, d.jsx)(a.u_.Switch, {
                        activeColor: r,
                        options: [{
                            id: "all",
                            label: h.f.nN
                        }, {
                            id: "selected",
                            label: h.f.nT
                        }],
                        selectedOptionId: A,
                        selectOption: (e, t) => I(t)
                    }), T.map.activity({
                        idle: () => T.map.result({
                            value: ({
                                value: e
                            }) => {
                                switch (A) {
                                    case "all":
                                        return (0, d.jsx)(f, {
                                            allFiles: e,
                                            currentlyViewedFile: x,
                                            accentColor: r,
                                            scrollElementRef: N,
                                            isFileSelected: _,
                                            onBrowse: P,
                                            onSelect: C
                                        });
                                    case "selected":
                                        return t || (t = (0, d.jsx)(b, {
                                            selectedFiles: y,
                                            accentColor: r,
                                            scrollElementRef: N,
                                            onSelect: C
                                        }));
                                    default:
                                        return null
                                }
                            },
                            error: ({
                                error: e
                            }) => (0, d.jsx)(a.u_.Error, {
                                children: j.translate(e)
                            })
                        }),
                        busy: () => s || (s = (0, d.jsx)(a.u_.Loader, {
                            isLoading: !0,
                            spinnerColor: r
                        }))
                    })]
                }), (0, d.jsxs)(a.u_.Actions, {
                    children: [(0, d.jsx)(a.u_.ActionButton, {
                        label: h.f.fe,
                        onPress: p
                    }), (0, d.jsx)(a.u_.ActionButton, {
                        label: h.f.fi,
                        isDisabled: T.isBusy || !R,
                        color: r,
                        variant: "opaque",
                        onPress: e => {
                            R && (u(y), p(e))
                        }
                    })]
                })]
            })
        }
        const p = -2,
            g = -1;

        function f(e) {
            const {
                currentlyViewedFile: t,
                accentColor: s,
                scrollElementRef: r,
                isFileSelected: c,
                onBrowse: l,
                onSelect: h
            } = e, f = n.Hooks.useIntl(), b = m(e.allFiles, f), [w, k] = n.React.useState(""), x = n.Hooks.useFuzzySearchList({
                list: b,
                queryText: w,
                getText: e => [e.name],
                mapResultItem: ({
                    item: e
                }) => e
            }), {
                activeItemIndex: j,
                arrowNavigationKeyEventHandler: T,
                activeItemRef: S
            } = n.Hooks.useArrowNavigationInList({
                list: x,
                scrollElementRef: r,
                numberOfItemsNotMappedAtTop: t ? 2 : 0
            });
            n.Hooks.useEventListener({
                eventName: "keydown",
                handler: n.ReactUtils.unlessImeEvent((e => {
                    if (T(e), "Enter" === e.key) {
                        if (n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), t) {
                            if (j === p) return void l("root");
                            if (j === g) return void l("parent")
                        }
                        const s = x[j];
                        s && (s.is_file ? h(s) : l(s))
                    }
                }))
            });
            const P = e => {
                switch (e) {
                    case "root":
                        return Boolean(t) && j === p;
                    case "parent":
                        return Boolean(t) && j === g;
                    default:
                        return j === x.indexOf(e)
                }
            };
            return (0, d.jsxs)(d.Fragment, {
                children: [(0, d.jsx)(a.u_.Heading, {
                    children: t ? t.name : f.f.nR
                }), (0, d.jsx)(a.u_.Section, {
                    children: (0, d.jsx)(i.Z, {
                        value: w,
                        onChange: k,
                        autoFocus: !0,
                        accentColor: s,
                        hoverIcon: "ƅ",
                        placeholder: f.f.nS
                    })
                }), (0, d.jsxs)(u, {
                    children: [t ? (0, d.jsxs)(d.Fragment, {
                        children: [(0, d.jsx)(o.Z, {
                            label: f.f.nR,
                            icon: "Ä",
                            contentRef: P("root") ? S : void 0,
                            isFocusedWithKeyboard: P("root"),
                            onPress: () => l("root")
                        }), (0, d.jsx)(o.Z, {
                            label: f.f.nQ,
                            icon: ":",
                            contentRef: P("parent") ? S : void 0,
                            isFocusedWithKeyboard: P("parent"),
                            onPress: () => l("parent")
                        })]
                    }) : null, x.map((e => {
                        const t = P(e) ? S : void 0;
                        return e.is_file ? (0, d.jsx)(v, {
                            file: e,
                            color: s,
                            keyboardFocusRef: t,
                            isSelected: c(e),
                            onPress: () => h(e)
                        }, e.id) : (0, d.jsx)(y, {
                            file: e,
                            color: s,
                            keyboardFocusRef: t,
                            onPress: () => l(e)
                        }, e.id)
                    }))]
                }), b.length ? null : (0, d.jsx)(a.u_.Paragraph, {
                    centered: !0,
                    children: f.f.nO
                })]
            })
        }

        function b(e) {
            const {
                selectedFiles: t,
                scrollElementRef: s,
                accentColor: o,
                onSelect: r
            } = e, i = n.Hooks.useIntl(), {
                activeItemIndex: c,
                activeItemRef: l,
                arrowNavigationKeyEventHandler: h
            } = n.Hooks.useArrowNavigationInList({
                list: t,
                scrollElementRef: s
            });
            return n.Hooks.useEventListener({
                eventName: "keydown",
                handler: n.ReactUtils.unlessImeEvent((e => {
                    if (h(e), "Enter" === e.key) {
                        e.preventDefault(), e.stopPropagation();
                        const s = t[c];
                        s && r(s)
                    }
                }))
            }), t.length ? (0, d.jsx)(u, {
                children: m(t, i).map(((e, t) => (0, d.jsx)(v, {
                    file: e,
                    color: o,
                    keyboardFocusRef: c === t ? l : void 0,
                    isSelected: !0,
                    onPress: () => r(e)
                }, e.id)))
            }) : (0, d.jsx)(a.u_.Paragraph, {
                centered: !0,
                children: i.f.nP
            })
        }

        function y(e) {
            const {
                file: t,
                color: s,
                keyboardFocusRef: n,
                onPress: a
            } = e;
            return invariant(!t.is_file, "Expected a directory"), (0, d.jsx)(o.Z, {
                label: t.name,
                icon: "°",
                iconColor: s,
                contentRef: n,
                isFocusedWithKeyboard: !!n,
                hasArrow: !0,
                onPress: a
            }, t.id)
        }

        function v(e) {
            var t;
            const {
                file: s,
                color: a,
                isSelected: o,
                keyboardFocusRef: i,
                onPress: l
            } = e;
            return invariant(s.is_file, "Expected a file"), (0, d.jsx)(r.Z, {
                label: s.name,
                color: a,
                icon: n.Styling.getAttachmentIcon(null != (t = s.mime_type) ? t : (0, c.lE)(s.name)),
                iconColor: a,
                isActive: o,
                contentRef: i,
                isFocusedWithKeyboard: !!i,
                onPress: l
            }, s.id)
        }
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            o: () => a,
            t: () => n
        });
        const n = (e, t) => e.replaceAll("@group:all", "@" + t.f.q9).replaceAll("@group:following", "@" + t.f.q$).replaceAll("@admins", "@" + t.f.Ea),
            a = (e, t) => {
                const s = (e, t) => [new RegExp("(\\B@)" + e + "(\\b)", "g"), "$1" + t + "$2"];
                return e.replaceAll(...s(t.f.q9, "group:all")).replaceAll(...s(t.f.q$, "group:following")).replaceAll(...s(t.f.Ea, "admins"))
            }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            DN: () => w,
            E9: () => j,
            EP: () => T,
            Kk: () => p,
            OC: () => u,
            SD: () => y,
            X2: () => m,
            e: () => b,
            i6: () => x,
            oj: () => g,
            p0: () => d,
            rs: () => _,
            vM: () => c,
            y7: () => h,
            yp: () => f
        });
        var n = s(145),
            a = s(800),
            o = s.n(a),
            r = s(1433),
            i = s(21);
        const c = Object.freeze({
                Freq: "FREQ",
                Interval: "INTERVAL",
                ByDay: "BYDAY",
                ByMonthDay: "BYMONTHDAY",
                ByMonth: "BYMONTH",
                BySetPos: "BYSETPOS",
                Until: "UNTIL",
                Count: "COUNT"
            }),
            l = Object.freeze({
                Monday: "MO",
                Tuesday: "TU",
                Wednesday: "WE",
                Thursday: "TH",
                Friday: "FR",
                Saturday: "SA",
                Sunday: "SU"
            }),
            d = [l.Monday, l.Tuesday, l.Wednesday, l.Thursday, l.Friday],
            u = [l.Saturday, l.Sunday],
            m = [l.Sunday, l.Monday, l.Tuesday, l.Wednesday, l.Thursday, l.Friday, l.Saturday],
            h = Object.freeze({
                Daily: "DAILY",
                Weekly: "WEEKLY",
                Monthly: "MONTHLY",
                Yearly: "YEARLY"
            }),
            p = [h.Daily, h.Weekly, h.Monthly, h.Yearly],
            g = Object.freeze({
                First: 1,
                Second: 2,
                Third: 3,
                Fourth: 4,
                Fifth: 5,
                SecondToLast: -2,
                Last: -1
            }),
            f = [g.First, g.Second, g.Third, g.Fourth, g.Fifth, g.SecondToLast, g.Last],
            b = Object.freeze({
                Day: "day",
                Weekday: "weekday",
                WeekendDay: "weekendDay"
            }),
            y = m.concat([b.Day, b.Weekday, b.WeekendDay]),
            v = "FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR",
            w = ({
                frequency: e,
                interval: t,
                byDay: s,
                byMonthDay: n,
                byMonth: a,
                bySetPos: o,
                onLastDay: r,
                until: i,
                count: l
            }) => {
                const d = c.Freq + "=" + e,
                    u = t ? c.Interval + "=" + t : null,
                    m = s && s.length ? c.ByDay + "=" + s.join(",") : null,
                    h = n && n.length && !r ? c.ByMonthDay + "=" + n.join(",") : null,
                    p = a && a.length ? c.ByMonth + "=" + a.join(",") : null,
                    g = o && o.length && !r ? c.BySetPos + "=" + o.join(",") : null,
                    f = r ? c.ByMonthDay + "=-1" : null,
                    b = i ? c.Until + "=" + function(e) {
                        const t = e.toUTC(),
                            s = k(t.getUTCFullYear(), 4),
                            n = k(t.getUTCMonth() + 1, 2),
                            a = k(t.getUTCDate(), 2);
                        return "" + s + n + a + "T000000Z"
                    }(i) : null;
                return [d, u, m, h, p, g, f, b, l && 1 <= l ? c.Count + "=" + l : null].filter(Boolean).join(";")
            };

        function k(e, t) {
            return e.toString().padStart(t, "0")
        }
        const x = {
                daily: "FREQ=DAILY",
                every2Days: "FREQ=DAILY;INTERVAL=2",
                every3Days: "FREQ=DAILY;INTERVAL=3",
                weekday: v,
                weekly: "FREQ=WEEKLY",
                every2Weeks: "FREQ=WEEKLY;INTERVAL=2",
                every3Weeks: "FREQ=WEEKLY;INTERVAL=3",
                every4Weeks: "FREQ=WEEKLY;INTERVAL=4",
                monthly: "FREQ=MONTHLY",
                every2Months: "FREQ=MONTHLY;INTERVAL=2",
                every3Months: "FREQ=MONTHLY;INTERVAL=3",
                every6Months: "FREQ=MONTHLY;INTERVAL=6",
                yearly: "FREQ=YEARLY"
            },
            j = Object.values(x),
            T = e => {
                if (!e) return null;
                return e.split(";").reduce(((e, t) => {
                    const [s, n] = t.split("=");
                    switch (s.toUpperCase()) {
                        case c.Freq:
                            p.includes(n) && (e.frequency = n);
                            break;
                        case c.ByDay: {
                            const t = n.split(",").filter((e => m.includes(e)));
                            0 < t.length && (e.byDay = t);
                            break
                        }
                        case c.ByMonthDay: {
                            const t = n.split(",").map((e => S(e))).filter(Boolean);
                            0 < t.length && (e.byMonthDay = t);
                            break
                        }
                        case c.Interval:
                            e.interval = S(n);
                            break;
                        case c.BySetPos:
                            e.bySetPos = S(n);
                            break;
                        case c.Count:
                            e.count = S(n);
                            break;
                        case c.Until:
                            e.until = function(e) {
                                const t = e.match(P);
                                if (!t) return null;
                                const [, s, n, a] = t, o = S(s), r = S(n), c = S(a);
                                if (!o || !r || !c) return null;
                                return i.DateTime.onDay(new Date(Date.UTC(o, r - 1, c)))
                            }(n)
                    }
                    return e
                }), {})
            };

        function S(e) {
            const t = parseInt(e, 10);
            return Number.isNaN(t) ? void 0 : t
        }
        const P = /^(\d{4})(\d{2})(\d{2})(T\d{2}\d{2}\d{2}Z?)?$/;
        const _ = (e, t) => {
            var s;
            if (e === v) return t.f.Cp;
            const a = T(e);
            if (!a) return "";
            const i = null != (s = a.interval) ? s : 1,
                c = a.until && t.formatDate(a.until.local, {
                    year: (0, n.Z)(a.until.local, new Date) ? void 0 : "numeric",
                    month: "short",
                    day: "numeric"
                }),
                l = c ? t.g("Co", {
                    date: c
                }) : void 0,
                p = a.count ? t.g("Cg", {
                    count: a.count
                }) : void 0;
            switch (a.frequency) {
                case h.Daily:
                    return t.g("Ci", {
                        daysCount: i,
                        until: l,
                        count: p
                    });
                case h.Weekly:
                    if (a.byDay) {
                        const e = o()[t.locale].weekdaysShort;
                        return t.g("Cr", {
                            weeksCount: i,
                            days: a.byDay.map((t => e[m.indexOf(t)])).join(", "),
                            until: l,
                            count: p
                        })
                    }
                    return t.g("Cq", {
                        weeksCount: i,
                        until: l,
                        count: p
                    });
                case h.Monthly: {
                    const {
                        byDay: e,
                        byMonthDay: s,
                        bySetPos: n
                    } = a;
                    if (e) {
                        var g;
                        const s = null != (g = function(e, t) {
                            if ((0, r.Z)(e, d)) {
                                return t.f.x5.toLowerCase()
                            }
                            if ((0, r.Z)(e, u)) {
                                return t.f.x6.toLowerCase()
                            }
                            if (1 === e.length && m.includes(e[0])) {
                                return o()[t.locale].weekdaysShort[m.indexOf(e[0])]
                            }
                            return null
                        }(e, t)) ? g : "";
                        return t.g("Cm", {
                            interval: i,
                            position: n,
                            day: s,
                            until: l,
                            count: p
                        })
                    }
                    if (s) {
                        if (1 === s.length) {
                            const e = t.f.x4;
                            return t.g("Cm", {
                                interval: i,
                                position: s[0],
                                day: e.toLowerCase(),
                                until: l,
                                count: p
                            })
                        }
                        const e = s.map((e => t.g("Cj", {
                            day: e
                        }))).join(", ");
                        return t.g("Cn", {
                            interval: i,
                            days: e,
                            until: l,
                            count: p
                        })
                    }
                    return t.g("Cl", {
                        monthsCount: i,
                        until: l,
                        count: p
                    })
                }
                case h.Yearly:
                    return t.g("Cs", {
                        yearsCount: i,
                        until: l,
                        count: p
                    });
                default:
                    return ""
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Cb: () => l,
            Ef: () => h,
            Pg: () => y,
            RL: () => o,
            TS: () => c,
            UV: () => b,
            Vg: () => m,
            Vh: () => r,
            cY: () => d,
            go: () => u,
            hi: () => f,
            kW: () => v,
            m$: () => w,
            s0: () => p,
            ss: () => g,
            zQ: () => i
        });
        var n = s(0),
            a = s(145);
        const o = (e, t = e.limits.openProjects, s = e.limits.sharedProjects) => e.activeProjectsWithoutTemplates.observeWithColumns([n.Model.Columns.projects.isOpen]).pipe(n.Rx.map((e => {
                const [a, o] = n.FP.partition((e => e.permissions.isOpen), e);
                return {
                    isOpenProjectsLimitExceeded: a.length > t,
                    isSharedProjectsLimitExceeded: o.length > s
                }
            }))),
            r = (e, t = e.limits.projectTemplates) => e.activeProjectTemplates.observeCount().pipe(n.Rx.map((e => e > t))),
            i = (e, t = e.limits.teamMembers, s = e.limits.teamAdmins) => e.membersExcludingRequests.observeWithColumns([n.Model.Columns.teamMembers.role]).pipe(n.Rx.map((e => {
                const a = e.filter(n.FP.propEq("role", "admin"));
                return {
                    isMembersLimitExceeded: e.length > t,
                    isAdminsLimitExceeded: a.length > s
                }
            }))),
            c = (e, t = e.limits.sharedTags, s = e.limits.privateTags) => e.tags.observeWithColumns([n.Model.Columns.tags.teamId]).pipe(n.Rx.map((e => n.FP.filter((e => Boolean(e.team.id)), e).length > t))),
            l = (e, t = e.limits.projectSections) => e.activeSections.observeWithColumns([n.Model.Columns.projectSections.projectId]).pipe(n.Rx.map(n.FP.pipe(n.FP.groupBy((e => e.project.id)), n.FP.values, n.FP.any((e => e.length > t))))),
            d = e => e.activeProjectsWithoutTemplates.observe().pipe(n.Rx.map((e => e.some((e => e.areTimeAttributesEnabled))))),
            u = (e, t = e.limits.memberGroups) => e.nonAdminGroups.observeCount().pipe(n.Rx.map((e => e > t))),
            m = (e, t = e.limits.projectGroups) => e.allProjectGroups.observeCount().pipe(n.Rx.map((e => e > t))),
            h = ({
                formatDate: e,
                date: t
            }) => e(t, (0, a.Z)(Date.now(), t) ? {
                month: "long",
                day: "numeric",
                year: void 0
            } : {
                month: "numeric",
                day: "numeric",
                year: "numeric"
            }),
            p = (e, t) => e.isFree ? t.f.xz : e.isTrial ? e.isBusiness ? t.f.xC : t.f.xB : e.isBusiness ? t.f.xy : t.f.xA,
            g = (e, t) => {
                const s = p(e, t);
                if (e.isFree) return s;
                const n = e.maxTeamMembers;
                return n ? s + " " + n : null
            },
            f = ({
                team: e,
                intl: t
            }) => {
                const {
                    planInfo: s
                } = e;
                return {
                    planName: t.g("v6", {
                        planName: g(s, t)
                    }),
                    validUntil: t.g("v8", {
                        date: h({
                            date: s.expiresAt,
                            formatDate: t.formatDate
                        }),
                        time: t.formatTime(s.expiresAt, {
                            hour: "numeric",
                            minute: "numeric"
                        })
                    }),
                    autoRenewal: t.g("v3", {
                        status: s.isRecurring ? t.f.v4 : t.f.v5
                    })
                }
            },
            b = (e, t) => {
                const s = g(e, t);
                return s ? t.g("v7", {
                    planName: s
                }) : null
            },
            y = (e, t) => {
                switch (e) {
                    case "create-projects":
                        return t.f.wI;
                    case "create-project-template":
                        return t.f.wJ;
                    case "invite-to-project":
                        return t.f.wN;
                    case "create-any-tag":
                    case "create-private-tag":
                    case "create-team-tag":
                        return t.f.wL;
                    case "invite-to-team":
                        return t.f.wO;
                    case "grant-admin":
                        return t.f.wM;
                    case "create-section":
                        return t.f.wK;
                    case "plan-has-expired":
                        return t.f.wP;
                    case "unlock-history":
                        return t.f.wQ;
                    case "attachment-limit":
                        return t.f.wG;
                    case "create-member-group":
                    case "create-project-group":
                        return t.f.wH;
                    default:
                        return t.f.wF
                }
            },
            v = (e, t) => {
                switch (e) {
                    case "APPLE":
                        return t.f.xD;
                    case "GOOGLE":
                        return t.f.xE;
                    default:
                        return n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Missing unsupported provider message for provider: " + (e || "")), t.f.xF
                }
            };

        function w({
            team: e,
            business: t
        }) {
            const s = e.name;
            if (e.isFree) return {
                teamName: s,
                planType: "free"
            };
            const {
                isBusiness: n
            } = e.planInfo;
            n && invariant(t, "Expected business to be present for a business plan");
            const a = (null == t ? void 0 : t.name) || "";
            return e.isTrial ? {
                teamName: s,
                planType: n ? "trialBusiness" : "trialPremium",
                businessName: a
            } : {
                teamName: s,
                planType: n ? "business" : "premium",
                businessName: a
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            AU: () => n,
            Cc: () => r,
            M6: () => i,
            Ot: () => c,
            qV: () => o,
            u7: () => a
        });
        s(5), s(4), s(8);
        const n = Object.freeze({
                AddMember: "add_member"
            }),
            a = Object.freeze(Object.assign({
                Upgrade: "upgrade",
                UpgradeBusiness: "upgrade_business",
                Extend: "extend"
            }, n)),
            o = Object.freeze({
                Name: "name",
                CreatedAt: "created_at",
                Custom: "custom"
            }),
            r = Object.freeze({
                Favorites: "favorites",
                ProjectsFollowed: "projects_followed",
                ProjectsActive: "projects_active"
            }),
            i = {
                [r.Favorites]: [o.CreatedAt],
                [r.ProjectsFollowed]: [],
                [r.ProjectsActive]: []
            },
            c = (Object.keys(r).map((e => r[e])), Object.freeze({
                email: "email",
                phone: "phone",
                misc: "misc"
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            QD: () => r,
            bA: () => d,
            fZ: () => u,
            iO: () => i,
            wE: () => c,
            xd: () => l
        });
        var n = s(0),
            a = s(444),
            o = s(1);
        const r = n.React.forwardRef(((e, t) => (0, o.jsx)("div", {
                className: a.Z.section + (e.noGutter ? " " + a.Z.noGutter : "") + " " + (e.className || ""),
                style: e.style,
                ref: t,
                children: e.children
            }))),
            i = n.React.forwardRef(((e, t) => (0, o.jsx)("span", {
                className: a.Z.text + (e.emphasis ? " " + a.Z.emphasis : "") + " " + (e.className || ""),
                style: e.style,
                ref: t,
                children: e.children
            }))),
            c = e => (0, o.jsx)("span", {
                className: a.Z.emphasis + " " + (e.className || ""),
                style: e.style,
                children: e.children
            }),
            l = n.React.forwardRef(((e, t) => (0, o.jsx)("span", {
                className: a.Z.text + " " + a.Z.paragraph + (e.emphasis ? " " + a.Z.emphasis : "") + (e.centered ? " " + a.Z.centered : "") + " " + (e.className || ""),
                style: e.style,
                ref: t,
                children: e.children
            }))),
            d = n.React.forwardRef(((e, t) => (0, o.jsx)("span", {
                className: a.Z.message + " " + a.Z.success + " " + (e.className || ""),
                style: e.style,
                ref: t,
                children: e.children
            }))),
            u = n.React.forwardRef(((e, t) => (0, o.jsx)("span", {
                className: a.Z.message + " " + a.Z.error + (e.noGutter ? " " + a.Z.noGutter : "") + " " + (e.className || ""),
                style: e.style,
                ref: t,
                children: e.children
            })))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Vw: () => a,
            k: () => o,
            lN: () => r,
            y4: () => i.Z,
            H: () => c.Z,
            Jn: () => l
        });
        var n = s(232);
        const a = Object.freeze({
            BadRequest: "BadRequest",
            Unauthorized: "Unauthorized",
            Forbidden: "Forbidden",
            NotFound: "NotFound",
            NotAcceptable: "NotAcceptable",
            Conflict: "Conflict",
            Gone: "Gone",
            TooManyRequest: "TooManyRequest",
            UnprocessableEntity: "UnprocessableEntity",
            TokenExpired: "TokenExpired",
            InternalServerError: "InternalServerError",
            ServiceUnavailable: "ServiceUnavailable",
            NetworkLikely: "NetworkLikely",
            Unknown: "Unknown"
        });
        class o extends Error {
            constructor(e, t) {
                super(function(e, t) {
                    const s = "Error code: " + e;
                    if (!t) return s;
                    const n = t instanceof Error ? t.message : JSON.stringify(t, null, 2);
                    return s + ", caused by: " + n
                }(e, t)), this.context = {}, this.framesToPop = 1, this.name = this.constructor.name, this.code = e, this.cause = t
            }
        }

        function r(e) {
            if (e instanceof o) return e.code;
            if (e instanceof n.A3) {
                var t, s;
                if (e.isNetworkErrorLikely) return a.NetworkLikely;
                switch ((null == (t = e.originalResponse) ? void 0 : t.status) || (null == (s = e.originalXHRResponse) ? void 0 : s.status)) {
                    case 400:
                        return a.BadRequest;
                    case 401:
                        return a.Unauthorized;
                    case 403:
                        return a.Forbidden;
                    case 404:
                        return a.NotFound;
                    case 406:
                        return a.NotAcceptable;
                    case 409:
                        return a.Conflict;
                    case 410:
                        return a.Gone;
                    case 429:
                        return a.TooManyRequest;
                    case 422:
                        return a.UnprocessableEntity;
                    case 441:
                        return a.TokenExpired;
                    case 500:
                        return a.InternalServerError;
                    case 503:
                        return a.ServiceUnavailable
                }
            }
            return a.Unknown
        }
        var i = s(803),
            c = s(1143);

        function l(e) {
            if (e instanceof o) return e;
            const t = r(e);
            return new o(t, e)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            sB: () => g,
            ZP: () => p,
            xf: () => b,
            pu: () => f
        });
        var n = s(41),
            a = s(64);
        var o = s(1524);
        s(5);
        const r = 6e4,
            i = 60 * r,
            c = 24 * i,
            l = 13.5 * i;

        function d(e) {
            return 0 == e % c
        }

        function u(e) {
            if (invariant(!Number.isNaN(e), "Invalid timestamp (NaN)"), d(e)) return e;
            const t = new Date(e + l),
                s = Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate());
            return invariant(d(s), "Broken sanitizeDueDate"), s
        }

        function m(e) {
            return function(e) {
                return 0 == e % r
            }(e) ? e : Math.round(e / r) * r
        }
        var h;
        class p {
            constructor(e) {
                if (!e.legacyDueDate) throw new Error("Invalid DateTimeOptions");
                {
                    const {
                        date: t,
                        isAllDay: s
                    } = e.legacyDueDate;
                    this._timestamp = function(e, t) {
                        return t ? u(e) : m(e)
                    }(t.getTime(), s), this._debugOriginalTimestamp = t.getTime(), this._isAllDay = s
                }
            }
            get isAllDay() {
                return this._isAllDay
            }
            get timestamp() {
                return this._timestamp
            }
            get local() {
                return function(e, t) {
                    if (t) {
                        const t = new Date(e);
                        return new Date(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate())
                    }
                    return new Date(e)
                }(this._timestamp, this._isAllDay)
            }
            get ymd() {
                return (0, o.Z)(this.local)
            }
            get day() {
                return this.isAllDay ? this : p.onDay(this.local)
            }
            withDay(e) {
                return this.isAllDay ? e.day : e.withTime(this.time)
            }
            get time() {
                if (this.isAllDay) throw new Error("Cannot get time of all-day DateTime");
                const e = this.local;
                return [e.getHours(), e.getMinutes()]
            }
            withTime(e) {
                const [t, s] = e, n = new Date(this.local);
                return n.setHours(t), n.setMinutes(s), p.at(n)
            }
            get legacyDueDate() {
                return {
                    date: this.local,
                    isAllDay: this._isAllDay
                }
            }
            get DONTUSEYET_toDueDate() {
                return {
                    date: new Date(this._timestamp),
                    isAllDay: this._isAllDay
                }
            }
            equals(e) {
                return g(this, e)
            }
            isBefore(e) {
                return f(this, e)
            }
            toUTC() {
                return function(e) {
                    const {
                        local: t
                    } = e;
                    return new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate()))
                }(this)
            }
        }

        function g(e, t) {
            return e && t ? e._timestamp === t._timestamp && e._isAllDay === t._isAllDay : e === t
        }

        function f(e, t) {
            return e.isAllDay !== t.isAllDay ? f(e.day, t.day) : e._timestamp < t._timestamp
        }

        function b(e) {
            const t = new Date(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate());
            return p.onDay(t)
        }
        h = p, p.fromLegacyDueDate = e => e ? new h({
            legacyDueDate: e
        }) : null, p.at = e => new h({
            legacyDueDate: {
                date: new Date(e),
                isAllDay: !1
            }
        }), p.onDay = e => new h({
            legacyDueDate: {
                date: (0, n.Z)(e),
                isAllDay: !0
            }
        }), p.addDays = (e, t) => function(e, t) {
            const s = (0, a.Z)(e.local, t);
            return e.isAllDay ? p.onDay(s) : p.at(s)
        }(e, t)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Fz: () => a,
            P9: () => o,
            tC: () => r,
            vR: () => i
        });
        var n = s(0);

        function a() {
            const [e] = n.React.useState((() => n.Misc.randomId()));
            return e
        }

        function o(e) {
            const t = n.React.useRef(),
                s = e || t;
            return [n.React.useMemo((() => ({
                closeAnimated: e => {
                    var t;
                    null == (t = s.current) || t.closeAnimated(e)
                },
                expand: () => {
                    var e;
                    null == (e = s.current) || null == e.expand || e.expand()
                }
            })), [s]), s]
        }
        const r = n.React.createContext({
            closeAnimated: n.FP.noop,
            expand: n.FP.noop,
            isClosingDisabled: !1,
            isFloating: !1,
            size: void 0,
            onClose: n.FP.noop,
            onDismiss: void 0,
            level: 0
        });

        function i() {
            return n.React.useContext(r)
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            JS: () => c,
            L0: () => l,
            US: () => i,
            uI: () => d
        });
        var n = s(146),
            a = s(110),
            o = s(21),
            r = s(494);

        function i(e, t) {
            return (0, r.Mf)(e) ? t ? (invariant("number" == typeof e, "Expected due date filter to be a numeric offset"), o.DateTime.at(Date.now() + e).day) : (invariant("number" != typeof e, "Expected due date filter to be a specific DateTime"), e) : e
        }

        function c(e, t) {
            return (0, r.Mf)(e) ? t ? "number" != typeof e ? (s = e, 24 * (0, n.Z)(s.local, new Date) * 3600 * 1e3) : e : "number" == typeof e ? (a = e, o.DateTime.at(Date.now() + a).day) : e : t ? void 0 : e;
            var s, a
        }

        function l(e, t) {
            return (0, r.Mf)(e) ? t ? (invariant("number" == typeof e, "Expected due date filter to be a numeric offset"), e) : (invariant("number" != typeof e, "Expected due date filter to be a specific DateTime"), (0, a.PD)(null == e ? void 0 : e.legacyDueDate)) : t ? void 0 : e
        }

        function d(e, t) {
            return t ? (0, r.Mf)(e) && "number" == typeof e ? e : void 0 : (0, r.Mf)(e) ? (s = e) && "object" == typeof s && "number" == typeof s.date && "boolean" == typeof s.isAllDay ? o.DateTime.fromLegacyDueDate((0, a.UP)(e)) : void 0 : e;
            var s
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(373)]).then(s.bind(s, 1506))))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            s: () => a
        });
        var n = s(9);

        function a(e) {
            return !("function" != typeof e || e.prototype && e.prototype.render || e.defaultProps) ? e : t => n.createElement(e, t)
        }(0, s(797)._setCreateFactory)(a)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            EZ: () => k,
            ZP: () => w
        });
        var n = s(9),
            a = s(141),
            o = s(798),
            r = s(312),
            i = s(200),
            c = s(80),
            l = s(14),
            d = s(1);
        const u = ({
            services: e
        }) => (n.useEffect((() => {
            e.router.goTo(l.pathToRoot)
        }), []), null);
        var m = s(799),
            h = s(54),
            p = s(124),
            g = s(8),
            f = (s(23), s(5));
        async function b(e, t) {
            try {
                const t = s(1252).Z;
                return await t(e)
            } catch (e) {
                return y(t)
            }
        }

        function y(e) {
            const t = e.find((e => !e.isShared));
            return invariant(t, "No fallback team found"), t
        }
        const v = ({
            services: e,
            from: t,
            to: s
        }) => {
            const {
                history: a
            } = e;
            return n.useEffect((() => {
                const e = (() => {
                    const e = a.currentPath.getValue();
                    try {
                        invariant(t !== s, "Two different teams are needed to switch the identity"), invariant(t.isShared, "The selected team is not shared when switching"), invariant(!s.isShared, "The current team should not be shared when switching"), invariant(e.includes("/teams/" + t.id + "/"), "Possibly unnecessary identity switch");
                        return {
                            path: e.replace("/teams/" + t.id + "/", "/teams/" + s.id + "/")
                        }
                    } catch (e) {
                        return l.pathToRoot
                    }
                })();
                a.replace(e)
            }), [t, s, a]), null
        };

        function w(e) {
            const t = (0, r.s)(e);
            return function(e) {
                const s = (0, i.Z)();
                return t(Object.assign({}, e, s))
            }
        }
        const k = (0, o.Z)((function(e) {
            return (0, a.R6)(["services"], (({
                services: e
            }) => ({
                currentUser: e.modelRoot.currentUser
            })))((t => {
                var s;
                const {
                    currentUser: a,
                    path: o,
                    services: r
                } = t, i = null != (s = null == a ? void 0 : a.isLimited) && s;
                return n.useMemo((() => {
                    return !i || (e = o, l.limitedAccountAllowedRoutes.some((t => (0, c.matchPath)(e, {
                        path: t,
                        exact: !0
                    }))));
                    var e
                }), [i, o]) ? (0, d.jsx)(e, Object.assign({}, t, {
                    isLimitedAccount: i
                })) : (0, d.jsx)(u, {
                    services: r
                })
            }))
        }), (function(e) {
            return (0, o.Z)((0, a.R6)(["services"], (({
                services: e
            }) => ({
                activeTeams: e.modelRoot.activeTeams,
                sharedTeams: e.modelRoot.sharedTeams
            }))), (0, m.Z)((({
                activeTeams: e,
                sharedTeams: t,
                path: s
            }) => {
                const a = (0, h.useIntl)(),
                    o = n.useMemo((() => (0, p.Hc)(a)([...e, ...t])), [a, e, t]),
                    {
                        teamId: r,
                        projectId: i,
                        taskId: c
                    } = function(e) {
                        const t = e.slice(1).split("/"),
                            s = "teams" === t[0],
                            n = "projects" === t[2],
                            a = "task_id" === t[2];
                        return {
                            teamId: s ? t[1] : null,
                            projectId: n ? t[3] : null,
                            taskId: a ? t[3] : null
                        }
                    }(s),
                    l = n.useMemo((() => function(e, t) {
                        const s = t.find((t => e ? t.id === e : t.isPersonal));
                        return s || ((0, f.PROD_CONSOLE)(f.PROD_CONSOLE_REASON.SAFE_ID).warn("Route points to Team ID " + (e || "null") + ", but no such team found. Will fall back to any available team"), y(t))
                    }(r, o)), [o, r]);
                return {
                    availableTeams: o,
                    selectedTeam: l,
                    projectId: i,
                    taskId: c
                }
            })), (0, a.R6)(["selectedTeam"], (({
                selectedTeam: e,
                projectId: t,
                taskId: s,
                availableTeams: n
            }) => ({
                currentTeam: e.isShared ? g.from(b({
                    team: e,
                    projectId: t,
                    taskId: s
                }, n)) : g.of(e)
            }))))((t => {
                const {
                    services: s,
                    selectedTeam: n,
                    currentTeam: a
                } = t;
                return n !== a ? (0, d.jsx)(v, {
                    services: s,
                    from: n,
                    to: a
                }) : (0, d.jsx)(e, Object.assign({}, t, {
                    currentTeam: a
                }))
            }))
        }), (0, a.R6)(["services"], (({
            services: e
        }) => ({
            currentUser: e.modelRoot.currentUser
        }))), (0, a.R6)(["currentTeam"], (({
            currentTeam: e
        }) => ({
            currentMember: e.currentMember
        }))))((({
            currentTeam: e,
            currentMember: t,
            isLimitedAccount: s,
            children: a,
            services: o,
            currentUser: r
        }) => {
            const c = n.useMemo((() => ({
                currentMember: t,
                currentTeam: e,
                isLimitedAccount: s,
                currentUser: r
            })), [t, e, s, r]);
            return o.ab.unsafeTeamId = e.id, o.db.__unsafeCurrentTeamId = e.id, (0, d.jsx)(i.x.Provider, {
                value: c,
                children: a
            })
        }))
    }, (e, t, s) => {
        const n = s(163);
        e.exports = n
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            K3: () => l,
            Rw: () => d,
            cl: () => c
        });
        var n = s(4),
            a = s(8),
            o = s(39);
        const r = s(16).o.projectSections,
            i = [r.position, r.archivedAt],
            c = n.sortWith([n.descend(n.prop("isActive")), n.descend(n.prop("archivedAt")), n.ascend(n.prop("position")), n.descend(n.prop("name"))]),
            l = e => e.observeWithColumns(i).pipe(a.map(c));
        async function d({
            section: e,
            sections: t,
            offset: s
        }) {
            const a = n.indexOf(e, t),
                r = await (0, o.getNewPosition)({
                    list: t,
                    index: a + (0 < s ? s + 1 : s),
                    selector: e => e.position,
                    updater: (e, t) => {
                        e.position = t
                    }
                });
            await e.do.updatePosition(r)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            BK: () => g
        });
        var n = s(0),
            a = s(256),
            o = (s(12), s(53)),
            r = s(157),
            i = s(125);
        s(2), s(3);
        const c = s(708);
        var l = s(1);
        const d = [{
                iconName: "Ó",
                color: "incoming",
                opacity: .3,
                size: 200
            }, {
                iconName: "Ô",
                color: "incoming",
                size: 200
            }],
            u = n.Hocs.compose()((e => {
                const {
                    closeMenu: t,
                    message: s,
                    onCopyToClipboard: u,
                    onAddToContacts: m
                } = e, h = n.Hooks.useIntl(), p = (0, r.useCopyButtonState)({
                    label: h.f.iy
                });
                return (0, l.jsx)(a.Z, {
                    title: h.f.is,
                    message: s,
                    closeMenu: t,
                    iconStack: d,
                    isDesktopModal: !0,
                    children: e => (0, l.jsxs)(l.Fragment, {
                        children: [(0, l.jsx)(i.Z, {
                            hint: h.f.fC,
                            helpPageUrl: n.ReactUtils.helpUrl(h, "taskcommunication/email-tasks/#emailactivate")
                        }), (0, l.jsx)("div", {
                            className: c.buttonsContainer,
                            children: (0, l.jsxs)(l.Fragment, {
                                children: [(0, l.jsx)(o.default, {
                                    label: p.label,
                                    onPress: n.ReactUtils.callBoth(u, p.copy)
                                }), (0, l.jsx)(o.default, {
                                    onPress: e,
                                    label: h.f.fF
                                })]
                            })
                        })]
                    })
                })
            }));
        s(931);
        var m = s(20);
        const h = n.Hocs.compose()((e => {
                const {
                    modalWebTarget: t,
                    onPress: s,
                    label: n
                } = e;
                return (0, l.jsx)(m.Z, {
                    icon: "¦",
                    hasArrow: !0,
                    label: n,
                    modalWebTarget: t,
                    onPress: s
                })
            })),
            p = n.ReactUtils.lazy((() => s(931))),
            g = ({
                team: e,
                parentRecord: t,
                next: s,
                onClose: a,
                strings: o,
                getRecordName: r
            }) => {
                const [i, c] = n.React.useState(null), d = n.Hooks.useServices(), m = n.Hooks.useIntl(), g = n.Hooks.useIsMounted(), f = n.Hooks.useModalState(), b = n.Hooks.useRemindExpired((() => a(n.ReactUtils.nullEvent()))), y = async () => {
                    try {
                        const {
                            email: n,
                            isCreated: a
                        } = await d.api.integrations.getEmailToNozbe(e, t);
                        n && g.current && c(n), a && n ? s("email_to_nozbe_confirm")() : g.current ? f.open() : s("email_to_nozbe_menu")()
                    } catch (e) {
                        n.ReactUtils.devAlert(m.f.iz), n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.API_ERROR, e)
                    }
                }, v = async () => {
                    try {
                        await d.api.integrations.deactivateEmailToNozbe(e, t)
                    } catch (e) {
                        n.ReactUtils.devAlert(o.deactivateError), n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.API_ERROR, e)
                    }
                }, w = async () => {
                    await v(), await y()
                }, k = () => {
                    i && n.ReactUtils.copyToClipboard(i, m.formatMessage)
                }, x = () => {
                    i && d.native.addContact(i, ((e, t) => t ? t(e) : e ? (invariant("string" == typeof e.name, "Cannot get record name for Email to Nozbe"), e.name) : void 0)(t, r))
                };
                return {
                    renderEmailToNozbeConfirm: () => (0, l.jsx)(u, {
                        closeMenu: a,
                        onCopyToClipboard: k,
                        message: i ? o.getActivated(i) : "",
                        onAddToContacts: x
                    }),
                    renderEmailToNozbeListItem: () => (0, l.jsx)(h, {
                        onPress: b(y),
                        modalWebTarget: f.target,
                        label: o.title
                    }),
                    renderEmailToNozbeMenu: () => (0, l.jsx)(p, {
                        closeMenu: a,
                        level: 90,
                        emailAddress: i,
                        target: f.target,
                        onAddToContacts: x,
                        onCopyEmailAddress: k,
                        onGenerateNewEmailAddress: w,
                        deactivateLabel: o.deactivate,
                        onDeactivateEmailToNozbe: v
                    }),
                    isEmailToNozbeOpen: f.isOpen
                }
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(6),
            o = s(25),
            r = s(90);
        s(2), s(3);
        const i = s(710);
        var c = s(1);
        const l = n.Hocs.compose()((e => {
            const {
                message: t,
                confirmationText: s,
                placeholderText: l,
                onConfirmPress: d,
                onBackPress: u,
                onClose: m,
                level: h,
                headerIcon: p,
                confirmButtonMessage: g
            } = e, [f, b] = n.React.useState("");
            return (0, c.jsxs)(o.default, {
                type: "delete",
                level: h,
                headerIcon: p,
                onConfirmPress: d,
                closeOnConfirm: !1,
                confirmButtonMessage: g,
                isConfirmDisabled: f !== s,
                hasTextContent: !1,
                onBackPress: u,
                onClose: m,
                children: [(0, c.jsx)(a.u_.Paragraph, {
                    children: t
                }), (0, c.jsx)(a.u_.Section, {
                    children: (0, c.jsx)(r.Z, {
                        className: i.userInput,
                        value: f,
                        onChange: b,
                        autoFocus: !0,
                        placeholder: l
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            c: () => p,
            k: () => u
        });
        s(0);
        var n = s(61),
            a = s(194),
            o = s(1465),
            r = s(189),
            i = s(41),
            c = s(64),
            l = s(856),
            d = s(1);
        const u = {
                OVERDUE: "OVERDUE",
                TODAY: "TODAY",
                TOMORROW: "TOMORROW"
            },
            m = {
                [u.TODAY]: (0, d.jsx)(n.Z, {
                    id: "gd"
                }),
                [u.OVERDUE]: (0, d.jsx)(n.Z, {
                    id: "nx"
                }),
                [u.TOMORROW]: (0, d.jsx)(n.Z, {
                    id: "ge"
                })
            },
            h = {
                day: "numeric",
                month: "short"
            },
            p = (e, t) => {
                if (e === u.OVERDUE) return m[u.OVERDUE];
                const s = new Date(Number(e));
                if (invariant(s, "Unexpected groupRoot type"), (0, a.Z)(s)) return m[u.TODAY];
                if ((0, o.Z)(s)) return m[u.TOMORROW];
                const n = new Date;
                return t(s, (0, r.Z)(s, {
                    start: (0, i.Z)(n),
                    end: (0, i.Z)((0, c.Z)(n, 7))
                }) ? Object.assign({}, h, {
                    weekday: "long"
                }) : Object.assign({}, h, {
                    weekday: "long",
                    year: (0, l.Z)(s) ? void 0 : "numeric"
                }))
            }
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            IC: () => r,
            ZP: () => c
        });
        s(9);
        var n = s(61),
            a = s(4);
        const o = (0, s(1).jsx)(n.Z, {
                id: "KL"
            }, "validation.nip.message"),
            r = e => {
                var t;
                return null != (t = null == e ? void 0 : e.replace(/[\ \-]|^pl/gi, "")) ? t : ""
            },
            i = (0, a.either)(a.isEmpty, (e => {
                const t = r(e);
                if (!/^\d{10}$/.test(t)) return !1;
                const s = [6, 5, 7, 2, 3, 4, 5, 6, 7];
                let n = 0;
                for (let e = 0; e < s.length; e += 1) n += parseInt(t[e], 10) * s[e];
                return n % 11 === parseInt(t[9], 10)
            })),
            c = e => ({
                error: o,
                isValid: i(e)
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(9);

        function a() {
            const e = (0, n.useRef)(!1);
            return (0, n.useLayoutEffect)((() => (e.current = !0, () => {
                e.current = !1
            })), []), e
        }
    }, (e, t, s) => {
        const n = s(163);
        e.exports = n
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c,
            u: () => a
        });
        var n = s(8);
        s(5);

        function a(e) {
            return "light" === e || "dark" === e
        }
        var o = s(1525);

        function r() {
            return o.rS.getValue()
        }

        function i(e, t = !1) {
            invariant(a(e), 'Attempted to set an invalid theme: "' + e + '"'), (o.rS.getValue() !== e || t) && (0, o._v)(e)
        }
        const c = {
            getSystemTheme: o.vn,
            onSystemThemeChange: o.E4,
            current: r,
            isLight: function() {
                return "light" === r()
            },
            isDark: function() {
                return "dark" === r()
            },
            asObservable: function() {
                return o.rS.asObservable().pipe(n.distinctUntilChanged())
            },
            change: i,
            reset: function() {
                i((0, o.vn)(), !0)
            },
            markRenderingBegins: o.o6
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            bD: () => f,
            gr: () => b,
            jw: () => p,
            k5: () => u,
            od: () => g
        });
        var n, a = s(24),
            o = s(120),
            r = s(33),
            i = s(5),
            c = (s(4), s(8)),
            l = s(21);
        const d = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);

        function u(e) {
            return Array.isArray(e) ? e.map((e => m(e))).filter(Boolean) : []
        }

        function m(e) {
            if ("object" != typeof e || !e) return null;
            const {
                id: t,
                vacation_from: s,
                vacation_to: n
            } = e;
            if ("string" != typeof t || !h(s) || !h(n)) return null;
            if (s > n) return null;
            return {
                id: t,
                vacation_from: s,
                vacation_to: n,
                time_zone: function(e) {
                    return "string" == typeof e && !!e.length
                }(e.time_zone) ? e.time_zone : null
            }
        }

        function h(e) {
            return "number" == typeof e && Number.isFinite(e) && Number.isInteger(e) && 0 <= e
        }
        class p {
            constructor(e) {
                this.vacationer = e
            }
            get all() {
                return f(this.vacationer._vacations.map((e => new g(e, this.vacationer))))
            }
            get active() {
                return this.all.filter((e => !e.isPast))
            }
            observe() {
                return this.vacationer.observe().pipe(c.mapTo(this))
            }
        }
        let g = (n = class e {
            static fromDates([t, s], n, a = i.randomId()) {
                const o = {
                    id: a,
                    vacation_from: t.timestamp,
                    vacation_to: s.timestamp,
                    time_zone: (0, l.getTimeZone)()
                };
                return invariant(m(o), "Invalid vacation dates"), new e(o, n)
            }
            constructor(e, t) {
                this.record = e, this.vacationer = t
            }
            get asModel() {
                return this.vacationer
            }
            get database() {
                return this.vacationer.database
            }
            get id() {
                return this.record.id
            }
            get from() {
                return l.DateTime.at(this.fromTimestamp)
            }
            get fromTimestamp() {
                return this.record.vacation_from
            }
            get to() {
                return l.DateTime.at(this.toTimestamp)
            }
            get toTimestamp() {
                return this.record.vacation_to
            }
            get dates() {
                return [this.from, this.to]
            }
            get timeZone() {
                return this.record.time_zone
            }
            get isPast() {
                const e = Date.now();
                return this.record.vacation_to < e
            }
            get isOngoing() {
                const e = Date.now();
                return this.record.vacation_from <= e && e <= this.record.vacation_to
            }
            get isScheduled() {
                return this.vacationer._vacations.some((e => this.id === e.id))
            }
            get spansOverOneDay() {
                return !(0, o.Z)(this.fromTimestamp, this.toTimestamp)
            }
            equals(e) {
                return this.fromTimestamp === e.fromTimestamp && this.toTimestamp === e.toTimestamp && this.vacationer.id === e.vacationer.id
            }
            compare(e) {
                return this.fromTimestamp - e.fromTimestamp || this.toTimestamp - e.toTimestamp
            }
            contains(e) {
                return this.fromTimestamp <= e.fromTimestamp && e.toTimestamp <= this.toTimestamp
            }
            overlapsWith(e) {
                return this.fromTimestamp <= e.toTimestamp && e.fromTimestamp <= this.toTimestamp
            }
            isFollowedBy(e) {
                const t = e.fromTimestamp - this.toTimestamp;
                return 0 <= t && t <= 36e5
            }
            async schedule() {
                if (this.isScheduled) return;
                invariant(!this.isPast, "Cannot schedule past vacations");
                const {
                    vacationer: e,
                    record: t
                } = this;
                await e.update((() => {
                    e._vacations = e._vacations.concat(t)
                }))
            }
            async reschedule(t) {
                const {
                    vacationer: s
                } = this, n = e.fromDates(t, s, this.id);
                invariant(!n.isPast, "Cannot reschedule vacation to the past"), await s.update((() => {
                    s._vacations = s._vacations.filter((e => this.id !== e.id)).concat(n.record)
                }))
            }
            async replaceWith(e) {
                const {
                    vacationer: t
                } = this;
                this.vacationer.id === e.vacationer.id ? await t.callWriter((() => this.reschedule(e.dates))) : (await t.callWriter((() => this.cancel())), await t.callWriter((() => e.schedule())))
            }
            async cancel() {
                if (!this.isScheduled) return;
                const {
                    vacationer: e
                } = this;
                await e.update((() => {
                    e._vacations = e._vacations.filter((e => this.id !== e.id))
                }))
            }
        }, d(n, "schedule", [r.writer]), d(n, "reschedule", [r.writer]), d(n, "replaceWith", [r.writer]), d(n, "cancel", [r.writer]), n);

        function f(e) {
            return [...e].sort(((e, t) => e.compare(t)))
        }

        function b(e) {
            const t = f(e.filter((e => !e.isPast)));
            if (!t.length) return null;
            let s = null;
            for (const e of t) {
                var n;
                if (e.isOngoing && (!s || e.contains(s) || s.isFollowedBy(e))) s = e;
                else if (null == (n = s) || !n.contains(e)) break
            }
            return s
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = {
            businesses: {
                name: 50
            },
            tasks: {
                name: 128
            },
            projects: {
                name: 128,
                description: 280
            },
            tags: {
                name: 50
            },
            projectSections: {
                name: 100
            },
            group: {
                name: 80
            },
            users: {
                name: 35
            },
            teams: {
                name: 50
            },
            teamMembers: {
                alias: 35,
                description: 140
            },
            comments: {
                bodyWithoutChecklist: 12e3,
                body: 8e4
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            F1: () => i,
            UB: () => r,
            kB: () => c
        });
        var n = s(19),
            a = s(16),
            o = s(65);

        function r(e, t) {
            return [n.Q.experimentalJoinTables([a.w.projects]), n.Q.or(n.Q.on(a.w.projects, (0, o.J$)(e)), n.Q.where(a.o.id, n.Q.oneOf(t))), n.Q.where(a.o.tasks.type, null)]
        }

        function i(e, t) {
            return [n.Q.experimentalJoinTables([a.w.projects]), n.Q.or(n.Q.on(a.w.projects, [(0, o.J$)(e), o.Y3]), n.Q.where(a.o.id, n.Q.oneOf(t))), n.Q.where(a.o.tasks.type, null)]
        }

        function c(e, t) {
            return [n.Q.experimentalJoinTables([a.w.projects]), n.Q.or(n.Q.on(a.w.projects, [(0, o.J$)(e), o.Y3, o.Vf]), n.Q.where(a.o.id, n.Q.oneOf(t))), n.Q.where(a.o.tasks.type, null)]
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(22),
            o = s(13);
        s(2), s(3);
        const r = s(519);
        var i = s(1);
        const c = e => {
            const {
                toggleSection: t,
                isCollapsed: s,
                iconSize: c = 28,
                size: l = 44,
                color: d = "onBackground3",
                badge: u
            } = e, m = n.Hooks.useIntl(), h = {
                name: "Ɠ",
                color: s ? d : "onBackground2",
                accessibilityLabel: s ? m.f.mS : m.f.mR
            };
            return void 0 === s ? null : t ? (0, i.jsx)(a.default, Object.assign({
                className: r.icon + (s ? "" : " " + r.iconExpanded)
            }, h, {
                iconSize: c,
                badge: s ? u : void 0,
                size: l,
                hoverColor: d,
                withHover: !0,
                onPress: e => {
                    e.preventDefault(), e.stopPropagation(), t && t()
                }
            })) : (0, i.jsx)("div", {
                className: r.iconContainer,
                style: {
                    width: l,
                    height: l
                },
                children: (0, i.jsx)(o.default, Object.assign({
                    className: r.icon + (s ? "" : " " + r.iconExpanded)
                }, h, {
                    size: c
                }))
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            c: () => a
        });
        var n = s(0);

        function a(e) {
            var t;
            if (e instanceof n.Model.Models.ProjectGroup) {
                const {
                    sidebarPosition: t
                } = e;
                return invariant("number" == typeof t, "Unexpected missing sidebarPosition"), null != t ? t : 0
            }
            return null != (t = e.position) ? t : 0
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            U: () => n,
            i: () => a
        });
        s(0);

        function n(e) {
            const {
                lastCreditsGrantedAt: t = 0,
                lastCreditsSeenAt: s = 0
            } = e || {};
            return t > s
        }
        const a = Object.freeze({
            Link: "link",
            Testimonial: "testimonial",
            Credits: "credits",
            Referrer: "referrer",
            Banners: "banners"
        })
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => v
        });
        var n = s(0),
            a = s(14),
            o = s(56),
            r = s(18),
            i = s(225),
            c = s(359),
            l = s(1);
        const d = n.Hocs.compose(n.Hocs.withIntl, n.Hocs.withObservables(["member", "intl"], (({
            intl: e,
            member: t
        }) => ({
            status: (0, i.k)(t, e)
        }))))((e => {
            const {
                status: t
            } = e;
            return t ? (0, l.jsx)(c.dk, {
                children: t
            }) : null
        }));
        var u = s(11);
        s(2), s(3);
        const m = s(538),
            h = n.Hocs.compose()((e => {
                const {
                    onAcceptPress: t,
                    onDeclinePress: s
                } = e, a = n.Hooks.useIntl();
                return (0, l.jsxs)("div", {
                    className: m.root,
                    children: [(0, l.jsx)(u.Z, {
                        className: m.button + " " + m.declineButton,
                        onPress: e => {
                            e.preventDefault(), s()
                        },
                        children: (0, l.jsx)("span", {
                            className: m.text + " " + m.declineText,
                            children: a.f.fo
                        })
                    }), (0, l.jsx)(u.Z, {
                        className: m.button + " " + m.acceptButton,
                        onPress: e => {
                            e.preventDefault(), t()
                        },
                        children: (0, l.jsx)("span", {
                            className: m.text + " " + m.acceptText,
                            children: a.f.e_
                        })
                    })]
                })
            })),
            p = s(539),
            g = n.Hocs.compose()((e => {
                const {
                    onResendPress: t,
                    onRemovePress: s
                } = e, a = n.Hooks.useIntl();
                return (0, l.jsxs)("div", {
                    className: p.root,
                    children: [(0, l.jsx)(u.Z, {
                        className: p.button + " " + p.removeButton,
                        onPress: e => {
                            n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), s()
                        },
                        children: (0, l.jsx)("span", {
                            className: p.text + " " + p.removeText,
                            children: a.f.fL
                        })
                    }), (0, l.jsx)(u.Z, {
                        className: p.button + " " + p.resendButton,
                        onPress: e => {
                            n.ReactUtils.preventDefault(e), t()
                        },
                        children: (0, l.jsx)("span", {
                            className: p.text + " " + p.resendText,
                            children: a.f.fN
                        })
                    })]
                })
            }));
        const f = s(23).identityElement,
            b = s(540);

        function y({
            member: e,
            intl: t,
            showFavFollowIcon: s,
            shouldRenderYou: a
        }) {
            return a && !s ? n.Rx.of(t.f.Ef) : n.Rx.combineLatestObject({
                preferredName: e.preferredName,
                isAwayOnVacation: e.isAwayOnVacation
            }).pipe(n.Rx.map((({
                preferredName: e,
                isAwayOnVacation: s
            }) => n.Styling.createMemberName(e, t, {
                isAwayOnVacation: s,
                shouldRenderYou: !!a
            }))))
        }
        const v = n.Hocs.compose(n.Hocs.withWebLazyRender((({
            isBelowTheFold: e
        }) => ({
            forceShow: !e,
            spacerHeight: 40
        }))), n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIntl, n.Hocs.withObservables(["member", "intl", "shouldRenderYou", "showFavFollowIcon"], (({
            member: e,
            intl: t,
            shouldRenderYou: s,
            showFavFollowIcon: n
        }) => ({
            member: e,
            team: e.team,
            primaryName: y({
                member: e,
                intl: t,
                shouldRenderYou: s,
                showFavFollowIcon: n
            }),
            secondaryName: e.secondaryName,
            groupCount: e.groups.observeCount()
        }))), n.Hocs.withHooks((({
            member: e,
            team: t
        }) => ({
            linkTo: (0, a.smartPathToMember)(t, e)
        }))), n.Hocs.withObservables(["member"], (({
            services: e,
            linkTo: t
        }) => ({
            isActive: e.history.matchesPath(t)
        }))))((e => {
            const {
                member: t,
                primaryName: s,
                secondaryName: n,
                isActive: a,
                linkTo: i,
                showCounter: u,
                hasDescription: m,
                showRequestControls: p,
                showResendControls: y,
                hasHairline: v,
                onPress: w,
                services: k,
                team: x,
                showFavFollowIcon: j = !0,
                groupCount: T,
                onLongPress: S
            } = e;
            invariant(!((p || y) && u), "Cannot show details and request controls at the same time"), invariant(!(p && y), "Cannot show request and resend controls at the same time");
            const P = Boolean((m || p || y) && (!!t.alias || T)),
                _ = async () => {
                    await t.do.archive(), await k.sync.synchronize()
                }, {
                    isFavorite: C
                } = t;
            return (0, l.jsx)(c.rU, {
                to: i,
                force: !0,
                children: (0, l.jsx)(c.fC, {
                    webComponent: "div",
                    onPress: w,
                    isRequest: p || y,
                    onLongPress: S,
                    children: (0, l.jsx)(c.VY, {
                        isActive: a,
                        hasHairline: v || p || !!y,
                        hasDescription: P || p || !!y,
                        children: (0, l.jsxs)("div", {
                            className: b.columnContainer,
                            children: [(0, l.jsxs)("div", {
                                className: b.rowContainer,
                                children: [(0, l.jsx)(f, {
                                    children: (0, l.jsx)(o.default, {
                                        className: b.avatar,
                                        member: t,
                                        size: "tiny"
                                    })
                                }), (0, l.jsxs)(c.lU, {
                                    children: [(0, l.jsx)("div", {
                                        className: b.rowContainer,
                                        children: (0, l.jsx)(r.default, {
                                            className: b.name + (a ? " " + b.activeName : ""),
                                            children: s
                                        })
                                    }), P || p || y ? (0, l.jsx)(d, {
                                        member: t,
                                        secondaryName: n
                                    }) : null]
                                }), C && j ? (0, l.jsx)(c.zx, {
                                    children: (0, l.jsx)(c.JO, {
                                        name: "Á",
                                        color: "red",
                                        size: 18,
                                        isActive: a
                                    })
                                }) : null, u ? (0, l.jsx)(c.Br, {
                                    source: t.activeTasksResponsibleFor.observeCount(),
                                    isActive: a
                                }) : null]
                            }), p ? (0, l.jsx)(h, {
                                onAcceptPress: async () => {
                                    await k.payments.invokeActionOrProposeUpgrade({
                                        name: "invite-to-team",
                                        currentTeam: x,
                                        membersCount: 1
                                    }, (async () => {
                                        await t.do.acceptJoinRequest(), await k.sync.synchronize()
                                    }))
                                },
                                onDeclinePress: _
                            }) : null, y ? (0, l.jsx)(g, {
                                onResendPress: async () => {
                                    await t.do.resendInvitation(), await k.sync.synchronize()
                                },
                                onRemovePress: _
                            }) : null]
                        })
                    })
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => f
        });
        var n, a, o = s(0),
            r = s(32),
            i = s(25),
            c = s(20),
            l = s(104),
            d = s(84),
            u = s(17),
            m = s(334),
            h = s(1);
        const p = s(42).wx,
            g = o.ReactUtils.lazy((() => s(214))),
            f = o.Hocs.compose(o.Hocs.memo, o.Hocs.withObservables(["group"], (({
                group: e
            }) => ({
                group: e,
                projectsInGroup: e.activeProjects,
                canBeManaged: o.Rx.from(e.canBeManaged())
            }))))((e => {
                const {
                    target: t,
                    group: s,
                    sort: f,
                    isGroupShowingThePast: b,
                    closeMenu: y,
                    toggleGroupShowingThePast: v,
                    projectsInGroup: w,
                    canBeManaged: k,
                    onAddNewProject: x
                } = e, j = o.Hooks.useIntl(), T = o.Hooks.useServices(), {
                    currentTeam: S
                } = o.Hooks.useIdentity(), P = o.Hooks.useModalState(), _ = o.Hooks.useModalState(), [{
                    closeAnimated: C
                }, R] = (0, r.XH)(), [A, I] = o.Hooks.useStateMachine("menu"), N = async (e, t) => {
                    await s.do.rename(t)
                }, E = async e => {
                    await s.do.delete(), y(e)
                }, O = async e => {
                    const t = o.FP.arrayDifference(w, e);
                    await s.do.updateProjects(t)
                }, M = () => (0, h.jsx)(p.ProjectMultiple, {
                    bundle$close: y,
                    onClose: y,
                    onConfirm: O,
                    placement: "right",
                    level: 1,
                    target: P.target,
                    selectedProjects: w,
                    currentGroup: s,
                    hideSingleTasks: !0
                }), D = () => (0, h.jsx)(g, {
                    sort: f,
                    onChange: (e, t) => {
                        (async e => {
                            await T.modelRoot.settings.setSidebarProjectGroupSort(s.id, e, S)
                        })(t), C(e)
                    },
                    target: _.target,
                    placement: "right",
                    onClose: _.close
                });
                return (0, h.jsx)(h.Fragment, {
                    children: A.map({
                        confirmDestroy: () => (0, h.jsx)(i.default, {
                            type: "delete",
                            onConfirmPress: E,
                            onBackPress: y,
                            onClose: y,
                            children: j.f.lS
                        }),
                        rename: () => (0, h.jsx)(l.default, {
                            onClose: y,
                            onConfirm: N,
                            currentValue: s.name,
                            title: j.f.fM,
                            placeholder: j.f.lX,
                            confirmButtonLabel: j.f.fM,
                            maxLength: u.MaxLengths.group.name
                        }),
                        addObjectToGroup: M,
                        menu: () => (0, h.jsxs)(r.ZP, {
                            ref: R,
                            onClose: y,
                            target: t,
                            children: [x ? (0, h.jsx)(c.Z, {
                                label: j.g("DR", {
                                    groupName: s.name
                                }),
                                icon: "ū",
                                hasArrow: !0,
                                onPress: x
                            }) : null, (0, h.jsx)(c.Z, {
                                icon: "Ƈ",
                                label: j.f.l1,
                                modalWebTarget: P.target,
                                hasArrow: !0,
                                onPress: P.open
                            }), k ? (0, h.jsx)(c.Z, {
                                icon: "Ƥ",
                                label: j.f.fM,
                                onPress: I("rename"),
                                hasArrow: !0
                            }) : null, n || (n = (0, h.jsx)(r.ZP.Separator, {})), (0, h.jsx)(m.Z, {
                                isActive: null !== s.sidebarPosition,
                                onPress: () => {
                                    s.do.toggleOnSidebar(), C(o.ReactUtils.nullEvent())
                                }
                            }), (0, h.jsx)(c.Z, {
                                label: j.f.EZ,
                                icon: "¯",
                                hasArrow: !0,
                                modalWebTarget: _.target,
                                onPress: _.open
                            }), _.isOpen ? D() : null, a || (a = (0, h.jsx)(r.ZP.Separator, {})), (0, h.jsx)(d.Z, {
                                isShowingThePast: b,
                                onPress: o.ReactUtils.callBoth(C, v),
                                onPressExtraParam: s
                            }), k ? (0, h.jsx)(c.Z, {
                                icon: "Ʊ",
                                label: j.f.fp,
                                iconColor: "red",
                                textColor: "red",
                                hasArrow: !0,
                                onPress: I("confirmDestroy")
                            }) : null, P.isOpen ? M() : null]
                        }),
                        sort: D
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(77),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                isActive: t,
                colorActive: s,
                colorInactive: r,
                isDisabled: i,
                onPress: c
            } = e, l = n.Hooks.useIntl();
            return (0, o.jsx)(a.Z, {
                icon: "Ũ",
                label: l.f.f2,
                isActive: t,
                colorActive: s,
                colorInactive: r,
                isDisabled: i,
                onChange: c
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(93),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                name: t,
                color: s,
                avatarSource: r,
                size: i = "normal",
                dotColor: c
            } = e;
            return (0, o.jsx)(a.default, {
                name: t,
                color: s,
                source: r,
                size: i,
                dotColor: c ? n.Styling.factoryColor(c) : null,
                isTeam: !0,
                className: e.className,
                style: e.style
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(11),
            o = s(895),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                isDisabled: t,
                accentColor: s = "purple",
                onPress: i,
                children: c,
                buttonRef: l
            } = e;
            return (0, r.jsx)(a.Z, {
                className: o.Z.touchableRoot + (t ? " " + o.Z.disabled : "") + " " + (e.className || ""),
                style: Object.assign({}, {
                    "--accent-color": n.Styling.factoryColor(s)
                }, e.style),
                onPress: i,
                __forwardedRef: l,
                children: (0, r.jsx)("span", {
                    className: o.Z.touchableText,
                    children: c
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            j: () => o
        });
        s(9), s(2), s(3);
        const n = s(747);
        var a = s(1);
        const o = e => (0, a.jsx)("span", {
            className: n.emphasis,
            children: e.children
        })
    }, , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        const n = !!globalThis.electron,
            a = globalThis.navigator.userAgent,
            o = !!a.includes("Nozbe4/") && a.includes("Electron/"),
            r = (() => {
                try {
                    return globalThis.top !== globalThis.self
                } catch (e) {
                    return !0
                }
            })(),
            i = r ? o : n;
        (r ? o === n : n !== o) && globalThis.alert("Electron preload broken!");
        const c = i
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            ZP: () => We,
            Mj: () => de
        });
        var n = s(69),
            a = s(24),
            o = s(5),
            r = s(4),
            i = s(8),
            c = s(16),
            l = s(237),
            d = s(21),
            u = s(181),
            m = s(37),
            h = s(23);
        const p = e => new Set(e.split(",")),
            g = p("BD,MV"),
            f = p("AE,AF,BH,DJ,DZ,EG,IQ,IR,JO,KW,LY,MA,OM,QA,SD,SY"),
            b = p("AG,AR,AS,BR,BS,BT,BW,BY,BZ,CA,CN,CO,DM,DO,ET,GT,GU,HK,HN,ID,IE,IL,IN,JM,JP,KE,KH,KR,LA,MH,MM,MO,MT,MX,MZ,NI,NP,NZ,PA,PE,PH,PK,PR,PY,SA,SG,SV,TH,TN,TT,TW,UM,US,VE,VI,WS,YE,ZA,ZW");
        const y = () => {
            throw new Error("unimplemented")
        };
        class v {
            constructor() {
                this.haptics = {
                    prepare() {},
                    success() {},
                    warning() {},
                    error() {},
                    impact() {},
                    selection() {}
                }, this.inAppPurchases = {
                    getProductInfo: async e => globalThis.electron ? globalThis.electron.iapGetProductInfo(e) : y(),
                    purchase: async (e, t) => globalThis.electron ? globalThis.electron.iapPurchaseProduct(e, t) : y(),
                    finishTransaction: async e => globalThis.electron ? globalThis.electron.iapFinishTransaction(e) : y(),
                    getReceipts: async () => y()
                }, this.biometricAuthState = new i.BehaviorSubject(null), this.serviceWorker = {
                    async register() {
                        if (o.isElectron) return null;
                        try {
                            console.log("[SW] Registering sw");
                            return await globalThis.navigator.serviceWorker.register("/service-worker.js")
                        } catch (e) {
                            return o.logError("safe message", "[SW] Registration failed: " + e.message, "warning"), null
                        }
                    },
                    async update() {
                        var e;
                        if (null != (e = globalThis.navigator) && null != (e = e.serviceWorker) && e.controller) {
                            const e = await globalThis.navigator.serviceWorker.getRegistration();
                            if (e) return e.update()
                        }
                        return null
                    },
                    async subscribeToNotifications(e) {
                        var t;
                        if (null != (t = globalThis.navigator) && null != (t = t.serviceWorker) && t.controller) try {
                            const t = await globalThis.navigator.serviceWorker.getRegistration();
                            if (null == t || !t.pushManager) return;
                            await t.pushManager.subscribe({
                                userVisibleOnly: !0,
                                applicationServerKey: e
                            })
                        } catch (e) {
                            o.logError("safe message", "[SW] Push notification subscription failed: " + e.message, "warning")
                        }
                    },
                    async unsubscribeFromNotifications() {
                        var e;
                        if (null == (e = globalThis.navigator) || null == (e = e.serviceWorker) || !e.controller || o.isElectron) return !1;
                        const t = await globalThis.navigator.serviceWorker.getRegistration();
                        if (null == t || !t.pushManager) return !1;
                        const s = await t.pushManager.getSubscription();
                        return !(null == s || !s.unsubscribe())
                    },
                    async getNotificationEndpoint() {
                        var e;
                        const t = await (null == (e = globalThis.navigator) || null == (e = e.serviceWorker) ? void 0 : e.getRegistration());
                        if (null == t || !t.pushManager || o.isElectron) return;
                        return await t.pushManager.getSubscription()
                    }
                }
            }
            setCurrentUserActivity() {}
            removeAllUserActivities() {}
            hideSplashScreen() {
                var e;
                s(403).O(), null == (e = globalThis.electron) || e.hideSplashScreen()
            }
            fetchPreferredLocales() {
                if (globalThis.electron) return globalThis.electron.getPreferredLanguages();
                const e = globalThis.navigator.languages || [globalThis.navigator.language];
                return Promise.resolve(e)
            }
            async fetchTimeHourCycle() {
                if (globalThis.electron) {
                    const e = await this.fetchSystemRegionLocale();
                    return new Intl.Locale(e).hourCycles[0]
                }
                const e = await this.fetchPreferredLocales();
                return new globalThis.Intl.DateTimeFormat(e[0], {
                    hour: "numeric",
                    minute: "numeric"
                }).resolvedOptions().hourCycle
            }
            fetchSystemRegionLocale() {
                return globalThis.electron ? globalThis.electron.getSystemRegionLocale() : Promise.resolve((new Intl.DateTimeFormat).resolvedOptions().locale)
            }
            async fetchFirstWeekday() {
                var e;
                if (globalThis.electron) return globalThis.electron.getFirstWeekday();
                const t = (s = null == (e = globalThis.document.body) ? void 0 : e.dataset.countryHint) ? b.has(s) ? 7 : f.has(s) ? 6 : g.has(s) ? 5 : 1 : null;
                var s;
                if (t) return Promise.resolve(t);
                const [n] = await this.fetchPreferredLocales(), a = n.replace("-", "_").toLowerCase();
                return "en" === a || "en_us" === a ? 7 : 1
            }
            get availableEmailApps() {
                return Promise.resolve([])
            }
            async openEmailApp(e = "default") {
                y()
            }
            async openTwoFactorApp(e = "default") {
                y()
            }
            get isBiometricAuthActive() {
                return i.of(!1)
            }
            get hasHardwareKeyboard() {
                return Promise.resolve(void 0)
            }
            get hasBiometricAuth() {
                return Promise.resolve(!1)
            }
            async toggleBiometricAuth() {
                y()
            }
            dogfoodingUpdate() {
                return y()
            }
            downloadAttachment({
                attachmentVersion: e,
                url: t,
                requestHeaders: s
            }) {
                return y()
            }
            async pickContacts() {
                return y()
            }
            addContact() {
                y()
            }
            _getOAuthState(e) {
                const t = ((e, t) => {
                    const s = Object.assign({
                            locale: e.locale,
                            invitation_id: e.invitationId,
                            is_invite_code: e.isInviteCode,
                            disable_onboarding: e.disableOnboarding,
                            disable_onboarding_ab: e.disableOnboardingAb
                        }, t),
                        n = Object.keys(s).reduce(((e, t) => {
                            const n = s[t];
                            return n ? [...e, t + "=" + ("string" == typeof n ? n : JSON.stringify(n))] : e
                        }), []).join("&");
                    return encodeURIComponent(n)
                })(e, {
                    is_electron: !!globalThis.electron
                });
                return t
            }
            async _requestOAuth(e, t, s) {
                const {
                    api: n
                } = e, a = await n.getServerUrl(), o = s(encodeURIComponent(a + "/" + t), this._getOAuthState(e));
                return h.openUrl(o, "_self"), null
            }
            async requestSignInWithApple(e) {
                if (!o.isMAS) return this._requestOAuth(e, "apple-signin", ((e, t) => "https://appleid.apple.com/auth/authorize?client_id=com.nozbe4.web&redirect_uri=" + e + "&response_type=code id_token&scope=name%20email&response_mode=form_post&state=" + t));
                {
                    const {
                        api: t
                    } = e, s = this._getOAuthState(e);
                    try {
                        const e = await globalThis.electron.authenticationRequestSignInWithApple();
                        return t.account.verifySignInWithAppleTokens(Object.assign({}, e, {
                            state: s
                        }))
                    } catch (e) {
                        return o.logError("Native error", e), null
                    }
                }
            }
            async requestGoogleSignIn(e) {
                if (o.platform.isMacElectron) {
                    const {
                        api: t
                    } = e, s = this._getOAuthState(e), n = await t.getServerUrl(), {
                        code: a
                    } = await globalThis.electron.authenticationRequestGoogleSignIn(n, h.webAppUrl, s);
                    return t.account.verifyGoogleSignIn({
                        code: a,
                        state: s
                    })
                }
                return this._requestOAuth(e, "google-signin", ((e, t) => "https://accounts.google.com/o/oauth2/v2/auth?scope=openid%20profile%20email&response_type=code&include_granted_scopes=true&&redirect_uri=" + e + "&client_id=514521098392-odj3gq10qm9fhrird3ui0bb1dlgb0jc7.apps.googleusercontent.com&state=" + t))
            }
            async googleLogout() {
                y()
            }
            uploadAttachments({
                files: e,
                serverUrl: t,
                headers: s
            }) {
                return y()
            }
            async turboLogin({
                syncId: e,
                serverUrl: t,
                headers: s,
                searchParams: n
            }) {
                y()
            }
            async cancelNativeNetworkingOperations() {}
            async removeAllCaches() {
                const e = globalThis.caches;
                e && await Promise.all([e.delete("pwa-nozbe"), e.delete("pwa-nozbe-v3-private")])
            }
            showAcknowledgements() {
                globalThis.electron ? globalThis.electron.showAcknowledgements() : y()
            }
            get supportsNotificationSettings() {
                return globalThis.electron && h.isApple
            }
            installUpdate() {
                y()
            }
            openNotificationSettings() {
                globalThis.electron ? globalThis.electron.openNotificationSettings() : y()
            }
            syncIosWidget() {}
            get supportsBadge() {
                return globalThis.electron
            }
            updateBadgeCount(e) {
                globalThis.electron ? globalThis.electron.updateBadgeCount(e) : y()
            }
            reload() {
                globalThis.location.reload()
            }
            _experimentalReloadReactView() {
                y()
            }
            async getAdsToken() {
                return y()
            }
            async getNativeLogs() {
                return y()
            }
        }
        class w {
            constructor() {
                this.loginTime = NaN, this.didSendLaunchTime = !1, this.didSendLoginTime = !1
            }
            get _experimentalInitAt() {
                return new Date(0)
            }
            get appLaunchTime() {
                return this.bundleLaunchTime
            }
            get bundleLaunchTime() {
                const {
                    _appLaunchedAt: e,
                    _appInitAt: t
                } = this;
                return e && t ? e.getTime() - t.getTime() : NaN
            }
            get ourLaunchTime() {
                const {
                    _appLaunchedAt: e,
                    _appBootedAt: t
                } = this;
                return e && t ? e.getTime() - t.getTime() : NaN
            }
            get latestPageLoadTime() {
                const {
                    _pageLoadedAt: e,
                    _pageStartedAt: t
                } = this;
                return e && t ? e.getTime() - t.getTime() : NaN
            }
            get memoryUsed() {
                return Math.round(((null == (e = globalThis.performance) || null == (e = e.memory) ? void 0 : e.usedJSHeapSize) || NaN) / 1024 / 1024);
                var e
            }
            markPageLoaded() {
                this._appLaunchedAt || (this._appLaunchedAt = new Date, this._appLaunchedAtPerformance = o.getPreciseTime()), this._pageLoadedAt = new Date
            }
            markBooted() {
                this._appBootedAt || (this._appBootedAt = new Date)
            }
            markInit(e) {
                this._appInitAt || (this._appInitAt = e)
            }
            markPageLoadStarted() {
                this._pageStartedAt = new Date
            }
            getPerfStatHeaders() {
                const e = {};
                return e["X-Stats-MemUsed"] = "" + this.memoryUsed, this.appLaunchTime && !this.didSendLaunchTime && (e["X-Stats-LaunchTime"] = "" + this.appLaunchTime, this.didSendLaunchTime = !0), this.loginTime && !this.didSendLoginTime && (e["X-Stats-LoginTime"] = "" + this.loginTime, this.didSendLoginTime = !0), e
            }
        }
        class k {
            constructor() {
                this.isLoggedIn = new i.BehaviorSubject(!1), this.isLoggingOut = new i.BehaviorSubject(!1), this.isForcingRelogin = new i.BehaviorSubject(!1), this.hasCanceledAccount = new i.BehaviorSubject(!1), this.projectInvitationToken = new i.BehaviorSubject, this.claimPurchaseToken = new i.BehaviorSubject, this.taskInvitationToken = new i.BehaviorSubject(null), this.teamInvitation = new i.BehaviorSubject(null), this.accountMerge = new i.BehaviorSubject(null), this.isUpdateAvaliable = new i.BehaviorSubject(!1)
            }
            resetCancelAccountState() {
                invariant(this.hasCanceledAccount.getValue(), "The account was not canceled"), this.hasCanceledAccount.next(!1)
            }
            startAcceptingProjectInvitation(e) {
                this.projectInvitationToken.next(e)
            }
            startClaimPurchase(e) {
                this.claimPurchaseToken.next(e)
            }
            finishAcceptingProjectInvitation() {
                this.projectInvitationToken.next(void 0)
            }
            finishClaimPurchase() {
                this.claimPurchaseToken.next(void 0)
            }
            startAcceptingTaskInvitation(e) {
                this.taskInvitationToken.next(e)
            }
            finishAcceptingTaskInvitation() {
                this.taskInvitationToken.next(null)
            }
            startAcceptingTeamInvitation(e) {
                this.teamInvitation.next(e)
            }
            finishAcceptingTeamInvitation() {
                this.teamInvitation.next(null)
            }
            startAcceptingAccountMerge(e) {
                this.accountMerge.next(e)
            }
            finishAcceptingAccountMerge() {
                this.accountMerge.next(null)
            }
        }
        var x = s(36);
        class j {
            constructor(e) {
                this._localStorage = e, this._subscribeToSystemThemeChanges()
            }
            async isUserThemeSelected() {
                return !!await this._getUserTheme()
            }
            async isSystemThemeSelected() {
                return !await this.isUserThemeSelected()
            }
            async restoreUserTheme() {
                const e = await this._getUserTheme();
                e && x.theme.change(e), x.theme.markRenderingBegins()
            }
            async setUserTheme(e) {
                await this._localStorage.set(m.d.theme, e), x.theme.change(e)
            }
            async removeUserTheme() {
                await this._localStorage.remove(m.d.theme), this.revertUserTheme()
            }
            revertUserTheme() {
                x.theme.reset()
            }
            async _getUserTheme() {
                const e = await this._localStorage.get(m.d.theme);
                return (0, x.isValidTheme)(e) ? e : null
            }
            _subscribeToSystemThemeChanges() {
                x.theme.onSystemThemeChange((async e => {
                    await this.isSystemThemeSelected() && x.theme.change(e)
                }))
            }
        }
        class T {
            constructor({
                api: e,
                native: t
            }) {
                this._native = t, this._api = e
            }
            async register(e) {
                if (globalThis.electron) {
                    const e = await this._api.windowsNotificationFeed();
                    globalThis.electron.notificationsRegister(e)
                } else "Safari" !== await (0, h.getDeviceModel)() && globalThis.Notification && (await Notification.requestPermission(), e && await e())
            }
            async unregister() {
                globalThis.electron ? globalThis.electron.notificationsUnregister() : await this._native.serviceWorker.unsubscribeFromNotifications()
            }
            getPushToken() {
                return globalThis.electron ? globalThis.electron.notificationsGetPushToken() : this._native.serviceWorker.getNotificationEndpoint()
            }
            async areNotificationsEnabled() {
                if (globalThis.electron) return globalThis.electron.notificationsGetEnabled();
                if (!await this._arePushNotificationsSupported() || !globalThis.Notification) return "disabled";
                switch (await Notification.permission) {
                    case "default":
                        return "notDetermined";
                    case "denied":
                    default:
                        return "disabled";
                    case "granted":
                        return "enabled"
                }
            }
            async _arePushNotificationsSupported() {
                return !(await (0, h.getDeviceModel)()).toLowerCase().includes("safari") && !(!navigator.serviceWorker || !globalThis.PushManager)
            }
            isSandbox() {
                return null
            }
        }
        const S = m.d.apiToken,
            P = m.d.nozbe3Token;
        class _ {
            constructor(e) {
                this._localStorage = e
            }
            get apiToken() {
                return this._localStorage.get(S)
            }
            set apiToken(e) {
                this._localStorage.set(S, e)
            }
            get nozbe3Token() {
                return this._localStorage.get(P)
            }
            set nozbe3Token(e) {
                e ? this._localStorage.set(P, e) : this._localStorage.remove(P)
            }
            clear() {
                this._localStorage.remove(S), this._localStorage.remove(P)
            }
        }
        const C = e => o.makeDecorator(((t = 2) => (s, n) => (s._registerExperiment(n, e), {
                configurable: !0,
                enumerable: !0,
                get() {
                    return this._get(n, e, t)
                }
            }))),
            R = C("user"),
            A = C("device"),
            I = (C("session"), C("sessionDaily"), o.makeDecorator((({
                subject: e,
                cohorts: t,
                md5: s
            }) => (n, a) => (n._registerExperiment(a, e), {
                configurable: !0,
                enumerable: !0,
                get() {
                    return this._get(a, e, t, s)
                }
            }))));
        const N = s(247),
            E = "abcdefghijk";

        function O(e, t, s, n = !1) {
            if (n) {
                const n = N(e + t),
                    a = parseInt(n.slice(-8), 16) % s;
                return E[a]
            }
            const a = function(e, t = 0) {
                let s = 3735928559 ^ t,
                    n = 1103547991 ^ t;
                for (let t, a = 0; a < e.length; a++) t = e.charCodeAt(a), s = Math.imul(s ^ t, 2654435761), n = Math.imul(n ^ t, 1597334677);
                return s = Math.imul(s ^ s >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(s ^ s >>> 13, 3266489909), 4294967296 * (2097151 & n) + (s >>> 0)
            }(e + t) % s;
            return E[a]
        }
        let M = null;

        function D(e) {
            if (M) return M;
            const t = (e => {
                const t = e.getSynchronously("ab_device_id");
                if (t) return t;
                const s = o.randomId();
                return e.set("ab_device_id", s), s
            })(e);
            return M = t, t
        }
        var H, F, Z, L, B, z, U, W, G, V, q, Q, Y, J, K, $, X, ee, te, se, ne;
        const ae = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let oe = (H = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), F = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), Z = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), L = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), B = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), z = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), U = I({
            subject: "user",
            cohorts: 2,
            md5: !0
        }), W = I({
            subject: "device",
            cohorts: 2,
            md5: !0
        }), V = ae(G = class {
            triggerEntryLaunched() {
                this._enduringStorage.getSynchronously("ab_newSignup_launched") || this._enduringStorage.set("ab_newSignup_launched", "true"), this._enduringStorage.getSynchronously("ab_entry_launched") || (this.entryBaseline.trackEvery("launched"), this._enduringStorage.set("ab_entry_launched", "true"))
            }
            triggerEntryLoggedIn() {
                this._enduringStorage.getSynchronously("ab_entry_logged_in") || (this.entryBaseline.trackEvery("loggedIn"), this._enduringStorage.getSynchronously("ab_entry_tagline_rendered") && this.entryTagline.trackEvery("loggedIn"), this._enduringStorage.set("ab_entry_logged_in", "true"))
            }
            triggerEntryTaglineRendered() {
                this._enduringStorage.getSynchronously("ab_entry_logged_in") || this._enduringStorage.getSynchronously("ab_entry_tagline_rendered") || (this.entryTagline.trackEvery("rendered"), this._enduringStorage.set("ab_entry_tagline_rendered", "true"))
            }
            constructor(e, t, s) {
                this._debugOverrides = {}, (0, n.Z)(this, "askBeforeReview", V, this), (0, n.Z)(this, "netPromoterScore2", q, this), (0, n.Z)(this, "paymentsBaseline5", Q, this), (0, n.Z)(this, "responsiblePickerBaseline", Y, this), (0, n.Z)(this, "allMembersBaseline", J, this), (0, n.Z)(this, "allTagsBaseline", K, this), (0, n.Z)(this, "moneyBackGuarantee", $, this), (0, n.Z)(this, "historyLimits", X, this), (0, n.Z)(this, "ongoingPromoBaseline", ee, this), (0, n.Z)(this, "projectPresetsBaseline", te, this), (0, n.Z)(this, "entryBaseline", se, this), (0, n.Z)(this, "entryTagline", ne, this), this._userId = null, this._teamId = null, this._sessionId = o.randomId(), this._sessionSentOnce = {}, this._getApi = e, this._enduringStorage = t, this._settings = s
            }
            _get(e, t, s, n = !1) {
                const a = (() => {
                    switch (t) {
                        case "user":
                            return this._userId;
                        case "team":
                            return this._teamId;
                        case "device":
                            return this._deviceId;
                        case "session":
                            return this._sessionId;
                        case "sessionDaily":
                            return this._sessionDailyId;
                        default:
                            throw new Error("[AB] Unknown subject type")
                    }
                })();
                a || o.logError(o.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "[AB] " + t + " ID is blank, cannot assign to correct cohort for " + e + "!");
                let r = O(e, String(a), s, n);
                return {
                    a: "a" === r,
                    b: "b" === r,
                    c: "c" === r,
                    d: "d" === r,
                    e: "e" === r,
                    f: "f" === r,
                    cohort: r,
                    cohortCount: s,
                    map: e => e[r],
                    trackEvery: t => this._track(e, r, t),
                    trackOnce: async s => {
                        await this._shouldTrackOnce(t, e, s) && this._track(e, r, s)
                    }
                }
            }
            get _deviceId() {
                return D(this._enduringStorage)
            }
            get _sessionDailyId() {
                const e = new Date;
                return this._sessionId + "." + e.getFullYear() + "." + (e.getMonth() + 1) + "." + e.getDate()
            }
            set unsafeUserId(e) {
                this._userId = e
            }
            set unsafeTeamId(e) {
                this._teamId !== e && (this._teamId = e)
            }
            _registerExperiment(e, t) {
                this._allExperiments || (this._allExperiments = []), this._allExperiments.push([e, t])
            }
            _track(e, t, s) {
                setTimeout((() => {
                    this._getApi().telemetry.abEvent(e, t, s)
                }), 4e3 + 4e3 * Math.random())
            }
            async _shouldTrackOnce(e, t, s) {
                switch (e) {
                    case "session": {
                        const e = t + ":" + s;
                        return !this._sessionSentOnce[e] && (this._sessionSentOnce[e] = !0, !0)
                    }
                    case "sessionDaily": {
                        const e = this._sessionDailyId + ":" + t + ":" + s;
                        return !this._sessionSentOnce[e] && (this._sessionSentOnce[e] = !0, !0)
                    }
                    case "user":
                        return this._settings.database.write((async e => {
                            const n = this._settings.abSentOnce(t, s);
                            return !await n.fetch() && (await e.callWriter((() => n.set(!0))), !0)
                        }));
                    case "device": {
                        const e = "ab_sent_once_" + t + ":" + s;
                        return "true" !== await this._enduringStorage.get(e) && (await this._enduringStorage.set(e, "true"), !0)
                    }
                    default:
                        throw new Error("trackOnce is not implemented for " + e)
                }
            }
        }, "askBeforeReview", [R]), q = ae(G, "netPromoterScore2", [R]), Q = ae(G, "paymentsBaseline5", [H]), Y = ae(G, "responsiblePickerBaseline", [F]), J = ae(G, "allMembersBaseline", [Z]), K = ae(G, "allTagsBaseline", [L]), $ = ae(G, "moneyBackGuarantee", [B]), X = ae(G, "historyLimits", [z]), ee = ae(G, "ongoingPromoBaseline", [U]), te = ae(G, "projectPresetsBaseline", [R]), se = ae(G, "entryBaseline", [A]), ne = ae(G, "entryTagline", [W]), G);
        const re = e => e.replace("_", "-").toLowerCase(),
            ie = e => re(e).split("-")[0] || "";
        var ce = s(277),
            le = s(1453);
        const de = ["en-US", "pl", "es-ES", "de-DE", "ja", "nl", "fr", "zh-CN", "uk"].filter(Boolean);

        function ue() {
            return s(509)
        }
        const me = "span";

        function he(e, t, s) {
            const n = (0, ce.Sn)(),
                a = (0, le.d)({
                    locale: e,
                    messages: t,
                    textComponent: me
                }, n),
                o = a.formatMessage;
            a.formatMessage = (e, s = null) => {
                const n = "string" == typeof e ? e : e.id;
                return s ? o({
                    id: n
                }, s, {
                    requiresOtherClause: !1
                }) : t[n] || n
            };
            {
                invariant(s, "System's time hour cycle is required on web for creating the intl object");
                const e = a.formatTime;
                a.formatTime = (t, n) => {
                    var a;
                    return e(t, Object.assign({}, n, {
                        hourCycle: null != (a = null == n ? void 0 : n.hourCycle) ? a : s
                    }))
                };
                const t = a.formatDate;
                a.formatDate = (e, n) => {
                    var a;
                    return t(e, Object.assign({}, n, {
                        hourCycle: null != (a = null == n ? void 0 : n.hourCycle) ? a : s
                    }))
                }
            }
            return a.fmt = t, a.f = a.fmt, a.g = a.formatMessage, a.enOrPl = "en-US" === a.locale || "pl" === a.locale, a
        }
        async function pe(e, t) {
            const n = await t.fetchTimeHourCycle();
            return he(e, await async function(e) {
                return "pl" === e ? s.e(730).then(s.t.bind(s, 1484, 23)).catch(ue) : "es-ES" === e ? s.e(650).then(s.t.bind(s, 1485, 23)).catch(ue) : "de-DE" === e ? s.e(144).then(s.t.bind(s, 1486, 23)).catch(ue) : "ja" === e ? s.e(400).then(s.t.bind(s, 1487, 23)).catch(ue) : "nl" === e ? s.e(54).then(s.t.bind(s, 1488, 23)).catch(ue) : "fr" === e ? s.e(810).then(s.t.bind(s, 1489, 23)).catch(ue) : "zh-CN" === e ? s.e(105).then(s.t.bind(s, 1490, 23)).catch(ue) : "uk" === e ? s.e(654).then(s.t.bind(s, 1491, 23)).catch(ue) : ue()
            }(e), n)
        }
        var ge, fe, be, ye, ve, we, ke;
        const xe = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });

        function je(e) {
            return de.includes(e)
        }

        function Te(...e) {
            return function(e, t) {
                const s = t.map(re),
                    n = s.map(ie);
                for (const a of e) {
                    const e = s.indexOf(re(a));
                    if (-1 < e) return t[e];
                    const o = ie(a),
                        r = n.indexOf(o);
                    if (-1 < r) return t[r]
                }
                return t[0]
            }(e, de)
        }
        let Se = (ge = o.lazy, fe = o.lazy, be = o.lazy, ve = xe(ye = class {
            async fetchSystemLocale() {
                return Te(...await this.native.fetchPreferredLocales())
            }
            get defaultSettings() {
                return this._createSettings()
            }
            get currentSettings() {
                return this.settings.getValue()
            }
            constructor({
                modelRoot: e,
                native: t
            }) {
                (0, n.Z)(this, "settings", ve, this), (0, n.Z)(this, "_intl", we, this), (0, n.Z)(this, "_syncedSettings", ke, this), this.formatMessage = (...e) => this.unsafeServicesIntl.formatMessage(...e), this.modelRoot = e, this.native = t, this.settings.pipe(i.distinctUntilKeysChanged(["locale"]), i.switchMap((e => pe(e.locale, this.native)))).subscribe((e => {
                    var t;
                    this._intl.next(e), null == (t = globalThis.electron) || t.setLocale(e.locale);
                    {
                        const t = globalThis.document.documentElement;
                        t && (t.lang = e.locale)
                    }
                }))
            }
            get unsafeServicesIntl() {
                return this._intl.getValue() || he("en-US", ue(), "h12")
            }
            async enableLocaleSync() {
                this._settingsSubscription ? this.currentSettings.useSystemLocale && await this._resetSettings() : this._settingsSubscription = this._syncedSettings.subscribe((e => {
                    this.settings.next(e)
                }))
            }
            async disableLocaleSync() {
                this._settingsSubscription && (this._settingsSubscription.unsubscribe(), this._settingsSubscription = void 0), await this._resetSettings()
            }
            async changeLocale(e) {
                const t = await this._createSettings(e);
                if (!!this._settingsSubscription) {
                    const {
                        locale: e,
                        useSystemLocale: s
                    } = t;
                    await this.modelRoot.settings.updateLocale(e, s)
                } else this.settings.next(t)
            }
            async _createSettings(e, t) {
                const s = e && String(e);
                return Boolean(t) ? {
                    locale: await this.fetchSystemLocale(),
                    useSystemLocale: !0
                } : s ? {
                    locale: je(s) ? s : Te(s),
                    useSystemLocale: !1
                } : {
                    locale: await this.fetchSystemLocale(),
                    useSystemLocale: !0
                }
            }
            _resetSettings() {
                return this.defaultSettings.then((e => {
                    this.settings.next(e)
                }))
            }
        }, "settings", [ge], (function() {
            return new i.BehaviorSubject({
                locale: "en-US",
                useSystemLocale: !0
            })
        })), we = xe(ye, "_intl", [fe], (function() {
            return new i.BehaviorSubject(null)
        })), ke = xe(ye, "_syncedSettings", [be], (function() {
            return this.modelRoot.settings.observeLocaleSetting().pipe(i.switchMap((e => this._createSettings(null == e ? void 0 : e.locale, null == e ? void 0 : e.use_system_locale))))
        })), ye);
        var Pe = s(510);
        const _e = e => "enduring_" + e;

        function Ce(e) {
            return globalThis.localStorage.getItem(_e(e))
        }
        class Re {
            get(e) {
                return async function(e) {
                    return Ce(e)
                }(e)
            }
            getSynchronously(e) {
                return Ce(e)
            }
            set(e, t) {
                return async function(e, t) {
                    globalThis.localStorage.setItem(_e(e), t)
                }(e, String(t))
            }
            remove(e) {
                return async function(e) {
                    globalThis.localStorage.removeItem(_e(e))
                }(e)
            }
        }
        var Ae, Ie, Ne, Ee, Oe, Me, De, He, Fe, Ze, Le, Be, ze;
        const Ue = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let We = (Ae = o.lazy, Ie = o.lazy, Ne = o.lazy, Ee = o.lazy, Oe = o.lazy, Me = o.lazy, He = Ue(De = class {
            get db() {
                return this.database
            }
            get collections() {
                return this.db.collections
            }
            get isServiceMode() {
                return this._isServiceMode && !1
            }
            get localStorage() {
                return this.db.localStorage
            }
            async _updateBadge() {
                const e = await this.localStorage.get(m.d.notificationBadge),
                    t = this.ab._userId ? {
                        type: "incoming"
                    } : {
                        type: "off"
                    },
                    {
                        type: s,
                        teamId: n
                    } = e || t;
                if ("off" === s) return void this.native.updateBadgeCount(0);
                const a = async e => {
                    switch (s) {
                        case "incoming":
                            return i.takeFirst(e.incomingTasksCounter);
                        case "activity":
                            return i.takeFirst(e.activityTasksCounter);
                        case "priority":
                            return i.takeFirst(e.activePriorityTasksCounter);
                        default:
                            return 0
                    }
                };
                if (n) {
                    const e = await this.database.get(c.w.teams).find(n),
                        t = await a(e);
                    this.native.updateBadgeCount(t)
                } else {
                    const e = await this.modelRoot.teams.fetch(),
                        t = r.sum(await r.allPromises(a, e));
                    this.native.updateBadgeCount(t)
                }
            }
            _makeUploader() {
                return new(0, s(1259).Z)({
                    database: this.database,
                    sync: this.sync,
                    getApi: () => this.api,
                    getCurrentUser: () => i.takeFirst(this.modelRoot.currentUser)
                })
            }
            constructor(e) {
                this._isServiceMode = !1, this.enduringStorage = new Re, (0, n.Z)(this, "account", He, this), (0, n.Z)(this, "api", Fe, this), (0, n.Z)(this, "sync", Ze, this), (0, n.Z)(this, "serverLink", Le, this), (0, n.Z)(this, "uploader", Be, this), (0, n.Z)(this, "payments", ze, this), this.scenes = new Map, this._launchId = o.randomId(), this.database = e, this.modelRoot = new l.default(this.database), this.native = new v, this.localization = new Se({
                    modelRoot: this.modelRoot,
                    native: this.native
                }), this.performance = new w, this.appState = new k, this.themeSettings = new j(this.localStorage), this.keychain = new _(this.localStorage), this.notifications = new T({
                    native: this.native,
                    api: this.api
                }), this.resources = new Pe.Z(this.api), this.ab = new oe((() => this.api), this.enduringStorage, this.modelRoot.settings)
            }
            restoreUserSession(e = {}) {
                return s(1532).Z(this, e)
            }
            async logOut(e = !0) {
                try {
                    o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] Logging out..."), this.sync.setAutoSyncEnabled(!1), await this._isSyncing() && (this.appState.isLoggingOut.next(!0), await this._waitForSync(2e4))
                } catch (e) {
                    o.logError("diagnostic error", e)
                }
                await this._forceLogOut({
                    shouldPushHistory: e,
                    reason: "requested by user"
                })
            }
            async forceRelogin() {
                try {
                    this.appState.isForcingRelogin.next(!0);
                    const e = await this.keychain.apiToken;
                    invariant(e, "relogin is forced but no token"), await this._forceLogOut({
                        reason: "forced relogin"
                    }), await this.account._logInSync({
                        authenticator: async () => (this.keychain.apiToken = e, {
                            needsOTP: !1
                        }),
                        skipAppStateChange: !1
                    })
                } catch (e) {
                    o.logError("diagnostic error", e), await (0, u.Z)(this.localization.formatMessage("C9"))
                } finally {
                    this.appState.isForcingRelogin.next(!1)
                }
            }
            async experimental_replacementSync() {
                try {
                    this.appState.isForcingRelogin.next(!0), await this.sync.experimental_replacementSync()
                } finally {
                    this.appState.isForcingRelogin.next(!1)
                }
            }
            _forceLogOut(e) {
                return s(1533).Z(this, e)
            }
            async persistSystemSettings() {
                try {
                    const e = await i.takeFirst(this.modelRoot.currentUser).catch((() => null));
                    if (!e) return;
                    const {
                        settings: t
                    } = this.modelRoot, {
                        locale: s
                    } = this.localization.currentSettings;
                    await e.do.updateTimeZone((0, d.getTimeZone)());
                    const n = await this.notifications.getPushToken();
                    n && await t.addPushToken({
                        token: n,
                        locale: s,
                        isSandbox: this.notifications.isSandbox()
                    })
                } catch (e) {
                    o.logError("diagnostic error", e)
                }
            }
            async createScene(e = "child") {
                if (!o.isElectron) throw new Error("creating scenes is not supported on this platform");
                {
                    const t = await globalThis.electron.getChildAppUrl(),
                        s = (() => {
                            switch (e) {
                                case "quick_add":
                                    return "_nozbe_quickadd_window_";
                                case "child":
                                    return "_nozbe_child_window_";
                                default:
                                    throw new Error("unexpected sceneType: " + e)
                            }
                        })();
                    globalThis.open(t, "" + s + o.nextTag())
                }
            }
            get mainScene() {}
            connectScene(e, t) {
                invariant(!this.scenes.has(e), "Scene with id " + e + " already connected"), this.scenes.set(e, t)
            }
            _disconnectScene(e, t) {
                const s = this.scenes.get(e);
                this.scenes.delete(e), invariant(s === t, "Scene with id " + e + " wasn't connected or wasn't the same as scene")
            }
            async _isSyncing() {
                const {
                    hasUnsyncedChanges: e
                } = s(166), t = this.sync.isSyncing.getValue(), n = await e({
                    database: this.database
                });
                return t && n
            }
            async _waitForSync(e = 2e4) {
                const t = this.sync.isSyncing.pipe(i.takeWhile((e => e)), i.timeout(e), i.mapTo(void 0));
                return i.takeLast(t)
            }
            _addDebugLog() {}
        }, "account", [Ae], (function() {
            return (() => new(0, s(1266).Z)(this))()
        })), Fe = Ue(De, "api", [Ie], (function() {
            return (() => new(0, s(1267).Z)({
                keychain: this.keychain,
                localStorage: this.localStorage,
                native: this.native,
                getPerfStatHeaders: () => this.performance.getPerfStatHeaders(),
                launchId: this._launchId
            }))()
        })), Ze = Ue(De, "sync", [Ne], (function() {
            return (() => new(0, s(1276).Z)({
                database: this.database,
                getApi: () => this.api,
                formatMessage: e => this.localization.formatMessage(e),
                pushSyncSignal: this.serverLink.syncSignals,
                onBeforeSync: async () => {
                    const e = Number(await this.localStorage.get(m.d.diagnosticSyncCount)) || 0;
                    this.localStorage.set(m.d.diagnosticSyncCount, e + 1), await this.persistSystemSettings()
                },
                onAfterSync: async e => {
                    "new_data" === e && this.native.syncIosWidget(), this.native.supportsBadge && await this._updateBadge()
                },
                forceLogOut: e => {
                    e ? this.forceRelogin() : this._forceLogOut({
                        reason: "forced by sync"
                    })
                },
                onPaymentRequired: e => {
                    e.forEach((async e => {
                        const t = await this.db.get(c.w.teams).find(e);
                        this.payments.requirements.set(t, "sync-rejection")
                    }))
                },
                displayMessages: async e => {
                    await r.mapAsync((async e => {
                        await (0, u.Z)(e)
                    }), e)
                }
            }))()
        })), Le = Ue(De, "serverLink", [Ee], (function() {
            return (() => new(s(1277).Z)({
                getApi: () => this.api
            }))()
        })), Be = Ue(De, "uploader", [Oe], (function() {
            return this._makeUploader()
        })), ze = Ue(De, "payments", [Me], (function() {
            return (() => new(0, s(1278).Z)({
                database: this.database,
                getApi: () => this.api,
                native: this.native,
                synchronize: async () => {
                    await this.sync.synchronize()
                }
            }))()
        })), De)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(8);
        const a = s(1198).Z.pipe(n.filter((e => "active" === e)))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(159),
            a = s.n(n);

        function o() {
            const e = a().getParser(globalThis.navigator.userAgent),
                t = globalThis.electron ? globalThis.electron.isMacAppStore ? "(MAS|Electron)" : "(Electron)" : "";
            return Promise.resolve("" + t + e.getBrowserName() + " " + e.getBrowserVersion() + " (" + e.getOSName() + ")")
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            C3: () => c,
            ZP: () => u
        });
        s(9);
        var n = s(61),
            a = s(4);
        const o = (0, s(1).jsx)(n.Z, {
                id: "KN"
            }, "validation.phone.message"),
            r = /(\+|00)[-\s\./0-9]{1,5}/,
            i = /[(]{0,1}[0-9]{1,4}[)]{0,1}[-\s\./0-9]*/,
            c = new RegExp("^(?:" + r.source + ")?" + i.source + "$"),
            l = new RegExp("^" + r.source + i.source + "$"),
            d = (0, a.either)(a.isEmpty, (e => (0, a.test)(l, e))),
            u = e => ({
                error: o,
                isValid: d(e)
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(9);
        const a = {
            threshold: .1,
            root: null,
            rootMargin: "0px 0px 0px 0px"
        };

        function o(e = a, t = !1) {
            const s = Object.assign({}, a, e),
                [o, r] = (0, n.useState)(t),
                i = (0, n.useRef)(null),
                c = (0, n.useRef)(new IntersectionObserver(((e, t) => {
                    e.some((e => e.isIntersecting)) && (r(!0), t.disconnect())
                }), s));
            return (0, n.useLayoutEffect)((() => {
                const e = i.current,
                    s = c.current;
                return e && s && !t ? (s.observe(e), () => {
                    s.disconnect()
                }) : () => {}
            }), []), {
                isInViewport: o,
                targetRef: i
            }
        }
    }, (e, t, s) => {
        const n = s(423),
            a = s(212);
        e.exports = n(a, !0)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(18),
            o = s(11);
        s(2), s(3);
        const r = s(459);
        var i = s(1);
        const c = n.ReactUtils.lazy((() => s(22))),
            l = n.React.forwardRef(((e, t) => {
                const {
                    variant: s = "standard",
                    right: l,
                    left: d,
                    children: u,
                    onPress: m,
                    helpPageUrl: h,
                    isActive: p
                } = e, g = {
                    standard: {
                        maxLines: 2,
                        isTextBoldUppercase: !0
                    },
                    vibrant: {
                        centered: !0,
                        maxLines: 1,
                        isTextBoldUppercase: !1
                    }
                } [s], {
                    centered: f,
                    maxLines: b,
                    isTextBoldUppercase: y
                } = Object.assign({}, g, e), v = n.Hooks.useIntl();
                return (0, i.jsxs)(o.Z, {
                    className: r.root + " " + (e.className || ""),
                    style: e.style,
                    ref: t,
                    onPress: m,
                    isDisabled: !m && !h && !p,
                    children: [d ? (0, i.jsx)("div", {
                        className: r.sideContent,
                        children: d
                    }) : null, (0, i.jsxs)("div", {
                        className: r.mainContent,
                        children: [(0, i.jsx)(a.default, {
                            className: r.text + (f ? " " + r.centered : "") + (y ? " " + r.boldUppercase : "") + ("vibrant" === s ? " " + r.biggerText : ""),
                            maxLines: b,
                            children: u
                        }), h ? (0, i.jsx)(c, {
                            name: "Ų",
                            onPress: e => {
                                n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), n.ReactUtils.openUrl(h)
                            },
                            size: 20,
                            hitSlop: {
                                left: 8,
                                right: 8,
                                top: 8,
                                bottom: 8
                            },
                            iconSize: 18,
                            color: "onBackground3",
                            accessibilityLabel: v.f.fC
                        }) : null]
                    }), l ? (0, i.jsx)("div", {
                        className: r.sideContent + " " + r.right,
                        children: l
                    }) : null]
                })
            })),
            d = n.Hocs.compose()(l)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(505)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Nz: () => i,
            n4: () => c
        });
        var n = s(4),
            a = s(8);
        s(5);
        const o = s(16).o.projectGroups,
            r = [o.name, o.sidebarPosition];

        function i(e, t) {
            return n.sortWith([n.descend((([, e]) => null !== e.sidebarPosition)), n.ascend((([, e]) => e.sidebarPosition)), n.ascendLocale((([e]) => e._name), t.locale)], e)
        }
        const c = e => t => t.observeWithColumns(r).pipe(a.map((t => function(e, t) {
            return n.sortWith([n.descend((e => null !== e.sidebarPosition)), n.ascend(n.prop("sidebarPosition")), n.ascendLocale(n.prop("name"), t.locale)])(e)
        }(t, e))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(0),
            a = s(68),
            o = s(9),
            r = s(54);

        function i(e) {
            var t;
            return "string" == typeof e.root ? e.root : "object" == typeof e.root && "string" == typeof(null == (t = e.root) ? void 0 : t.id) ? e.root.id : ""
        }

        function c(e) {
            const {
                section: t
            } = e, s = function(e) {
                var t;
                return "string" == typeof e.item ? e.item : "object" == typeof e.item && "string" == typeof(null == (t = e.item) ? void 0 : t.id) ? e.item.id : String(e.index)
            }(e), n = i(t);
            return e.type + "-" + s + "-" + n
        }
        const l = {
            animated: !0,
            scrollMode: "if-needed",
            alignment: "center"
        };

        function d(e) {
            const t = Object.assign({}, l, e);
            return {
                behavior: t.animated ? "smooth" : "instant",
                scrollMode: t.scrollMode,
                alignment: t.alignment
            }
        }
        var u = s(1);
        const m = n.React.forwardRef(((e, t) => {
            const {
                children: s
            } = e;
            return (0, u.jsx)("div", {
                ref: t,
                children: s
            })
        }));
        const h = e => {
            var t;
            const {
                sections: s,
                renderItem: l,
                createItemConfig: h,
                estimatedItemSize: p,
                rootRecord: g,
                renderListHeader: f,
                renderListFooter: b,
                extraData: y,
                renderSectionItemsContainer: v,
                contentContainerStyle: w,
                ContentWrapperWeb: k,
                CellRendererComponent: x = m,
                getSectionFooterLength: j,
                getSectionHeaderLength: T,
                bottomBarInset: S,
                topBarInset: P,
                listHandleRef: _
            } = e, C = function(e) {
                const t = (0, r.useKeyMapper)(e);
                return o.useCallback((e => t(c(e))), [t])
            }(g), R = n.React.useRef(null), A = null != (t = e.scrollRef) ? t : R, I = n.React.useRef([]), N = n.React.useCallback((e => {
                const t = l(e, n.FP.noop, !1),
                    s = C(e);
                return (0, u.jsx)(x, {
                    ref: t => {
                        I.current[e.index] = t
                    },
                    itemConfig: e,
                    children: t
                }, s)
            }), [l, C]), E = k || n.React.Fragment, O = n.React.useMemo((() => f && g ? f(g) : null), [f, g]), M = n.React.useMemo((() => b && g ? b(g) : null), [b, g]), D = function(e) {
                const t = n.Hooks.useServices();
                return n.React.useMemo((() => {
                    const s = t.scene.webWindow.innerHeight;
                    return Math.ceil(s / e)
                }), [e, t])
            }(p), H = function(e, t, s, n, a, r) {
                return o.useMemo((() => {
                    const o = [];
                    let i = 0;
                    return e.forEach(((c, l) => {
                        if (c.root) {
                            const t = a(c),
                                r = {
                                    item: c.root,
                                    type: "SECTION_HEADER",
                                    index: o.length,
                                    position: {
                                        indexInSection: -1,
                                        isFirst: 0 === l,
                                        isLast: l === e.length - 1,
                                        isAboveTheFold: o.length < s
                                    },
                                    section: c,
                                    extraData: n,
                                    layout: {
                                        length: t,
                                        offset: i,
                                        index: o.length
                                    }
                                };
                            i += r.layout.length, o.push(r)
                        }
                        if (c.isCollapsed || c.items.forEach(((e, a) => {
                                const r = {
                                        indexInSection: a,
                                        isAboveTheFold: o.length < s,
                                        isFirst: 0 === a,
                                        isLast: a === c.items.length - 1
                                    },
                                    l = t({
                                        item: e,
                                        index: o.length,
                                        section: c,
                                        position: r,
                                        extraData: n
                                    }, i);
                                i += l.layout.length, o.push(l)
                            })), c.hasFooter && !c.isCollapsed) {
                            const t = r(c),
                                a = {
                                    item: c.root,
                                    type: "SECTION_FOOTER",
                                    index: o.length,
                                    position: {
                                        indexInSection: -1,
                                        isFirst: 0 === l,
                                        isLast: l === e.length - 1,
                                        isAboveTheFold: o.length < s
                                    },
                                    section: c,
                                    extraData: n,
                                    layout: {
                                        length: t,
                                        offset: i,
                                        index: o.length
                                    }
                                };
                            i += a.layout.length, o.push(a)
                        }
                    })), o
                }), [e, t, s, n, a, r])
            }(s, h, D, y, T, j), F = n.React.useMemo((() => {
                if (!v) return H.map((e => N(e)));
                const e = new Map;
                return H.forEach((t => {
                    var s;
                    const n = N(t),
                        a = null != (s = e.get(t.section)) ? s : {
                            items: [],
                            header: null,
                            footer: null
                        };
                    switch (t.type) {
                        case "SECTION_HEADER":
                            a.header = n;
                            break;
                        case "SECTION_FOOTER":
                            a.footer = n;
                            break;
                        default:
                            a.items.push(n)
                    }
                    e.set(t.section, a)
                })), s.map((t => {
                    var s;
                    const n = null != (s = e.get(t)) ? s : {
                        items: [],
                        header: null,
                        footer: null
                    };
                    return [n.header, v(t, n.items), n.footer]
                }))
            }), [H, N, s, v]), Z = n.React.useMemo((() => Object.assign({}, w, {
                paddingBottom: S,
                paddingTop: P
            })), [w, S, P]);
            return function({
                listHandleRef: e,
                data: t,
                itemsRef: s,
                scrollRef: a
            }) {
                n.React.useImperativeHandle(e, (() => {
                    const e = {
                        getItemConfigs: () => t,
                        scrollToIndex(e, t = {}) {
                            const a = s.current[e];
                            if (!a) return void n.Misc.PROD_CONSOLE(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR).error("Missing element when trying to scroll to index: " + e);
                            const o = d(t);
                            n.ReactUtils.scrollIntoView({
                                element: a,
                                behavior: o.behavior,
                                scrollMode: o.scrollMode,
                                alignment: o.alignment
                            })
                        },
                        scrollToSection(s, a) {
                            const o = t.find((e => e.section === s));
                            o ? e.scrollToIndex(o.index, a) : n.Misc.PROD_CONSOLE(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR).error("Missing section item when trying to scroll to section: " + i(s))
                        },
                        scrollToTop(e = {}) {
                            var t;
                            const s = d(e);
                            null == (t = a.current) || t.scrollTo({
                                top: 0,
                                behavior: s.behavior
                            })
                        }
                    };
                    return e
                }), [t, s, a])
            }({
                listHandleRef: _,
                data: H,
                itemsRef: I,
                scrollRef: A
            }), (0, u.jsx)(a.Z, {
                contentContainerStyle: Z,
                scrollRef: A,
                children: (0, u.jsxs)(E, {
                    children: [O, F, M]
                })
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            m: () => a
        });
        var n = s(0);

        function a(e, t = !1) {
            const [
                [s, a], o
            ] = n.React.useState([!1, t]);
            return {
                isFocused: s,
                hasErrors: a,
                onFocus: () => {
                    o([!0, !1])
                },
                onBlur: () => {
                    o([!1, !!e && n.FP.isNotEmpty(e)])
                }
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            p: () => n
        });
        const n = Object.freeze({
            Team: "space_team",
            Personal: "space_personal"
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            C$: () => u,
            nu: () => i,
            rt: () => l,
            wY: () => d
        });
        var n = s(0),
            a = s(870),
            o = s(331),
            r = s(357);

        function i(e, t) {
            return "dark" === t ? e.replace(/banners\//g, "banners/dark_").replace(/images\/nt-/g, "images/dark_nt-") : e
        }
        const c = /(.*)\.([^\.]*)$/;

        function l(e, t) {
            const s = c.exec(e);
            invariant(s, "Invalid image URL for banner");
            return s[1] + "-" + t + "." + s[2]
        }

        function d(e, t) {
            const {
                intl: s
            } = t;
            switch (e) {
                case "upgrade":
                case "upgrade_business":
                    return s.f.DJ;
                case "extend":
                    return s.f.fw;
                case "add_member":
                    return s.f.fz;
                case "add_project":
                case "add_space":
                    return s.f.DI;
                case "open_link":
                case "help_page":
                case "open_settings":
                case "open_news_feed":
                case "referral":
                    return s.f.f9;
                case "import_np":
                    return s.f.rA;
                default:
                    return null
            }
        }

        function u(e, t, s) {
            const {
                services: i,
                intl: c,
                currentTeam: l,
                onOpenNewMemberModal: d,
                onOpenNewProjectModal: u
            } = t;
            switch (e) {
                case "upgrade":
                case "upgrade_business":
                    i.payments.requirements.set(l, "plan-changing", {
                        shouldDisplayBusinessOffer: "upgrade_business" === e
                    });
                    break;
                case "extend":
                    i.payments.requirements.set(l, "plan-extending");
                    break;
                case "add_member":
                    d();
                    break;
                case "add_project":
                    u();
                    break;
                case "open_link":
                    invariant(s, "This action (" + e + ") requries payload"), n.ReactUtils.openUrl(s);
                    break;
                case "help_page":
                    invariant(s, "This action (" + e + ") requries payload"), n.ReactUtils.openUrl(n.ReactUtils.helpUrl(c, s));
                    break;
                case "add_space": {
                    const e = Object.values(r.p).includes(s) ? s : void 0;
                    i.uiState.addTeamModal.open(e ? {
                        initialSetup: e
                    } : void 0);
                    break
                }
                case "open_settings": {
                    const e = Object.values(a.A).includes(s) ? s : "user";
                    i.uiState.appSettingsModal.open({
                        pane: e
                    });
                    break
                }
                case "open_news_feed":
                    i.uiState.newsFeedModal.open();
                    break;
                case "import_np":
                    i.uiState.npImporterModal.open();
                    break;
                case "referral": {
                    const e = Object.values(o.i).includes(s) ? s : void 0;
                    i.uiState.referralModal.open(e ? {
                        initialPane: e
                    } : void 0);
                    break
                }
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            VY: () => f,
            Br: () => j,
            dk: () => k,
            JO: () => T,
            iJ: () => b,
            rU: () => u.Z,
            VG: () => x,
            zx: () => y,
            fC: () => p,
            lU: () => v,
            c7: () => w
        });
        var n = s(52),
            a = s(0),
            o = s(11),
            r = s(18),
            i = s(13),
            c = s(1);
        const l = a.Hocs.compose(a.Hocs.withObservables(["source"], (({
            source: e
        }) => ({
            count: "number" == typeof e ? a.Rx.of(e) : e
        }))))((e => {
            const {
                count: t,
                showZero: s
            } = e;
            return t || s ? (0, c.jsx)("span", {
                className: e.className,
                style: e.style,
                children: t
            }) : null
        }));
        s(2), s(3);
        const d = s(532);
        var u = s(82);
        const m = ["isRequest"],
            h = e => (0, c.jsx)(o.Z, {
                className: d.root + (e.hasHairline ? " " + d.withHairline : ""),
                title: e.title,
                webComponent: e.webComponent,
                onPress: e.onPress,
                onPressExtraParam: e.onPressExtraParam,
                testId: e.testId,
                __forwardedRef: e.__forwardedRef,
                onLongPress: e.onLongPress,
                disableLongPressHaptics: e.disableLongPressHaptics,
                children: e.children
            }),
            p = e => {
                const {
                    isRequest: t
                } = e, s = (0, n.Z)(e, m);
                return (0, c.jsx)("div", {
                    className: d.rootWrapper + (t ? " " + d.request : ""),
                    style: {
                        overflow: "hidden"
                    },
                    children: (0, c.jsx)(h, Object.assign({}, s))
                })
            },
            g = e => (0, c.jsx)("div", {
                className: d.content + (e.isActive ? " " + d.activeContent : "") + (e.hasHairline ? " " + d.contentWithHairline : "") + (e.hasDot ? " " + d.contentWithDot : ""),
                style: {
                    paddingBottom: e.paddingBottom,
                    paddingTop: e.paddingTop
                },
                children: e.children
            });
        const f = e => {
                const {
                    hasDescription: t,
                    hasHairline: s
                } = e, n = function({
                    hasDescription: e,
                    isDense: t,
                    hasHairline: s
                }) {
                    return e ? t ? 3 : 5 : t ? 8 : 10
                }({
                    hasDescription: t,
                    isDense: a.Hooks.useDense(),
                    hasHairline: s
                });
                return (0, c.jsx)(g, Object.assign({}, e, {
                    paddingTop: n,
                    paddingBottom: n
                }))
            },
            b = e => (0, c.jsx)("div", {
                className: d.iconContainer,
                children: e.children
            }),
            y = e => (0, c.jsx)("div", {
                className: d.iconContainer + " " + d.rightIconContainer,
                children: e.children
            }),
            v = e => (0, c.jsx)("div", {
                className: d.textContainer,
                children: e.children
            }),
            w = e => (0, c.jsx)("div", {
                className: d.titleContainer,
                children: e.children
            }),
            k = e => (0, c.jsx)(r.default, {
                className: d.description + " " + (e.className || ""),
                style: e.style,
                children: e.children
            }),
            x = e => (0, c.jsx)(r.default, {
                className: d.name + (e.isActive ? " " + d.activeName : "") + (e.isEnded ? " " + d.itemCrossed : "") + " " + (e.className || ""),
                style: e.style,
                maxLines: e.maxLines,
                children: e.children
            }),
            j = e => (0, c.jsx)(l, {
                className: d.counter + (e.isActive ? " " + d.activeCounter : "") + (e.isEnded ? " " + d.endedCounter : ""),
                source: e.source,
                children: e.children
            }),
            T = e => (0, c.jsx)(i.default, {
                className: (e.isEnded ? d.iconEnded : "") + (e.isActive ? " " + d.iconActive : ""),
                name: e.name,
                color: e.color,
                size: e.size,
                children: e.children
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(564)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(22),
            o = s(1);
        const r = e => {
            const {
                onPress: t,
                isPriority: s,
                __webFixBlurEventOrder: r,
                keyboardShortcutID: i,
                taskListRippleWorkaround: c,
                usesRNGH: l
            } = e, d = e.outlineColor || "onBackground2", u = e.fillColor || "purple", m = n.Hooks.useIntl();
            return (0, o.jsx)(a.default, {
                __webFixBlurEventOrder: r,
                name: s ? "Ƙ" : "Ɨ",
                accessibilityLabel: s ? m.f.mB : m.f.mA,
                keyboardShortcutID: i,
                iconSize: 28,
                color: s ? u : d,
                onPress: t,
                androidBorderless: !0,
                androidRippleRadius: c ? 25 : void 0,
                usesRNGH: l
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => a,
            languages: () => n.Mj
        });
        s(5);
        var n = s(346);
        class a {
            constructor(e, t) {
                this.app = e, this.scene = t
            }
            get account() {
                return this.app.account
            }
            get database() {
                return this.app.database
            }
            get db() {
                return this.app.database
            }
            get modelRoot() {
                return this.app.modelRoot
            }
            get api() {
                return this.app.api
            }
            get native() {
                return this.app.native
            }
            get keychain() {
                return this.app.keychain
            }
            get notifications() {
                return this.app.notifications
            }
            get localStorage() {
                return this.app.localStorage
            }
            get performance() {
                return this.app.performance
            }
            get appState() {
                return this.app.appState
            }
            get themeSettings() {
                return this.app.themeSettings
            }
            get collections() {
                return this.app.collections
            }
            get sync() {
                return this.app.sync
            }
            get serverLink() {
                return this.app.serverLink
            }
            get uploader() {
                return this.app.uploader
            }
            get payments() {
                return this.app.payments
            }
            get localization() {
                return this.app.localization
            }
            get resources() {
                return this.app.resources
            }
            get ab() {
                return this.app.ab
            }
            get uiState() {
                return this.scene.uiState
            }
            get router() {
                return this.scene.router
            }
            get history() {
                return this.scene.history
            }
            get navigation() {
                return this.scene.navigation
            }
            get shortcuts() {
                return this.scene.shortcuts
            }
            get nativeScene() {
                return this.scene.nativeScene
            }
            get layout() {
                return this.scene.layout
            }
            get engager() {
                return this.scene.engager
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(6),
            o = s(12);
        s(2), s(3);
        const r = s(634);
        var i, c = s(1);
        const l = "Android" === n.ReactUtils.getDeviceOS() ? "green" : "blue",
            d = [{
                iconName: "ą",
                color: l,
                opacity: .3
            }, {
                iconName: "Ć",
                color: l,
                opacity: 1
            }],
            u = n.Hocs.compose()((e => {
                const {
                    onClose: t
                } = e, s = n.Hooks.useIntl(), u = n.Hooks.useServices().history.currentPath.getValue();
                return (0, c.jsxs)(a.u_, {
                    onClose: t,
                    size: "content",
                    level: 99999,
                    children: [(0, c.jsx)(a.u_.Header, {
                        children: s.f.jF
                    }), (0, c.jsxs)(a.u_.Content, {
                        isStatic: !0,
                        children: [i || (i = (0, c.jsx)(a.u_.IconStack, {
                            fillMaxSize: !0,
                            stack: d
                        })), (0, c.jsx)(a.u_.Paragraph, {
                            emphasis: !0,
                            children: s.f.jE
                        }), (0, c.jsxs)(a.u_.Buttons, {
                            direction: "column",
                            spacing: 8,
                            children: [(0, c.jsx)(o.default, {
                                label: s.f.jC,
                                iconName: "}",
                                color: l,
                                variant: "opaque",
                                onPress: () => {
                                    switch (n.ReactUtils.getDeviceOS()) {
                                        case "iOS":
                                            n.ReactUtils.openUrl("https://apps.apple.com/pl/app/nozbe-teams/id1457232572");
                                            break;
                                        case "Android":
                                            n.ReactUtils.openUrl("market://details?id=com.nozbe4&referrer=" + encodeURIComponent(u))
                                    }
                                }
                            }), (0, c.jsx)("span", {
                                className: r.text,
                                children: s.f.jB
                            }), (0, c.jsx)(o.default, {
                                label: s.f.jA,
                                color: "purple",
                                iconName: "»",
                                variant: "opaque",
                                onPress: () => {
                                    n.ReactUtils.openUrl("nozbe4://goto" + u)
                                }
                            })]
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(0);
        const a = () => {
            const e = (() => {
                    {
                        const e = n.ReactUtils.getDeviceOS();
                        return "Android" === e || "iOS" === e
                    }
                })(),
                [t, s] = n.React.useState(e);
            return [t, s]
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = s(23).createQueryParamParser("team")
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => m
        });
        var n = s(0),
            a = s(11),
            o = s(13),
            r = s(32),
            i = s(20),
            c = s(30);
        s(2), s(3);
        const l = s(663);
        var d = s(1);
        const u = (e, t) => {
                const s = "default" === e ? t.f.kE : e;
                return n.FP.toUpper(s[0]).concat(s.slice(1))
            },
            m = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables([], (({
                services: e
            }) => ({
                availableEmailApps: n.Rx.from(e.native.availableEmailApps)
            }))))((e => {
                const {
                    email: t,
                    onSendAgain: s,
                    services: m,
                    availableEmailApps: h,
                    title: p
                } = e, g = n.Hooks.useModalState(), [{
                    closeAnimated: f
                }, b] = (0, r.XH)(), y = n.Hooks.useIntl(), [v, w, k] = function(e) {
                    const t = n.Hooks.useIntl(),
                        s = n.Hooks.useIsMounted(),
                        [a, o, r, i] = n.Hooks.useLoadingState(),
                        c = t.f.kF,
                        [l, d] = n.React.useState(c);
                    return n.React.useEffect((() => {
                        let e;
                        return (a.isSuccess || a.isError) && (e = setTimeout((() => {
                            s.current && d(c)
                        }), 3e3)), () => {
                            clearTimeout(e)
                        }
                    }), [c, s, a]), [a.isLoading, l, async () => {
                        if (!a.isLoading) {
                            o(), d(t.f.e$);
                            try {
                                await e(), s.current && (d(t.f.fX), r())
                            } catch (e) {
                                s.current && (d(t.f.f4), i())
                            }
                        }
                    }]
                }(s);
                return (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsx)("div", {
                        className: l.iconContainer,
                        children: (0, d.jsx)(o.default, {
                            name: "ń",
                            color: "orange",
                            size: 200
                        })
                    }), (0, d.jsx)("span", {
                        className: l.title,
                        children: null != p ? p : y.f.kG
                    }), (0, d.jsx)("span", {
                        className: l.description,
                        children: y.g("kC", {
                            email: (0, d.jsx)(c.fy, {
                                children: " " + t
                            }, "entry_register_verification_description")
                        })
                    }), null, g.isOpen ? (0, d.jsx)(r.ZP, {
                        ref: b,
                        onClose: g.close,
                        target: g.target,
                        boundTo: "center",
                        children: h.map((e => (0, d.jsx)(i.Z, {
                            icon: "»",
                            iconColor: "purple",
                            label: u(e, y),
                            onPress: t => {
                                m.native.openEmailApp(e), f(t)
                            }
                        }, e)))
                    }) : null, (0, d.jsxs)(a.Z, {
                        className: l.button + (v ? " " + l.buttonDisabled : ""),
                        webComponent: "div",
                        onPress: k,
                        children: [(0, d.jsx)(o.default, {
                            name: "»",
                            size: 28,
                            color: "orange"
                        }), (0, d.jsx)("span", {
                            className: l.buttonText + (v ? " " + l.buttonTextDisabled : ""),
                            children: w
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            ZP: () => m,
            eC: () => u,
            hA: () => l
        });
        var n = s(0),
            a = s(43),
            o = s(45),
            r = s(12),
            i = s(30),
            c = s(1);
        const l = [a.C1, (0, a.Ei)(6), (0, a.BS)(6)],
            d = /^https:\/\/(?:www\.)?(?:(?:(?:teams|dev4)\.nozbe\.com)|nozbe\.app)\/j\/([a-zA-Z0-9]{6})\/?$/;

        function u() {
            const [e, t] = n.React.useState(null);
            return [e, e => {
                if (e) {
                    const s = e.match(d);
                    if (s) {
                        const [, e] = s;
                        return void t(e)
                    }
                }
                t(e)
            }]
        }
        const m = n.Hocs.compose()((e => {
            const {
                inviteCode: t,
                setInviteCode: s,
                goBack: a,
                onDonePress: d,
                title: u
            } = e, m = n.Hooks.useIntl(), h = n.Hooks.useValidation({
                inviteCode: [t || "", l]
            });
            return (0, c.jsxs)(c.Fragment, {
                children: [u ? (0, c.jsx)(i.v0, {
                    style: {
                        fontWeight: "bold"
                    },
                    text: u,
                    atBottom: !1
                }) : null, (0, c.jsx)(i.v0, {
                    text: m.f.kf,
                    atBottom: !1
                }), (0, c.jsx)(o.default, {
                    onChange: s,
                    value: t || "",
                    errors: h.inviteCode.errors,
                    placeholder: m.f.kg,
                    forEntryViews: !0,
                    autoFocus: !0,
                    onSubmit: h.isValid ? d : n.FP.noop
                }), (0, c.jsx)(r.default, {
                    marginTop: "big",
                    variant: "opaque",
                    color: "purple",
                    isDisabled: !h.isValid,
                    onPress: d,
                    label: m.f.fr
                }), a ? (0, c.jsx)(r.default, {
                    marginTop: "big",
                    onPress: a,
                    label: m.f.fe
                }) : null]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(695)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            j: () => n
        });
        s(0);
        const n = 100
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(0);
        const n = [{
            iconName: "ß",
            color: "avatarColor4",
            opacity: 1,
            size: 175
        }]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            y: () => n
        });
        s(0);
        const n = [{
            iconName: "Þ",
            size: 175,
            color: "blue"
        }]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            y: () => n
        });
        s(0);
        const n = [{
            iconName: "á",
            size: 175,
            color: "brown"
        }]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            $: () => n
        });
        s(0);
        const n = [{
            iconName: "â",
            size: 175,
            color: "lightblue"
        }]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(11),
            o = s(18);
        s(2), s(3);
        const r = s(735);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                isActive: t,
                onPress: s
            } = e, c = n.Hooks.useIntl();
            return (0, i.jsx)(a.Z, {
                className: r.button + (t ? " " + r.activeButton : "") + " " + (e.className || ""),
                style: e.style,
                onPress: s,
                children: (0, i.jsx)(o.default, {
                    className: r.label + (t ? " " + r.activeLabel : ""),
                    children: c.f.fH
                })
            })
        }))
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            $4: () => c,
            O7: () => m,
            VT: () => g,
            bI: () => d,
            bO: () => a,
            fT: () => p,
            ip: () => u
        });
        let n = {};

        function a(e) {
            n = e(n)
        }
        const o = [];

        function r(e) {
            o.push(Object.assign({}, e, {
                timestamp: Date.now() / 1e3
            })), 50 < o.length && o.shift()
        }
        let i = e => e;

        function c() {
            const e = globalThis.console,
                t = Object.assign({}, e);
            ["log", "warn", "error", "info", "debug"].forEach((s => {
                t[s] = function(...t) {
                    r({
                        category: "console",
                        message: t.join(" "),
                        level: "warn" === s ? "warning" : s
                    }), e[s](...t)
                }
            })), globalThis.console = t
        }
        const l = globalThis.fetch;

        function d() {
            globalThis.fetch = (...e) => {
                const [t, s] = e, n = String(t.url || t), a = {
                    category: "fetch",
                    data: {
                        method: String(t.method || s && s.method || "GET"),
                        url: n
                    },
                    type: "http"
                };
                return l(...e).then((e => (a.data.status_code = e.status, r(a), e)), (e => {
                    throw a.level = "error", r(a), e
                }))
            }
        }

        function u() {
            globalThis.onerror = (e, t, s, n, a) => {
                m(a)
            }, globalThis.onunhandledrejection = e => {
                var t;
                m(null != (t = null == e ? void 0 : e.reason) ? t : new Error("Unknown reason"), {
                    mechanism: {
                        type: "onunhandledrejection",
                        handled: !1
                    }
                })
            }
        }

        function m(e, t = {}) {
            const a = e || {},
                r = a.name || "Unknown",
                c = a.message || String(a);
            let l = {};
            try {
                l = s(1048).Z(a)
            } catch (e) {
                l = {
                    debugStack: a.stack || "no stack",
                    frames: []
                }
            }! function(e) {
                const t = Object.assign({
                    exception: e,
                    event_id: "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, (e => {
                        var t = 0 | 16 * Math.random();
                        return ("x" == e ? t : 8 | 3 & t).toString(16)
                    })),
                    platform: "javascript",
                    sdk: {
                        name: "microsentry",
                        version: "0.0.1"
                    },
                    breadcrumbs: o,
                    request: {
                        url: globalThis.location.href,
                        headers: {
                            "User-Agent": globalThis.navigator.userAgent
                        }
                    }
                }, n);
                h(i(t))
            }({
                values: [Object.assign({
                    type: r,
                    value: c,
                    stacktrace: l
                }, t)]
            })
        }
        let h = () => {
            throw new Error("microsentry transport not set up")
        };

        function p(e) {
            h = e
        }

        function g(e, t, s) {
            return function(n) {
                l("https://" + e + "/api/" + t + "/store/?sentry_key=" + s + "&sentry_version=7", {
                    method: "POST",
                    body: JSON.stringify(n),
                    keepalive: !0
                }).then((e => {
                    if (!e.ok) throw e
                })).catch((() => {
                    setTimeout((() => {
                        h(n)
                    }), 6e4)
                }))
            }
        }
    }, , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            O: () => b,
            I: () => f
        });
        var n = s(9),
            a = s(404),
            o = s(5),
            r = s(0),
            i = s(37);
        s(2), s(3);
        const c = s(508);
        var l = s(1);
        const d = new i.a,
            u = ({
                rootRef: e
            }) => {
                const t = d.get(i.d.lastRoute) || "",
                    s = !!d.get(i.d.sidebarCollapsed),
                    [n, a] = t.includes("/priority") ? [r.Styling.vars.color.priority, r.Styling.vars.color.priority] : t.includes("/incoming") ? [r.Styling.vars.color.incoming, "transparent"] : t.includes("/activity") ? [r.Styling.vars.color.activity, "transparent"] : t.includes("/single_tasks") ? [r.Styling.vars.color.singleTasks, r.Styling.vars.color.singleTasks] : t.includes("/calendar") || t.includes("/search") ? ["#FFFFFF", "transparent"] : ["transparent", r.Styling.vars.color.onBackground2],
                    o = r.Styling.theme.current(),
                    u = "light" === o,
                    m = (e, t) => (0, l.jsx)("div", {
                        className: c.sidebarItem,
                        style: {
                            opacity: t
                        },
                        children: (0, l.jsx)("div", {
                            className: c.placeholderText,
                            style: {
                                width: e
                            }
                        })
                    }),
                    h = e => (0, l.jsxs)("div", {
                        className: c.teamSwitchItem,
                        style: {
                            opacity: e
                        },
                        children: [(0, l.jsx)("div", {
                            className: c.teamSwitchAvatar
                        }), (0, l.jsx)("div", {
                            className: c.placeholderText
                        })]
                    });
                return (0, l.jsxs)("div", {
                    className: c.root,
                    ref: e,
                    "data-theme": o,
                    children: [s ? null : (0, l.jsxs)(l.Fragment, {
                        children: [(0, l.jsxs)("div", {
                            className: c.teamSwitch,
                            children: [h(.95), h(.68), h(.38), h(.06)]
                        }), (0, l.jsxs)("div", {
                            className: c.sidebar,
                            children: [(0, l.jsxs)("div", {
                                className: c.nav + " " + c.sidebarNav,
                                children: [(0, l.jsx)("div", {
                                    className: c.placeholderText
                                }), (0, l.jsx)("div", {
                                    className: c.spacer
                                }), (0, l.jsx)("div", {
                                    className: c.navButton
                                }), (0, l.jsx)("div", {
                                    className: c.navButton
                                })]
                            }), (0, l.jsxs)("div", {
                                className: c.boxRow,
                                children: [(0, l.jsx)("div", {
                                    className: c.piastBox + " " + c.priorityBox,
                                    children: (0, l.jsx)("div", {
                                        className: c.placeholderText
                                    })
                                }), (0, l.jsx)("div", {
                                    className: c.piastBox + " " + c.incomingBox,
                                    children: (0, l.jsx)("div", {
                                        className: c.placeholderText
                                    })
                                })]
                            }), (0, l.jsxs)("div", {
                                className: c.boxRow,
                                children: [(0, l.jsx)("div", {
                                    className: c.piastBox + " " + c.activityBox,
                                    children: (0, l.jsx)("div", {
                                        className: c.placeholderText
                                    })
                                }), (0, l.jsx)("div", {
                                    className: c.piastBox + " " + c.singleTasksBox,
                                    children: (0, l.jsx)("div", {
                                        className: c.placeholderText
                                    })
                                })]
                            }), (0, l.jsxs)("div", {
                                className: c.sidebarItems,
                                children: [null, m(70, 1), (0, l.jsx)("div", {
                                    className: c.sidebarHeader,
                                    children: (0, l.jsx)("div", {
                                        className: c.placeholderText
                                    })
                                }), m(100, .95), m(150, .84), m(130, .68), m(95, .52), m(160, .38), m(70, .22), m(150, .06)]
                            })]
                        })]
                    }), (0, l.jsxs)("div", {
                        className: c.masterColumn,
                        style: s ? {
                            marginLeft: 0
                        } : void 0,
                        children: [(0, l.jsx)("div", {
                            className: c.nav + " " + c.masterNav,
                            style: {
                                backgroundColor: u ? n : r.Styling.vars.color.backgroundPrimary
                            },
                            children: (0, l.jsx)("div", {
                                className: c.placeholderText,
                                style: {
                                    backgroundColor: !u || "#FFFFFF" !== n && "transparent" !== n ? "white" : "black"
                                }
                            })
                        }), (0, l.jsx)("div", {
                            className: c.masterPlus,
                            style: {
                                backgroundColor: a,
                                boxShadow: "0 2px 12px " + a
                            }
                        })]
                    })]
                })
            };
        var m;
        const h = globalThis.document.getElementById("launchscreen"),
            p = n.createRef();
        let g;

        function f() {
            invariant(h, "#launchscreen not found");
            const e = (0, a.s)(h);
            e.render(m || (m = (0, l.jsx)(u, {
                rootRef: p
            }))), g = e, setTimeout((() => {
                p.current && ((0, o.logError)("safe literal", "Launch screen timed out - hiding", "warning"), b())
            }), 4e3)
        }

        function b() {
            const {
                current: e
            } = p;
            e && (e.style.opacity = "0", p.current = null, setTimeout((() => {
                var e;
                null == (e = g) || e.unmount()
            }), 250))
        }
    }, , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(8);
        class a {
            get state() {
                return this._state.getValue()
            }
            constructor(e) {
                this._state = new n.BehaviorSubject(null != e ? e : {
                    isOpen: !1
                })
            }
            open(e) {
                this._state.next({
                    isOpen: !0,
                    context: e
                })
            }
            close() {
                this._state.next({
                    isOpen: !1
                })
            }
            observe() {
                return this._state.pipe(n.distinctUntilChanged(((e, t) => e.isOpen && t.isOpen ? e.context === t.context : e.isOpen === t.isOpen)))
            }
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = s(9).createContext(void 0)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            LJ: () => r,
            VY: () => a,
            Y2: () => i,
            ZX: () => o,
            hU: () => l,
            v9: () => c
        });
        var n = s(9);
        const a = n.createContext(void 0),
            o = n.createContext(void 0),
            r = n.createContext(void 0),
            i = n.createContext(void 0),
            c = n.createContext(void 0),
            l = n.createContext(void 0)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            z: () => r
        });
        var n = s(23),
            a = s(5),
            o = s(21);
        const r = async ({
            currentTeam: e,
            ownerId: t,
            user: s,
            membersCount: r,
            npsRating: i
        }, c) => "\n\n______________________________________\nSent from " + c + "\nTeam ID: " + e.id + "\n" + (t ? "Owner ID: " + t + "\n" : "") + "User ID: " + s.id + "\nApp version: " + a.appVersion + "\nDevice: " + await n.getDeviceName() + "\nTime zone: " + ((0, o.getTimeZone)() || "unknown") + "\n" + (i ? "NPS: " + i + "\n" : "") + "Plan: " + ["\n  Paid: " + (e.isFree ? "no" : "yes"), "Type: " + e.planInfo.type, "Seats taken: " + r + "/" + e.limits.teamMembers, e.isFree ? null : "Currency: " + e.planInfo.currency, e.planInfo.provider ? "Provider: " + e.planInfo.provider : null, e.isFree ? null : "Expires at: " + e.expiresAt.toString()].filter(Boolean).join(",\n  ") + "\n______________________________________\n\n"
    }, e => {
        e.exports = {
            basic: "'(Rikp¯°±ĴķşšūƅƉƏƐƑƒƖƘƝơƣƦƨƩƪƾǀ"
        }
    }, e => {
        e.exports = {
            "2FaIcon": "!",
            "2FaPassword": '"',
            "2FaSms": "#",
            aa: "$",
            abandon: "%",
            accessibility: "&",
            activity: "'",
            activityDone: "(",
            activityTick: ")",
            addPeople: "*",
            addReminder: "+",
            addSpaces: ",",
            aliasNew: "-",
            appIconNew: ".",
            apple: "/",
            appleTag: "0",
            archive: "1",
            arrowCircleDown: "2",
            arrowDown: "3",
            arrowDownNtNew: "4",
            arrowFatLeft: "5",
            arrowFatRight: "6",
            arrowLeft: "7",
            arrowMarkRight: "8",
            arrowRight: "9",
            arrowUp: ":",
            arrowUpNtNew: ";",
            asana: "<",
            attachment: "=",
            attachmentCode: ">",
            attachmentDoc: "?",
            attachmentExcel: "@",
            attachmentMusic: "A",
            attachmentRar: "B",
            attachmentVideo: "C",
            autoStar: "D",
            avatar: "E",
            baby: "F",
            backAndroid: "G",
            badgeNew: "H",
            battery: "I",
            bigArrowLeft: "J",
            bigArrowRight: "K",
            blob: "L",
            bold: "M",
            book: "N",
            bulb: "O",
            bulletList: "P",
            buy: "Q",
            calendar: "R",
            calendarBadge: "S",
            camera: "T",
            car: "U",
            cards: "V",
            cart: "W",
            checkboxEmpty: "X",
            checkboxFull: "Y",
            checkboxIndeterminate: "Z",
            checklist: "[",
            checklistAdd: "\\",
            checklistDone: "]",
            checklistEmpty: "^",
            circleOld: "_",
            clipboard: "`",
            clone: "a",
            closeNew: "b",
            closeTaskDetailsWeb: "c",
            clothes: "d",
            code: "e",
            coffee: "f",
            color: "g",
            colorDrop: "h",
            colorSelect: "i",
            commentMultiple: "j",
            commentNew: "k",
            computer: "l",
            contactsPlusNew: "m",
            convertToProject: "n",
            copyComment: "o",
            createButton: "p",
            createSection: "q",
            crown: "r",
            dateOverdue: "s",
            dateOverdueBadge: "t",
            dateRecurringBadge: "u",
            dateRecurringNew: "v",
            delegateOn: "w",
            delivery: "x",
            devPlaceholder: "y",
            dollar: "z",
            doneTaskDetailsNew: "{",
            down: "|",
            download: "}",
            dragNew: "~",
            dragNtNew: "¡",
            dropbox: "¢",
            editSections: "£",
            electricity: "¤",
            email: "¥",
            emailToNozbe: "¦",
            endProject: "§",
            errands: "¨",
            evernote: "©",
            everyday: "ª",
            everymonth: "«",
            everyweek: "¬",
            everyyear: "®",
            filter: "¯",
            folder: "°",
            follow: "±",
            followEmpty: "²",
            food: "³",
            forklift: "´",
            fullscreen: "µ",
            gamepad: "¶",
            gift: "·",
            globe: "¸",
            google: "¹",
            googleDrive: "º",
            goToProject: "»",
            grantManager: "¼",
            groups: "½",
            hammer: "¾",
            hardware: "¿",
            hashtagNt: "À",
            heart: "Á",
            heartEmpty: "Â",
            helpNew: "Ã",
            home: "Ä",
            hourglass: "Å",
            illustrations_2FaHappy1: "Æ",
            illustrations_2FaHappy2: "Ç",
            illustrations_2FaHappy3: "È",
            illustrations_2FaMethod1: "É",
            illustrations_2FaMethod2: "Ê",
            illustrations_2FaMethod3: "Ë",
            illustrations_2FaMethod4: "Ì",
            illustrations_calendarFeed1: "Í",
            illustrations_calendarFeed2: "Î",
            illustrations_clone1: "Ï",
            illustrations_clone2: "Ð",
            illustrations_code1: "Ñ",
            illustrations_code2: "Ò",
            illustrations_emailToNozbe1: "Ó",
            illustrations_emailToNozbe2: "Ô",
            illustrations_emptyViewAirplane1: "Õ",
            illustrations_emptyViewAirplane2: "Ö",
            illustrations_emptyViewAirplane3: "×",
            illustrations_emptyViewBaloon1: "Ø",
            illustrations_emptyViewBaloon2: "Ù",
            illustrations_emptyViewBaloon3: "Ú",
            illustrations_emptyViewBoat1: "Û",
            illustrations_emptyViewBoat2: "Ü",
            illustrations_emptyViewBoat3: "Ý",
            illustrations_integrationDropbox: "Þ",
            illustrations_integrationEvernote: "ß",
            illustrations_integrationGCal: "à",
            illustrations_integrationGoogleDrive: "á",
            illustrations_integrationOneDrive: "â",
            illustrations_integrationOutlook: "ã",
            illustrations_integrationSlack: "ä",
            illustrations_integrationZapier: "å",
            illustrations_inviteByMail1: "æ",
            illustrations_inviteByMail2: "ç",
            illustrations_joinTeam1: "è",
            illustrations_joinTeam2: "é",
            illustrations_jointProject1: "ê",
            illustrations_jointProject2: "ë",
            illustrations_jointProject3: "ì",
            illustrations_jointProjectInvitation1: "í",
            illustrations_jointProjectInvitation2: "î",
            illustrations_jointProjectInvitation3: "ï",
            illustrations_jointProjectInvitation4: "ð",
            illustrations_key1: "ñ",
            illustrations_key2: "ò",
            illustrations_leaveTeam1: "ó",
            illustrations_leaveTeam2: "ô",
            illustrations_megaphone1: "õ",
            illustrations_megaphone2: "ö",
            illustrations_megaphone3: "÷",
            illustrations_messages1: "ø",
            illustrations_messages2: "ù",
            illustrations_messages3: "ú",
            illustrations_messages4: "û",
            illustrations_newProjectCreated1: "ü",
            illustrations_newProjectCreated2: "ý",
            illustrations_noteComment: "þ",
            illustrations_nozbe1Up: "ÿ",
            illustrations_nozbePassword1: "Ā",
            illustrations_nozbePassword2: "ā",
            illustrations_openProject1: "Ă",
            illustrations_openProject2: "ă",
            illustrations_openProject3: "Ą",
            illustrations_phoneNumber1: "ą",
            illustrations_phoneNumber2: "Ć",
            illustrations_pointyHand: "ć",
            illustrations_portalTeam1: "Ĉ",
            illustrations_portalTeam2: "ĉ",
            illustrations_portalTeam3: "Ċ",
            illustrations_pwa1: "ċ",
            illustrations_pwa2: "Č",
            illustrations_pwa3: "č",
            illustrations_referralBanners1: "Ď",
            illustrations_referralBanners2: "ď",
            illustrations_referralProgramBackground: "Đ",
            illustrations_referralProgramLink: "đ",
            illustrations_referralProgramSmile: "Ē",
            illustrations_referralTestimonial1: "ē",
            illustrations_referralTestimonial2: "Ĕ",
            illustrations_referrer1: "ĕ",
            illustrations_referrer2: "Ė",
            illustrations_removeTeam1: "ė",
            illustrations_removeTeam2: "Ę",
            illustrations_rooster1: "ę",
            illustrations_rooster2: "Ě",
            illustrations_rooster3: "ě",
            illustrations_slack: "Ĝ",
            illustrations_tada1: "ĝ",
            illustrations_tada2: "Ğ",
            illustrations_teamColor1: "ğ",
            illustrations_teamColor2: "Ġ",
            illustrations_teamColor3: "ġ",
            illustrations_trial1: "Ģ",
            illustrations_trial2: "ģ",
            illustrations_ufo1: "Ĥ",
            illustrations_ufo2: "ĥ",
            illustrations_ufo3: "Ħ",
            illustrations_vacation1: "ħ",
            illustrations_vacation2: "Ĩ",
            illustrations_vacation3: "ĩ",
            illustrations_waitForTeamOwner1Native: "Ī",
            illustrations_waitForTeamOwner1Web: "ī",
            illustrations_waitForTeamOwner2Native: "Ĭ",
            illustrations_waitForTeamOwner2Web: "ĭ",
            illustrations_wallet1: "Į",
            illustrations_wallet2: "į",
            illustrations_wallet3: "İ",
            illustrations_zapier: "ı",
            imageTag: "Ĳ",
            importGeneric: "ĳ",
            incoming: "Ĵ",
            integrations: "ĵ",
            inviteByCode: "Ķ",
            inviteOnlyProject: "ķ",
            italic: "ĸ",
            jointProjectIcon: "Ĺ",
            labeldownNew: "ĺ",
            laugh1: "Ļ",
            laugh2: "ļ",
            layers: "Ľ",
            link: "ľ",
            linkShare: "Ŀ",
            lock: "ŀ",
            lockOpen: "Ł",
            login: "ł",
            logout: "Ń",
            mailConfirm: "ń",
            manage: "Ņ",
            mapMarker: "ņ",
            max: "Ň",
            measure: "ň",
            mention: "ŉ",
            mic: "Ŋ",
            min: "ŋ",
            monday: "Ō",
            movie: "ō",
            music: "Ŏ",
            newMarker: "ŏ",
            newsInApp: "Ő",
            newTeam: "ő",
            no: "Œ",
            noColor: "œ",
            nok: "Ŕ",
            note: "ŕ",
            notifications: "Ŗ",
            notion: "ŗ",
            nozbeOld: "Ř",
            nozbeTeamsFullLogo: "ř",
            npLogoIntoN: "Ś",
            numberedList: "ś",
            ok: "Ŝ",
            oneDrive: "ŝ",
            openNew: "Ş",
            openProject: "ş",
            outlook: "Š",
            overdueOld: "š",
            palette: "Ţ",
            passwordNew: "ţ",
            past: "Ť",
            paymentHistory: "ť",
            pet: "Ŧ",
            phone: "ŧ",
            pin: "Ũ",
            plane: "ũ",
            play: "Ū",
            plus: "ū",
            projectCircleBack: "Ŭ",
            projectDone: "ŭ",
            projectNew: "Ů",
            projectOld: "ů",
            projectRestored: "Ű",
            promo: "ű",
            purpose: "Ų",
            purposeNew: "ų",
            puzzle: "Ŵ",
            qrCode: "ŵ",
            radioEmpty: "Ŷ",
            radioFull: "ŷ",
            reactionFaceBackground: "Ÿ",
            refer: "Ź",
            reminder: "ź",
            reminderBadge: "Ż",
            repeatNew: "ż",
            restart: "Ž",
            restore: "ž",
            review: "ſ",
            revokeManager: "ƀ",
            rocket: "Ɓ",
            sad1: "Ƃ",
            sad2: "ƃ",
            saw: "Ƅ",
            searchNew: "ƅ",
            section: "Ɔ",
            selectTasks: "Ƈ",
            send: "ƈ",
            settingsNew: "Ɖ",
            share: "Ɗ",
            shareAndroid: "Ƌ",
            sharedProjectOld: "ƌ",
            shield: "ƍ",
            shieldX: "Ǝ",
            sidebar: "Ə",
            sidebarBorder: "Ɛ",
            sidebarFill: "Ƒ",
            singleTasks: "ƒ",
            smallChevron: "Ɠ",
            smallPointDown: "Ɣ",
            spaces: "ƕ",
            spacesNew: "Ɩ",
            starEmpty: "Ɨ",
            starFill: "Ƙ",
            statistics: "ƙ",
            student: "ƚ",
            switchSpaces: "ƛ",
            syncNew: "Ɯ",
            tag: "Ɲ",
            taskDoneEmpty: "ƞ",
            taskDoneFull: "Ɵ",
            taskLink: "Ơ",
            team: "ơ",
            template: "Ƣ",
            templatesGroup: "ƣ",
            textEdit: "Ƥ",
            themes: "ƥ",
            threeDots: "Ʀ",
            threeDotsAndroid: "Ƨ",
            tickCircleEmpty: "ƨ",
            tickCircleFull: "Ʃ",
            tickNoCircle: "ƪ",
            tickPlus: "ƫ",
            timeNeeded: "Ƭ",
            timeNew: "ƭ",
            timer: "Ʈ",
            timeSpent: "Ư",
            todoist: "ư",
            trashOld: "Ʊ",
            trello: "Ʋ",
            underline: "Ƴ",
            unread: "ƴ",
            up: "Ƶ",
            user: "ƶ",
            userMinus: "Ʒ",
            userPlus: "Ƹ",
            vacation: "ƹ",
            vimeo: "ƺ",
            volume: "ƻ",
            wrench: "Ƽ",
            write: "ƽ",
            xCircleFull: "ƾ",
            xDeactivate: "ƿ",
            xNoCircle: "ǀ",
            youtube: "ǁ"
        }
    }, e => {
        e.exports = {
            activity: "M31.802 36.05a1.03 1.03 0 0 1-1.106.11L7.446 24.313a1.029 1.029 0 0 1 .077-1.868l6.37-2.608 3.572-7.009a9.334 9.334 0 1 1 16.633 8.476l-3.57 7.008L32.161 35a1.03 1.03 0 0 1-.36 1.05zm-15.258-.853a3.297 3.297 0 0 0 4.435-1.441l-5.876-2.994a3.297 3.297 0 0 0 1.441 4.435",
            activityDone: "M13.33 28.19a2.69 2.69 0 0 0-2.69 2.69c0 1.48 1.21 2.69 2.69 2.69a2.69 2.69 0 0 0 0-5.38m7.12-4.56c-2.15-2.12-5.03-3.22-7.9-3.01a2.216 2.216 0 0 0-2.05 2.37 2.223 2.223 0 0 0 2.37 2.05c1.6-.11 3.23.52 4.47 1.74 1.26 1.24 1.93 2.88 1.83 4.5v.13c0 1.22.99 2.21 2.22 2.21 1.17 0 2.14-.91 2.21-2.09.16-2.89-.98-5.77-3.15-7.9m10.04 1.29a9.05 9.05 0 0 1-4.64.39c.86 1.83 1.32 3.8 1.31 5.76v.34a2.211 2.211 0 0 0 3.78 1.52c.39-.39.64-.93.65-1.52v-.33c0-2.09-.38-4.17-1.1-6.16M13.26 12.38h-.55c-1.22 0-2.22.99-2.22 2.21 0 1.23 1 2.22 2.22 2.22h.52c1.86-.02 3.69.4 5.41 1.2-.08-.49-.12-.98-.12-1.49 0-1.1.2-2.14.56-3.11-1.87-.68-3.83-1.03-5.82-1.03m14.181-2.278a6.421 6.421 0 1 0 0 12.842 6.421 6.421 0 0 0 0-12.842m3.247 5.148-4.067 3.99a.71.71 0 0 1-.499.205h-.008a.72.72 0 0 1-.502-.214l-1.69-1.73a.713.713 0 0 1 1.02-.997l1.19 1.218 3.557-3.491a.713.713 0 0 1 .999 1.019",
            calendar: "M28.364 23.57a1.492 1.492 0 1 1 1.493-1.491 1.493 1.493 0 0 1-1.493 1.491M28.29 7.861H15.71a7.857 7.857 0 0 0-7.85 7.85v12.58a7.857 7.857 0 0 0 7.85 7.85h12.58a7.857 7.857 0 0 0 7.85-7.85v-12.58a7.857 7.857 0 0 0-7.85-7.85m5.97 20.43a5.98 5.98 0 0 1-5.97 5.97H15.71a5.98 5.98 0 0 1-5.97-5.97v-9.43a2.364 2.364 0 0 1 2.36-2.36h19.8a2.356 2.356 0 0 1 2.36 2.36zm-12.182 1.565a1.492 1.492 0 1 1 1.493-1.491 1.494 1.494 0 0 1-1.493 1.491m0-6.286a1.492 1.492 0 1 1 1.493-1.491 1.494 1.494 0 0 1-1.493 1.491m6.286 6.286a1.492 1.492 0 1 1 1.493-1.491 1.493 1.493 0 0 1-1.493 1.491m-12.571 0a1.492 1.492 0 1 1 1.493-1.491 1.494 1.494 0 0 1-1.493 1.491m0-6.286a1.492 1.492 0 1 1 1.493-1.491 1.494 1.494 0 0 1-1.493 1.491",
            colorSelect: "M22 0A22 22 0 1 1 6.444 6.444 21.93 21.93 0 0 1 22 0",
            commentNew: "M21.03 37.04c-8.295-.01-15.01-6.742-15-15.037.011-8.295 6.744-15.01 15.039-15s15.01 6.743 14.999 15.038a15 15 0 0 1-.58 4.111l2.327 4.135a1.514 1.514 0 0 1-1.31 2.256H31.77a14.93 14.93 0 0 1-10.74 4.498m7.519-17.294a2.255 2.255 0 1 0 .003 4.51 2.255 2.255 0 0 0-.003-4.51m-7.52 0a2.256 2.256 0 1 0 0 4.511 2.256 2.256 0 0 0 0-4.511m-7.518 0a2.256 2.256 0 1 0 0 4.511 2.256 2.256 0 0 0 0-4.511",
            createButton: "M34.19 18.725h-7.484a1.66 1.66 0 0 1-1.661-1.661V9.81a3.047 3.047 0 0 0-6.095 0v7.254c0 .917-.743 1.66-1.66 1.66l-7.48.001a3.048 3.048 0 0 0 0 6.095h7.48a1.66 1.66 0 0 1 1.66 1.66v7.71a3.048 3.048 0 0 0 6.095 0v-7.71a1.66 1.66 0 0 1 1.661-1.66h7.483a3.048 3.048 0 0 0 0-6.095",
            filter: "m30.18 31.7-4.7-3.8c1.4-2.1 2.2-4.5 2.2-7.2 0-7.2-5.8-13-13-13s-13 5.8-13 13 5.8 13 13 13c2.7 0 5.1-.8 7.2-2.2l3.8 4.7c.4.5 1 .8 1.7.9h.1c.6 0 1.2-.2 1.7-.7l1.1-1.1c.5-.5.7-1.1.7-1.8 0-.8-.3-1.4-.8-1.8m-23.7-11c0-4.6 3.7-8.3 8.3-8.3s8.3 3.7 8.3 8.3-3.7 8.3-8.3 8.3c-4.6-.1-8.3-3.8-8.3-8.3m33.34-8h-9a2.5 2.5 0 0 1 0-5h9a2.5 2.5 0 1 1 0 5m0 7.5a2.5 2.5 0 0 0-2.5-2.5h-4a2.5 2.5 0 0 0 0 5h4a2.5 2.5 0 0 0 2.5-2.5",
            folder: "M39.03 17.954v13.822a4.344 4.344 0 0 1-4.344 4.344H9.314a4.344 4.344 0 0 1-4.344-4.344V12.224A4.344 4.344 0 0 1 9.314 7.88H19.37l5.06 5.73h10.256c2.4 0 4.344 1.945 4.344 4.344",
            follow: "M22.471 36.08a2.937 2.937 0 0 1-2.934-3.106c.124-2.146-.761-4.317-2.427-5.958-1.649-1.624-3.81-2.464-5.923-2.311-1.62.102-3.025-1.097-3.143-2.715a2.937 2.937 0 0 1 2.715-3.143c3.8-.278 7.619 1.173 10.472 3.984 2.871 2.827 4.391 6.647 4.17 10.48a2.937 2.937 0 0 1-2.93 2.769M11.8 28.875a3.565 3.565 0 1 0 0 7.13 3.565 3.565 0 0 0 0-7.13m24.193 4.268v-.44c.02-6.377-2.7-12.77-7.462-17.538C23.863 10.492 17.886 7.92 11.7 7.92h-.728a2.937 2.937 0 1 0 0 5.874h.692c4.635-.033 9.144 1.953 12.71 5.522 3.665 3.67 5.758 8.543 5.744 13.379v.448a2.937 2.937 0 0 0 5.873 0z",
            incoming: "M15.71 36.14a7.857 7.857 0 0 1-7.85-7.85V15.71a7.857 7.857 0 0 1 7.85-7.85h12.58a7.857 7.857 0 0 1 7.85 7.85v12.58a7.857 7.857 0 0 1-7.85 7.85zM9.74 15.71v9.439a2.356 2.356 0 0 0 2.36 2.35h4.47a4.7 4.7 0 0 0 4.644 3.93H22.8a4.7 4.7 0 0 0 4.643-3.93h4.47a2.364 2.364 0 0 0 2.36-2.36v-9.43A5.98 5.98 0 0 0 28.29 9.74H15.71a5.98 5.98 0 0 0-5.97 5.97m11.309 9.557-4.099-4.096A1.449 1.449 0 0 1 19 19.122l1.606 1.606v-7.074a1.449 1.449 0 0 1 2.897 0v7.11l1.641-1.64a1.449 1.449 0 1 1 2.085 2.01l-.036.037-4.097 4.096a1.45 1.45 0 0 1-2.048 0z",
            inviteOnlyProject: "M21.998 36.23a14.234 14.234 0 1 1 14.238-14.232A14.234 14.234 0 0 1 21.998 36.23m0-18.976a4.744 4.744 0 1 0 4.746 4.743 4.75 4.75 0 0 0-4.746-4.741z",
            openProject: "M21.998 36.23a14.234 14.234 0 1 1 14.238-14.232A14.234 14.234 0 0 1 21.998 36.23",
            overdueOld: "M13.856 17.398a7.6 7.6 0 0 0 2.647 2.478A18.27 18.27 0 0 1 19.19 9.08c.336-.462 4.117-5.377 4.327-3.318.378 4.117 5.167 7.519 7.771 10.333a14.2 14.2 0 0 1 4.243 10.124 13.62 13.62 0 0 1-6.049 10.838c-.462.294-1.092.126-.798-.672.126-.42 2.604-8.611-5.293-12.98a.401.401 0 0 0-.589.42 10.16 10.16 0 0 1-2.688 8.36.75.75 0 0 1-.756.251 13 13 0 0 1-3.108-1.428.414.414 0 0 0-.63.336 10 10 0 0 0 2.016 6.301c.378.505-.126.967-.672.757-8.695-3.067-11.425-15.165-4.872-21.676 1.302-1.302 1.008-.673 1.764.672",
            plus: "M33.25 19.835h-9.083v-9.083a2.167 2.167 0 1 0-4.332 0v9.085H10.75a2.167 2.167 0 1 0 0 4.331h9.085v9.085a2.167 2.167 0 1 0 4.332 0v-9.087h9.083a2.167 2.167 0 1 0 0-4.331",
            searchNew: "m35.1 30.7-4.7-3.8c1.4-2.1 2.2-4.5 2.2-7.2 0-7.2-5.8-13-13-13s-13 5.8-13 13 5.8 13 13 13c2.7 0 5.1-.8 7.2-2.2l3.8 4.7c.4.5 1 .8 1.7.9h.1c.6 0 1.2-.2 1.7-.7l1.1-1.1c.5-.5.7-1.1.7-1.8 0-.8-.3-1.4-.8-1.8m-23.7-11c0-4.6 3.7-8.3 8.3-8.3s8.3 3.7 8.3 8.3-3.7 8.3-8.3 8.3c-4.6-.1-8.3-3.8-8.3-8.3",
            settingsNew: "M38.64 19.834v4.033a.68.68 0 0 1-.505.63l-3.738.714a1.22 1.22 0 0 0-.714.588l-.63 1.513a1.03 1.03 0 0 0 .083.924l2.143 3.15a.636.636 0 0 1-.084.799l-2.857 2.898a.69.69 0 0 1-.798.042l-3.15-2.142a1.03 1.03 0 0 0-.925-.084l-1.47.63a.93.93 0 0 0-.588.714l-.714 3.739a.67.67 0 0 1-.63.504h-4.075a.63.63 0 0 1-.63-.504l-.714-3.739a1.07 1.07 0 0 0-.63-.714l-1.429-.63a1.01 1.01 0 0 0-.923.084l-3.151 2.142a.76.76 0 0 1-.84-.042l-2.858-2.898a.635.635 0 0 1-.084-.798l2.142-3.151a1.03 1.03 0 0 0 .084-.924l-.587-1.513a1.19 1.19 0 0 0-.757-.588l-3.739-.714a.68.68 0 0 1-.503-.63v-4.033a.72.72 0 0 1 .503-.63l3.74-.714a1.19 1.19 0 0 0 .756-.588l.587-1.512a1.03 1.03 0 0 0-.084-.924L8.73 12.315a.636.636 0 0 1 .084-.798L11.67 8.62a.76.76 0 0 1 .84-.042l3.152 2.142a1.01 1.01 0 0 0 .923.084l1.429-.588a1.17 1.17 0 0 0 .63-.714l.714-3.78a.63.63 0 0 1 .63-.505h4.075a.67.67 0 0 1 .63.504l.714 3.78a1 1 0 0 0 .588.715l1.47.588a1.03 1.03 0 0 0 .925-.084l3.15-2.142a.69.69 0 0 1 .798.042l2.857 2.898a.636.636 0 0 1 .084.798l-2.143 3.15a1.4 1.4 0 0 0-.084.925l.63 1.512a1.22 1.22 0 0 0 .715.588l3.738.715a.72.72 0 0 1 .504.63zm-11.144 2.022a5.466 5.466 0 1 0 0 .042z",
            sidebar: "M27.5 5.5h-11c-6.068 0-11 4.913-11 11v11c0 6.068 4.932 11 11 11h11c6.087 0 11-4.932 11-11v-11c0-6.087-4.913-11-11-11m7.333 22c0 4.033-3.281 7.333-7.333 7.333H22V9.167h5.5a7.33 7.33 0 0 1 7.333 7.333z",
            sidebarBorder: "M27.5 5.5h-11c-6.09 0-11 4.91-11 11v11c0 6.07 4.91 11 11 11h11c6.09 0 11-4.93 11-11v-11c0-6.09-4.91-11-11-11m7.33 22c0 4.03-3.28 7.33-7.33 7.33h-11c-4.05 0-7.33-3.3-7.33-7.33v-11c0-4.05 3.28-7.33 7.33-7.33h11c4.05 0 7.33 3.28 7.33 7.33z",
            sidebarFill: "M22 5.5v33h-5.5c-6.07 0-11-4.93-11-11v-11c0-6.09 4.93-11 11-11z",
            singleTasks: "M28.394 29.07A6.394 6.394 0 1 1 22 22.676a6.394 6.394 0 0 1 6.394 6.394m-8.19-14.14a6.394 6.394 0 1 0-6.393 6.394 6.394 6.394 0 0 0 6.394-6.394zm9.986-6.394a6.394 6.394 0 1 0 6.395 6.394 6.394 6.394 0 0 0-6.396-6.394z",
            spacesNew: "M8.241 27.87q-.754-.557-.743-1.46t.775-1.46q.523-.375 1.156-.38a1.88 1.88 0 0 1 1.156.38l11.406 8.565 11.426-8.566a1.96 1.96 0 0 1 2.303-.01q.764.559.78 1.466.015.908-.738 1.465l-11.426 8.607a3.9 3.9 0 0 1-2.35.786 3.76 3.76 0 0 1-2.34-.786zm11.406-.2-9.48-7.156Q8.68 19.4 8.68 17.593c0-1.806.495-2.178 1.486-2.921l9.48-7.156q1.058-.782 2.345-.782c1.287 0 1.64.26 2.345.782l9.48 7.156q1.486 1.115 1.486 2.92c0 1.806-.495 2.178-1.486 2.922l-9.48 7.156q-1.057.781-2.345.781c-1.288 0-1.64-.26-2.344-.78",
            starFill: "m28.179 24.672 3.333 10.941-9.519-6.453-9.511 6.455 3.333-10.943-9.218-7.166 11.585-.098L22 6.313l3.819 11.095 11.586.098z",
            tag: "m36.34 22.202-.023-.024v-.092L23.845 9.683a10.03 10.03 0 0 0-14.165.01l-.024.023a10.03 10.03 0 0 0-.011 14.165l.023.024 12.45 12.38a3.24 3.24 0 0 0 4.582.01l.011-.01 9.606-9.514a3.23 3.23 0 0 0 .023-4.57zm-17.498-3.335a2.908 2.908 0 1 1 0-4.113 2.91 2.91 0 0 1 0 4.113",
            team: "M14.665 9.167a6.417 6.417 0 1 1-6.415 6.416 6.417 6.417 0 0 1 6.416-6.416zm16.5 3.666a4.583 4.583 0 1 1-4.583 4.584 4.583 4.583 0 0 1 4.583-4.584m2.747 12.837h-5.5a7 7 0 0 0-.91.06 10.92 10.92 0 0 1 2.75 7.27v1.83h11V33a7.336 7.336 0 0 0-7.34-7.33m-23.83-.003h9.167A7.333 7.333 0 0 1 26.582 33v1.833H2.75V33a7.333 7.333 0 0 1 7.333-7.333z",
            templatesGroup: "M32.74 35.645a7.1 7.1 0 0 1-6.15 3.54H14.47c-5.34 0-9.67-4.33-9.67-9.67v-7.56c0-2.3 1.46-4.26 3.51-4.99v9.6c0 5.01 4.08 9.1 9.1 9.1 0 0 15.12-.01 15.33-.02m6.46-19.212v10.128a7.1 7.1 0 0 1-7.102 7.101H17.41a7.1 7.1 0 0 1-7.1-7.101V16.433a5.296 5.296 0 0 1 5.296-5.296h1.766V9.775a4.97 4.97 0 0 1 4.97-4.96h4.83a4.96 4.96 0 0 1 4.96 4.96v1.362h1.773a5.296 5.296 0 0 1 5.295 5.296m-18.23-5.298h7.56v-1.36c0-.75-.61-1.36-1.36-1.36h-4.83c-.76 0-1.37.61-1.37 1.36z",
            threeDots: "M11.58 24.685a2.82 2.82 0 0 1-2.8-2.801 2.855 2.855 0 0 1 2.802-2.868 2.89 2.89 0 0 1 2.867 2.868 2.854 2.854 0 0 1-2.867 2.8zm10.424 0a2.835 2.835 0 1 1 .035 0zm10.392 0a2.835 2.835 0 1 1 2.834-2.869v.068a2.847 2.847 0 0 1-2.834 2.8z",
            tickCircleEmpty: "M22 .85a21 21 0 1 0 21 21 20.997 20.997 0 0 0-21-21m0 40.69a19.69 19.69 0 1 1 19.69-19.69A19.71 19.71 0 0 1 22 41.54",
            tickCircleFull: "M22 .85a21 21 0 1 0 21 21 20.997 20.997 0 0 0-21-21m0 40.69a19.69 19.69 0 1 1 19.69-19.69A19.71 19.71 0 0 1 22 41.54m9.517-27.182 1.857 1.857-14.162 14.163-7.332-7.365 1.86-1.852 5.477 5.5z",
            tickNoCircle: "m31.517 14.358 1.857 1.857-14.162 14.163-7.332-7.365 1.86-1.852 5.477 5.5z",
            xCircleFull: "M22 .85C5.834.85-4.269 18.35 3.813 32.35c8.083 14 28.291 14 36.374 0A21 21 0 0 0 43 21.85c.001-11.599-9.401-21.001-21-21m0 40.69c-15.157 0-24.631-16.408-17.052-29.535s26.525-13.127 34.104 0a19.7 19.7 0 0 1 2.638 9.845C41.68 32.72 32.87 41.53 22 41.54m6.947-28.493L22 19.994l-6.947-6.947-1.856 1.856 6.947 6.947-6.947 6.947 1.856 1.856L22 23.706l6.947 6.947 1.856-1.856-6.947-6.947 6.947-6.947z",
            xNoCircle: "M28.947 13.047 22 19.994l-6.947-6.947-1.856 1.856 6.947 6.947-6.947 6.947 1.856 1.856L22 23.706l6.947 6.947 1.856-1.856-6.947-6.947 6.947-6.947z"
        }
    }, (e, t, s) => {
        const n = {
            light: {
                backgroundPrimary: "#FFFFFF",
                backgroundSecondary: "#F7F9FA",
                backgroundSecondaryInverse: "#080605",
                backgroundNavigation: "#FBFCFC",
                textPrimary: "#000000",
                textPrimaryInverse: "#FFFFFF",
                textSecondary: "#7F8B99",
                surface: "#FFFFFF",
                onBackground1: "#E6ECF0",
                onBackground2: "#ADBBC7",
                onBackground3: "#58616E",
                onBackground4: "#2D3238",
                priority: "#A71FCF",
                incoming: "#FA8200",
                activity: "#3C64FF",
                singleTasks: "#58616E",
                iosListItemHighlight: "#D8D8D8",
                pinnedBackground: "#FFFCF0",
                pinnedBorder: "#FFC36E",
                searchHighlight: "#F5DC00"
            },
            dark: {
                backgroundPrimary: "#000",
                backgroundSecondary: "#000",
                backgroundSecondaryInverse: "#e8e8e8",
                backgroundNavigation: "#1B1B1C",
                textPrimary: "#E3E3E3",
                textPrimaryInverse: "#1c1c1c",
                textSecondary: "#636366",
                surface: "#202022",
                onBackground1: "#2C2C2C",
                onBackground2: "#48484A",
                onBackground3: "#ABABAB",
                onBackground4: "#E6ECF0",
                priority: "#CE0DFC",
                incoming: "#FF9300",
                activity: "#009FFF",
                singleTasks: "#788698",
                iosListItemHighlight: "#2C2C2E",
                pinnedBackground: "#FA8200",
                pinnedBorder: "#FA8200",
                searchHighlight: "#F7FF0F"
            }
        };

        function a() {
            try {
                const e = s(325).Z.current();
                if (n[e]) return n[e]
            } catch (e) {}
            return n.light
        }
        const o = {
            disabled: "#C8C7CC",
            transparent: "transparent",
            white: "#FFFFFF",
            black: "#000000",
            gray0: "#FAFCFC",
            gray1: "#F7F9FA",
            gray2: "#E6ECF0",
            gray3: "#ADBBC7",
            gray4: "#7F8B99",
            gray5: "#58616E",
            gray6: "#2D3238",
            gray7: "#262A2F",
            dodgerblue: "#1C82FB",
            lightpurple: "#F5E7F9",
            avatarColor1: "#0173E1",
            avatarColor2: "#CC3333",
            avatarColor3: "#647282",
            avatarColor4: "#109D57",
            avatarColor5: "#C816E1",
            avatarColor6: "#AF6401",
            avatarColor7: "#3333CC",
            avatarColor8: "#56C39E",
            avatarColor9: "#AF491D",
            avatarColor10: "#DE7600",
            avatarColor11: "#D6207E",
            avatarColor12: "#56B228",
            yellow: "#FBC100",
            orange: "#FF9600",
            ocher: "#DB8729",
            pink: "#FF5C94",
            lightpink: "#FFA695",
            heather: "#C077DA",
            red: "#FF5428",
            green: "#30D15B",
            darkgreen: "#009E54",
            olive: "#8D9C00",
            aquamarine: "#2AD59A",
            teal: "#00A8A2",
            ocean: "#007580",
            stone: "#95AEC8",
            brown: "#D35B09",
            karmin: "#D4004E",
            aubergine: "#95062A",
            sand: "#E0BD80",
            dustpink: "#D9A69F",
            taupe: "#9D8563",
            burntsienna: "#955A5A",
            mauve: "#675B70",
            midnight: "#284249",
            indigo: "#453992",
            ultramarine: "#593AFF",
            blue: "#0076FF",
            lightblue: "#0FB0F5",
            navy: "#517F80",
            purple: "#A902D2",
            deeppurple: "#850096",
            pedro: "#FF895D",
            toto: "#C9B200",
            fluffy: "#AFB83B",
            felus: "#006F1E",
            luna: "#96C3EB",
            rufus: "#1480B0",
            maja: "#03C3CB",
            elwis: "#001981",
            pinned: "#FFA700",
            roosterRed: "#DE122C",
            aqua: "#97D9CA",
            spectra: "#2F5E5F",
            lightningYellow: "#F9BF13",
            mandy: "#E75D72",
            darkRed: "#9E253F",
            darkNavigationBackground: "#313134",
            get backgroundPrimary() {
                return a().backgroundPrimary
            },
            get backgroundSecondary() {
                return a().backgroundSecondary
            },
            get backgroundSecondaryInverse() {
                return a().backgroundSecondaryInverse
            },
            get backgroundNavigation() {
                return a().backgroundNavigation
            },
            get textPrimary() {
                return a().textPrimary
            },
            get textPrimaryInverse() {
                return a().textPrimaryInverse
            },
            get textSecondary() {
                return a().textSecondary
            },
            get surface() {
                return a().surface
            },
            get onBackground1() {
                return a().onBackground1
            },
            get onBackground2() {
                return a().onBackground2
            },
            get onBackground3() {
                return a().onBackground3
            },
            get onBackground4() {
                return a().onBackground4
            },
            get priority() {
                return a().priority
            },
            get incoming() {
                return a().incoming
            },
            get activity() {
                return a().activity
            },
            get singleTasks() {
                return a().singleTasks
            },
            get iosListItemHighlight() {
                return a().iosListItemHighlight
            },
            get pinnedBackground() {
                return a().pinnedBackground
            },
            get pinnedBorder() {
                return a().pinnedBorder
            },
            get searchHighlight() {
                return a().searchHighlight
            }
        };
        e.exports = {
            layer: {
                underContent: -10,
                content: 0,
                androidHeader: 4,
                androidFAB: 6,
                contentTweaks: 10,
                aboveContent: 20,
                stickyHeader: 25,
                masterButton: 30,
                drawer: 70,
                modalOverlay: 80,
                modal: 90,
                keyboardBar: 100,
                onboarding: 110,
                splashscreen: 120,
                tooltip: 999
            },
            font: {
                size: {
                    huge: 20,
                    big: 18,
                    body: 16,
                    header: 16,
                    small: 14,
                    taskEvent: 14,
                    caption: 13,
                    xsmall: 12,
                    entryButton: 16,
                    pillButton: 14,
                    teamSwitch: 11,
                    teamSwitchNew: 10,
                    tiny: 10
                },
                lineHeight: {
                    huge: 32,
                    big: 28,
                    body: 24,
                    header: 24,
                    small: 20,
                    taskEvent: 18,
                    caption: 20,
                    xsmall: 14,
                    entryButton: 28,
                    pillButton: 16,
                    teamSwitch: 13,
                    teamSwitchNew: 10,
                    tiny: 24
                },
                letterSpacing: {
                    huge: -10,
                    big: -10,
                    body: -10,
                    header: 0,
                    small: 50,
                    taskEvent: 0,
                    caption: 10,
                    xsmall: 70,
                    entryButton: -16,
                    pillButton: 10,
                    teamSwitch: 0,
                    teamSwitchNew: 0,
                    tiny: -10
                },
                family: {
                    main: '-apple-system, system-ui, BlinkMacSystemFont, ".SFNSText-Regular", "Helvetica Neue", Helvetica, Arial, sans-serif'
                }
            },
            fontWeight: {
                ultralight: "100",
                light: "300",
                normal: "normal",
                medium: "500",
                semibold: "600",
                bold: "bold",
                bolder: "700"
            },
            spacing: {
                iconToLabel: 5,
                listPaddingPhone: 4,
                listPaddingDesktop: 8,
                listPaddingForMasterPlus: 104
            },
            theme: n,
            color: o,
            radius: {
                sidebarBox: 16,
                pillButton: 18,
                r4: 4,
                r6: 6,
                r10: 10,
                r12: 12,
                r20: 20,
                full: 1e3
            },
            avatar: {
                size: {
                    tiny: 20,
                    teamSwitch: 22,
                    small: 28,
                    normal: 32,
                    medium: 56,
                    large: 88,
                    big: 144,
                    entry: 100
                },
                fontSize: {
                    tiny: 8,
                    teamSwitch: 9,
                    small: 10,
                    normal: 14,
                    medium: 24,
                    large: 37,
                    big: 47,
                    entry: 42
                },
                dotSize: {
                    tiny: 5,
                    small: 8,
                    normal: 11,
                    medium: 16,
                    large: 19,
                    big: 24,
                    entry: 22,
                    teamSwitch: 10
                },
                borderSize: {
                    tiny: 1,
                    teamSwitch: 2,
                    small: 2,
                    normal: 2,
                    medium: 2,
                    large: 3,
                    big: 3,
                    entry: 3
                },
                teamRadius: {
                    tiny: 8,
                    teamSwitch: 8,
                    small: 10,
                    normal: 12,
                    medium: 20,
                    large: 26,
                    big: 32,
                    entry: 28
                },
                status: {
                    active: "",
                    pending: o.orange,
                    archived: o.gray4,
                    requesting_join: o.orange,
                    expired: o.red
                },
                downloadWidth: 250
            },
            opacity: {
                pressedButton: .25
            },
            size: {
                electronTitleBar: 48,
                verificationButton: 56,
                emailVerificationIcon: 100,
                termsLink: {
                    width: 234,
                    marginTop: 20,
                    marginBottom: 50
                },
                entryContainer: {
                    minHeight: 620,
                    maxHeight: 800,
                    minWidth: 1e3,
                    maxWidth: 1400,
                    marginVertical: 70,
                    columnWidth: 375
                },
                header: 48,
                menuIcon: {
                    icon: 24,
                    background: 32
                },
                modal: {
                    handleHeight: 4,
                    handleWidth: 40,
                    header: 56,
                    search: 56,
                    searchIcon: 22
                },
                paymentsListItem: {
                    heightNormal: 56,
                    heightLarge: 63
                },
                search: {
                    height: 36,
                    iconWidth: 32
                },
                smallModalHeader: 40,
                teamSwitch: 68,
                teamSwitchNew: 84,
                sidebar: {
                    width: 344,
                    widthTablet: 320,
                    widthDesktopWide: 320,
                    teamSwitch: {
                        width: 58,
                        height: 58,
                        highlight: 30,
                        highlightNew: 34,
                        activeBar: {
                            width: 4,
                            height: 24
                        }
                    },
                    header: {
                        icon: 24,
                        iconContainer: 28,
                        backButton: 48,
                        backButtonIcon: 36
                    },
                    item: {
                        smallerHeight: 36,
                        height: 48,
                        heightDense: 36,
                        content: 40,
                        icon: 28,
                        iconContainer: 24,
                        rightContainer: 30,
                        rightIcon: 18,
                        statusIconOld: 16
                    },
                    memberItemAvatar: 28,
                    group: {
                        title: 56,
                        togglerContainer: 22,
                        togglerIcon: 22
                    },
                    box: {
                        height: 80,
                        heightDense: 70,
                        icon: 28
                    },
                    banner: {
                        closeButton: {
                            size: 32,
                            icon: 24
                        }
                    }
                },
                progressBar: {
                    height: 44,
                    paddingTop: 30
                },
                entryButton: 44,
                copyButton: 44,
                pillButton: {
                    normal: 32,
                    compact: 24
                },
                summaryContentHeight: 56,
                task: 72,
                taskDense: 54,
                newTaskForm: 72,
                rawSectionHeader: 56,
                rawSectionHeaderWithDescription: 72,
                expander: 44,
                newTaskIcons: 48,
                newTaskParams: 40,
                snackbar: 48,
                taskDetails: {
                    attributes: 140,
                    attributesBigger: 184,
                    sharedTaskBanner: 40,
                    miniAttributes: 40,
                    iconMark: 22,
                    attributeIcon: 24,
                    iconMarkDetailsIcon: 88,
                    closeButton: 28,
                    commentPrompt: 120,
                    footer: 44
                },
                emptyList: {
                    buttonHeight: 56,
                    iconSize: 240
                },
                wysywigToolbar: 40,
                editorCloseButton: 16,
                loadingCommentsIconSize: 20,
                tick: {
                    icon: 34
                },
                listItem: {
                    icon: 28
                },
                internalLink: {
                    icon: 16
                },
                taskRedirect: {
                    icon: 48
                },
                attachment: {
                    height: 40,
                    totalHeight: 52,
                    totalHeightWithThumbnail: 252,
                    thumbnail: {
                        downloadWidth: 500,
                        maxHeight: 200
                    }
                },
                messageBox: {
                    icon: 22,
                    iconContainer: 28
                },
                dueDatePicker: {
                    minHeight: 500,
                    minHeightReminder: 326
                },
                projectInvitationModal: {
                    memberContentHeight: 50
                },
                pickerMaxHeight: 500,
                settings: {
                    buttonWidth: 140,
                    footerHeight: 65
                },
                navBar: {
                    ripple: 20
                },
                stats: {
                    pace: {
                        entryHeight: 80
                    },
                    progressMarker: {
                        height: 25
                    }
                },
                filtersBar: {
                    height: 40
                }
            },
            animation: {
                duration: {
                    faster: ".125s",
                    fast: ".25s",
                    regular: ".5s",
                    slow: "2s"
                }
            }
        }
    }, e => {
        e.exports = (e, t) => {
            function s(s) {
                const n = e.font.size[s],
                    a = e.font.lineHeight[s];
                return {
                    fontSize: n,
                    lineHeight: t ? a / n : a,
                    letterSpacing: e.font.letterSpacing[s] / (t ? 1e3 : 100)
                }
            }
            return {
                font: {
                    huge: s("huge"),
                    big: s("big"),
                    body: s("body"),
                    small: s("small"),
                    header: s("header"),
                    caption: s("caption"),
                    xsmall: s("xsmall"),
                    taskEvent: s("taskEvent"),
                    entryButton: s("entryButton"),
                    pillButton: s("pillButton"),
                    teamSwitch: s("teamSwitch"),
                    teamSwitchNew: s("teamSwitchNew"),
                    tiny: s("tiny")
                },
                unreadActivityDot: {
                    position: "absolute",
                    top: 8,
                    right: 8,
                    height: 7,
                    width: 7,
                    borderRadius: e.radius.full,
                    backgroundColor: e.color.activity
                },
                column: {
                    display: "flex",
                    flexDirection: "column"
                },
                row: {
                    display: "flex",
                    flexDirection: "row"
                },
                centered: {
                    alignItems: "center",
                    justifyContent: "center"
                },
                rowCentered: {
                    display: "flex",
                    flexDirection: "row",
                    alignItems: "center",
                    justifyContent: "center"
                },
                columnCentered: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center"
                },
                absoluteFill: {
                    position: "absolute",
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                },
                webTextEllipsis: t ? {
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                    wordWrap: "normal"
                } : {},
                webScrollable: t ? {
                    overflowY: "auto",
                    overflowX: "hidden",
                    cursor: "default",
                    WebkitOverflowScrolling: "touch",
                    touchAction: "pan-y"
                } : {}
            }
        }
    }, e => {
        e.exports = Object.freeze({
            ultrawide: 1340,
            wide: 1024,
            standard: 716,
            narrow: 0
        })
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(429)
    }, , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n = s(52),
            a = s(0);
        s(2), s(3);
        const o = s(439);
        var r = s(1);
        const i = e => (0, r.jsx)("div", {
            className: o.root + " " + (e.className || ""),
            style: Object.assign({
                paddingBottom: e.bottomInset
            }, e.style),
            children: e.children
        });
        var c = s(1526),
            l = s(440);
        const d = s(443);
        s(307);
        const u = ["padded", "keyboardShouldPersistTaps"],
            m = ["isStatic", "bottomInset", "containsScroll", "children"],
            h = ["isStatic"];
        const p = e => {
            const {
                padded: t,
                keyboardShouldPersistTaps: s = "always"
            } = e, o = (0, n.Z)(e, u), p = "boolean" == typeof(g = e.avoidKeyboard) && g;
            var g;
            const f = !p || o.isStatic && o.containsScroll ? a.React.Fragment : c.Z,
                b = a.Hooks.useLayoutBottomInset();
            if (o.isStatic) {
                const {
                    bottomInset: s,
                    containsScroll: a,
                    children: c
                } = o;
                (0, n.Z)(o, m);
                return (0, r.jsx)(f, {
                    children: (0, r.jsx)(i, {
                        className: d.container + (a ? " " + d.staticScroll : "") + (t ? " " + d.padded : "") + " " + (e.className || ""),
                        style: e.style,
                        bottomInset: p ? 0 : null != s ? s : b,
                        children: c
                    })
                })
            }
            const y = (0, n.Z)(o, h);
            return (0, r.jsx)(l.Z, Object.assign({
                className: (t ? d.padded : "") + " " + (e.className || ""),
                style: e.style
            }, y, {
                avoidKeyboard: p,
                keyboardShouldPersistTaps: s
            }))
        }
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        s(0);
        var n = s(68);
        s(2), s(3);
        const a = s(442);
        var o = s(1);
        const r = e => {
            const {
                children: t,
                scrollRef: s
            } = e;
            return (0, o.jsx)(n.Z, {
                className: a.scroll + " " + (e.className || ""),
                style: e.style,
                isAbsoluteFilled: !1,
                topBarInset: 56,
                reachesTopOfScreen: !1,
                scrollRef: s,
                children: t
            })
        }
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(445)
    }, , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            k: () => b
        });
        s(0);
        var n = s(242),
            a = s(36);
        const {
            vars: o,
            mixins: r,
            zcolor: i,
            rgba: c
        } = a, {
            size: l,
            spacing: d,
            radius: u,
            color: m,
            layer: h,
            fontWeight: p
        } = o, g = s(455);
        var f = s(1);
        const b = ({
            badge: e
        }) => (0, f.jsx)(n.Z, {
            className: g.iconBubble,
            badge: e
        })
    }, , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            B: () => n
        });
        const n = s(9).createContext(!1)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            $: () => r,
            l: () => o
        });
        const n = {
                txt: "text/plain",
                html: "text/html",
                htm: "text/html",
                css: "text/css",
                csv: "text/csv",
                js: "text/javascript",
                jsx: "text/javascript",
                ts: "text/typescript",
                tsx: "text/typescript",
                jpg: "image/jpeg",
                jpeg: "image/jpeg",
                png: "image/png",
                gif: "image/gif",
                webp: "image/webp",
                svg: "image/svg+xml",
                ico: "image/x-icon",
                bmp: "image/bmp",
                mp3: "audio/mpeg",
                wav: "audio/wav",
                ogg: "audio/ogg",
                m4a: "audio/mp4",
                mp4: "video/mp4",
                webm: "video/webm",
                avi: "video/x-msvideo",
                mov: "video/quicktime",
                pdf: "application/pdf",
                doc: "application/msword",
                docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                xls: "application/vnd.ms-excel",
                xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                ppt: "application/vnd.ms-powerpoint",
                pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                zip: "application/zip",
                rar: "application/x-rar-compressed",
                "7z": "application/x-7z-compressed",
                tar: "application/x-tar",
                gz: "application/gzip",
                json: "application/json",
                xml: "application/xml",
                woff: "font/woff",
                woff2: "font/woff2",
                ttf: "font/ttf",
                otf: "font/otf"
            },
            a = ["image/png", "image/jpeg", "image/gif", "application/pdf"];

        function o(e) {
            var t;
            const s = e.toLowerCase().split(".").pop();
            return null != (t = n[s]) ? t : "application/octet-stream"
        }

        function r(e) {
            return a.includes(e) || e.startsWith("video/")
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => F
        });
        var n, a, o, r, i, c, l, d, u, m, h, p, g, f, b, y, v, w, k, x, j, T, S, P = s(69),
            _ = s(24),
            C = s(19),
            R = s(33),
            A = s(16),
            I = s(5),
            N = s(244),
            E = s(1229),
            O = s(243),
            M = s(473);
        const D = (e, t, s, n = null) => (0, _.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            H = A.o.attachmentVersions;
        let F = (n = I.lazy, a = (0, R.text)(H.name), o = (0, R.field)(H.size), r = (0, R.text)(H.status), i = (0, R.text)(H.integrationType), c = (0, R.text)(H.mimeType), l = (0, R.date)(H.createdAt), d = (0, R.json)(H.extra, N.u), u = (0, R.immutableRelation)(A.w.attachments, H.attachmentId), m = (0, R.experimentalFailsafe)(), h = (0, R.immutableRelation)(A.w.teamMembers, H.authorId), (S = class extends C.Model {
            constructor(...e) {
                super(...e), (0, P.Z)(this, "do", g, this), (0, P.Z)(this, "name", f, this), (0, P.Z)(this, "size", b, this), (0, P.Z)(this, "status", y, this), (0, P.Z)(this, "_integrationType", v, this), (0, P.Z)(this, "mimeType", w, this), (0, P.Z)(this, "createdAt", k, this), (0, P.Z)(this, "extra", x, this), (0, P.Z)(this, "attachment", j, this), (0, P.Z)(this, "author", T, this), this.file = null
            }
            get isExternal() {
                return !!this._integrationType
            }
            get asExternalAttachment() {
                return (0, E.KB)(this)
            }
            get hasRemoteThumbnail() {
                const {
                    mimeType: e,
                    asExternalAttachment: t
                } = this;
                if (t) switch (t.integration) {
                    case O.m.Evernote:
                        return "text/html" === e;
                    case O.m.Dropbox:
                    case O.m.OneDrive:
                        return t.metadata.is_thumbnail_available;
                    case O.m.GoogleDrive: {
                        const {
                            thumbnail_link: e
                        } = t.metadata;
                        return Boolean(e)
                    }
                    default:
                        return !1
                }
                return (0, M.$)(e)
            }
        }).table = A.w.attachmentVersions, S.associations = (0, C.associations)([A.w.attachments, {
            type: "belongs_to",
            key: H.attachmentId
        }], [A.w.teamMembers, {
            type: "belongs_to",
            key: H.authorId
        }]), g = D(p = S, "do", [n], (function() {
            return (() => new(0, s(1230).Z)(this))()
        })), f = D(p, "name", [a]), b = D(p, "size", [R.nochange, o]), y = D(p, "status", [r]), v = D(p, "_integrationType", [R.nochange, i]), w = D(p, "mimeType", [R.nochange, c]), k = D(p, "createdAt", [R.nochange, l]), x = D(p, "extra", [d]), j = D(p, "attachment", [u]), T = D(p, "author", [m, h]), p)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(4);
        const a = /^\d+\. /,
            o = /^(?:\((\+|\-)\)|-\s\[[\sx]\])\s/,
            r = ["***", "---", "___", "* * *"];

        function i(e) {
            const t = [],
                s = n.splitLines(e);
            let i = 0;
            const l = (e, s) => !!s && (t.push([e, s]), i += s.length, !0);
            for (; i < s.length;) {
                if (l("checklist", c(s, i, (e => o.test(e))))) continue;
                if (l("bullet-list", c(s, i, (e => e.startsWith("- "))))) continue;
                if (l("numbered-list", c(s, i, (e => a.test(e))))) continue;
                if (l("blockquote", c(s, i, (e => e.startsWith(">"))))) continue;
                const e = s[i];
                if (e.startsWith("# ")) {
                    l("heading-one", [e]);
                    continue
                }
                if (e.startsWith("## ")) {
                    l("heading-two", [e]);
                    continue
                }
                if (r.includes(e.trim())) {
                    l("horizontal-rule", [e]);
                    continue
                }
                if ("```" === e) {
                    const e = s.indexOf("```", i + 1);
                    if (e >= i + 2) {
                        l("code-block", s.slice(i, e + 1));
                        continue
                    }
                }
                l("paragraph", c(s, i, (e => !("" === e || e.startsWith(">") || e.startsWith("# ") || e.startsWith("## ") || e.startsWith("- ") || r.includes(e))))) || (i += 1)
            }
            return t
        }
        const c = (e, t, s) => {
            const n = [];
            for (let a = t; a < e.length; a += 1) {
                const t = e[a];
                if (!s(t)) break;
                n.push(t)
            }
            return n.length ? n : null
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            m: () => n
        });
        const n = Object.freeze({
            Pending: "pending",
            Accepted: "accepted",
            Rejected: "rejected"
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => Fe
        });
        var n, a, o, r, i, c, l, d, u, m, h = s(69),
            p = s(24),
            g = s(279),
            f = s(19),
            b = s(33),
            y = s(5),
            v = s(8),
            w = s(4),
            k = s(16),
            x = s(108),
            j = s(29),
            T = s(1236),
            S = s(1233),
            P = s(476);
        const _ = (e, t, s, n = null) => (0, p.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            C = k.o.projects;
        let R = (n = y.lazy, a = (0, b.field)(C.isOpen), o = (0, b.children)(k.w.projectAccesses), i = _(r = class {
            get asModel() {
                return this.project
            }
            get database() {
                return this.project.database
            }
            constructor(e) {
                (0, h.Z)(this, "do", i, this), (0, h.Z)(this, "isOpen", c, this), (0, h.Z)(this, "isPrivate", l, this), (0, h.Z)(this, "accesses", d, this), (0, h.Z)(this, "managerAccesses", u, this), (0, h.Z)(this, "members", m, this), this.project = e
            }
            async doesMemberHaveAccess(e, t = !0) {
                if (t && this.isOpen) return !e.isArchived;
                const s = this.accesses.extend(f.Q.where(k.o.projectAccesses.memberId, e.id));
                return 0 < await s.fetchCount()
            }
            async hasGrantedManagerAccess(e) {
                this.project._ensureNotSingleTasks();
                const t = this.managerAccesses.extend(f.Q.where(k.o.projectAccesses.memberId, e.id));
                return 0 < await t.fetchCount()
            }
            async canBeManagedBy(e) {
                this.project._ensureNotSingleTasks();
                const t = await v.takeFirst(e.hasAdminPowers);
                return this.isOpen && (this.project.author.id === e.id || t) || t || this.hasGrantedManagerAccess(e)
            }
            async canBeManaged() {
                const e = await this.project._me;
                return this.canBeManagedBy(e)
            }
            async canUpdateAccess() {
                return !this.project.isEnded && this.canBeManaged()
            }
            async isEligibleForManagerClaim() {
                if (this.project._ensureNotSingleTasks(), this.isOpen || await this.project.isPersonalProject) return !1;
                if (0 < await this.managerAccesses.fetchCount()) return !1;
                const e = this.accesses.extend(f.Q.on(k.w.teamMembers, [f.Q.where(k.o.teamMembers.role, f.Q.oneOf(["owner", "admin"])), f.Q.where(k.o.teamMembers.status, "active")]));
                return !(0 < await e.fetchCount())
            }
            async _ensureCanManage() {
                invariant(await this.canBeManaged(), "You can't manage this project")
            }
        }, "do", [n], (function() {
            return (() => new(0, s(1237).Z)(this.project))()
        })), c = _(r, "isOpen", [a]), l = _(r, "isPrivate", [b.lazy], (function() {
            return this.project.observe().pipe(v.switchMap((e => e.isSingleTasks ? v.of(!0) : this.isOpen ? v.of(!1) : this.accesses.observeCount().pipe(v.map((e => 2 > e))))), v.cacheWhileConnected)
        })), d = _(r, "accesses", [o]), u = _(r, "managerAccesses", [b.lazy], (function() {
            return this.accesses.extend(f.Q.where(k.o.projectAccesses.isManager, !0))
        })), m = _(r, "members", [b.lazy], (function() {
            return this.project.observe().pipe(v.distinctUntilChanged(w.identical, (e => e.permissions.isOpen)), v.map((e => e.collections.get(k.w.teamMembers).query(f.Q.or(f.Q.where(k.o.teamMembers.teamId, e.team.id), ...this.project.sharedTeam.id ? [f.Q.where(k.o.teamMembers.teamId, this.project.sharedTeam.id)] : []), f.Q.where(k.o.teamMembers.status, f.Q.notEq("archived")), f.Q.where(k.o.teamMembers.status, f.Q.notEq("requesting_join")), f.Q.where(k.o.teamMembers.status, f.Q.notEq("expired")), ...this.isOpen ? [] : [f.Q.on(k.w.projectAccesses, k.o.projectAccesses.projectId, e.id)]))))
        })), r);
        var A, I, N, E, O, M, D, H, F, Z, L, B, z, U, W, G, V, q, Q, Y, J, K, $, X, ee, te, se, ne, ae, oe, re, ie, ce, le, de, ue, me, he, pe, ge, fe, be, ye, ve, we, ke, xe, je, Te, Se, Pe, _e, Ce, Re, Ae, Ie, Ne, Ee, Oe;
        const Me = (e, t, s) => (0, p.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            De = (e, t, s, n = null) => (0, p.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            He = k.o.projects;
        let Fe = (A = y.lazy, I = (0, b.text)(He.name), N = (0, b.field)(He.isSingleTasks), E = (0, b.field)(He.sidebarPosition), O = (0, b.field)(He.isFavorite), M = (0, b.field)(He.isTemplate), D = (0, b.field)(He.userColor), H = (0, b.field)(He.teamColor), F = (0, b.text)(He.description), Z = (0, b.date)(He.endedAt), L = (0, b.date)(He.lastEventAt), B = (0, b.date)(He.lastSeenEventAt), z = (0, b.immutableRelation)(k.w.teams, He.teamId), U = (0, b.relation)(k.w.teams, He.sharedTeamId), W = (0, b.experimentalFailsafe)(), G = (0, b.immutableRelation)(k.w.teamMembers, He.authorId), V = (0, b.children)(k.w.projectSections), q = (0, b.children)(k.w.tasks), Q = (0, b.children)(k.w.groupAssignments), Y = (0, b.children)(k.w.projectEvents), J = (0, b.children)(k.w.taskRecurrences), K = (0, b.json)(He.preferences, T.G), $ = (0, b.json)(He.extra, S.u), X = (0, b.date)(He.createdAt), (Oe = class extends f.Model {
            constructor(...e) {
                super(...e), (0, h.Z)(this, "permissions", te, this), (0, h.Z)(this, "do", se, this), (0, h.Z)(this, "_name", ne, this), (0, h.Z)(this, "isSingleTasks", ae, this), (0, h.Z)(this, "sidebarPosition", oe, this), (0, h.Z)(this, "isFavorite", re, this), (0, h.Z)(this, "isTemplate", ie, this), (0, h.Z)(this, "userColor", ce, this), (0, h.Z)(this, "teamColor", le, this), (0, h.Z)(this, "description", de, this), (0, h.Z)(this, "endedAt", ue, this), (0, h.Z)(this, "lastEventAt", me, this), (0, h.Z)(this, "lastSeenEventAt", he, this), (0, h.Z)(this, "team", pe, this), (0, h.Z)(this, "sharedTeam", ge, this), (0, h.Z)(this, "_relatedTeams", fe, this), (0, h.Z)(this, "currentTeam", be, this), (0, h.Z)(this, "author", ye, this), (0, h.Z)(this, "allSections", ve, this), (0, h.Z)(this, "activeSections", we, this), (0, h.Z)(this, "archivedSections", ke, this), (0, h.Z)(this, "allTasks", xe, this), (0, h.Z)(this, "groups", je, this), (0, h.Z)(this, "groupAssignments", Te, this), (0, h.Z)(this, "activeTasks", Se, this), (0, h.Z)(this, "endedTasks", Pe, this), (0, h.Z)(this, "allTasksWithoutSection", _e, this), (0, h.Z)(this, "activeTasksWithoutSection", Ce, this), (0, h.Z)(this, "events", Re, this), (0, h.Z)(this, "taskRecurrences", Ae, this), (0, h.Z)(this, "preferences", Ie, this), (0, h.Z)(this, "extra", Ne, this), (0, h.Z)(this, "createdAt", Ee, this)
            }
            get isTeamProject() {
                return this.team.fetch().then((e => e.isTeam))
            }
            get isPersonalProject() {
                return this.team.fetch().then((e => e.isPersonal))
            }
            get isShared() {
                return !!this.sharedTeam.id
            }
            get isHostSharedProject() {
                return this.isShared ? this.getCurrentTeam().then((e => e.id === this.team.id)) : Promise.resolve(!1)
            }
            get isGuestSharedProject() {
                return this.isShared ? this.getCurrentTeam().then((e => e.id === this.sharedTeam.id)) : Promise.resolve(!1)
            }
            get hasBeenUnshared() {
                return !this.isShared && this.hasAcceptedInvitation
            }
            get isFollowed() {
                return null !== this.sidebarPosition
            }
            get color() {
                return this.shouldUseTeamColor ? this.teamColor : this.userColor
            }
            get isActive() {
                return !this.endedAt
            }
            get isEnded() {
                return !!this.endedAt
            }
            get hasUnseenEvents() {
                return !this.lastSeenEventAt || this.lastEventAt > this.lastSeenEventAt
            }
            getCurrentTeam() {
                return v.takeFirst(this.currentTeam)
            }
            get shouldHidePurpose() {
                return Boolean(this.preferences[T.u.shouldHidePurpose])
            }
            get shouldProposeUnfollow() {
                var e;
                return null == (e = this.preferences[T.u.shouldProposeUnfollow]) || e
            }
            get shouldUseTeamColor() {
                return Boolean(this.preferences[T.u.shouldUseTeamColor])
            }
            get invitation() {
                return this.extra[S.k.invitation]
            }
            get hasPendingInvitation() {
                var e;
                return (null == (e = this.invitation) ? void 0 : e.status) === P.m.Pending
            }
            get hasAcceptedInvitation() {
                var e;
                return (null == (e = this.invitation) ? void 0 : e.status) === P.m.Accepted
            }
            get hasRejectedInvitation() {
                var e;
                return (null == (e = this.invitation) ? void 0 : e.status) === P.m.Rejected
            }
            get areTimeAttributesEnabled() {
                return !!this.extra[S.k.areTimeAttributesEnabled]
            }
            async follow() {
                this._ensureNotSingleTasks(), await this.callWriter((() => this.do._markEndedTasksAsRead()));
                const e = await this.team.fetch(),
                    t = await e.followedNotFavoriteProjects.fetch();
                await (0, x.NV)(this, t, e)
            }
            async unfollow() {
                this._ensureNotSingleTasks();
                const e = await this.team.fetch();
                await (0, x.OO)(this, e)
            }
            async favorite() {
                this._ensureNotSingleTasks(), await this.callWriter((() => this.do._markEndedTasksAsRead()));
                const e = await this.team.fetch();
                await (0, x.GD)(this, e)
            }
            async unfavorite() {
                this._ensureNotSingleTasks();
                const e = await this.team.fetch(),
                    t = await e.followedNotFavoriteProjects.fetch();
                await (0, x.WN)(this, t, e)
            }
            async getTopPosition() {
                const e = await this.activeTasks.fetch();
                return (0, j.Fv)(e)
            }
            async getBottomPosition() {
                const e = await this.activeTasks.fetch();
                return (0, j.pv)(e)
            }
            async canCreateSection() {
                const e = await this.getCurrentTeam();
                return await this.activeSections.fetchCount() < e.limits.projectSections
            }
            async canEnableTimeAttributes() {
                return (await this.getCurrentTeam()).canEnableTimeAttributes
            }
            async canBeEdited() {
                if (this.isSingleTasks) return !1;
                return !!(5 > (0, g.Z)(new Date, this.createdAt)) || this.permissions.canBeManaged()
            }
            get isShareable() {
                return !this.isShared && !this.isSingleTasks && !this.isTemplate
            }
            async canBeMoved() {
                const e = await this.permissions.canBeManaged();
                return this.isShareable && e
            }
            async canBeShared() {
                const e = await this.team.fetch();
                return await this.canBeMoved() && !e.isFree
            }
            get canBeUnshared() {
                return this.isShared && !this.isEnded
            }
            async updateSidebarPosition(e, t) {
                this._ensureNotSingleTasks(), invariant(t.id === this.team.id || t.id === this.sharedTeam.id, "Model does not belong to the given team"), await (0, x.D5)(this, t, e)
            }
            asSidebarFavoritable(e) {
                return e.id !== this.team.id && e.id !== this.sharedTeam.id ? new x.ke : this
            }
            async canDelete() {
                if (this.isSingleTasks) return !1;
                const e = await this.canBeEdited(),
                    t = await this.isGuestSharedProject;
                return this.isEnded && e && !t
            }
            canBeCopied() {
                return this.isActive
            }
            canBeCloned() {
                return this.canBeCopied() && !this.isSingleTasks
            }
            async experimentalMarkAsDeleted() {
                this._ensureNotSingleTasks(), await super.experimentalMarkAsDeleted()
            }
            get _me() {
                return this.getCurrentTeam().then((e => v.takeFirst(e.currentMember)))
            }
            get _observableMe() {
                return this.currentTeam.pipe(v.switchMap((e => e.currentMember)))
            }
            _ensureNotSingleTasks() {
                invariant(!this.isSingleTasks, "Operation not allowed on Single Tasks")
            }
            async _ensureTeamProject() {
                invariant(await this.isTeamProject, "Operation not allowed on Personal team projects")
            }
            _ensureNotEnded() {
                invariant(this.isActive, "Operation not allowed on ended projects")
            }
            async _ensureCanBeEdited() {
                invariant(await this.canBeEdited(), "Current account cannot do this action")
            }
            _ensureIsShared() {
                invariant(this.isShared, "Operation not allowed on not shared projects")
            }
        }).table = k.w.projects, Oe.associations = (0, f.associations)([k.w.teams, {
            type: "belongs_to",
            key: He.teamId
        }], [k.w.teamMembers, {
            type: "belongs_to",
            key: He.authorId
        }], [k.w.projectSections, {
            type: "has_many",
            foreignKey: k.o.projectSections.projectId
        }], [k.w.projectAccesses, {
            type: "has_many",
            foreignKey: k.o.projectAccesses.projectId
        }], [k.w.projectEvents, {
            type: "has_many",
            foreignKey: k.o.projectEvents.projectId
        }], [k.w.groupAssignments, {
            type: "has_many",
            foreignKey: k.o.groupAssignments.objectId
        }], [k.w.tasks, {
            type: "has_many",
            foreignKey: k.o.tasks.projectId
        }], [k.w.taskRecurrences, {
            type: "has_many",
            foreignKey: k.o.taskRecurrences.projectId
        }]), te = De(ee = Oe, "permissions", [b.lazy], (function() {
            return new R(this)
        })), se = De(ee, "do", [A], (function() {
            return (() => new(0, s(1528).Z)(this))()
        })), ne = De(ee, "_name", [I]), ae = De(ee, "isSingleTasks", [b.nochange, N]), oe = De(ee, "sidebarPosition", [E]), re = De(ee, "isFavorite", [O]), ie = De(ee, "isTemplate", [M]), ce = De(ee, "userColor", [D]), le = De(ee, "teamColor", [H]), de = De(ee, "description", [F]), ue = De(ee, "endedAt", [Z]), me = De(ee, "lastEventAt", [L]), he = De(ee, "lastSeenEventAt", [B]), pe = De(ee, "team", [z]), ge = De(ee, "sharedTeam", [U]), fe = De(ee, "_relatedTeams", [b.lazy], (function() {
            return v.of(this.sharedTeam).pipe(v.map((() => this.collections.get(k.w.teams).query(f.Q.where(k.o.teams.isShared, !1), f.Q.or(f.Q.where(k.o.id, this.team.id), ...this.sharedTeam.id ? [f.Q.where(k.o.id, this.sharedTeam.id)] : [])))))
        })), be = De(ee, "currentTeam", [b.lazy], (function() {
            return this._relatedTeams.pipe(v.cacheWhileConnected, v.switchMap((e => e.observe())), v.map((e => {
                if (this.isShared ? invariant(e.length && 2 >= e.length, "Expected at most two host teams, got " + e.length + " instead") : invariant(1 === e.length, "Expected one host team for project, got " + e.length + " instead"), 1 === e.length) return e[0];
                const t = this.db.__unsafeCurrentTeamId;
                invariant(t, "Expected current team id");
                const s = e.find((e => e.id === t));
                return invariant(s, "Expected current team to be one of the host teams"), y.logError(y.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Project " + this.id + " has multiple host teams: " + e.map((e => e.id)).join(",") + ". Selected " + s.id + " the as current team.", "warning"), s
            })), v.distinctUntilChanged())
        })), ye = De(ee, "author", [W, G]), ve = De(ee, "allSections", [V]), we = De(ee, "activeSections", [b.lazy], (function() {
            return this.allSections.extend(f.Q.where(k.o.projectSections.archivedAt, null))
        })), ke = De(ee, "archivedSections", [b.lazy], (function() {
            return this.allSections.extend(f.Q.where(k.o.projectSections.archivedAt, f.Q.notEq(null)))
        })), xe = De(ee, "allTasks", [q]), je = De(ee, "groups", [b.lazy], (function() {
            return this.collections.get(k.w.projectGroups).query(f.Q.on(k.w.groupAssignments, k.o.groupAssignments.objectId, this.id))
        })), Te = De(ee, "groupAssignments", [Q]), Se = De(ee, "activeTasks", [b.lazy], (function() {
            return this.allTasks.extend(j.rG)
        })), Pe = De(ee, "endedTasks", [b.lazy], (function() {
            return this.allTasks.extend(j.kU)
        })), _e = De(ee, "allTasksWithoutSection", [b.lazy], (function() {
            return this.allTasks.extend(f.Q.where(k.o.tasks.projectSectionId, null))
        })), Ce = De(ee, "activeTasksWithoutSection", [b.lazy], (function() {
            return this.allTasksWithoutSection.extend(j.rG)
        })), Re = De(ee, "events", [Y]), Ae = De(ee, "taskRecurrences", [J]), Ie = De(ee, "preferences", [K]), Ne = De(ee, "extra", [$]), Ee = De(ee, "createdAt", [b.nochange, X]), Me(ee, "follow", [b.writer]), Me(ee, "unfollow", [b.writer]), Me(ee, "favorite", [b.writer]), Me(ee, "unfavorite", [b.writer]), Me(ee, "updateSidebarPosition", [b.writer]), ee)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            k: () => o,
            u: () => r
        });
        var n = s(4),
            a = s(83);
        const o = {
            forwardedEmailMetadata: "forwarded_email_metadata",
            clonedFromId: "cloned_from_id"
        };

        function r(e) {
            const t = {};
            if (n.isObject(e)) {
                const s = function(e) {
                    if (Array.isArray(e)) return e.map((e => i(e.sender_email) && n.isString(e.sender_name) ? {
                        senderEmail: e.sender_email,
                        senderName: e.sender_name
                    } : null)).filter(Boolean);
                    return []
                }(e[o.forwardedEmailMetadata]);
                Array.isArray(s) && 0 < s.length && (t[o.forwardedEmailMetadata] = s);
                const a = e[o.clonedFromId];
                n.isString(a) && Boolean(a) && (t[o.clonedFromId] = a)
            }
            return t
        }
        const i = e => n.isString(e) && a.Ej.test(e)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(13);
        s(2), s(3);
        const o = s(480);
        var r = s(1);
        const i = ["Ĳ", "B", "C", "@", "?", "A", ">"],
            c = e => {
                const {
                    onDrop: t,
                    header: s,
                    description: c
                } = e, [l, d] = n.React.useState(!1), [u, m, h] = n.React.useMemo((() => i.sort((() => .5 - Math.random()))), []);
                return (0, r.jsxs)("div", {
                    className: o.root + (l ? " " + o.draggingOver : ""),
                    onDrop: t,
                    onDragOver: () => {
                        d(!0)
                    },
                    onDragLeave: () => {
                        d(!1)
                    },
                    children: [(0, r.jsxs)("div", {
                        className: o.iconsContainer,
                        children: [(0, r.jsx)(a.default, {
                            className: o.iconLeft,
                            name: u,
                            size: 70,
                            color: "blue"
                        }), (0, r.jsx)(a.default, {
                            className: o.iconMiddle,
                            name: m,
                            size: 90,
                            color: "purple"
                        }), (0, r.jsx)(a.default, {
                            className: o.iconRight,
                            name: h,
                            size: 70,
                            color: "orange"
                        })]
                    }), (0, r.jsxs)("div", {
                        className: o.textContainer,
                        children: [(0, r.jsx)("span", {
                            className: o.header,
                            children: s
                        }), (0, r.jsx)("span", {
                            className: o.label,
                            children: c
                        })]
                    })]
                })
            }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => m
        });
        var n = s(0),
            a = s(48),
            o = s(246),
            r = (s(60), s(121)),
            i = s(503),
            c = s(1257);
        s(2), s(3);
        const l = s(506);
        var d = s(1);
        const u = n.ReactUtils.lazy((() => s(1258))),
            m = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    title: t,
                    color: s,
                    right: m,
                    extraText: h,
                    onTitlePress: p,
                    menuTarget: g,
                    isEnded: f,
                    onCountersPress: b,
                    onExtraTextPress: y,
                    left: v,
                    headerRef: w,
                    menuBadge: k
                } = e, x = n.Hooks.useServices(), j = n.Hooks.useDesktopLayout(), {
                    isLimitedAccount: T
                } = n.Hooks.useIdentity(), S = (0, a.y)(), P = S ? e => (0, d.jsx)(r.Z, {
                    observables: {
                        listCounters: S.list
                    },
                    resetOn: [S],
                    children: ({
                        listCounters: t
                    }) => (0, d.jsx)(o.Z, {
                        className: l.taskCounters,
                        variant: "timeAttributesOnly",
                        color: e,
                        counters: t.activeTasks,
                        onPress: b,
                        allowFontScaling: !1
                    })
                }) : null, _ = v ? () => v : j && !T ? e => (0, d.jsx)(u, {
                    color: e
                }) : void 0, C = P || m ? e => (0, d.jsxs)(d.Fragment, {
                    children: [null == P ? void 0 : P(e), m]
                }) : void 0;
                return (0, d.jsx)(i.Z, {
                    headerRef: w,
                    renderTitle: e => (0, d.jsx)(c.e, {
                        color: e,
                        isEnded: f,
                        hoverText: t,
                        children: t
                    }),
                    onTitlePress: p,
                    renderLeft: _,
                    onLeftIconPress: t => {
                        e.onLeftIconPress && e.onLeftIconPress(t), x.navigation.showSidebar()
                    },
                    renderRight: C,
                    extraText: h,
                    onExtraTextPress: y,
                    menuTarget: g,
                    menuBadge: k,
                    color: s
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(0);

        function a(e) {
            const t = n.Hooks.useServices();
            return async () => e.areTimeAttributesEnabled ? (await e.do.setAreTimeAttributesEnabled(!1), !0) : t.payments.invokeActionOrProposeUpgrade({
                name: "enable-time-attributes",
                project: e
            }, (async () => {
                await e.do.setAreTimeAttributesEnabled(!e.areTimeAttributesEnabled)
            }))
        }
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(9), s(54), s(17), s(36), s(5), s(4), s(23), s(8), s(13), s(2), s(3);
        s(488);
        s(1);
        const n = e => {
            const {
                isEnabledOnProduction: t
            } = e;
            return null
        }
    }, , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => g
        });
        var n = s(0),
            a = s(18),
            o = s(13),
            r = s(11);
        s(2), s(3);
        const i = s(493);
        var c = s(1);
        const l = n.Hocs.compose()((e => {
            const {
                value: t,
                iconName: s,
                color: l = "onBackground2",
                iconColor: d,
                onClear: u
            } = e, m = n.Hooks.useIntl(), h = !u, [p, g] = n.React.useState(!1);
            return (0, c.jsxs)(r.Z, {
                className: i.chip,
                style: {
                    backgroundColor: n.Styling.rgba(n.Styling.factoryColor(l), p ? .3 : .1),
                    borderColor: n.Styling.factoryColor(l)
                },
                accessibilityLabel: m.f.l9,
                isDisabled: h,
                onPress: u,
                onMouseEnter: () => g(!0),
                onMouseLeave: () => g(!1),
                children: [(0, c.jsx)(o.default, {
                    name: s,
                    color: d || "onBackground3",
                    size: 18
                }), (0, c.jsx)(a.default, {
                    className: i.text,
                    children: t
                }), h ? null : (0, c.jsx)(o.default, {
                    name: "b",
                    size: 20,
                    color: "onBackground3"
                })]
            })
        }));
        var d = s(1530),
            u = s(494),
            m = s(1531);
        s(9);
        const h = s(495),
            p = e => (0, c.jsx)("div", {
                className: h.root + " " + (e.className || ""),
                style: e.style,
                children: e.children
            }),
            g = n.Hocs.compose(d.p)((e => {
                const {
                    filterState: {
                        filterDueDateRelative: t,
                        filterDueDateOverdue: s,
                        filterDueDate: a,
                        filterDueDateStart: o,
                        filterDueDateEnd: r,
                        filterName: i,
                        filterPriority: d,
                        filterTimeNeeded: h,
                        filterIsShared: g,
                        sort: f,
                        groupBy: b
                    },
                    filterState: y,
                    setFilterState: v,
                    responsibleNames: w,
                    color: k,
                    project: x,
                    projects: j,
                    projectSection: T,
                    tags: S,
                    groups: P
                } = e, _ = n.Hooks.useIntl(), {
                    projectActive: C,
                    projectsActive: R,
                    sectionActive: A,
                    responsibleActive: I,
                    tagsActive: N,
                    dueDateActive: E,
                    dueDateStartActive: O,
                    dueDateEndActive: M,
                    priorityActive: D,
                    timeNeededActive: H,
                    groupsActive: F,
                    isSharedActive: Z,
                    sortActive: L,
                    groupByActive: B
                } = (0, u.De)(y), z = e => v ? () => v(Object.assign({}, y, e)) : void 0;
                return (0, c.jsxs)(p, {
                    className: e.className,
                    style: e.style,
                    children: [i ? (0, c.jsx)(l, {
                        iconName: "$",
                        color: k,
                        value: i,
                        onClear: z({
                            filterName: ""
                        })
                    }) : null, C && x ? (0, c.jsx)(l, {
                        iconName: n.Styling.getProjectIcon(x),
                        color: k,
                        value: n.Styling.getProjectName(x, _),
                        iconColor: null == x ? void 0 : x.color,
                        onClear: z({
                            filterProject: void 0,
                            filterSection: void 0
                        })
                    }) : null, R && j ? (0, c.jsx)(l, {
                        iconName: 1 === j.length ? n.Styling.getProjectIcon(j[0]) : "ů",
                        iconColor: 1 === j.length ? j[0].color : void 0,
                        color: k,
                        value: (0, m.Hd)(_, j),
                        onClear: z({
                            filterProjects: [],
                            filterSection: void 0
                        })
                    }) : null, A ? (0, c.jsx)(l, {
                        iconName: "Ɔ",
                        color: k,
                        value: (0, m.Jp)(_, T),
                        onClear: z({
                            filterSection: void 0
                        })
                    }) : null, I ? (0, c.jsx)(l, {
                        iconName: "ƶ",
                        color: k,
                        value: (0, m.R5)(_, w),
                        onClear: z({
                            filterResponsibles: void 0
                        })
                    }) : null, N ? (0, c.jsx)(l, {
                        iconName: "Ɲ",
                        color: k,
                        value: (0, m.xw)(_, S),
                        onClear: z({
                            filterTags: void 0
                        })
                    }) : null, E || O || M ? (0, c.jsx)(l, {
                        iconName: "R",
                        color: k,
                        value: (0, m.og)({
                            intl: _,
                            filterDueDateRelative: t,
                            filterDueDateOverdue: s,
                            filterDueDate: a,
                            filterDueDateStart: o,
                            filterDueDateEnd: r
                        }),
                        onClear: z({
                            filterDueDateOverdue: !1,
                            filterDueDate: void 0,
                            filterDueDateStart: void 0,
                            filterDueDateEnd: void 0
                        })
                    }) : null, H ? (0, c.jsx)(l, {
                        iconName: "Ƭ",
                        color: k,
                        value: (0, m.xn)(_, h),
                        onClear: z({
                            filterTimeNeeded: void 0
                        })
                    }) : null, D ? (0, c.jsx)(l, {
                        iconName: d ? "Ƙ" : "Ɨ",
                        color: k,
                        value: (0, m.SM)(_, d),
                        onClear: z({
                            filterPriority: void 0
                        })
                    }) : null, F ? (0, c.jsx)(l, {
                        iconName: "½",
                        color: k,
                        value: (0, m.i0)(_, P),
                        onClear: z({
                            filterGroups: void 0
                        })
                    }) : null, Z ? (0, c.jsx)(l, {
                        iconName: "ľ",
                        color: k,
                        value: (0, m.NM)(_, g),
                        onClear: z({
                            filterIsShared: void 0
                        })
                    }) : null, L ? (0, c.jsx)(l, {
                        color: k,
                        value: f ? (0, m._k)(_, f.by, f.order) : "",
                        onClear: z({
                            sort: null
                        }),
                        iconName: "ś"
                    }) : null, B && b ? (0, c.jsx)(l, {
                        color: k,
                        value: (0, m.rZ)(_, b),
                        onClear: z({
                            groupBy: null
                        }),
                        iconName: "V"
                    }) : null]
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            De: () => o,
            MF: () => r,
            Mf: () => a
        });
        var n = s(0);

        function a(e) {
            return function(e) {
                return void 0 !== e
            }(e) && null !== e
        }

        function o({
            filterName: e,
            filterProject: t,
            filterProjects: s,
            filterSection: n,
            filterResponsibles: a,
            filterTags: o,
            filterDueDateOverdue: r,
            filterDueDate: i,
            filterDueDateStart: c,
            filterDueDateEnd: l,
            filterTimeNeeded: d,
            filterPriority: u,
            filterGroups: m,
            filterIsShared: h,
            sort: p,
            groupBy: g,
            disabledOptions: f
        }) {
            return {
                nameActive: !!e,
                projectActive: !!t && !f.includes("project"),
                projectsActive: !(!s || !s.length || f.includes("project") || f.includes("projects")),
                sectionActive: void 0 !== n && !f.includes("section"),
                responsibleActive: void 0 !== a && !f.includes("responsible"),
                tagsActive: !!o && !!o.length && !f.includes("tags"),
                dueDateActive: !(void 0 === i && !r || f.includes("dueDate")),
                dueDateStartActive: void 0 !== c && !f.includes("dueDate"),
                dueDateEndActive: void 0 !== l && !f.includes("dueDate"),
                timeNeededActive: void 0 !== d && !f.includes("timeNeeded"),
                priorityActive: void 0 !== u && !f.includes("priority"),
                groupsActive: !!m && !!m.length && !f.includes("groups"),
                isSharedActive: void 0 !== h && !f.includes("isShared"),
                sortActive: !!p && !f.includes("sort"),
                groupByActive: !!g && !f.includes("groupBy")
            }
        }

        function r(e) {
            return n.FP.values(o(e)).some((e => e))
        }
    }, , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(138),
            o = s(11),
            r = s(13),
            i = s(353),
            c = s(1);
        const l = e => {
            const {
                leftIcon: t,
                iconColor: s
            } = e;
            return (0, c.jsx)("div", {
                className: i.Z.iconContainer,
                children: (0, c.jsx)(r.default, {
                    name: t,
                    color: s,
                    size: 28
                })
            })
        };
        const d = n.Hocs.compose(n.Hocs.memo)((e => {
            n.Hooks.useOnDidLaunch();
            const {
                renderTitle: t,
                renderLeft: s,
                renderRight: r,
                color: d,
                extraText: u,
                onTitlePress: m,
                menuTarget: h,
                onExtraTextPress: p,
                headerRef: g,
                onLeftIconPress: f,
                menuBadge: b
            } = e, {
                darkContent: y,
                backgroundColor: v,
                textColor: w,
                iconColor: k,
                statusBarStyle: x,
                isStatusBarTransparent: j
            } = (e => {
                if (n.Styling.theme.isLight()) {
                    const t = e || "white",
                        s = "white" === t;
                    return {
                        darkContent: s,
                        backgroundColor: t,
                        textColor: s ? "black" : "white",
                        iconColor: s ? "gray6" : "white",
                        statusBarStyle: s ? "dark" : "light",
                        isStatusBarTransparent: "white" === t
                    }
                }
                return {
                    darkContent: !1,
                    backgroundColor: "backgroundPrimary",
                    textColor: e || "textPrimary",
                    iconColor: e || "onBackground3",
                    statusBarStyle: "light",
                    isStatusBarTransparent: !0
                }
            })(d), T = n.Hooks.useLayoutTopInset(), S = e.leftIcon || "_";
            n.Hooks.useStatusBar({
                style: x,
                level: n.Hooks.useStatusBar.levels.main,
                isTransparentAndroid: j
            });
            return (0, c.jsxs)("div", {
                className: i.Z.root,
                style: {
                    backgroundColor: n.Styling.factoryColor(v) || n.Styling.vars.color.surface,
                    height: T + 56,
                    paddingTop: T
                },
                ref: g,
                children: [(0, c.jsxs)("div", {
                    className: i.Z.container + (y ? "" : " " + i.Z.colorHairline),
                    children: [(null == s ? void 0 : s(k)) || (0, c.jsx)(l, {
                        onPress: f,
                        leftIcon: S,
                        iconColor: k
                    }), null, (0, c.jsxs)(o.Z, {
                        className: i.Z.textContainer,
                        isDisabled: !1,
                        onPress: m ? n.ReactUtils.callBoth(m, n.ReactUtils.dismissKeyboard) : void 0,
                        webComponent: "div",
                        children: [t(w), u ? (0, c.jsx)(o.Z, {
                            onPress: p ? e => {
                                n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), p(e)
                            } : void 0,
                            webComponent: "div",
                            children: (0, c.jsx)("span", {
                                className: i.Z.extraText,
                                style: {
                                    color: n.Styling.factoryColor(w)
                                },
                                children: u
                            })
                        }) : null, m ? (0, c.jsx)(a.Z, {
                            color: k,
                            onPress: m,
                            badge: b
                        }) : null]
                    }), r ? r(k) : null, null, h ? (0, c.jsx)("div", {
                        className: i.Z.menuTarget,
                        ref: h
                    }) : null, null]
                }), null]
            })
        }))
    }, , , , , , e => {
        e.exports = {
            a: "Are you sure you want to reject the merge with the {account_email} account?",
            b: "To finish merging the {account_email} account, select which space should receive its tasks.",
            c: "We couldn’t process the merge. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            d: "Select which space to use for the merge.",
            e: "Selected space",
            f: "You can now access tasks from the {account_email} account in the {selected_team} space.",
            g: "Accounts merge",
            h: "Sign up",
            i: "Unlock the power of unlimited productivity and discover task-based communication by registering your Nozbe account. Discover powerful features that won’t be available to you if you continue using Nozbe as a guest. You can sign up for free now or log in to an existing account and retain access to all shared tasks.",
            j: "The task invitation link is incorrect. Please open the invitation link and try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            k: "We couldn’t register your space. Please make sure you’re connected to the Internet, and try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            l: "Sign up for free",
            m: "Looks like you have read everything! Congrats!",
            n: "No new activity",
            o: "Follow projects to receive info about changes in them in your Activity view. You can also mark items as Favorites to place them on top of the main navigation panel.",
            p: "Project created",
            q: "New project created by: {authorName}",
            r: "Project ended",
            s: "Project ended by: {authorName}",
            t: "Project not followed",
            u: "Project restored",
            v: "Project restored by: {authorName}",
            w: "Tasks you have participated in",
            x: "Tasks you are responsible for",
            y: "Activity",
            z: "Add a space",
            A: "Create a space in business",
            B: "Create a New Space",
            C: "and get {credits} credits",
            D: "Create a Personal Space",
            E: "As you already own one free space, we will start the Premium Trial plan for the additional space you create. Trial will be valid until {endDateFormatted}.",
            F: "We couldn’t create a new space. Please check your Internet connection, or try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            G: "You can select the existing members from your {businessName} business and invite them to your new {teamName} space right away.",
            H: "Business members to invite",
            I: "Set up a personal space",
            J: "Plan type: ",
            K: "Your space has been created.",
            L: "Space created",
            M: "Set up a Space",
            N: "You can be a part of multiple spaces that will help you keep things organized! Create a space for your personal tasks, set up an additional space for your business, or join a space using an invite code.\n\nA space in Nozbe is free for up to 3 active projects and 3 people. You can own one Free space.",
            O: "You’re about to create a new space in the {businessName} business. You can create a space for your personal or household tasks. You can also set up an additional space - for example, for your company or department.",
            P: "Something went wrong",
            Q: "Join a Space",
            R: "We couldn’t send the join request. Make sure that you are online, and check if you are entering the correct invite code. If the issue persists, please get in touch with us at support@nozbe.com.",
            S: "We’ve sent your request to join the space. You’ll be notified once the space admin accepts it.",
            T: "Request sent",
            U: "Join a Space",
            V: "Upgrade {teamName} to Premium",
            W: "You can only have 1 Free and/or 1 Trial space. To add another, please upgrade one of your spaces to Premium.",
            X: "You have 1 or more spaces that haven’t been fully created yet. Wait for the process to finish (you need to be online), and then upgrade one to Premium.",
            Y: "Pending Spaces",
            Z: "Limits Exceeded",
            a2: "Loading…",
            a3: "We could not connect to the server. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            a4: "Activate 2FA",
            a5: "Your Two-Factor Authentication (2FA) is active. Thanks for keeping your account safe!",
            a6: "2FA is now active",
            a7: "Add to app",
            a8: "2FA via app",
            a9: "Google Authenticator, 1Password, Authy etc.",
            a$: "Paste or type the code you received in 2FA app.",
            a_: "Paste or type the code you received in SMS.",
            ba: "Activate 2FA via app",
            bb: "Activate 2FA via SMS",
            bc: "Disable 2FA",
            bd: "We couldn’t process your request. Please check your Internet connection and try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            be: "You can activate 2FA using apps like Google Authenticator, 1Password, Authy etc. You can also provide a phone number to activate 2FA using SMS.",
            bf: "Activate 2FA",
            bg: "Choose 2FA method",
            bh: "Two-Factor Authentication (2FA) is an additional layer of security, thanks to which you can be sure that you are the only person that can access your account.",
            bi: "Two-Factor Authentication (2FA)",
            bj: "This is your secret code. Add it to the 2FA app.",
            bk: "Show QR code",
            bl: "Or scan the QR code",
            bm: "Scan the QR code",
            bn: "Add your code to the app",
            bo: "Enter your one-time password",
            bp: "Wrong code. Please try again.",
            bq: "Enter your Nozbe password to unlock 2FA activation methods.",
            br: "Wrong password. Please try again.",
            bs: "Your password",
            bt: "Your Nozbe password",
            bu: "Make sure to enter your contry’s prefix number.",
            bv: "Activate 2FA via SMS",
            bw: "Your phone number (+1 111 111 1111)",
            bx: "Enter your phone number",
            by: "Scan this QR code using your 2FA app",
            bz: "Scan the QR code",
            bA: "Backup codes are used to access your account should you not be able to receive two-factor authentication codes. We recommend saving them in a password manager, such as Lastpass, 1Password, or Keeper.",
            bB: "Backup codes",
            bC: "Please save your backup codes",
            bD: "Set up 2FA",
            bE: "2FA via SMS",
            bF: "You can request a full copy of your account data, including projects, tasks, comments, and attached files. We will send you a single-use download link for the archive via email. You can request one backup at a time.",
            bG: "Include files in the backup",
            bH: "You have already requested a backup. Once the file is ready, we will send you an email with a download link.",
            bI: "Request backup",
            bJ: "We received your backup request. Once the backup file is ready, we will send you an email with a download link.",
            bK: "Include data in CSV format",
            bL: "Advanced",
            bM: "Biometric authentication",
            bN: "Require authentication on launch",
            bO: "Cancel account",
            bP: "Dense layout",
            bQ: "Diagnostics",
            bR: "Enable fuzzy search",
            bS: "Open Source Licenses",
            bT: "App version",
            bU: "Your app is up to date 🎉",
            bV: "Update",
            bW: "Appearance",
            bX: "Change the app icon",
            bY: "Dark sidebar",
            bZ: "Show week numbers in Calendar",
            b0: "Show Nozbe on the menu bar",
            b1: "Show counters in sidebar",
            b2: "Show the Synchronize button in sidebar",
            b3: "App theme",
            b4: "Calendar feed",
            b5: "You can easily integrate Nozbe with your calendar. Just enable the calendar feed below, and paste the generated URL in your calendar app to subscribe to it. All tasks assigned to you with a due date set will show up in your calendar app.",
            b6: "Hide all-day events",
            b7: "Hide completed events",
            b8: "Calendars",
            b9: "Are you sure you want to log out?",
            b$: "Contact us",
            b_: "Copy diagnosis",
            ca: "We couldn’t sync the diagnosis. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            cb: "If you run into technical troubles with Nozbe, our Customer Support team might ask you to run some of these diagnostics to help us resolve the issue. Make sure to send us the diagnosis along with a short description of the issue you experienced.",
            cc: "{count} issues found with this diagnostics tool. Please click “Copy diagnosis” and send it to our Customer Support team for analysis. Thank you!",
            cd: "Diagnostics results",
            ce: "Run basic diagnostics",
            cf: "Run full diagnostics (takes a few minutes)",
            cg: "Thank you! No issues found with this diagnostics tool.",
            ch: "Dropbox",
            ci: "Open the app at startup",
            cj: "App behavior",
            ck: "Now record your own shortcut",
            cl: "Hotkey for Global Quick Add",
            cm: "The shortcut must use at least one modifier key in combination with one other key",
            cn: "Email reports",
            co: "Daily report",
            cp: "Contains a summary of tasks from your Incoming that you should focus on.",
            cq: "Daily space report",
            cr: "Contains a summary of activity in your space.",
            cs: "Reports for {teamName}",
            ct: "Weekly productivity report",
            cu: "Weekly productivity admin report",
            cv: "Contains statistics for your space’s overall productivity, as well as performance and individual statistics for all members. It is available only to the space owner and space admins.",
            cw: "Contains statistics for your productivity and performance in the last week in comparison with the previous week.",
            cx: "Evernote",
            cy: "Google Calendar",
            cz: "Sync your tasks from the {teamName} space in Google Calendar",
            cA: "Google Drive",
            cB: "Help",
            cC: "Help & Contact",
            cD: "Help page",
            cE: "We couldn’t add your token. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            cF: "Add new token",
            cG: "Adding…",
            cH: "Nozbe easily integrates with services like Zapier and others",
            cI: "By default, the API tokens you add will give access only to the space you’re creating them in. To add a token that gives access to all of your spaces, toggle the “Add it as a global token” option.",
            cJ: "Global API tokens",
            cK: "Last used: {date}",
            cL: "Last used: Never",
            cM: "Integrate Nozbe",
            cN: "Remove",
            cO: "API tokens for {teamName} space",
            cP: "Add it as a global token",
            cQ: "New Token",
            cR: "We couldn’t remove your token. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            cS: "Get a unique token for each service you want to integrate Nozbe with. If you no longer require a token, remove it.",
            cT: "API tokens",
            cU: "Log out",
            cV: "You have UNSYNCED changes. Are you sure you want to log out? The changes will be PERMANENTLY lost.",
            cW: "Unsynced comments: {count}",
            cX: "Unsynced projects: {count}",
            cY: "Unsynced tasks: {count}",
            cZ: "Microsoft Teams",
            c0: "News",
            c1: "See what’s new in the app",
            c2: "Badge",
            c3: "All spaces",
            c4: "Email notifications for {teamName}",
            c5: "Group mentions",
            c6: "Mentions",
            c7: "Push notifications for {teamName}",
            c8: "System",
            c9: "Open system settings",
            c$: "OneDrive",
            c_: "Outlook Calendar",
            da: "Sync your tasks from the {teamName} space in Outlook Calendar",
            db: "Settings",
            dc: "Two-factor authentication",
            dd: "{teamName} backup",
            de: "Change email address",
            df: "We couldn’t change your email address. This address is already in use.",
            dg: "Change email address",
            dh: "New email address",
            di: "Repeat new email address",
            dj: "To confirm, enter your password",
            dk: "Language",
            dl: "Change password",
            dm: "Are you sure you want to change your password? You will need to log in again on all devices.",
            dn: "Current password",
            do: "Wrong password",
            dp: "Changing password – please wait…",
            dq: "New password",
            dr: "Repeat new password",
            ds: "Change theme",
            dt: "Switch theme when your system does",
            du: "Dark",
            dv: "Light",
            dw: "General",
            dx: "Integrations",
            dy: "API tokens",
            dz: "Notifications",
            dA: "Profile",
            dB: "Referral program",
            dC: "Add Referrer",
            dD: "In order to add your referrer, type in their Referral ID or the entire referral link below and confirm. Once we verify that it’s correct, the information about your referrer will be automatically applied.",
            dE: "Download ready-made banners to promote Nozbe and earn more commissions",
            dF: "Banners",
            dG: "We couldn’t change your referral code. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            dH: "Change testimonial",
            dI: "Your testimonial can be max. 1000 characters long, and should not contain any HTML or Markdown.",
            dJ: "We couldn’t save your testimonial. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            dK: "Here you can write down the reason why you would recommend Nozbe to others",
            dL: "Testimonial saved.",
            dM: "Referral code updated.",
            dN: "Provided referral code is not available",
            dO: "Contact Support",
            dP: "Copy link",
            dQ: "Your credits",
            dR: "Credits available",
            dS: "Credits pending",
            dT: "Credits total",
            dU: "Tell people about a more efficient way to get stuff done in thanks to Nozbe and get 25% credit when they become paying customers.",
            dV: "Edit",
            dW: "In order to change the link, please edit the input below and verify it. The link will be automatically updated if it is available for use.",
            dX: "Change link",
            dY: "Check out Nozbe: {referralLink}",
            dZ: "Email link",
            d0: "Nozbe - a modern way to get stuff done",
            d1: "Extending…",
            d2: "To claim your credits, please update your payment details and switch from in-app payments to our payment system. You will save 20% when choosing a yearly plan!",
            d3: "Your referral link",
            d4: "You can use your credits to buy or extend the Nozbe Premium subscription for your space. You can also pay it out as cash via PayPal by contacting our support. Pending credits can be used within 30 days from the payment date.",
            d5: "Extend your Premium plan",
            d6: "You can use your accumulated credits ({creditsAvailable}) to extend your space’s plan by {days} days. This would extend your space’s Nozbe Premium plan until: {expiresAt}.",
            d7: "We couldn’t extend your space’s Premium plan. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            d8: "Premium plan has been extended.",
            d9: "Upgrade to Premium plan",
            d$: "You can use your accumulated credits ({creditsAvailable}) to upgrade your space’s plan to Nozbe Premium {teamMembersLimit} with unlimited projects and all premium features for {days} days. Your new Nozbe Premium {teamMembersLimit} plan would be valid until {expiresAt}",
            d_: "We couldn’t upgrade your space’s plan to Premium. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            ea: "Your space’s plan has been upgraded to Premium.",
            eb: "Referrer",
            ec: "Are you sure you want to add the {referrerCode} referrer to your account? After we verify the code, you won’t be able to change it.",
            ed: "Give some extra credits to the person who referred you to Nozbe. This option will remain active for up to 30 days after you upgrade your plan to Premium.",
            ee: "The referrer ID you’ve entered is invalid or doesn’t exist.",
            ef: "We couldn’t add your referrer. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            eg: "You used the following referral code to register your account.",
            eh: "Share link",
            ei: "Join Nozbe",
            ej: "Switch Payment System",
            ek: "To switch to our payment system, you will need to purchase the Premium plan using the button below. We will automatically extend your space’s Premium plan by the remaining time from your previous payment. Then you will be able to spend your credits to extend it even further. You can also save 20% by buying the Premium plan for a year!",
            el: "Link",
            em: "Credits",
            en: "Testimonial",
            eo: "You can show your testimonial (alongside your name and avatar) to anyone who visits your referral link.",
            ep: "Referral program",
            eq: "Upgrading…",
            er: "Thank you for adding your referrer. Keep spreading the word about Nozbe! We’ve granted you extra credits to keep you going.",
            es: "Rate us",
            et: "Keyboard shortcuts",
            eu: "Show the app tour again",
            ev: "Slack",
            ew: "Stats",
            ex: "Synchronize",
            ey: "Space settings for {teamName}",
            ez: "My Nozbe Settings",
            eA: "Restart and apply update",
            eB: "Credit card expires before the next plan renewal",
            eC: "Update payment method",
            eD: "This advanced feature allows you to integrate Nozbe with other apps by calling special URLs.",
            eE: "Enable x-callback-url automation",
            eF: "Automate with x-callback-url",
            eG: "You can use apps like Shortcuts (iOS), Automate, or Tasker (Android) to automate adding tasks, opening specific views, etc. Learn more on our Help Page.",
            eH: "Zapier",
            eI: "Nozbe",
            eJ: "Downloading…",
            eK: "File couldn’t be downloaded. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            eL: "Add files",
            eM: "Drop files here to add them to your comment",
            eN: "File can’t be larger than {maxSize} on the Free plan. To increase the file size limit, upgrade your plan to Premium.",
            eO: "File can’t be larger than {maxSize}",
            eP: "Download",
            eQ: "The file could not be downloaded. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            eR: "This file can’t be previewed in Nozbe anymore. You can still open it using the link.",
            eS: "The preview for this file could not be loaded.",
            eT: "Open in browser",
            eU: "Open file in Dropbox",
            eV: "Open in Evernote",
            eW: "Open file in Google Drive",
            eX: "Open file in OneDrive",
            eY: "Open in Vimeo",
            eZ: "Open in YouTube",
            e0: "Preparing preview…",
            e1: "Show all attachments",
            e2: "Are you sure you want to remove this file?",
            e3: "File unavailable: {fileName}",
            e4: "Waiting for upload…",
            e5: "Processing file…",
            e6: "Uploading…",
            e7: "Start typing to search for parameters",
            e8: "Are you sure you want to remove this user’s admin status? This user will no longer be able to manage the business settings and add or remove spaces.",
            e9: "Are you sure you want to promote this user to admin? Admins can add and remove spaces, as well as gain admin privileges for all spaces belonging to the business.",
            e$: "Please wait…",
            e_: "Accept",
            fa: "Add",
            fb: "Add next",
            fc: "Archive",
            fd: "Back",
            fe: "Cancel",
            ff: "Change",
            fg: "Clone",
            fh: "Close",
            fi: "Confirm",
            fj: "Continue",
            fk: "Convert into a project",
            fl: "Copied",
            fm: "Copy",
            fn: "Create",
            fo: "Decline",
            fp: "Delete",
            fq: "Disable",
            fr: "Done",
            fs: "Download",
            ft: "Download all",
            fu: "Edit",
            fv: "Enable",
            fw: "Extend",
            fx: "Follow",
            fy: "Got it",
            fz: "Invite",
            fA: "Keep",
            fB: "Later",
            fC: "Learn more",
            fD: "Next",
            fE: "Notify space owner",
            fF: "OK",
            fG: "Premium",
            fH: "Preview",
            fI: "Read",
            fJ: "Read More",
            fK: "Reject",
            fL: "Remove",
            fM: "Rename",
            fN: "Resend",
            fO: "Opt out",
            fP: "Restore",
            fQ: "Retry",
            fR: "Reviewed",
            fS: "Save",
            fT: "Search",
            fU: "Select a file",
            fV: "Select all",
            fW: "Send",
            fX: "Sent!",
            fY: "Set",
            fZ: "Set color",
            f0: "Set icon",
            f1: "Share",
            f2: "Show in sidebar",
            f3: "Skip",
            f4: "Try again",
            f5: "Upgrade",
            f6: "Upload",
            f7: "Verify",
            f8: "Verifying…",
            f9: "View",
            f$: "Write a review",
            f_: ", Week {weekOfMonth}",
            ga: "Show the next 30 days",
            gb: "Show a week",
            gc: "Next 30 days",
            gd: "Today",
            ge: "Tomorrow",
            gf: "Cancel account",
            gg: "You will lose access to this space and delete your Nozbe account. This cannot be undone.",
            gh: "WARNING: This will permanently delete your whole account and all your spaces. All space members will lose access to them. All projects, tasks, and all other data will be deleted. This cannot be undone. Are you sure you want to delete your account?",
            gi: "Account downgrade possibilities",
            gj: "We couldn’t cancel your account. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            gk: "Wrong password. Please try again.",
            gl: "We couldn’t transfer your private projects to the owner. Please check the projects you want to transfer and try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            gm: "To cancel your account, turn off the auto-renewal of your subscription first. Go to Settings → Change plan and turn off the auto-renewal, then try again.",
            gn: "An unknown error occurred. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            go: "Your account has been canceled. Please leave us feedback about our service.",
            gp: "Your account has been canceled.",
            gq: "Enter your password",
            gr: "Transfer projects",
            gs: "Before you cancel your account, you can transfer your private projects to the space owner. Untransferred projects will be deleted.",
            gt: "Why do you want to cancel your account?",
            gu: "Contact Customer Support to check the downgrade options.",
            gv: "I want to downgrade my account",
            gw: "You can leave a space at any time without canceling your account.",
            gx: "I want to leave this space",
            gy: "Change your email address. You can update this information at any time.",
            gz: "I want to use a different email address for my account",
            gA: "Remove your account and give us feedback. We’ll be very sorry to see you go. Please let us know how we can improve our service.",
            gB: "Other",
            gC: "We’re sorry to see you go. Please help us improve Nozbe and tell us why you’re canceling your account. Your feedback will help us make Nozbe better in future.",
            gD: "Why are you canceling your Nozbe account?",
            gE: "One thing before you go…",
            gF: "Change contact info",
            gG: "Something went wrong. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            gH: "To claim the Nozbe Premium subscription for a space, you need to be the owner of one. Please create a new space, and then try claiming the subscription again. If the issue persists, please get in touch with us at support@nozbe.com.",
            gI: "This purchase cannot be claimed. You may have already claimed this subscription. If not, please get in touch with us at support@nozbe.com.",
            gJ: "Pick a space you wish to upgrade to Nozbe Premium.",
            gK: "Nozbe Premium was granted to the {teamName} space.",
            gL: "Claim Nozbe Premium",
            gM: "Clone active tasks only",
            gN: "Clone pinned comments only",
            gO: "Reference date",
            gP: "We will use the reference date as a base to set relative dates for tasks in the created project",
            gQ: "Selected project",
            gR: "Selected project section",
            gS: "Reload app",
            gT: "We couldn’t perform this action. Please try again. If this issue persists, please reload the app or contact us at support@nozbe.com.",
            gU: "Add your comment or upload a file",
            gV: "Use @mention to notify someone",
            gW: "Type in your message",
            gX: "New comment",
            gY: "{attachmentCount, plural,\n    one {Attachment}\n    other {Attachments}}\n  ",
            gZ: "Deleted comment",
            g0: "Pinned",
            g1: "(Note: rest of the comment is in the attachment)",
            g2: "You’re editing this comment",
            g3: "Editing",
            g4: "edited",
            g5: "{name} (imported)",
            g6: "Unsaved changes",
            g7: "Are you sure you want to delete this comment?",
            g8: "Are you sure you want to discard unsaved changes in this comment?",
            g9: "All formatting will be lost if you edit this comment. Are you sure you want to proceed?",
            g$: "Copy",
            g_: "Create a task from this comment",
            ha: "By @{authorName}",
            hb: "Comment from: {taskLink}",
            hc: "Create a task from this message",
            hd: "Discard changes",
            he: "Imported from {source} by {author}",
            hf: "Mark as unread",
            hg: "Make editable by others",
            hh: "Anyone with access to this task will be able to edit this comment. It will also get pinned automatically. This cannot be undone. Are you sure you want to proceed?",
            hi: "Open in {app}",
            hj: "Pin",
            hk: "Reply",
            hl: "Restore",
            hm: "Unpin",
            hn: "Formatted using {markdown}",
            ho: "Comment preview",
            hp: "This will notify everyone in your space who has access to this project. Are you sure you want to do this?",
            hq: "By using @following, you will notify everyone who follows this project. Are you sure you want to do this?",
            hr: "Hide completed",
            hs: "Show all completed",
            ht: "We couldn’t send your question. Please try sending your message again, or contact us by email: {supportEmail}",
            hu: "Got any questions, feedback, or noticed a bug? Get in touch with us! We will reply to you as soon as possible, usually within a few hours.",
            hv: "Write us a message",
            hw: "Run and attach full diagnosis",
            hx: "We have received your message. Our customer support team will email you back shortly.",
            hy: "Thank you!",
            hz: "What can we help you with?",
            hA: "Account question",
            hB: "Subscription & billing question",
            hC: "Feature request",
            hD: "Feedback",
            hE: "Technical issue",
            hF: "Other question",
            hG: "I have a…",
            hH: "With this integration, you can connect Nozbe with Microsoft Teams to streamline collaboration: turn conversations into tasks, share updates directly in channels, and keep your team aligned without switching tools.",
            hI: "With this integration, you can automate Nozbe with hundreds of apps—no coding needed. Create Zaps that turn events in one app into actions in Nozbe.",
            hJ: "Connect your Dropbox account with Nozbe to attach your files to tasks.",
            hK: "Later",
            hL: "A new version has been downloaded. Restart Nozbe to apply the update.",
            hM: "Restart",
            hN: "Nozbe update available",
            hO: "Would you like Nozbe to be moved to the Applications folder? This might require an administrator password.",
            hP: "Do not move",
            hQ: "Move to Applications",
            hR: "Move to the Applications folder?",
            hS: "About Nozbe",
            hT: "Close window",
            hU: "Edit",
            hV: "Copy",
            hW: "Cut",
            hX: "Delete",
            hY: "Paste",
            hZ: "Paste and match style",
            h0: "Redo",
            h1: "Select all",
            h2: "Undo",
            h3: "File",
            h4: "Hide Nozbe",
            h5: "Hide others",
            h6: "Quick Add Hotkey",
            h7: "Quit Nozbe",
            h8: "Services",
            h9: "Show all",
            h$: "View",
            h_: "Reload",
            ia: "Force Reload",
            ib: "Toggle Fullscreen",
            ic: "Zoom",
            id: "Zoom In",
            ie: "Zoom Out",
            if: "Reset Zoom",
            ig: "Window",
            ih: "Bring All to Front",
            ii: "Minimize",
            ij: "Window",
            ik: "Zoom",
            il: "Do you want to try reloading the app?",
            im: "Nozbe has become unresponsive",
            in: "15 minutes",
            io: "1 day",
            ip: "1 hour",
            iq: "1 minute",
            ir: "4 hours",
            is: "Email to Nozbe",
            it: "Add to contacts",
            iu: "Add comments via email",
            iv: "You can now add comments by sending an email to {email}",
            iw: "Deactivate adding comments via email",
            ix: "We couldn’t deactivate adding comments via email. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            iy: "Copy to clipboard",
            iz: "We couldn’t generate the email address. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            iA: "Generate new email address",
            iB: "Add tasks via email",
            iC: "You can now add tasks by sending an email to {email}",
            iD: "Deactivate adding tasks via email",
            iE: "We couldn’t deactivate adding tasks via email. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            iF: "Go to my Activity",
            iG: "Go to my Incoming",
            iH: "Go to my Priority",
            iI: "Invite members",
            iJ: "Add your",
            iK: "first task!",
            iL: "Create a new account or log in to the existing one. All shared tasks will be added to it automatically.",
            iM: "Log in to an existing Nozbe account. All shared tasks will be added to it automatically.",
            iN: "Confirming email change…",
            iO: "We couldn’t confirm your email address change. The link may have expired - please try changing your email address again. If the issue persists, please get in touch with us at support@nozbe.com.",
            iP: "You need to log in using the old email address to confirm the change.",
            iQ: "Email changed. You can now log in using the new email address.",
            iR: "Enter your email address",
            iS: "You’ve been invited to {teamName}.\nSign up to create a new account and join the team.",
            iT: "You’ve been invited to {teamName} by {inviterName} ({inviterEmail}). If you already have an account, you can log in to accept the invitation. Otherwise, sign up to create a new account and join the space.",
            iU: "{inviterName} ({inviterEmail}) invited you to join the {teamName} space. Log in to accept the invitation.",
            iV: "You’ve been invited to {teamName}.\nTo join {teamName}, you have to log out and create a new account.",
            iW: "You’ve been invited to a new space. To join it, you have to log out and create a new account.",
            iX: "You’re requesting to join a new space using invite code. If you already have an account, you can log in to send the request. Otherwise, sign up to create a new account and join the space. After sending the request, you’ll need to wait for approval from one of the team’s admins.",
            iY: "You’re requesting to join a new space using the invite code. Log in to send the request. After sending the request, you’ll need to wait for the approval from one of the space’s admins.",
            iZ: "You have been invited by {inviterEmail} to share a project in Nozbe. You need to have an account in Nozbe in order to see the invitation. If you already are using Nozbe, simply log in to your account. Otherwise, you can accept the invitation by creating a new account.",
            i0: "{inviterEmail} invited you to share a project in Nozbe. Log in to accept the invitation.",
            i1: "You have been invited by {inviterEmail} to share a task in Nozbe. You can accept the invitation by logging into an existing account or registering a new one.",
            i2: "The invitation to a shared task has already been accepted. Log in to your Nozbe account to view your shared tasks.",
            i3: "{inviterEmail} invited you to share a task in Nozbe. Log in to accept the invitation.",
            i4: "Log in",
            i5: "Enter the 6-digit code from your authenticator app or SMS. Can’t access them? Use a recovery code.",
            i6: "Provide one-time password",
            i7: "A server error occurred. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            i8: "Wrong password or email address",
            i9: "You are trying to log in to Nozbe using Nozbe Classic credentials. To log in to Nozbe Classic, go to {appUrl}",
            i$: "We couldn’t verify your {provider, select, apple {Apple} google {Google} other {3rd party}} account. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            i_: "Unable to connect to server. Please check your Internet connection, or contact us at support@nozbe.com.",
            ja: "We couldn’t log you in - too many login attempts. Please wait a few minutes and try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            jb: "Logging in…",
            jc: "We will now ask your permission to send notifications so that you could receive reminders, notifications about tasks assigned to you, and @mentions.",
            jd: "Notifications",
            je: "It seems that you already have an account registered with this email address. Click the “Login” button to log in using your email and password.",
            jf: "It seems that you already have an account registered with this email address. We’ve emailed you a link that will allow you to log in using this method.",
            jg: "Forgot your password?",
            jh: "Sign up",
            ji: "Accept project invitation",
            jj: "Sign in with Apple",
            jk: "Continue with Apple",
            jl: "Sign up with email",
            jm: "Continue with email",
            jn: "Google Sign In",
            jo: "Continue with Google",
            jp: "Join a space",
            jq: "To import your data, log in to your Nozbe Classic account using the form below.",
            jr: "The credentials are incorrect. Please verify your email address and password, and try again.",
            js: "Start the data import",
            jt: "The import for this account has already been completed. We sent you an email with a link to set a new password for the imported account. Use it to log in to the new Nozbe. If you want to import separate projects, you can do so within the new Nozbe app. If you wish to import this account again, please get in touch with our support team at questions@nozbe.com.",
            ju: "We’ve started the import of your data. Once it’s done, we’ll email you so you can set up a password for your account in the new Nozbe.",
            jv: "Password for your Nozbe Classic account",
            jw: "Import data from Nozbe Classic",
            jx: "Show more options",
            jy: "Your Name",
            jz: "Enter your name",
            jA: "Launch app",
            jB: "If you already have the app",
            jC: "Download app",
            jD: "To log in to Nozbe, use our mobile app",
            jE: "To fully enjoy Nozbe on your device, download our app",
            jF: "Get our mobile app",
            jG: "What’s the name of your company, department, or group?",
            jH: "Choose from contacts",
            jI: "Enter the email addresses of people you wish to invite.\nTip: You can add multiple addresses separated by commas, new lines, or spaces.",
            jJ: "Add {memberCount, plural,\n    one {{memberCount} member}\n    few {{memberCount} members}\n    other {{memberCount} members}} to space",
            jK: "Add new space members",
            jL: "Free",
            jM: "Premium Trial",
            jN: "john@mail.com",
            jO: "Another email",
            jP: "By adding {invitesCount} space members you’ll automatically start Premium Trial plan. Trial is valid until {endDateFormatted}. You can change your subscription details later.",
            jQ: "Starting Trial",
            jR: "I don’t need that",
            jS: "My space",
            jT: "My Nozbe",
            jU: "Enter the name of your personal space",
            jV: "Enter the name of your space",
            jW: "It looks like you’ve provided the wrong invite code too many times. Ask the space’s admin to invite you to Nozbe using your email address.",
            jX: "You have logged in, but you’ll need to wait until the space owner accepts you as a new space member.",
            jY: "Watch tutorial",
            jZ: "Learn the basics of Nozbe while waiting.",
            j0: "Waiting for the space owner’s action",
            j1: "You own an account in Nozbe Classic. Would you like to import your data from Nozbe Classic to Nozbe, create a new Nozbe account from scratch, or log in to Nozbe Classic?",
            j2: "Log in to Nozbe Classic",
            j3: "Import data from Nozbe Classic",
            j4: "Register a new account",
            j5: "Enter your password",
            j6: "Repeat password",
            j7: "Check your mailbox",
            j8: "Reset password",
            j9: "Reset",
            j$: "Your password has been changed.",
            j_: "If you’ve lost your password or wish to change it, type your email address below. We will send you instructions on how to reset it.",
            ka: "Verifying…",
            kb: "Your password reset link is invalid or expired",
            kc: "Verifying…",
            kd: "Your account has been created, but the invite code you’ve provided is invalid. Please log in and try again.",
            ke: "We couldn’t confirm your registration. Perhaps you are offline, or the link has expired.",
            kf: "Provide the invite code that was given to you by space admin to join the space!",
            kg: "Invite code",
            kh: "One last step before you can use Nozbe",
            ki: "To confirm your new account, you need to log out first.",
            kj: "Your email address has been confirmed.",
            kk: "Set avatar",
            kl: "Set avatar",
            km: "All set!",
            kn: "We couldn’t sign you up. You may be offline, the invitation may have expired, or you may be using a different email address than before. If the issue persists, please get in touch with us at support@nozbe.com.",
            ko: "This email address is already linked to an existing account. To join this space, log in to that account or create a new one by using a different email address.",
            kp: "The login link you used is invalid. Please try signing in one more time or contact us at support@nozbe.com.",
            kq: "The project invitation you received is invalid or has expired. Please try requesting a new invitation or contact us at support@nozbe.com.",
            kr: "Accept All",
            ks: "Accept Terms",
            kt: "By creating a Nozbe account, you need to agree to our Terms of Service and Privacy Policy.",
            ku: "I want to receive practical productivity-related newsletter and sneak peeks at Nozbe deals every few weeks. No spam. No third-parties involved.",
            kv: "We also recommend to agree to receive practical productivity-related newsletter and sneak peeks at Nozbe deals every few weeks. No spam. No third-parties involved.",
            kw: "Privacy Policy",
            kx: "https://nozbe.com/terms#privacy",
            ky: "Terms of Service",
            kz: "https://nozbe.com/terms",
            kA: "Verifying…",
            kB: "Your registration link is invalid or has expired. Please try signing up one more time or contact us at support@nozbe.com.",
            kC: "We’ve sent an email to {email}.\n Check your mail and confirm your address.",
            kD: "Open your email app",
            kE: "Mail",
            kF: "Send again",
            kG: "Verify your email address",
            kH: "the fastest way to DONE!",
            kI: "Nozbe helps you work calmly, with all communication organized in projects, tasks, and comments.",
            kJ: "Welcome to Nozbe",
            kK: "Focus on what’s important",
            kL: "Something went wrong with {name}. Please log out, then log in again. If the issue persists, please contact us at support@nozbe.com.",
            kM: "We’re very sorry about this. Try going back or reloading the app.",
            kN: "If the issue persists, please contact us at support@nozbe.com.",
            kO: "Something went wrong",
            kP: "Reload the app",
            kQ: "{name} crashed.",
            kR: "Error",
            kS: "Log out and log in",
            kT: "Our server couldn’t process your request. This may be a temporary situation. Please try again in a few minutes or contact support@nozbe.com if the issue persists.",
            kU: "A network error prevented the action from being completed. Make sure you’re online and that your Internet connection isn’t broken. If the issue persists, please get in touch with us at support@nozbe.com.",
            kV: "Only space admins and project managers can do that.",
            kW: "It seems that our servers are currently offline. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            kX: "Your app seems to be making a lot of requests to our servers right now. We’ll be temporarily rejecting them to keep our service operational. Please wait a few minutes and try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            kY: "We encountered an unknown issue. Please contact us at support@nozbe.com.",
            kZ: "Connect your Evernote account with Nozbe now and gain access to your notes and reminders.",
            k0: "Sync Evernote reminders",
            k1: "Export to CSV",
            k2: "Would you like to send us feedback on what we can do better?",
            k3: "Would you like to send us your feedback on what we can do to make Nozbe even better?",
            k4: "We are sorry to hear that.",
            k5: "We are glad to hear that!",
            k6: "Send Feedback",
            k7: "How are you enjoying Nozbe?",
            k8: "If you have a few minutes to spare, please write us a review on G2.",
            k9: "We are glad that you enjoy using Nozbe!",
            k$: "Review us on G2",
            k_: "You received {value} worth of Nozbe Credits for your hard work.",
            la: "Check out your credits",
            lb: "Congratulations!",
            lc: "Receive the reward",
            ld: "Do you want to opt out of this challenge? You will miss out on the chance to get Nozbe Premium Credits!",
            le: "A challenge for you!",
            lf: "General",
            lg: "Go",
            lh: "Favorite #1",
            li: "Favorite #2",
            lj: "Favorite #3",
            lk: "Favorite #4",
            ll: "Forward",
            lm: "Jump to",
            ln: "Search",
            lo: "Shortcuts help",
            lp: "List",
            lq: "Close new task",
            lr: "New Task…",
            ls: "New Window",
            lt: "Synchronize",
            lu: "Task",
            lv: "Mark as Abandoned",
            lw: "Add Comment",
            lx: "Change Responsible",
            ly: "Change Due Date",
            lz: "Change Project",
            lA: "Change Reminders",
            lB: "Change Section",
            lC: "Change Tags",
            lD: "Change Time Needed",
            lE: "Change Time Spent",
            lF: "Close task",
            lG: "Toggle fullscreen mode",
            lH: "Mark as Completed",
            lI: "Restore",
            lJ: "Next",
            lK: "Previous",
            lL: "Rename task",
            lM: "Toggle task priority",
            lN: "Toggle Bold",
            lO: "Comment Preview",
            lP: "Toggle Italic",
            lQ: "Spaces",
            lR: "Connect your Google Drive account with Nozbe to attach your files to tasks.",
            lS: "Are you sure you want to permanently delete this group?",
            lT: "Create new group",
            lU: "Manage members",
            lV: "Manage projects",
            lW: "Group name",
            lX: "Group name",
            lY: "Everyone can see this group",
            lZ: "Who can see this group",
            l0: "Only you can see this group",
            l1: "Manage projects",
            l2: "Learn more about {viewName}",
            l3: "Hint: ",
            l4: "Learn more about recurring tasks",
            l5: "After a user signs up with the invite code, the admin will need to confirm the invitation in the Space view.",
            l6: "Go to next month",
            l7: "Go to previous month",
            l8: "Go to today",
            l9: "Clear",
            l$: "Attach content",
            l_: "Add attachment",
            ma: "Download attachment {fileName}",
            mb: "Remove attachment {fileName}",
            mc: "Add bullet list",
            md: "Attach a photo",
            me: "Add checklist",
            mf: "Attach Dropbox file",
            mg: "Attach Evernote note",
            mh: "Toggle focus mode",
            mi: "Attach Google Drive file",
            mj: "Add mention",
            mk: "Add task or list link",
            ml: "Add numbered list",
            mm: "Attach OneDrive file",
            mn: "Attach a file from Photo library",
            mo: "Save comment",
            mp: "Go back",
            mq: "Hide",
            mr: "Visit our help page to learn more",
            ms: "Add new task with file",
            mt: "Add new project section",
            mu: "Open menu",
            mv: "Drag and drop task",
            mw: "Set due date",
            mx: "Set task parameters with autocomplete",
            my: "Add new task to the bottom",
            mz: "Add new task to the top",
            mA: "Mark task as Priority",
            mB: "Remove task from Priority",
            mC: "Add reminder",
            mD: "Task parameters",
            mE: "Create a tag",
            mF: "Add new task",
            mG: "Follow project",
            mH: "Revoke task access",
            mI: "Cancel search",
            mJ: "Add new task to section",
            mK: "Mark tasks in this group as read",
            mL: "Mark group as reviewed",
            mM: "Open sidebar",
            mN: "Collapse sidebar",
            mO: "Expand sidebar",
            mP: "Add new member",
            mQ: "Invite new member to your space",
            mR: "Collapse section",
            mS: "Expand section",
            mT: "Close task details",
            mU: "Complete task",
            mV: "Exit fullscreen mode",
            mW: "Check why task is in your Incoming",
            mX: "Show only pinned comments",
            mY: "Previous occurrence of this task wasn’t completed",
            mZ: "Next task",
            m0: "Previous task",
            m1: "Restore task",
            m2: "Assign task",
            m3: "Create a new template",
            m4: "Send a new message",
            m5: "App key for {importSite}",
            m6: "We’ve started importing your data. This may take a while. Once the process is finished, we will notify you via email.",
            m7: "You are going to import all the data from {importSite} to {teamName}",
            m8: "Learn more",
            m9: "Provide the key generated in {importSite}",
            m$: "{importSite} Login",
            m_: "{importSite} Password",
            na: "Start the import",
            nb: "Import from {importSite}",
            nc: "Add to Priority",
            nd: "You have {tasksCount, plural, one {one task} other {{tasksCount} tasks}} delegated to you that are not set as Priority. Would you like to add {tasksCount, plural, one {it} other {them}} to Priority?",
            ne: "You have {tasksCount, plural, one {one task} other {{tasksCount} tasks}} due today that {tasksCount, plural, one {is} other {are}} not marked as Priority. Would you like to add {tasksCount, plural, one {it} other {them}} to Priority?\n",
            nf: "You have {tasksCount, plural, one {one task with a mention} other {{tasksCount} tasks with mentions}} that {tasksCount, plural, one {is} other {are}} not marked as Priority. Would you like to add {tasksCount, plural, one {it} other {them}} to Priority?\n",
            ng: "You have {tasksCount, plural,\n    one {one overdue task}\n    other {{tasksCount} overdue tasks}\n} that {tasksCount, plural, one {is} other {are}} not marked as Priority. Would you like to add {tasksCount, plural, one {it} other {them}} to Priority?",
            nh: "You have {tasksCount, plural, one {one task with a reminder} other {{tasksCount} tasks with reminders}} for today that {tasksCount, plural, one {is} other {are}} not marked as Priority. Would you like to add {tasksCount, plural, one {it} other {them}} to Priority?",
            ni: "Assigned to you",
            nj: "Choose which tasks from Incoming are automatically added to your Priority view",
            nk: "Due today",
            nl: "Prioritize automatically",
            nm: "You were mentioned in",
            nn: "Overdue",
            no: "Today’s reminders",
            np: "Assigned to you",
            nq: "Due today",
            nr: "Looks like you have reviewed everything! Congrats!",
            ns: "Nothing to review",
            nt: "You were mentioned in",
            nu: "Recently added",
            nv: "Notifications",
            nw: "Ignore",
            nx: "Overdue",
            ny: "Incoming",
            nz: "Enable integration",
            nA: "All spaces",
            nB: "This space only",
            nC: "Choose whether to disable this integration in all spaces or only in the {teamName} space.",
            nD: "Enable integration in all spaces",
            nE: "Done! Your account is now connected to {name}.",
            nF: "Dropbox integration",
            nG: "All set! Your Dropbox account is connected. You can now attach files in {teamCount, plural, one {the {teamName} space} other {all your spaces}} in Nozbe.",
            nH: "Choose Dropbox files",
            nI: "It seems that you didn’t finish the authorization. Please try to go back and authorize one more time. If the issue persists, please get in touch with us at support@nozbe.com.",
            nJ: "Our servers couldn’t confirm the integration. This may be a temporary situation, so please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            nK: "The integration you’re trying to authorize is currently not supported by Nozbe.",
            nL: "Evernote integration",
            nM: "Done! Your account is now connected to Evernote. You can now use your notes and see your Evernote reminders in the {teamName} space in Nozbe.",
            nN: "Available files",
            nO: "Folder is empty",
            nP: "No files chosen yet",
            nQ: "Previous folder",
            nR: "Main folder",
            nS: "Search files",
            nT: "Chosen files",
            nU: "Done! Your account is now connected to Google Calendar. Tasks with due dates from the {teamName} space that are assigned to you are now synchronized with your Google Calendar.",
            nV: "Google Drive integration",
            nW: "All set! Your Google Drive is now connected. You can attach files in {teamCount, plural, one {the {teamName} space} other {all your spaces}} in Nozbe.",
            nX: "Choose Google Drive files",
            nY: "Microsoft Teams integration",
            nZ: "OneDrive integration",
            n0: "All set! Your OneDrive is connected. You can now use your files in {teamCount, plural, one {the {teamName} space} other {all your spaces}} in Nozbe.",
            n1: "Choose OneDrive files",
            n2: "Succcess! Your account is now connected to Outlook Calendar. Tasks with due dates from the {teamName} space that are assigned to you are now synchronized with your Outlook Calendar.",
            n3: "Disable integration",
            n4: "Choose whether to disable the integration in all spaces or only in the {teamName} space.",
            n5: "Disable integration in all spaces",
            n6: "Are you sure you want to disable the integration in all spaces?",
            n7: "Are you sure you want to disable the integration in {teamName} space?",
            n8: "Slack integration",
            n9: "Unknown integration",
            n$: "Zapier integration",
            n_: "Unknown link",
            px: "Are you sure you want to hide your request to join a space using the {inviteCode} code? You won’t be able to track the request’s status.\nYour request will remain active, and the space admin will still be able to accept or reject it.",
            py: "You’ve requested to join a space using the {inviteCode} code. Your request has to be accepted by one of the space’s admins.",
            pz: "Your request to join a space using the {inviteCode} code has been rejected by the admin.",
            pA: "Use ⬆ & ⬇ to navigate, and ↩ to jump",
            pB: "Jump to projects, tags, users, and more",
            pC: "member",
            pD: "project",
            pE: "section",
            pF: "tag",
            pG: "task",
            pH: "Search {queryText} in comments",
            pI: "Search in comments",
            pJ: "Search {queryText} in completed tasks",
            pK: "Search in completed tasks",
            pL: "Jump to",
            pM: "Jump to space member",
            pN: "Jump to project",
            pO: "Jump to section",
            pP: "Jump to tag",
            pQ: "Jump to task",
            pR: "System language",
            pS: "Select the color that will be used to identify spaces belonging to the business.",
            pT: "Add spaces",
            pU: "Are you sure you want to add the following spaces to {businessName} business?",
            pV: "Select spaces that should be added to {businessName} business.",
            pW: "Create new space",
            pX: "Join space",
            pY: "Are you sure you want to join the {teamName} space in {businessName} business? After confirming, you will be automatically logged out and in again.",
            pZ: "Move space out of business",
            p0: "Are you sure that you want to move out the {teamName} space out of the {businessName} business? The space will be granted a one-day trial, so you can still use it outside of your business.",
            p1: "Move out",
            p2: "The {teamName} space is the last space inside of the {businessName} business. Moving it out will convert the space to Premium and will close the business. Are you sure you want to continue?",
            p3: "Space settings",
            p4: "Manage business",
            p5: "Add to business",
            p6: "Are you sure you want to add the {teamName} space to the {businessName} business?",
            p7: "{teamName} space is already a part of the {businessName} business. Do you want to remove the space from the business first?",
            p8: "Convert to business",
            p9: "Move to business",
            p$: "Send invoices to",
            p_: "No additional email for invoices is currently set.",
            qa: "Invoices will be sent to {email}.",
            qb: "Tax ID for invoices",
            qc: "You haven’t set a Tax ID for invoices",
            qd: "Invoices will be issued with the Tax ID: {taxId}.",
            qe: "Are you sure you want to leave the {teamName} space?",
            qf: "This will remove your membership in the {teamName} space. You will keep your account, with which you can continue using Nozbe.",
            qg: "Select new members from business",
            qh: "Are you sure you want to add following business members to space {teamName}?",
            qi: "Paid via {provider, select, google {Google} apple {Apple}}",
            qj: "Business space",
            qk: "The {teamName} space is part of the {businessName} business. To see its payment history, please open the business settings.",
            ql: "The {teamName} space is part of the {businessName} business. Only the business owner can see its payment history.",
            qm: "Open business settings",
            qn: "Download invoice",
            qo: "Only space owners can access the payment history. Make sure you have sufficient permissions in this space. If the issue persists, please get in touch with us at support@nozbe.com.",
            qp: "Change details",
            qq: "Open App Store",
            qr: "Open Google Play",
            qs: "{planName, select, premium {Premium} business {Business}} other {Unknown}} {memberLimit} {paymentSchedule, select, monthly {monthly} yearly {yearly}} other {unknown}},",
            qt: "Refunded",
            qu: "Finished",
            qv: "Remove space",
            qw: "Are you sure you want to remove the {teamName} space?",
            qx: "This will completely remove the {teamName} space and all data related to it: members, projects, and tasks. You will keep your account, with which you can continue using Nozbe.",
            qy: "Manage space",
            qz: "The selected file is too big. The maximum allowed size is {size}.",
            qA: "The type of the selected file is invalid. Only JPGs and PNGs are supported at the moment.",
            qB: "Alias",
            qC: "Alias for {teamName}",
            qD: "Remove from space",
            qE: "You’re about to remove this user from the space. They will lose all access to this space (also their private tasks), and all their tasks will be changed to unassigned. This cannot be undone. Are you sure you want to proceed?",
            qF: "Remove",
            qG: "Are you sure you want to remove this user’s admin status? They will no longer be able to invite or remove users from the space.",
            qH: "Are you sure you want to leave this space?",
            qI: "Leave",
            qJ: "Are you sure you want to leave this space? You will lose access to all data, including your private projects.\nTo confirm, type the name of the space you want to leave below.",
            qK: "Are you sure you want to change this user’s status to admin? Admins can invite and remove users from the space.",
            qL: "Remove admin status",
            qM: "Description",
            qN: "Description for {teamName}",
            qO: "Email address",
            qP: "Invitation sent to",
            qQ: "Leave Space",
            qR: "Are you sure you want to modify {memberName}’s access to projects?",
            qS: "Granted accesses",
            qT: "Revoked accesses",
            qU: "Promote to admin",
            qV: "Resend invitation",
            qW: "Set alias",
            qX: "Name",
            qY: "Vacation mode",
            qZ: "Archived profile",
            q0: "Away until {awayUntil}\n\n",
            q1: "Expired invitation",
            q2: "Groups:",
            q3: "Waiting for activation",
            q4: "Spaces:",
            q5: "Unknown space member",
            q6: "This will notify anyone who is a member of this group",
            q7: "{count} members",
            q8: "@{name} Group",
            q9: "all",
            q$: "following",
            q_: "Don’t show this message again",
            ra: "{taskCount, plural, one {{taskCount} chat} other {{taskCount} chats}}",
            rb: "No messages yet",
            rc: "Start chatting with your space members to see the conversations here!",
            rd: "Send a message to {memberName}",
            re: "Hide archived",
            rf: "Show archived",
            rg: "Now you can send direct messages within the app. They are perfect for quick work-related chats that aren’t tied to specific tasks. This way, you can keep your whole team communication in one place.",
            rh: "Say hello to Messages!",
            ri: "Messages",
            rj: "Archived",
            rk: "Groups",
            rl: "Other",
            rm: "People",
            rn: "Messages: {threadName}",
            ro: "Nozbe: The fastest way to DONE",
            rp: "Members",
            rq: "Loading project list from Nozbe… Please wait",
            rr: "Couldn’t load projects from Nozbe Classic. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            rs: "Loading projects from Nozbe Classic. Please wait…",
            rt: "Import from Nozbe Classic",
            ru: "We couldn’t finish the import. If the issue persists, please get in touch with us at support@nozbe.com.",
            rv: "Import team members",
            rw: "We will send an invite to all your team members",
            rx: "Import more",
            ry: "Project imported.",
            rz: "We’ve started importing selected projects, and we’ll notify you once it’s done.",
            rA: "Import",
            rB: "{taskCountMessage} (Imported to Single Tasks)",
            rC: "{taskCountMessage} (Imported to Single Tasks)",
            rD: "Switch Nozbe Classic account",
            rE: "Nozbe Classic account email address",
            rF: "Log in to Nozbe Classic",
            rG: "Wrong email address or password",
            rH: "Log in",
            rI: "Couldn’t log in to Nozbe Classic. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            rJ: "Nozbe Classic account password",
            rK: "If you sign in with Google, go to Nozbe Classic, open Settings → Account, and set a password.",
            rL: "Show duplicates",
            rM: "Projects that already exist in Nozbe",
            rN: "{number} - Very unlikely",
            rO: "{number} - Very likely",
            rP: "How likely are you to recommend Nozbe to a friend or a colleague?",
            rQ: "Type",
            rR: "Type of contact info",
            rS: "Email address",
            rT: "Other",
            rU: "Phone",
            rV: "Type in the contact info",
            rW: "New contact info",
            rX: "Tip:",
            rY: "Administration",
            rZ: "Clients",
            r0: "Design",
            r1: "Finance",
            r2: "General",
            r3: "HR",
            r4: "Legal",
            r5: "Marketing",
            r6: "Orders",
            r7: "Sales",
            r8: "What is your team up to?",
            r9: "What are you up to?",
            r$: "My own project…",
            r_: "Finance",
            sa: "Groceries",
            sb: "Hobby",
            sc: "Plan holidays",
            sd: "House",
            se: "Kids",
            sf: "Learn new language",
            sg: "Home renovation",
            sh: "Study",
            si: "Select projects to add.",
            sj: "Don’t keep to-dos in your head! Jot down a few tasks related to {projectName}.",
            sk: "What needs to be done in {projectName}?",
            sl: "Let’s create your first project!",
            sm: "For work",
            sn: "Now that you know the basics, let’s create some projects. Are you using Nozbe for work or just for yourself?",
            so: "How will you use Nozbe? We’ll help set you up",
            sp: "Personal use",
            sq: "You’ll never have to ask: “what have you been up to?” again.",
            sr: "Just open the Activity view to see everything that happened in projects you follow: new comments, files, tasks, and more.",
            ss: "Activity shows what your team’s been up to",
            st: "If you get lost, click here to find our {em1}, or to {em2} for support.",
            su: "Help Page",
            sv: "Contact Us",
            sw: "Overwhelmed? Don’t worry!",
            sx: "Incoming is for stuff that requires your most urgent reaction.",
            sy: "Tasks due today or overdue, reminders, tasks assigned to you, and more.",
            sz: "Tasks due today or overdue, reminders, and more.",
            sA: "Your attention is needed here",
            sB: "Add new ones, remove old ones",
            sC: "Or create and assign groups.",
            sD: "Here you can manage your space members",
            sE: "In Nozbe, only you decide which tasks are the most important to you. Click ★ on a task to see it in Priority.",
            sF: "Set your own Priorities",
            sG: "Create projects to organize your space’s work.",
            sH: "Create projects to organize your life.",
            sI: "A project can be a large goal ({em1}) or a category of work you do ({em2}).",
            sJ: "Rebranding, Our new product",
            sK: "Home renovation, Learning Spanish",
            sL: "Marketing, Customer Support",
            sM: "Plants, Presents",
            sN: "A project can be a large goal ({em1}) or a category of things you need to do ({em2}).",
            sO: "Tasks belong to projects",
            sP: "Hi, {userName}",
            sQ: "See new projects, new tasks, and completed tasks in your space.",
            sR: "Don’t care about a project’s day-to-day changes? Activity only shows new comments from projects that you {em1}.",
            sS: "follow",
            sT: "New Comments are now Activity",
            sU: "Here you can import projects from Nozbe Classic.",
            sV: "Tasks due today or overdue, reminders, mentions, and tasks assigned to you.",
            sW: "Decide here if they’re ★, if they need to be rescheduled, or assigned to someone else.",
            sX: "In the new {em1}, only you decide which tasks are ★.",
            sY: "Priority",
            sZ: "You’ll find tasks that are due today or assigned to you in {em1}.",
            s0: "Incoming",
            s1: "See what’s changed in the new Nozbe",
            s2: "You can now share projects with {em1} with one click.",
            s3: "everyone in your space",
            s4: "Simplified project management",
            s5: "Tasks without a project live here.",
            s6: "Use the email integration and the Share feature on your phone to add new tasks here quickly.",
            s7: "This is your new Inbox",
            s8: "You can now add text, files, and checklists in a single comment.",
            s9: "The newest comments are at the bottom.",
            s$: "You can pin multiple comments.",
            s_: "Easy access to task history — check who changed the task, how, and when.",
            ta: "Improved comments",
            tb: "Need an extra reminder about a task before its {em1}? Want to check in later on a task someone else is assigned to? Set a reminder.",
            tc: "due date",
            td: "Remind me",
            te: "Clean up large projects by dividing them into Sections.",
            tf: "Sections",
            tg: "Remember to {follow} projects that are important to you.",
            th: "When you follow a project, you will see all of the new tasks and comments in the {activity} view.",
            ti: "Interested in {projectName}?",
            tj: "No more kick-off meetings, emails, or phone calls to hash out the details. You can {em1} with Nozbe.",
            tk: "work together more calmly",
            tl: "Write down what needs to be done in a task. Assign the person responsible. They will get notified. Ask them to put the result of their work here and to assign the task back to you.",
            tm: "Collaborate through tasks",
            tn: "Add your thoughts, comments, files, or checklists. Whatever information is required to complete this task.",
            to: "How to do it?",
            tp: "Just click here to cross it off the list!",
            tq: "And when the task is done…",
            tr: "If there is a deadline, set it here. Everyone will see when this task is due.",
            ts: "If there is a deadline, set it here",
            tt: "When does this have to be done?",
            tu: "Assign the person responsible for completing this task.",
            tv: "The new assignee will see this task in their Incoming.",
            tw: "Who’s responsible for this?",
            tx: "I work alone",
            ty: "Add Comment & Files",
            tz: "Add a comment",
            tA: "Change space",
            tB: "Give your task a name…",
            tC: "New task added: {taskName}",
            tD: "News Feed",
            tE: "So many reasons you’ll be more productive with Business.",
            tF: "Multiple workspaces",
            tG: "Create as many workspaces as you want",
            tH: "Priority support",
            tI: "Priority email support, dedicated account manager and training",
            tJ: "Unlimited files storage",
            tK: "Keep all your project attachments in Nozbe, no matter how many you have",
            tL: "Project and member groups",
            tM: "Organize similar projects together. @Mention groups of people easily.",
            tN: "So many reasons you’ll be more productive with Premium.",
            tO: "Share projects with clients",
            tP: "Invite another Nozbe space to your projects",
            tQ: "And more!",
            tR: "Flexible price as your team grows",
            tS: "Upgrade or downgrade at any time without losing your credits",
            tT: "Project access controls",
            tU: "Limit who can see a project",
            tV: "Project sections",
            tW: "Clean up projects by splitting them into sections",
            tX: "Project templates",
            tY: "Jump-start projects more quickly using templates",
            tZ: "Time needed and spent",
            t0: "Estimate time that is needed to complete your tasks, and track the time spent on getting them done.",
            t1: "Unlimited history",
            t2: "See discussions in completed tasks and projects",
            t3: "Unlimited projects",
            t4: "Create as many projects as you need",
            t5: "20 GB of storage/user",
            t6: "Keep all your project attachments in Nozbe, no matter how many",
            t7: "Active task count",
            t8: "Amount",
            t9: "Avatar",
            t$: "Business",
            t_: "Business members",
            ua: "Business name",
            ub: "Color",
            uc: "Comment",
            ud: "Date",
            ue: "Due date",
            uf: "Email address",
            ug: "Group by",
            uh: "Markdown",
            ui: "Members",
            uj: "More",
            uk: "Name",
            ul: "Name",
            um: "None",
            un: "Off",
            uo: "Options",
            up: "Password",
            uq: "Payment history",
            ur: "Current plan",
            us: "Project",
            ut: "Projects",
            uu: "Reminders",
            uv: "Responsible",
            uw: "Section",
            ux: "Sort",
            uy: "Status",
            uz: "Tags",
            uA: "Task count",
            uB: "Task name",
            uC: "Template",
            uD: "Time attributes",
            uE: "Time needed",
            uF: "Time spent",
            uG: "You",
            uH: "Importing these projects will exceed the limits of the Free plan. We will start the Premium Trial plan once the import is finished. Your Premium Trial will be valid until {endDateFormatted}.",
            uI: "Connect your OneDrive account with Nozbe to attach your files to tasks.",
            uJ: "Change plan",
            uK: "Credits",
            uL: "Extend plan",
            uM: "Features",
            uN: "Limited",
            uO: "{number1}/{number2}",
            uP: "People",
            uQ: "via {provider, select, apple {Apple} google {Google}}",
            uR: "Expires",
            uS: "Start Trial",
            uT: "Upgrade",
            uU: "Your space’s plan:",
            uV: "Your plan",
            uW: "Keep being productive with Nozbe and get one month of {emphasis}",
            uX: "Nozbe Premium for free!",
            uY: "Turn off auto-renewal",
            uZ: "Get one month for free!",
            u0: "+1 month on us!",
            u1: "Can we change your mind?",
            u2: "Sync disabled due to plan limitations",
            u3: "Synchronization error",
            u4: "Business features",
            u5: "Unlimited spaces, projects, sections, storage, admins and groups + limited access projects, and more.",
            u6: "Business",
            u7: "Premium",
            u8: "Current plan",
            u9: "You can only have 1 free space",
            u$: "Nozbe Premium Subscription (monthly)",
            u_: "Change plan for {planType, select, business {{businessName} business} other {{teamName} space}}",
            va: "Extend plan",
            vb: "Extend plan for {planType, select, business {{businessName} business} other {{teamName} space}}",
            vc: "Upgrade {planType, select, business {{businessName} business} other {{teamName} space}}",
            vd: "Transfer funds from Nozbe Classic to the {planType, select, business {{businessName} business} other {{teamName} space}}",
            ve: "Plan expired",
            vf: "Plan expired for {planType, select, business {{businessName} business} other {{teamName} space}}",
            vg: "Upgrade plan",
            vh: "Upgrade plan for {planType, select, business {{businessName} business} other {{teamName} space}}",
            vi: "Admins limit exceeded",
            vj: "Limits exceeded",
            vk: "Member groups limit exceeded",
            vl: "Members: {peopleCount}",
            vm: "Project groups limit exceeded",
            vn: "Project templates limit exceeded\n",
            vo: "Open access projects limit exceeded",
            vp: "Invite-only projects limit exceeded",
            vq: "Project sections limit exceeded",
            vr: "Tags limit exceeded",
            vs: "Time attributes are enabled",
            vt: "More than {peopleCount} people",
            vu: "Add payment method",
            vv: "Buy Nozbe Premium",
            vw: "Buy now",
            vx: "Unlock unlimited productivity",
            vy: "Change plan",
            vz: "Change plan for free",
            vA: "Downgrade",
            vB: "Use Nozbe Classic subscription",
            vC: "Create a pro forma invoice",
            vD: "Choose plan",
            vE: "Contact us for more options",
            vF: "Expires in {date}",
            vG: "There {spacesNumber, plural, one {is {spacesNumber} space} few {are {spacesNumber} spaces} other {are {spacesNumber} spaces}} in your business. If you downgrade, the {spaceName} space’s plan will be changed to a paid Premium {plan} plan. Other spaces that belong to this business will be granted a 1-day Trial and will need to be paid for separately. Are you sure you want to downgrade?",
            vH: "You cannot currently downgrade your space’s plan to Nozbe Free because you have an ongoing subscription. Wait until the end of your subscription, and then downgrade your plan to Nozbe Free.",
            vI: "Coudn’t load pricing. Try again later.",
            vJ: "Currently valid until: {date}",
            vK: "We couldn’t import your subscription. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            vL: "We couldn’t import your Nozbe Classic subscription because it expires in less than 7 days.",
            vM: "Your subscription has been imported. You should see the updated plan in a few minutes.",
            vN: "Import",
            vO: "This will move your subscription from Nozbe Classic to Nozbe. Your Nozbe Classic account’s validity date will be reduced to seven days. Are you sure you want to proceed?",
            vP: "Loading pricing…",
            vQ: "Your payment information has been updated.",
            vR: "We couldn’t process your payment. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            vS: "Payment error",
            vT: "We couldn’t change your plan. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            vU: "You’ll be notified when payment is processed. This may take a while.",
            vV: "Payment in progress",
            vW: "Payment:",
            vX: "Online transfer, card, or BLIK",
            vY: "Bank transfer (proforma invoice)",
            vZ: "Monthly",
            v0: "Yearly",
            v1: "Save {percent}%",
            v2: "Plan for the {planType, select, business {{businessName} business} other {{teamName} space}} has been updated",
            v3: "Auto-renewal is {status}",
            v4: "active",
            v5: "inactive",
            v6: "Your space’s current plan is {planName}",
            v7: "Previous plan: {planName}",
            v8: "Valid until {date} ({time})",
            v9: "Valid until: {date}",
            v$: "{price}/month",
            v_: "Add payment method",
            wa: "To enable the automatic renewal, you need to provide a valid payment method.",
            wb: "Subtotal: {priceWithoutTax} + taxes (if applicable)",
            wc: "Total gross price: {priceWithTax} ({priceWithoutTax} + VAT)",
            wd: "Enter a Tax ID for the pro forma invoice",
            we: "Tax ID (optional)",
            wf: "Free trial for 1 month",
            wg: "You can not perform this action due to current plan limitations.",
            wh: "You can have up to {limit} active projects on the Nozbe Free plan. Space owner {ownerName} has been notified.",
            wi: "You can have up to {limit} project templates on the Nozbe Free plan. Space owner {ownerName} has been notified.",
            wj: "You can have up to {limit} sections per project on the Nozbe Free plan. Space owner {ownerName} has been notified.",
            wk: "You can have up to {limit} tags on the Nozbe Free plan. Space owner {ownerName} has been notified.",
            wl: "Granting admin rights is available only on the Nozbe Premium plan. Space owner {ownerName} has been notified.",
            wm: "You can have up to {limit} admins on the {planName} plan. Space owner {ownerName} has been notified.",
            wn: "Limited access projects are available only on the Nozbe Premium plan. Space owner {ownerName} has been notified. ",
            wo: "You can invite up to {limit} team members on the current plan. Space owner {ownerName} has been notified.",
            wp: "Your subscription has expired on {expiresAt}. Space owner {ownerName} has been notified.",
            wq: "Tracking time needed and spent is a Nozbe Premium feature. Space owner {ownerName} has been notified.",
            wr: "Tasks completed more than 14 days ago are hidden. Space owner {ownerName} has been notified.",
            ws: "Groups are a Nozbe Premium feature",
            wt: "You can have up to {limit} active projects on the Nozbe Free plan. To add more, please upgrade your space’s plan to Premium.",
            wu: "You can have up to {limit} project templates on the Nozbe Free plan. To add more, please upgrade your space’s plan to Premium.",
            wv: "You can have up to {limit} sections per project on the Nozbe Free plan. To add more, please upgrade your space’s plan to Premium.",
            ww: "You can have up to {limit} tags on the Nozbe Free plan. To add more, please upgrade your space’s plan to Premium.",
            wx: "Granting admin rights is available on Nozbe Premium. Upgrade your plan to Premium.",
            wy: "You can have up to {limit} admins on the {planName} plan. To add more, please upgrade your space’s plan to Business.",
            wz: "Limited access projects are available on Nozbe Premium. To unlock this feature, please upgrade your space’s plan to Premium.",
            wA: "You can have up to {limit} space members within the current plan. Change the plan to Premium.",
            wB: "You can invite {limit} members on the current plan. Upgrade your plan to add more.",
            wC: "Subscription has expired on {expiresAt}. Extend your space’s plan.",
            wD: "Tracking time needed and spent is a Nozbe Premium feature.",
            wE: "Tasks completed more than 14 days ago are hidden. Upgrade to Premium to unlock history.",
            wF: "This is a premium feature",
            wG: "File limit exceeded",
            wH: "You’ve discovered a Nozbe Premium feature",
            wI: "Project limit reached",
            wJ: "’Template limit reached’",
            wK: "Section limit reached",
            wL: "Tag limit reached",
            wM: "Admins limit reached",
            wN: "Premium feature",
            wO: "Member limit reached",
            wP: "Plan has expired",
            wQ: "History is locked",
            wR: "Contact support",
            wS: "Sync disabled. Admins limit reached.",
            wT: "Sync disabled. Member limit reached.",
            wU: "Sync disabled. Open access projects limit reached.",
            wV: "Sync disabled. Invite-only projects limit reached.",
            wW: "Sync disabled. Section limit reached.",
            wX: "Sync disabled. Tag limit reached.",
            wY: "Sync disabled. Contact support.",
            wZ: "Premium benefits: Unlimited projects, sections, and storage. Premium features: Admins, Groups, limited-access projects, and more!",
            w0: "Premium features",
            w1: "Unlimited projects, sections, and storage; admins, groups, limited access projects, and more.",
            w2: "Buy now",
            w3: "Start your 30-day Trial and take advantage of everything Nozbe has to offer - for free.",
            w4: "No credit card required!",
            w5: "Or buy Nozbe Premium right now",
            w6: "Trial activated",
            w7: "Trial for this space has already been used. To unlock the full set of Nozbe’s features, please upgrade your space’s plan to Nozbe Premium.",
            w8: "{peopleCount, plural,\n    one {For {peopleCount} person}\n    few {Up to {peopleCount} people}\n    other {Up to {peopleCount} people}}",
            w9: "30-day Money Back Guarantee",
            w$: "See all plans…",
            w_: "By tapping the “Buy Nozbe Premium” button, your Google Play Store account will be automatically charged for the purchase. Your subscription will automatically renew every month until you cancel it in the ”Subscriptions” tab in your Google Play Store at least 24 hours before the end of the current period.",
            xa: "By tapping “Buy Nozbe Premium”, you agree to:",
            xb: "Renew automatically",
            xc: "Subscription auto-renewal will be disabled after paylessly switching to Business. To ensure a smooth transition, please activate it again manually after the switch.",
            xd: "Switching plans doesn’t require immediate payment",
            xe: "We’ll set the new validity date based on credit left from your old plan. When the new plan is due, you’ll pay the full renewal price.",
            xf: "Charge me",
            xg: "Monthly",
            xh: "Yearly",
            xi: "Plan",
            xj: "Pay now:",
            xk: "Next payment: {date}",
            xl: "/month",
            xm: "per month (+ taxes)",
            xn: "/user",
            xo: "/year",
            xp: "Get {monthsText} by purchasing Nozbe Business today",
            xq: "{months, plural, one {one month} other {{months} months}} extra",
            xr: "Special offer",
            xs: "Get {monthsText} by purchasing Nozbe Premium today",
            xt: "Extend your {planName} plan today and get additional {monthsText}.",
            xu: "Buy Nozbe Premium for 3 months and get additional {monthsText}.",
            xv: "Extend your {planName} plan for 3 months and get additional {monthsText}.",
            xw: "You have bought Premium via {provider, select, apple {Apple} google {Google}}. Switch to our payment system to take advantage of our future promos. You can also save 20% when choosing yearly billing! Simply purchase the Premium plan using the button below. We will automatically add the remaining time from your current subscription to your new plan’s expiration date.",
            xx: "To invite more people to your space, please upgrade your space’s plan.",
            xy: "Nozbe Business",
            xz: "Nozbe Free",
            xA: "Nozbe Premium",
            xB: "Nozbe Premium Trial",
            xC: "Nozbe Business Trial",
            xD: "You are subscribed via Apple in-app purchases. Use iOS app to manage your space’s plan.",
            xE: "You are subscribed via Google in-app purchases. Use Android app to manage your space’s plan.",
            xF: "Your plan provider is not supported on this platform. Please log in to the device you’ve used to buy the Premium plan, or contact our customer support for more info.",
            xG: "{teamName} space is still being created. Make sure you’re online and wait for the process to finish.",
            xH: "Pending space",
            xI: "Camera",
            xJ: "Files",
            xK: "Photo Library",
            xL: "Due Dates",
            xM: "Autocomplete",
            xN: "Responsible",
            xO: "Sections",
            xP: "Recurrences",
            xQ: "Before",
            xR: "Remind",
            xS: "No color",
            xT: "Repeat every:",
            xU: "After",
            xV: "{count, plural, one {{count} time} other {{count} times}}",
            xW: "End repeat",
            xX: "Never",
            xY: "On date",
            xZ: "{count, plural, one {Day} other {Days}}",
            x0: "{count, plural, one {Month} other {Months}}",
            x1: "{count, plural, one {Week} other {Weeks}}",
            x2: "{count, plural, one {Year} other {Years}}",
            x3: "On a specific day:",
            x4: "Day",
            x5: "Weekday",
            x6: "Weekend day",
            x7: "Fifth",
            x8: "First",
            x9: "Fourth",
            x$: "Last",
            x_: "Second",
            ya: "Second to Last",
            yb: "Third",
            yc: "Always on:",
            yd: "Custom",
            ye: "Repeat on days:",
            yf: "In 2 weeks",
            yg: "You are setting a due date that’s in the past. The task will be marked as overdue.",
            yh: "Next week",
            yi: "No date",
            yj: "All",
            yk: "Do you want to update the due date only for this task, or for all future versions of it?",
            yl: "Only this task",
            ym: "Update recurrence",
            yn: "Remove date",
            yo: "Are you sure you want to remove the due date from this task? It will also remove its recurrence.",
            yp: "Remove recurrence",
            yq: "Repeat",
            yr: "Set time",
            ys: "Due date",
            yt: "We couldn’t load your notes from Evernote. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            yu: "Tap to load more notes…",
            yv: "No matching notes found",
            yw: "Recent notes",
            yx: "Search notes",
            yy: "Searched notes",
            yz: "Pick Evernote note(s)",
            yA: "Abandon",
            yB: "Advanced",
            yC: "Add comment",
            yD: "Add comment to selected tasks",
            yE: "Complete",
            yF: "Are you sure you want to do this? Selected tasks will be archived and disappear from the list.",
            yG: "Could not change these tasks ({length}): {list}. If the issue persists, please get in touch with us at support@nozbe.com.",
            yH: "Mark as Read",
            yI: "Mark as Reviewed",
            yJ: "Mark as Unread",
            yK: "Mark as Not Priority",
            yL: "Mark as Priority",
            yM: "{members} do not have access to this project. Do you want to grant access only to this task?",
            yN: "People following this project",
            yO: "Everyone with access to this project",
            yP: "Mention",
            yQ: "Create a new project",
            yR: "When you move this task, it will no longer be accessible to the members of the current project unless they have access to the new location. Are you sure you want to proceed?",
            yS: "This task belongs to a project shared with you by another space and cannot be moved to another project. Consider cloning the task instead.",
            yT: "Project",
            yU: "Set project purpose",
            yV: "Before due date",
            yW: "Days",
            yX: "Hours",
            yY: "Minutes",
            yZ: "Remind on",
            y0: "In the afternoon",
            y1: "In the evening",
            y2: "In an hour",
            y3: "{formattedTime} before due",
            y4: "On due date",
            y5: "{formattedTime} before",
            y6: "Next {lastDay}",
            y7: "Next week",
            y8: "On {lastDay}",
            y9: "Pick date",
            y$: "Remind on",
            y_: "Remind me",
            za: "Do not repeat",
            zb: "Grant access",
            zc: "{member} does not have access to this task. Do you want to grant access only to this task?",
            zd: "Are you sure you want to unassign this task? Its due date will also be removed.",
            ze: "Are you sure you want to unassign this task? Its due date and recurrence will be removed.",
            zf: "Change access",
            zg: "You can’t grant a task to more than 1 member. Do you want to remove access from {currentMember} and grant the access to {selectedMember}?",
            zh: "Other members",
            zi: "Share with anyone",
            zj: "Generate a link inviting someone to this task and share it however you like. The task can be shared with only one person and will remain assigned to you until the invitation is accepted.",
            zk: "Share with email",
            zl: "Enter the email of a person you want to share this task with. The task will stay assigned to you until the invitation is accepted.",
            zm: "Suggested",
            zn: "After {senderData} accepts the invitation, they will gain access to this task and become responsible for it. Are you sure you want to proceed?",
            zo: "Who is responsible?",
            zp: "Unassigned",
            zq: "Add a new section",
            zr: "None",
            zs: "Create a new tag",
            zt: "Tags",
            zu: "Link a task",
            zv: "Start a chat with:",
            zw: "With Nozbe Premium, you can create groups to bring similar projects together. You can also split your space’s members into groups. Then, if you need input from the whole Marketing group, you can just mention @Marketing in a task, and all of its members will be notified!",
            zx: "Organize projects and users into groups",
            zy: "Moving from another app to Nozbe? As a Nozbe Premium user, you can migrate your tasks and projects from your old productivity system with our easy-to-use import tools!",
            zz: "Import projects from other apps",
            zA: "If you want to collaborate with someone outside your space, you can share a project with them thanks to Nozbe Premium. This way, you don’t need to invite them to your space - you can work together in a joint project without anything standing in your way.",
            zB: "Share projects with another space",
            zC: "Transparency is important, but not everything in a space should be seen by everyone. Create projects that only chosen members can see or private projects just for you, for those super-secret tasks you are working on!",
            zD: "Limited access projects",
            zE: "Organize tasks in your project by splitting them into sections. For example, create a section for tasks that are currently in progress, to be done, and ready for review. With sections, it’s much easier to keep track of what’s happening!",
            zF: "Project sections",
            zG: "Add as many attachments as you want thanks to unlimited storage space! With Nozbe Premium, you don’t need to worry about reaching any limits.",
            zH: "Unlimited storage space",
            zI: "Some projects are very similar and require the same steps to be finished. With Nozbe Premium, you can create ready-to-use templates with all sections, tasks, and comments you need to jump-start your projects!",
            zJ: "Project templates",
            zK: "Plan your work by estimating time that is needed to complete your tasks, and tracking the time spent on getting them done.",
            zL: "Nozbe Premium Benefits",
            zM: "Your space is currently on a trial of our {nozbePremiumEmphasis} plan. Your trial will end on {date}.\nHere is a list of a few benefits that you get by staying a Nozbe Premium user.",
            zN: "Your space is on a free trial!",
            zO: "Keep track of everything that happens in your {lifeOrTeam} without sacrificing clarity. With Nozbe Premium, you can have as many projects as you need.",
            zP: "life",
            zQ: "space",
            zR: "Unlimited number of projects",
            zS: "Remember about tasks that require reviewing.",
            zT: "You’ve done everything. Good work!",
            zU: "Everything’s done",
            zV: "Priority",
            zW: "https://nozbe.com/terms/#privacy",
            zX: "Privacy Policy",
            zY: "Add new contact info",
            zZ: "Contact info",
            z0: "Show: ",
            z1: "Project cloned from {originalProjectUrl}",
            z2: "{projectName} - clone",
            z3: "{projectName} - {currentDate}",
            z4: "{projectName} - template",
            z5: "Create template from project",
            z6: "Create project from template",
            z7: "Clone the project",
            z8: "Clone the template",
            z9: "Project purpose",
            z$: "Join project",
            z_: "The project invitation you are trying to use is invalid. Please ask the inviter to send you a new invitation.",
            Aa: "Project invitation",
            Ab: "Are you sure you want to reject the invitation to the {projectName} project from the {teamName} space?",
            Ac: "{inviterName} ({inviterEmail}) from the {teamName} space wants to share the {projectName} project with you and your space. Details below:",
            Ad: "You cannot accept the invitation. Make sure that you do not share any other project with the inviting space.",
            Ae: "The project you have been invited to join doesn’t exist.",
            Af: "You cannot accept the invitation using a space that shared the project.",
            Ag: "We couldn’t process the invitation. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            Ah: "Who can see this project",
            Ai: "Everyone",
            Aj: "{memberCount, plural,\n    one {{memberCount} member}\n    few {{memberCount} members}\n    other {{memberCount} members}}",
            Ak: "Accepting Space",
            Al: "Members with access",
            Am: "Selected members will have access to this project:",
            An: "Project {projectName} is now shared between your space and {teamName} space.",
            Ao: "Congratulations",
            Ap: "Pick a Space",
            Aq: "Select which space to use to accept the invitation. You can only choose a space in which you are the owner or admin.",
            Ar: "Status changed",
            As: "Access granted",
            At: "Access revoked",
            Au: "Become project manager",
            Av: "This is an invite-only project. Only project managers, admins and the space owner can invite people to this project.",
            Aw: "You are about to change access to this project",
            Ax: "Are you sure you want to share this project with the entire space? Everyone will be able to change its name, purpose, and access settings.",
            Ay: "Who can see this project",
            Az: "Managers",
            AA: "Grant manager status",
            AB: "Remove from project",
            AC: "Remove manager status",
            AD: "Share with another space",
            AE: "Are you sure you want to delete this project and all its tasks permanently? This can’t be undone!",
            AF: "This can’t be undone! Your project will be gone forever. Are you sure you want to proceed?",
            AG: "Are you sure you want to delete this project and all its tasks permanently? This can’t be undone! Leaving it as Ended will allow you to still get back to it if you need it. Write the project name below to confirm that you want to permanently delete it.",
            AH: "Are you sure you want to end this project?",
            AI: "Are you sure you want to restore this project?",
            AJ: "End project",
            AK: "Favorite",
            AL: "From project",
            AM: "From template",
            AN: "Go to project",
            AO: "Manage",
            AP: "Rename, or change purpose, color, and access",
            AQ: "Move to another space",
            AR: "Choose a space to move the project {projectName} to. Note: Some users may lose access to this project after the move.",
            AS: "We couldn’t move the project to another space. Please try again. If the problem persists, contact support@nozbe.com.",
            AT: "Success! Your project has been moved.",
            AU: "Only project managers can do that",
            AV: "Purpose",
            AW: "Show project purpose",
            AX: "You are a guest in this project. Only the host can restore it.",
            AY: "Add section",
            AZ: "Set section name",
            A0: "Share project with another space",
            A1: "Shared by {name} space",
            A2: "Sharing with {name} space",
            A3: "Project name",
            A4: "Add people",
            A5: "Add",
            A6: "Add a space",
            A7: "Space: {shareEmail}",
            A8: "More options",
            A9: "Color",
            A$: "Everyone",
            A_: "Selected users",
            Ba: "+ another space (optional)",
            Bb: "Type in the project name",
            Bc: "Private",
            Bd: "In space:",
            Be: "Create a template",
            Bf: "New project",
            Bg: "New template",
            Bh: "{teamName} space is on the Nozbe Free plan, which only supports projects that are open to all space members. Upgrade its plan to Premium to unlock invite-only projects and more features, then try again.",
            Bi: "{teamName} space to which you are trying to add this project has exceeded the Free plan limits. Upgrade its plan to Premium to unlock unlimited projects and more features, then try again.",
            Bj: "This project will be visible only to these people:",
            Bk: "Everyone in your space can see this project and change its purpose.",
            Bl: "Who can see this project",
            Bm: "Created by: {authorName} on {createdAt}",
            Bn: "Project author",
            Bo: "Switch the suggested color on to see what color the owner suggested for this project. You can switch between the color of your choice and the suggested color at any time.",
            Bp: "This is a suggested color for this project. Switch it off if you want to use the color of your choice instead.",
            Bq: "Change suggested color",
            Br: "Suggested color was set (and can be changed) by the project owner or space admin. You can switch between the color of your choice and the suggested color at any time. Use suggested colors to communicate better with your space members.",
            Bs: "Use suggested color",
            Bt: "Set color",
            Bu: "General",
            Bv: "Groups",
            Bw: "Manage project",
            Bx: "Project name copied",
            By: "You must be a project manager, admin, or space owner to change this project’s name.",
            Bz: "Project purpose copied",
            BA: "Time needed and spent",
            BB: "Enable time attributes",
            BC: "You don’t seem to have the proper permissions to share this project with another space. Only the space’s owner and admins can do that - ask them to share it with the space you want to collaborate with.",
            BD: "Share this project",
            BE: "Share this project by entering the email address of a member of the invited space.",
            BF: "We sent the invitation to {invitationEmail}. Project will be shared after activation on the other space‘s side.",
            BG: "Cancel invitation",
            BH: "Change email",
            BI: "Invitation sent",
            BJ: "Send again",
            BK: "Are you sure you want to cancel the invitation to the {projectName} project?",
            BL: "Email of the space’s member",
            BM: "We couldn’t send the invitation. Please try again. If the issue persists, please get in touch with us at support@nozbe.com.",
            BN: "Send invitation",
            BO: "Leave shared project",
            BP: "Stop sharing project",
            BQ: "{team} space is sharing this project with you.",
            BR: "This project was shared with another space.",
            BS: "Space {invitedTeamName} accepted your invitation to project {projectName}. This project is now shared between your space and {teamName} space.",
            BT: "Sharing project",
            BU: "This project will become shared once user {email} confirms the invitation.",
            BV: "User {email} rejected your invitation to share the {projectName} project.",
            BW: "Invitation rejected",
            BX: "Your space shares this project with {team} space.",
            BY: "Create a project",
            BZ: "Template purpose",
            B0: "This is a project template. You can modify it just like any other Nozbe project. Create a new project from this template to automatically copy its full content to that project.",
            B1: "This can’t be undone! Your template will be gone forever. Are you sure you want to proceed?",
            B2: "Are you sure you want to delete this template and all its tasks permanently? This can’t be undone! Leaving it as Ended will allow you to still get back to it if you need it. Write the template name below to confirm that you want to permanently delete it.",
            B3: "Are you sure you want to end this template?",
            B4: "End template",
            B5: "Show template purpose",
            B6: "Template name",
            B7: "Template author",
            B8: "Manage template",
            B9: "You must be a template manager, admin, or space owner to change this template’s name.",
            B$: "{daysRemaining, plural,\n    one {{daysRemaining} day}\n    other {{daysRemaining} days}\n}{hoursRemaining, plural,\n    one {, {hoursRemaining} hour}\n    other {, {hoursRemaining} hours}\n} left",
            B_: "{hoursRemaining, plural,\n    one {{hoursRemaining} hour}\n    other {{hoursRemaining} hours}\n    } left",
            Ca: "{freeMonths, plural,\n    one {{freeMonths} month}\n    other {{freeMonths} months}} for free!",
            Cb: "Last chance!",
            Cc: "Special offer just for you",
            Cd: "Nozbe: The fastest way to DONE",
            Ce: "Quick Add",
            Cf: "{membersCount, plural,\n        one {{membersCount} person}\n        other {{membersCount} people}}",
            Cg: "{count, plural, one {- last occurrence} other {- {count} more times}}",
            Ch: "Custom",
            Ci: "Every {daysCount, plural,\n    one {day}\n    other {{daysCount} days}} {until} {count}",
            Cj: "{day, selectordinal, one {#st} two {#nd} few {#rd} other {#th}}",
            Ck: "Last",
            Cl: "Every {monthsCount, plural,\n    one {month}\n    other {{monthsCount} months}} {until} {count}",
            Cm: "Every {interval, plural, one {month} other {{interval} months}} on {position, selectordinal, one {#st} two {#nd} few {#rd} other {#th} =-1 {last} =-2 {2nd to last}} {day}",
            Cn: "Every {interval, plural, one {month} other {{interval} months}} on {days}",
            Co: "until {date}",
            Cp: "Every weekday",
            Cq: "Every {weeksCount, plural,\n    one {week}\n    other {{weeksCount} weeks}} {until} {count}",
            Cr: "Every {weeksCount, plural,\none {week}\nother {{weeksCount} weeks}} on {days} {until} {count}",
            Cs: "Every {yearsCount, plural, one {year} other {{yearsCount} years}} {until} {count}",
            Ct: "Every week on…",
            Cu: "Every (e.g. 2nd Friday) of the month",
            Cv: "Revoke access",
            Cw: "Are you sure you want to leave this task? After leaving, you won’t be able to reaccess it without a new invitation.",
            Cx: "Are you sure you want to revoke link access to this task?",
            Cy: "Are you sure you want to revoke access to this task for {member}?",
            Cz: "Logging out and in again… This may take a minute.",
            CA: "Logging out… Please wait",
            CB: "Please try again in a few minutes. If the issue persists, please contact us at support@nozbe.com.",
            CC: "I am having issues with my Nozbe account’s synchronization.",
            CD: "The issue occurred when I… (please explain what happened - this will help us analyze and fix the issue.)",
            CE: "(We added some technical information below that will be helpful to our developers. Don’t worry, no private data is sent.)",
            CF: "Synchronization issue",
            CG: "Your data could not be synchronized.",
            CH: "Reason: {reasonText}",
            CI: "Application error",
            CJ: "Unable to connect to server. Please check your Internet connection, or contact us at support@nozbe.com.",
            CK: "Server error (code {status})",
            CL: "Too many requests. If your company uses a VPN or a proxy server, please contact us at support@nozbe.com.",
            CM: "Load more",
            CN: "Comments",
            CO: "Tasks",
            CP: "Search in comments",
            CQ: "Search in completed tasks",
            CR: "No results",
            CS: "Search tasks",
            CT: "Clone this section with selected tasks and their comments. Please note that the attachments in cloned tasks may be visible after a few minutes.",
            CU: "Clone section",
            CV: "{sectionName} - clone",
            CW: "Section clone name",
            CX: "Add task",
            CY: "Archive",
            CZ: "Are you sure you want to archive this section?\n\nActive tasks will remain in the project with no section assigned.",
            C0: "Are you sure you want to permanently delete this section?",
            C1: "This will convert the {sectionName} section into a project of the same name. All active tasks from this section will be moved to the new project, and the section will be archived. Are you sure you want to proceed?",
            C2: "Convert section into a project",
            C3: "Move down",
            C4: "Move up",
            C5: "New section name",
            C6: "The logout process is not complete. Are you sure you want to close this page?",
            C7: "We couldn’t log you out correctly. Please remove and reinstall the app.",
            C8: "We couldn’t log you out correctly. Please clear the browser’s cache, then reload the page.",
            C9: "We couldn’t log you out and in again automatically. Please log in again manually.",
            C$: "A database error occurred in Nozbe. Press Cancel to reload the app. If the issue persists, press OK to log out.",
            C_: "We encountered a database error. Please try reloading the app. If the issue persists, please log out and in again, or contact us at support@nozbe.com.",
            Da: "Could not open Nozbe due to a database error. Press Cancel to reload the app. If the issue persists, press OK to log out.",
            Db: "We couldn’t open Nozbe due to a database error. Please try reloading the app. If the issue persists, please log out and in again, or contact us at support@nozbe.com.",
            Dc: "Warning: Your changes may be PERMANENTLY lost! You must be online to use Nozbe in multiple tabs of your browser. Keep all tabs open until you can synchronize them.",
            Dd: "Nozbe ran out of disk space. All unsynchronized data will be lost when you quit or reload the app. Please get in touch with us at support@nozbe.com.",
            De: "Nozbe does not support Fluid web browser. All unsynchronized data will be lost when you quit or reload the app.",
            Df: "We’re experiencing a synchronization issue. If this issue persists, please contact us at support@nozbe.com.",
            Dg: "Can’t synchronize, because this app and the server are incompatible. Please download the latest version of Nozbe.",
            Dh: "Account merges",
            Di: "Account email",
            Dj: "You have multiple pending account merges. Select the one you want to finish.",
            Dk: "Work together on projects",
            Dl: "Invite members",
            Dm: "Organize your work in projects",
            Dn: "Create first project",
            Do: "Create a space for private projects",
            Dp: "Create a space for your team",
            Dq: "Create space",
            Dr: "Create space",
            Ds: "Watch the tutorial to uncover Nozbe’s power",
            Dt: "Watch",
            Du: "Install our desktop app",
            Dv: "Get Nozbe mobile app",
            Dw: "Install",
            Dx: "Download",
            Dy: "Set your avatar",
            Dz: "Settings",
            DA: "Recommend Nozbe and earn credits",
            DB: "You earned a comission",
            DC: "Referral program",
            DD: "Learn more",
            DE: "Unlimited projects and Premium features",
            DF: "Unlimited spaces and Business features",
            DG: "Upgrade to Business",
            DH: "Upgrade",
            DI: "Add",
            DJ: "Upgrade",
            DK: "Upgrade to Premium",
            DL: "Invite people",
            DM: "Message",
            DN: "Project",
            DO: "Tag",
            DP: "Task",
            DQ: "New project",
            DR: "Create new project in: {groupName}",
            DS: "Manage tags",
            DT: "Manage space members",
            DU: "Active tags",
            DV: "Active templates",
            DW: "All members",
            DX: "All projects",
            DY: "All tags",
            DZ: "Archived tags",
            D0: "Ended projects",
            D1: "Ended templates",
            D2: "Favorites",
            D3: "Member groups",
            D4: "Expired invitations",
            D5: "Pending members",
            D6: "More",
            D7: "Project groups",
            D8: "Favorite",
            D9: "Following",
            D$: "Templates",
            D_: "Active projects",
            Ea: "Admins",
            Eb: "New project",
            Ec: "Last Free",
            Ed: "Calendar",
            Ee: "Ended on {date}",
            Ef: "My tasks",
            Eg: "Project invitations",
            Eh: "You’ve been invited to share the following projects. Select a project and respond to the invitation.",
            Ei: "Search for project",
            Ej: "Show all projects",
            Ek: "Show ended projects",
            El: "New group",
            Em: "All",
            En: "Groups",
            Eo: "Hide ended",
            Ep: "Show ended",
            Eq: "Search project",
            Er: "Join request",
            Es: "More",
            Et: "Personal",
            Eu: "Hide archived",
            Ev: "Show archived",
            Ew: "Task invitations",
            Ex: "You’ve been invited to share the following tasks. Select a task and respond to the invitation.",
            Ey: "Create new item",
            Ez: "Add ",
            EA: "Search",
            EB: "Change space",
            EC: "Spaces",
            ED: "Members",
            EE: "Followed projects",
            EF: "Active projects",
            EG: "Single tasks",
            EH: "Members",
            EI: "Free trial in progress",
            EJ: "Register your Nozbe account to unlock unlimited productivity",
            EK: "Log in to your Nozbe account to unlock all features",
            EL: "Introduce yourself to Nozbe without creating an account",
            EM: "Shared via link",
            EN: "With {username}",
            EO: "Single tasks",
            EP: "Connect Slack with Nozbe to turn messages into tasks, preview them, add reminders, and get notified when you’re mentioned or assigned a task—all without leaving Slack.",
            EQ: "Assignee, {order, select, ascending {ascending} other {descending}}",
            ER: "Comments, {order, select, ascending {least at top} other {most at top}}",
            ES: "Created at, {order, select, ascending {oldest first} other {newest first}}",
            ET: "Custom order",
            EU: "Due date, {order, select, ascending {earliest first} other {latest first}}",
            EV: "Last activity, {order, select, ascending {oldest first} other {newest first}}",
            EW: "Name, {order, select, ascending {ascending} other {descending}}",
            EX: "Time needed, {order, select, ascending {ascending} other {descending}}",
            EY: "Time spent, {order, select, ascending {ascending} other {descending}}",
            EZ: "Sort by",
            E0: "General",
            E1: "New active tasks in this period: {value}",
            E2: "Completed tasks in this period: {value} ({progress})",
            E3: "Active tasks:",
            E4: "Completed tasks:",
            E5: "Includes completed and abandoned tasks",
            E6: "Pace",
            E7: "Daily",
            E8: "Time needed for new active tasks in this period: {value}",
            E9: "Time needed for completed tasks in this period: {value} ({progress})",
            E$: "Time spent on active tasks in this period: {value}",
            E_: "Time spent on completed tasks in this period: {value} ({progress})",
            Fa: "Monthly",
            Fb: "No pace data available yet",
            Fc: "Weekly",
            Fd: "Progress",
            Fe: "{parent} statistics",
            Ff: "I don’t want to answer",
            Fg: "I don’t remember",
            Fh: "Last question!",
            Fi: "Other",
            Fj: "Send answer",
            Fk: "Ads",
            Fl: "Blog",
            Fm: "Nozbe Blog",
            Fn: "Nozbe books (No Office, 10 Steps to Ultimate Productivity)",
            Fo: "Other blog/book",
            Fp: "Blog/book",
            Fq: "Which blog or book?",
            Fr: "From a friend",
            Fs: "Podcast",
            Ft: "Nozbe Podcasts (The Podcast/No Office)",
            Fu: "Other podcast",
            Fv: "Which podcast?",
            Fw: "How did you find out about Nozbe?",
            Fx: "Google search",
            Fy: "Social media",
            Fz: "Other",
            FA: "Which social media?",
            FB: "App Store/Play Store",
            FC: "Webinar/Video",
            FD: "Other video",
            FE: "Other Nozbe video",
            FF: "Nozbe Podcasts (No Office/Nie Ma Biura)",
            FG: "Nozbe Product Vlog",
            FH: "Which video?",
            FI: "Video/Webinar",
            FJ: "Nozbe Webinar",
            FK: "That’s it!",
            FL: "Your answer will help us make Nozbe better.",
            FM: "Thank you!",
            FN: "One quick question!",
            FO: "Quick survey!",
            FP: "Error",
            FQ: "Sync error",
            FR: "Are you sure you want to archive this tag?",
            FS: "Are you sure you want to restore this tag?",
            FT: "Icon",
            FU: "New tag name",
            FV: "More options",
            FW: "Change color",
            FX: "Change icon",
            FY: "Type in the tag name",
            FZ: "New tag",
            F0: "Who can see this tag",
            F1: "Keep recurrence",
            F2: "Remove recurrence",
            F3: "The task you abandoned was recurring. Do you want to remove the recurrence as well?",
            F4: "Recurring task abandoned",
            F5: "You’ve just completed a recurring task. It will renew at night with a new due date. It will keep renewing until you disable the recurrence in that task. You can access its past occurrences in your completed tasks.",
            F6: "You’ve just completed a recurring task. {count, plural, =0 {This is its last occurrence, and it won’t renew again} one {It will renew one more time at night with a new due date} other {It will renew {count} more times}}. You can access its past occurrences through your completed tasks.",
            F7: "You’ve just completed a recurring task. It will renew at night with a new due date. It will keep renewing until {endDate}. You can access its past occurrences through your completed tasks.",
            F8: "Recurring task completed",
            F9: "You’ve granted access to a recurring task. The guest won’t be able to see or change your recurrence settings, however they will have access to the task and its whole history from now on.",
            F$: "Recurring task granted",
            F_: "{taskCount, plural,\n        one {{taskCount} task}\n        other {{taskCount} tasks}}",
            Ga: "{hours, plural,\n    =0 {}\n    one {{hours} hour }\n    other {{hours} hours }\n    }{minutes, plural,\n    =0 {}\n    other {{minutes} minutes}}",
            Gb: "{hours}:{minutes}",
            Gc: "This task belongs to a project ended by {memberName}. Consider completing this task or moving it to another project.",
            Gd: "This task repeats {pattern}. You are viewing its occurrence scheduled for {ghostDate}. The active task is scheduled for {originalDate}.",
            Ge: "This task repeats {pattern}. You are viewing its occurrence completed on {completeDate}. The current active task is scheduled for {newDate}.",
            Gf: "This task is in your Incoming because\n it was assigned to you.",
            Gg: "This task is in your Incoming because it’s due today.",
            Gh: "This task is in your Incoming because\n you were mentioned in a comment.",
            Gi: "This task is in your Incoming because\n you added it via Quick Add or outside of the app.",
            Gj: "This task is in your Incoming because it’s overdue.",
            Gk: "This task is in your Incoming because\n you set a reminder for it.",
            Gl: "History is locked",
            Gm: "Tasks completed more than 7 days ago are hidden.",
            Gn: "Go Premium to unlock full history and more efficiency-boosting features.",
            Go: "Notify space owner",
            Gp: "",
            Gq: "Upgrade",
            Gr: "",
            Gs: "Enjoying task-based communication?",
            Gt: "New comments",
            Gu: "New reactions",
            Gv: "New messages",
            Gw: "Remind me",
            Gx: "{times, plural,\n    one {One occurrence of this task was not completed on time.}\n    other {{times} occurrences of this task were not completed on time.}}",
            Gy: "This task will be assigned to {granteeEmail} after they accept the invitation.",
            Gz: "This task will be assigned to the guest user once they open the invitation link.",
            GA: "Pending invitation for {granteeEmail}",
            GB: "Shared with {member}",
            GC: "Access granted by {member}",
            GD: "Pending invitation via link",
            GE: "Couldn’t load comments.",
            GF: "Couldn’t load the timeline.",
            GG: "It seems you’re offline.",
            GH: "Loading comments…",
            GI: "Loading more comments…",
            GJ: "Please wait",
            GK: "Tap to load more",
            GL: "Task abandoned",
            GM: "Revoked from:",
            GN: "Task access changed to:",
            GO: "Task access revoked",
            GP: "Task access granted to:",
            GQ: "Granted to:",
            GR: "Task completed",
            GS: "Task added",
            GT: "Comment deleted",
            GU: "from",
            GV: "Due date changed to:",
            GW: "Due date changed",
            GX: "Due date removed",
            GY: "Due date set to:",
            GZ: "to",
            G0: "{eventsCount} changes",
            G1: "via {integration, select, api {Nozbe API} evernote {Evernote} zapier {Zapier} make {Make} mcal {Outlook Calendar} gcal {Google Calendar} email {email} other {unknown integration}}\n\n",
            G2: "from",
            G3: "Renamed to:",
            G4: "to",
            G5: "from project",
            G6: "Moved to",
            G7: "Moved",
            G8: "to",
            G9: "Recurrence added:",
            G$: "from",
            G_: "Recurrence changed to:",
            Ha: "Recurrence changed",
            Hb: "Recurrence removed:",
            Hc: "to",
            Hd: "from",
            He: "Reminder changed to:",
            Hf: "Reminder changed",
            Hg: "Reminder removed",
            Hh: "Reminder set to:",
            Hi: "to",
            Hj: "Recurring task completed",
            Hk: "from",
            Hl: "Task renewed:",
            Hm: "to",
            Hn: "from",
            Ho: "Assigned to:",
            Hp: "Assigned",
            Hq: "Unassigned:",
            Hr: "Assigned to:",
            Hs: "to",
            Ht: "Task restored",
            Hu: "from section",
            Hv: "Moved to section:",
            Hw: "Moved",
            Hx: "Unassigned section:",
            Hy: "Moved to section:",
            Hz: "to section",
            HA: "Assigned {tagsCount, plural,\n    one {{tagsCount} tag}\n    other {{tagsCount} tags}}:",
            HB: "Assigned",
            HC: "Changed {tagsCount, plural,\n    one {{tagsCount} tag}\n    other {{tagsCount} tags}}:",
            HD: "Unassigned {tagsCount, plural,\n    one {{tagsCount} tag}\n    other {{tagsCount} tags}}:",
            HE: "Unassigned",
            HF: "Highlight related comment",
            HG: "Editable comment updated",
            HH: "Comment converted to editable by others",
            HI: "Time needed changed to:",
            HJ: "Time needed changed",
            HK: "Time needed removed:",
            HL: "Time needed set to:",
            HM: "Time spent changed to:",
            HN: "Time spent changed",
            HO: "Time spent removed",
            HP: "Time spent set to:",
            HQ: "from",
            HR: "to",
            HS: "Unknown event",
            HT: "Unknown",
            HU: "You’ve been invited to collaborate on the task {taskName}.\nAccept the invitation using this link: {link}.",
            HV: "The invitation link is active",
            HW: "This task is already shared with {granteeName}. Revoke their access first if you want to share this task with someone else.",
            HX: "Generate link",
            HY: "Invitation link",
            HZ: "Drop files here to create a task for them",
            H0: "{completedCount} completed, {abandonedCount} abandoned today",
            H1: "{abandonedCount} abandoned today",
            H2: "{completedCount} completed today",
            H3: "Show more",
            H4: "From {date}",
            H5: "Due date from",
            H6: "Until {date}",
            H7: "Due date until",
            H8: "{start} – {end}",
            H9: "Date is relative",
            H$: "Without due date",
            H_: "Without groups",
            Ia: "Filter by name",
            Ib: "Doesn’t matter",
            Ic: "With",
            Id: "Without",
            Ie: "Without section",
            If: "Only shared tasks",
            Ig: "Without shared tasks",
            Ih: "Doesn’t matter",
            Ii: "Granted access",
            Ij: "With",
            Ik: "Without",
            Il: "Without tags",
            Im: "Filters",
            In: "Copy task list link",
            Io: "Share task list link",
            Ip: "Change {count}",
            Iq: "Select tasks",
            Ir: "Select all",
            Is: "With { member }",
            It: "Task cloned from {originalTaskUrl}",
            Iu: "Clone this task",
            Iv: "Clone this task with all its attributes and pinned comments. Please note that in cloned tasks, the attachments in pinned comments may be visible after a few minutes.",
            Iw: "The person you shared the original task with won’t automatically receive access to the cloned task.",
            Ix: "{taskName} - clone",
            Iy: "Task clone name",
            Iz: "Task name",
            IA: "Selected responsibles",
            IB: "If you select more than 1 responsible person, the task will be cloned for each person",
            IC: "Completed at",
            ID: "Added at",
            IE: "Change task name",
            IF: "Opening task…",
            IG: "Unknown link. This task no longer exists or you don’t have access to it.",
            IH: "Join task",
            II: "{inviterName} ({inviterEmail}) from the {teamName} space wants to share the {taskName} task with you.",
            IJ: "You cannot accept the invitation because you’re using Nozbe as a guest. You can sign up to Nozbe for free, or use a different Nozbe account to accept the invitation.",
            IK: "It looks like you don’t have access to this task. Make sure that the invitation isn’t expired, or try refreshing the app.",
            IL: "Task invitation",
            IM: "Are you sure you want to reject the invitation to the {taskName} task from {inviterName} from the {teamName} space?",
            IN: "You now have access to the {taskName} task from {inviterName} from the {teamName} space.",
            IO: "Select which space to use to accept the invitation.",
            IP: "Abandon",
            IQ: "Are you sure you want to permanently delete this task and all its comments? This can’t be undone! Leaving it as Abandoned will allow you to still get back to it if you need it. Write the task’s name below to confirm that you want to permanently delete it.",
            IR: "This can’t be undone! This task will be gone forever. Are you sure you want to proceed?",
            IS: "This task is visible to others. Are you sure you want to delete this task permanently? THIS CAN NOT BE UNDONE!",
            IT: "Leaving it as Abandoned will allow you to still get back to it if you need it.",
            IU: "This will convert the {taskName} task into a project of the same name. Checklists will be converted into tasks, while other content will be moved to separate tasks with project resources. This will also abandon the task. Are you sure you want to proceed?",
            IV: "Convert task into a project",
            IW: "Convert pinned comments only",
            IX: "Converted from task {TaskButton}",
            IY: "Project resources",
            IZ: "Converted into project {projectLink}",
            I0: "Files",
            I1: "Notes",
            I2: "Copy task link",
            I3: "Enable time attributes in:",
            I4: "Enter fullscreen mode",
            I5: "Mark as reviewed",
            I6: "Mark as unread",
            I7: "Move to another space",
            I8: "Select the space and project to move the task {taskName} to. WARNING: Some users may lose access to this task.",
            I9: "Select the space and project to move {tasksCount} tasks to. WARNING: Some users may lose access to these task.",
            I$: "We couldn’t move {tasksCount, plural,\none {task}\nother {{tasksCount} tasks}} to another space. Please try again, and if the problem persists, contact us at support@nozbe.com.",
            I_: "{tasksCount, plural,\n  one {task was moved successfully.}\n  other {{tasksCount} tasks were moved successfully.}}",
            Ja: "New task name",
            Jb: "Share link",
            Jc: "You cannot restore a granted task.",
            Jd: "Undo",
            Je: "Task marked as read",
            Jf: "“{taskName}” marked as read",
            Jg: "{numberOfTasks, plural, one {One task} other {{numberOfTasks} tasks}} marked as read",
            Jh: "“{projectName}” marked as seen",
            Ji: "Task marked as reviewed",
            Jj: "“{taskName}” marked as reviewed",
            Jk: "{numberOfTasks, plural, one {One task} other {{numberOfTasks} tasks}} marked as reviewed",
            Jl: "Abandoned",
            Jm: "Open",
            Jn: "Completed",
            Jo: "Enabling time attributes will allow for setting time needed and spent for every task in the project. Do you want to enable them in the {projectName} project?",
            Jp: "Space invitation",
            Jq: "{inviterName} ({inviterEmail}) invited you to join the {teamName} space. After accepting the invitation, you will be logged in to your account again.",
            Jr: "This invitation has expired or has already been used and cannot be accepted anymore. If you didn’t accept it in time, please contact the inviting party and request a new invitation.",
            Js: "You’re requesting to join a new space. After sending a request, you’ll need to wait for approval from one of the space’s admins.",
            Jt: "Your request was sent. Now you need to wait for one of the space’s admins’ approval. We will notify you when it’s done.",
            Ju: "Hooray! You’ve been invited to join a space in Nozbe! Sign up and accept the invitation to unlock the power of unlimited productivity through task-based communication. Discover powerful features that won’t be available if you continue using Nozbe as a guest. You will still retain access to all shared tasks after signing up and joining the space.",
            Jv: "Admins:",
            Jw: "Congratulations!",
            Jx: "You’ve joined {teamName}.",
            Jy: "{membersCount, plural,\n    one {{membersCount} member}\n    few {{membersCount} members}\n    other {{membersCount} members}}",
            Jz: "Space avatar",
            JA: "Assigned business",
            JB: "Activate the link and share it to invite as many new members as you like!",
            JC: "Activate invite by code",
            JD: "You can paste addresses separated by commas or dots.",
            JE: "You can paste addresses separated by commas or dots, or simply choose them from your contacts list.",
            JF: "You’ve been invited to {teamName}.\nYour invitation code is {teamCode}. Sign up using this link: {link} to create a new account and join the space. ",
            JG: "By email",
            JH: "The invitations are on their way to your new space members!\nHowever, the following email addresses are incorrect or have already been invited. You can change them by hitting the ”Try Again” button:",
            JI: "Invite code is active",
            JJ: "Deactivate code",
            JK: "Generate code",
            JL: "Copied!",
            JM: "Generate invite code",
            JN: "Your code",
            JO: "Share link",
            JP: "Email",
            JQ: "Join {teamName} in Nozbe!",
            JR: "By link",
            JS: "Invited {numberOfEmails, plural,\none {{email} to the space}\nother {{numberOfEmails} members}\n}!",
            JT: "Invite new space member",
            JU: "Type a new name",
            JV: "Space name",
            JW: "Owner",
            JX: "Space settings",
            JY: "We couldn’t save your space’s settings. Please try again in a few minutes. If the issue persists, please get in touch with us at support@nozbe.com.",
            JZ: "My Nozbe settings",
            J0: "Template name",
            J1: "New template name",
            J2: "Who can see this template",
            J3: "https://nozbe.com/terms",
            J4: "and",
            J5: "Terms of Service",
            J6: "Connect account",
            J7: "Selected {thirdPartyName} teammates will receive an invitation to {teamName}’s Nozbe.",
            J8: "Invite {thirdPartyName} team members to Nozbe",
            J9: "Do you want to connect your account to {thirdPartyName}?",
            J$: "Choose space",
            J_: "Your account is connected!",
            Ka: "New message to: {threadName}",
            Kb: "Message preview",
            Kc: "Messages",
            Kd: "{value, plural,\n    one {{value} day}\n    few {{value} days}\n    other {{value} days}}",
            Ke: "{value, plural,\n    one {{value} hour}\n    few {{value} hours}\n    other {{value} hours}}",
            Kf: "{value, plural,\n    one {{value} minute}\n    few {{value} minutes}\n    other {{value} minutes}}",
            Kg: "{value} d",
            Kh: "{value} h",
            Ki: "{value} min",
            Kj: "@all mention will notify everyone in your space who has access to this project. Note that the users who have access to this project but are not following it will also be notified.",
            Kk: "Mention all with access",
            Kl: "@following mention will notify anyone who follows this project. Users that have access to this project but are not following it won’t be notified.",
            Km: "Mention all following",
            Kn: "Local time",
            Ko: "Task me",
            Kp: "Message me",
            Kq: "View profile",
            Kr: "Schedule your vacation",
            Ks: "Are you sure you want to update your vacation from {previousVacationDate} to {newVacationDate}?",
            Kt: "You’ve selected {selectedVacationDate}, but vacations are already planned for this period. Do you want to continue?",
            Ku: "Are you sure you want to cancel your vacation for {vacationDate}?\n",
            Kv: "Turning on vacation mode will pause all notifications until you’re back.",
            Kw: "Set for the entire {businessName} business",
            Kx: "Business-wide",
            Ky: "End date",
            Kz: "Edit vacation",
            KA: "Schedule your vacation",
            KB: "Pick date",
            KC: "Start date",
            KD: "Scheduled vacations",
            KE: "{memberName} is away on vacation until {awayUntil}. Do you want to continue?\n\n",
            KF: "Only English letters, numbers, underscores, and dots are allowed",
            KG: "Valid email address required",
            KH: "Only English letters and numbers are allowed",
            KI: "Fields don’t match",
            KJ: "Maximum length is {maxLength}",
            KK: "Minimum length is {minLength}",
            KL: "The Tax ID you entered is invalid",
            KM: "Password must contain at least 1 digit, 1 lower case letter, 1 upper case letter, and 1 special character.",
            KN: "Phone number with country code is required"
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => f
        });
        var n = s(69),
            a = s(24),
            o = s(5),
            r = s(4),
            i = s(8);
        const c = (e, ...t) => {
            false
        };
        class l {
            constructor() {
                const e = new o.MemoryResourceStorage({
                    cleanup: {
                        maxCachedSize: 2e7,
                        getEntrySize: ([, e]) => e.size,
                        onCleanup: e => this._purgeFetchedImages(e)
                    },
                    onRemoveResource: ([, e]) => URL.revokeObjectURL(e.objectUrl)
                });
                this._cache = new o.AsyncResourceCache({
                    storage: e,
                    fetcher: (e, t, s) => this._fetchImage(e, t, s),
                    logger: (e, t) => {
                        const [, s] = t.match(/^http(?:.*)files\/(?:avatars\/)?([^?]+)/) || [];
                        c()
                    }
                })
            }
            observe(e, t) {
                return this._cache.fetch(e, t).pipe(i.map((e => e.objectUrl)))
            }
            abort(e) {
                return this._cache.abort(e)
            }
            invalidate() {
                this._cache.clear()
            }
            _purgeFetchedImages(e) {
                const t = r.sortBy((([, e]) => e.size))(e),
                    s = t.slice(0, -10);
                t.slice(-10);
                return c(0), s
            }
            async _fetchImage(e, t, s) {
                const n = await fetch(e, {
                    headers: s,
                    signal: t
                });
                if (!n.ok) throw new Error("fetch failed");
                const a = await n.blob();
                return {
                    objectUrl: URL.createObjectURL(a),
                    size: a.size
                }
            }
        }
        const d = (e, t) => e + ":" + t;
        class u {
            constructor({
                getApi: e
            }) {
                this._getApi = e, this._cache = new o.AsyncResourceCache({
                    fetcher: (e, t, s) => this._fetchVideoMetadata(e, s),
                    storage: new o.MemoryResourceStorage
                })
            }
            get(e, t) {
                const s = d(e, t);
                return this._cache.read(s)
            }
            has(e, t) {
                const s = d(e, t);
                return this._cache.has(s)
            }
            observe(e, t, s) {
                const n = d(e, t);
                return this._cache.fetch(n, s)
            }
            invalidate() {
                this._cache.clear()
            }
            async _fetchVideoMetadata(e, t) {
                const s = this._getApi(),
                    [n, a] = (e => {
                        const t = e.split(":");
                        invariant(2 === t.length, "Broken external video cache key");
                        const [s, n] = t;
                        return invariant("youtube" === s || "vimeo" === s, "Unsupported cached external video"), [s, n]
                    })(e);
                return s.attachments.getExternalVideoMetadata(n, a, t.videoUrl)
            }
        }
        var m, h, p;
        const g = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let f = (h = g(m = class {
            constructor(e) {
                (0, n.Z)(this, "image", h, this), (0, n.Z)(this, "externalVideo", p, this), this._api = e
            }
            invalidate() {
                this.image.invalidate(), this.externalVideo.invalidate()
            }
        }, "image", [o.lazy], (function() {
            return new l
        })), p = g(m, "externalVideo", [o.lazy], (function() {
            return new u({
                getApi: () => this._api
            })
        })), m)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(5);
        var n = s(4),
            a = s(232);

        function o(e, t) {
            const s = new Date;
            return new Promise(((o, i) => {
                const {
                    method: c = "GET",
                    body: l,
                    headers: d = {},
                    signal: u,
                    onDownloadProgress: m,
                    onUploadProgress: h
                } = t, p = new globalThis.XMLHttpRequest;
                p.open(c, e, !0), n.toPairs(d).forEach((([e, t]) => {
                    p.setRequestHeader(e, t)
                })), p.responseType = "blob", p.onload = async () => {
                    const e = new r(p);
                    e.ok ? o(e) : i(await (0, a.oE)(e))
                }, p.onerror = () => {
                    i((0, a.S3)(new TypeError("Network request failed"), s))
                }, p.onabort = () => {
                    i((0, a.S3)(new globalThis.DOMException("Aborted", "AbortError"), s))
                }, p.ontimeout = () => {
                    i((0, a.S3)(new TypeError("Network request timed out"), s))
                }, m && (p.onloadstart = e => {
                    m(e.lengthComputable ? 0 : void 0)
                }, p.onprogress = e => {
                    m(e.lengthComputable ? e.loaded / e.total : void 0)
                }), h && (p.upload.onloadstart = e => {
                    h(e.lengthComputable ? 0 : void 0)
                }, p.upload.onprogress = e => {
                    h(e.lengthComputable ? e.loaded / e.total : void 0)
                }), u && (u.onabort = () => {
                    p.abort()
                }), p.send(null != l ? l : null)
            }))
        }
        class r {
            constructor(e) {
                this.isXHRResposne = !0, this._xhr = e
            }
            get status() {
                return this._xhr.status
            }
            get ok() {
                return 200 <= this.status && 300 > this.status
            }
            text() {
                return this._xhr.response instanceof Blob ? this._xhr.response.text() : Promise.reject(new Error("Expected XHR response to be a blob"))
            }
            json() {
                return this.text().then(JSON.parse)
            }
            blob() {
                return this._xhr.response instanceof Blob ? Promise.resolve(this._xhr.response) : Promise.reject(new Error("no blob available for this response"))
            }
        }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            $n: () => a,
            F2: () => r,
            hv: () => o,
            vq: () => n
        });
        s(17), s(5), s(23);
        async function n() {
            try {
                const e = await fetch("https://hello.nozbe.com/getid/", {
                    credentials: "include"
                });
                return (await e.json()).id
            } catch (e) {
                return ""
            }
        }

        function a(e) {
            return {
                name: e.name,
                id: e.id,
                teamId: e.team_id,
                lastUsed: e.last_time_used,
                value: e.value
            }
        }
        const o = e => Object.keys(e).map((t => "object" == typeof e[t] ? encodeURIComponent(t) + "=" + encodeURIComponent(JSON.stringify(e[t])) : encodeURIComponent(t) + "=" + encodeURIComponent(e[t]))).join("&");

        function r(e, t) {
            return Object.assign({
                team_id: e.id,
                is_electron: String(!!globalThis.electron),
                dev_application_url: void 0
            }, null != t && {
                is_for_all_spaces: String(t)
            })
        }
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(1282))),
            r = (n.ReactUtils.lazy((() => s(1289))), e => {
                const {
                    switchSidebarContent: t,
                    isShowingTeamSwitch: s
                } = e;
                return (0, a.jsx)(o, {
                    switchSidebarContent: t,
                    isShowingTeamSwitch: s
                })
            })
    }, , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            $: () => S
        });
        var n = s(0),
            a = s(849),
            o = s(1459),
            r = s(331),
            i = s(357),
            c = s(358);

        function l(e, t) {
            const {
                intl: s,
                currentTeam: a
            } = e, o = a.allProjectsWithoutSingleTasks.observeCount().pipe(n.Rx.map((e => 1 > e))), r = {
                name: "add_project",
                imageUrl: "https://files.nozbe.com/images/nt-banner-add-project-1.png",
                headline: s.f.Dm,
                buttonLabel: s.f.Dn,
                action: "add_project",
                canBeDisplayed: o,
                shouldReappearAfterHiding: x
            };
            return new k(r, e, t)
        }

        function d(e, t) {
            const {
                intl: s,
                services: a,
                hasCurrentMemberAdminPowers: o,
                prefersPersonalUI: r,
                currentTeam: i
            } = e, c = o && !r ? a.modelRoot.settings.hasSkippedTeamSetup.forTeam(i).observe().pipe(n.Rx.switchMap((e => e ? n.Rx.of(!1) : i.members.observeCount().pipe(n.Rx.map((e => 1 === e)))))) : n.Rx.of(!1), l = {
                name: "add_member",
                imageUrl: "https://files.nozbe.com/images/nt-banner-add-member-3.png",
                headline: s.f.Dk,
                buttonLabel: s.f.Dl,
                action: "add_member",
                canBeDisplayed: c
            };
            return new k(l, e, t)
        }

        function u(e, t) {
            const {
                intl: s,
                services: o
            } = e, r = o.modelRoot.settings.signedUpAt.observe().pipe(n.Rx.map((e => !!e && 1 > (0, a.Z)(Date.now(), e)))), i = {
                name: "help_page",
                imageUrl: "https://files.nozbe.com/images/nt-banner-help-page-1.png",
                headline: s.f.Ds,
                buttonLabel: s.f.Dt,
                action: "help_page",
                payload: "general/video-tutorial",
                canBeDisplayed: r,
                hideOnAction: !0
            };
            return new k(i, e, t)
        }

        function m(e, t) {
            const {
                intl: s,
                services: a
            } = e, o = n.Misc.isElectron ? n.Rx.of(!1) : a.modelRoot.settings.lastUsedDesktopAt.observe().pipe(n.Rx.map((e => !e))), r = {
                name: "install_app",
                imageUrl: "https://files.nozbe.com/images/nt-banner-install-app.png",
                headline: s.f.Du,
                buttonLabel: s.f.Dx,
                action: "open_link",
                payload: j(),
                canBeDisplayed: o
            };
            return new k(r, e, t)
        }

        function h(e, t) {
            const {
                intl: s,
                services: a
            } = e, o = a.modelRoot.settings.lastUsedMobileAt.observe().pipe(n.Rx.map((e => !e))), r = {
                name: "install_app_mobile",
                imageUrl: "https://files.nozbe.com/images/nt-banner-install-app-mobile.png",
                headline: s.f.Dv,
                buttonLabel: s.f.Dw,
                action: "open_link",
                payload: "https://nozbe.com/download?p=mobile",
                canBeDisplayed: o
            };
            return new k(r, e, t)
        }

        function p(e, t) {
            const {
                intl: s,
                currentMember: a
            } = e, o = a.user.observe().pipe(n.Rx.map((e => !e.avatarId))), r = {
                name: "open_settings",
                imageUrl: "https://files.nozbe.com/images/nt-banner-open-settings-1.png",
                headline: s.f.Dy,
                buttonLabel: s.f.Dz,
                action: "open_settings",
                canBeDisplayed: o
            };
            return new k(r, e, t)
        }

        function g(e, t) {
            const {
                intl: s,
                hasCurrentMemberAdminPowers: a,
                isShowingSomeOtherPromo: o,
                currentTeam: r
            } = e, i = a && !o ? r.observe().pipe(n.Rx.map((e => e.isFree))) : n.Rx.of(!1), c = {
                name: "up_to_premium",
                imageUrl: "https://files.nozbe.com/images/nt-banner-upgrade-1.png",
                headline: s.f.DE,
                buttonLabel: s.f.DH,
                action: "upgrade",
                canBeDisplayed: i,
                shouldReappearAfterHiding: x
            };
            return new k(c, e, t)
        }

        function f(e, t) {
            const {
                intl: s,
                services: a,
                hasCurrentMemberAdminPowers: o,
                currentTeam: r
            } = e, c = o ? n.Rx.combineLatestObject({
                team: r.observe(),
                manageableStandaloneTeams: a.modelRoot.manageableStandaloneTeams
            }).pipe(n.Rx.map((({
                team: e,
                manageableStandaloneTeams: t
            }) => {
                const {
                    isFreeOrTrial: s,
                    isBusiness: n
                } = e.planInfo;
                return !s && !n && 2 <= t.length
            }))) : n.Rx.of(!1), l = {
                name: "up_to_premium_business",
                imageUrl: "https://files.nozbe.com/images/nt-banner-upgrade-business-1.png",
                headline: s.f.DF,
                buttonLabel: s.f.DG,
                action: "upgrade_business",
                payload: i.p.Personal,
                canBeDisplayed: c
            };
            return new k(l, e, t)
        }

        function b(e, t) {
            const {
                intl: s,
                services: a,
                prefersPersonalUI: o
            } = e, r = o ? n.Rx.of(!1) : a.modelRoot.ownedTeams.pipe(n.Rx.switchMap((e => n.Rx.combineLatest(e.map((e => e.members.observeCount()))))), n.Rx.map((e => e.every((e => 1 < e))))), c = {
                name: "add_space",
                imageUrl: "https://files.nozbe.com/images/nt-banner-add-space-3.png",
                headline: s.f.Do,
                buttonLabel: s.f.Dr,
                action: "add_space",
                payload: i.p.Personal,
                canBeDisplayed: r
            };
            return new k(c, e, t)
        }

        function y(e, t) {
            const {
                intl: s,
                services: a,
                prefersPersonalUI: o
            } = e, r = o ? a.modelRoot.ownedTeams.pipe(n.Rx.switchMap((e => n.Rx.combineLatest(e.map((e => e.members.observeCount()))))), n.Rx.map((e => e.every((e => 1 === e))))) : n.Rx.of(!1), c = {
                name: "add_space_2",
                imageUrl: "https://files.nozbe.com/images/nt-banner-add-space-4.png",
                headline: s.f.Dp,
                buttonLabel: s.f.Dq,
                action: "add_space",
                payload: i.p.Team,
                canBeDisplayed: r
            };
            return new k(c, e, t)
        }

        function v(e, t) {
            const {
                intl: s,
                services: a
            } = e, o = a.modelRoot.settings.observeCreditsGrantedSetting().pipe(n.Rx.map((e => !e))), i = {
                name: "referral",
                imageUrl: "https://files.nozbe.com/images/nt-banner-referral-2.png",
                headline: s.f.DA,
                buttonLabel: s.f.DD,
                action: "referral",
                payload: r.i.Link,
                canBeDisplayed: o
            };
            return new k(i, e, t)
        }

        function w(e, t) {
            const {
                intl: s,
                services: a
            } = e, o = a.modelRoot.settings.observeCreditsGrantedSetting().pipe(n.Rx.map((e => (0, r.U)(e)))), i = {
                name: "referral_2",
                imageUrl: "https://files.nozbe.com/images/nt-banner-referral-3.png",
                headline: s.f.DB,
                buttonLabel: s.f.DC,
                action: "referral",
                payload: r.i.Credits,
                canBeDisplayed: o
            };
            return new k(i, e, t)
        }
        class k {
            get name() {
                return this._content.name
            }
            get isVisible() {
                return n.Rx.nowAndEveryDay().pipe(n.Rx.switchMap((() => n.Rx.wrap(!this.isHidden && this._content.canBeDisplayed))))
            }
            get isHidden() {
                var e, t;
                const s = this._hiddenBanners.get(this.name);
                return !(!s || null != (e = (t = this._content).shouldReappearAfterHiding) && e.call(t, s))
            }
            get canBeHidden() {
                var e;
                return null == (e = this._content.canBeHidden) || e
            }
            constructor(e, t, s) {
                this._content = e, this._context = t, this._hiddenBanners = s
            }
            getImageUrl(e, t) {
                return (0, c.nu)(this._content.imageUrl, t)
            }
            getHeadline() {
                return this._content.headline
            }
            getButtonLabel() {
                return this._content.buttonLabel || this._content.action && (0, c.wY)(this._content.action, this._context)
            }
            triggerAction() {
                const {
                    action: e,
                    payload: t,
                    hideOnAction: s
                } = this._content;
                e && ((0, c.C$)(e, this._context, t), s && this.hide())
            }
            async hide() {
                if (this.canBeHidden) {
                    const {
                        services: e,
                        currentTeam: t
                    } = this._context;
                    await e.modelRoot.settings.hideAppBanner(this.name, t)
                }
            }
        }

        function x(e) {
            const {
                hiddenCount: t = 0
            } = e;
            return !(6 < t) && (3 === t ? function({
                hiddenOn: e
            }) {
                return 0 < (0, o.Z)(new Date, e)
            }(e) : function({
                hiddenOn: e
            }) {
                return 0 < (0, a.Z)(new Date, e)
            }(e))
        }

        function j() {
            switch (n.ReactUtils.getDeviceOS()) {
                case "macOS":
                    return "https://nozbe.com/download?=macos";
                case "Windows":
                    return "https://nozbe.com/download?p=windows";
                default:
                    return "https://nozbe.com/download?p=desktop"
            }
        }
        class T {
            get name() {
                return this._banner.name
            }
            get isVisible() {
                return n.Rx.nowAndEveryHour().pipe(n.Rx.map((() => this.canBeDisplayed && !this.isHidden)))
            }
            get canBeDisplayed() {
                const {
                    action: e
                } = this._banner, {
                    currentMember: t,
                    hasCurrentMemberAdminPowers: s,
                    currentTeam: a
                } = this._context, o = Object.values(n.Model.AdminBannerButtonActions), r = Object.values(n.Model.OwnerBannerButtonActions);
                return o.includes(e) ? s : r.includes(e) ? t.isOwner : "extend" !== e || a.isFreeOrTrial
            }
            get isHidden() {
                var e, t;
                const s = Date.now(),
                    n = null == (e = this._hiddenBanners.get(this.name)) ? void 0 : e.hiddenOn,
                    a = null != (t = this._banner.hide_for) ? t : 1 / 0;
                return !!n && s - n <= a
            }
            constructor(e, t, s) {
                this.canBeHidden = !0, this._banner = e, this._context = t, this._hiddenBanners = s
            }
            getImageUrl(e, t) {
                const {
                    path_to_image: s,
                    i18n_path_to_image: n
                } = this._banner, a = n ? (0, c.rt)(n, e) : s;
                return a ? (0, c.nu)(a, t) : null
            }
            getHeadline(e) {
                var t;
                return (null == (t = this._banner.i18n) ? void 0 : t[e]) || this._banner.message
            }
            getButtonLabel(e) {
                const {
                    i18n_button: t,
                    i18n_path_to_image: s,
                    action: n
                } = this._banner;
                if (null != t && t[e]) return t[e];
                return !Boolean(s) && n ? (0, c.wY)(n, this._context) : null
            }
            triggerAction() {
                this._banner.action && (0, c.C$)(this._banner.action, this._context, this._banner.payload)
            }
            async hide() {
                if (this.canBeHidden) {
                    const {
                        services: e,
                        currentTeam: t
                    } = this._context;
                    await e.modelRoot.settings.hideBackendBanner(this.name, t)
                }
            }
        }

        function S(e, t) {
            const {
                services: s,
                currentTeam: a,
                isShowingSomeOtherPromo: o
            } = e, r = o ? 3 : 4;
            return n.Rx.combineLatestObject({
                backendBannerSetting: _(s, a),
                hiddenBackendBanners: s.modelRoot.settings.hiddenBackendBanners.forTeam(a).observe().pipe(n.Rx.map(P)),
                hiddenAppBanners: s.modelRoot.settings.hiddenAppBanners.forTeam(a).observe().pipe(n.Rx.map(P))
            }).pipe(n.Rx.map((({
                backendBannerSetting: s,
                hiddenBackendBanners: n,
                hiddenAppBanners: a
            }) => {
                const o = function(e, t, s) {
                        return e.map((e => new T(e, t, s)))
                    }(s, e, n),
                    r = function(e, t) {
                        return [l, d, u, m, h, p, g, f, b, y, v, w].map((s => s(e, t)))
                    }(e, a),
                    {
                        omitBannersByName: i
                    } = t;
                return [...o, ...r].filter((e => !i.includes(e.name)))
            })), n.Rx.switchMap((e => n.Rx.combineLatestTuples(e.map((e => [e, e.isVisible]))).pipe(n.Rx.map((e => {
                const t = [];
                for (const [s, n] of e)
                    if (n && t.push(s), t.length === r) break;
                return t
            }))))))
        }

        function P(e) {
            return new Map(e.map((e => [e.name, e])))
        }

        function _(e, t) {
            const {
                settings: s
            } = e.modelRoot;
            return n.Rx.combineLatest(s.backendBanners.observe(), s.backendBannersPersonalized.forTeam(t).observe()).pipe(n.Rx.map((([e, t]) => e.concat(t).slice().sort(((e, t) => {
                var s, n;
                return (null != (s = e.priority) ? s : 0) - (null != (n = t.priority) ? n : 0)
            })))))
        }
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(535)
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(537)
    }, , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(32),
            o = s(20),
            r = s(1);
        const i = n.ReactUtils.lazy((() => s(214))),
            c = n.Hocs.compose()((e => {
                const {
                    closeMenu: t,
                    target: s,
                    sort: c
                } = e, l = n.Hooks.useIntl(), d = n.Hooks.useServices(), {
                    currentTeam: u
                } = n.Hooks.useIdentity(), [m, h] = n.Hooks.useStateMachine("main"), p = n.Hooks.useModalState(), g = () => (0, r.jsx)(i, {
                    sort: c,
                    onChange: (e, s) => {
                        (async e => {
                            await d.modelRoot.settings.setSidebarBuiltinGroupSort(n.Model.SidebarBuiltinGroups.Favorites, e, u)
                        })(s), t()
                    },
                    disabled: n.Model.SidebarBuiltinGroupsDisabledSortBy[n.Model.SidebarBuiltinGroups.Favorites],
                    target: p.target,
                    placement: "right",
                    onClose: p.close
                });
                return m.map({
                    main: () => (0, r.jsxs)(r.Fragment, {
                        children: [(0, r.jsx)(a.ZP, {
                            onClose: t,
                            target: s,
                            children: (0, r.jsx)(o.Z, {
                                label: l.f.EZ,
                                icon: "¯",
                                hasArrow: !0,
                                modalWebTarget: p.target,
                                onPress: p.open
                            })
                        }), p.isOpen ? g() : null]
                    }),
                    sort: g
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n, a, o = s(0),
            r = s(32),
            i = s(20),
            c = s(334),
            l = s(1);
        const d = o.ReactUtils.lazy((() => s(214))),
            u = o.Hocs.compose()((e => {
                const {
                    groupRoot: t,
                    closeMenu: s,
                    target: u,
                    sort: m,
                    onManagePress: h,
                    isCustomSortSupported: p,
                    switchSidebarContent: g,
                    onAddNewProject: f
                } = e, b = o.Hooks.useIntl(), {
                    currentTeam: y
                } = o.Hooks.useIdentity(), v = o.Hooks.useServices(), [{
                    closeAnimated: w
                }, k] = (0, r.XH)(), [x, j] = o.Hooks.useStateMachine("main"), T = o.Hooks.useModalState(), S = o.Hooks.useRemindExpired((() => w(o.ReactUtils.nullEvent()))), P = S((async () => {
                    await v.modelRoot.settings.toggleSidebarBuiltinGroup(t, y)
                })), _ = () => (0, l.jsx)(d, {
                    sort: m,
                    onChange: (e, n) => {
                        (async e => {
                            await v.modelRoot.settings.setSidebarBuiltinGroupSort(t, e, y)
                        })(n), s()
                    },
                    disabled: p ? void 0 : [o.Model.SidebarGroupsSortBy.Custom],
                    target: T.target,
                    placement: "right",
                    onClose: T.close
                });
                return x.map({
                    main: () => (0, l.jsxs)(r.ZP, {
                        ref: k,
                        onClose: s,
                        target: u,
                        children: [f ? (0, l.jsx)(i.Z, {
                            label: b.f.DQ,
                            icon: "ū",
                            hasArrow: !0,
                            onPress: f
                        }) : null, h ? (0, l.jsx)(l.Fragment, {
                            children: (0, l.jsx)(i.Z, {
                                label: b.f.l1,
                                icon: "ş",
                                hasArrow: !0,
                                onPress: h
                            })
                        }) : null, h || f ? n || (n = (0, l.jsx)(r.ZP.Separator, {})) : null, (0, l.jsx)(c.Z, {
                            isActive: !0,
                            onPress: () => {
                                P(), w(o.ReactUtils.nullEvent())
                            }
                        }), (0, l.jsx)(i.Z, {
                            label: b.f.EZ,
                            icon: "¯",
                            hasArrow: !0,
                            modalWebTarget: T.target,
                            onPress: T.open
                        }), T.isOpen ? _() : null, a || (a = (0, l.jsx)(r.ZP.Separator, {})), (0, l.jsx)(i.Z, {
                            label: b.f.Ei,
                            icon: "ƅ",
                            onPress: e => {
                                g(e, "projectsSearch"), w(e)
                            }
                        }), (0, l.jsx)(i.Z, {
                            label: b.f.Ej,
                            icon: "ş",
                            onPress: e => {
                                g(e, "projects"), w(e)
                            }
                        }), (0, l.jsx)(i.Z, {
                            label: b.f.Ek,
                            icon: "Ť",
                            onPress: e => {
                                g(e, "projectsEnded"), w(e)
                            }
                        })]
                    }),
                    sort: _
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(552)
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(0),
            a = s(57),
            o = s(554),
            r = s(92);
        s(2), s(3);
        const i = s(557);
        var c = s(1);
        const l = n.Hocs.compose()((e => {
                const {
                    topDescription: t,
                    title: s,
                    bottomDescription: a,
                    onPressButton: o,
                    onClose: l,
                    buttonLabel: d,
                    textColor: u = "black",
                    shouldCloseOnPress: m = !0
                } = e, h = n.Styling.factoryColor(u);
                return (0, c.jsxs)("div", {
                    className: i.root,
                    children: [t ? (0, c.jsx)("span", {
                        className: i.topDescription + " " + i.textRightGutter,
                        style: {
                            color: h
                        },
                        children: t
                    }) : null, s ? (0, c.jsx)("span", {
                        className: i.title + " " + i.textRightGutter,
                        style: {
                            color: h
                        },
                        children: s
                    }) : null, a ? (0, c.jsx)("span", {
                        className: i.bottomDescription,
                        style: {
                            color: h
                        },
                        children: a
                    }) : null, d && o ? (0, c.jsx)(r.Z, {
                        className: i.button,
                        label: d,
                        isOpaque: !0,
                        color: "black",
                        textColor: "white",
                        onPress: e => {
                            e.stopPropagation(), null == o || o(), m && (null == l || l())
                        }
                    }) : null]
                })
            })),
            d = ({
                imageUrl: e,
                locale: t,
                theme: s
            }) => (e || "empty") + "_" + t + "_" + s;
        const u = s(558);
        var m;
        const h = n.Hocs.compose(n.Hocs.withObservables(null, (() => ({
            currentTheme: n.Styling.theme.asObservable()
        }))))((e => {
            const {
                banner: t,
                onContentMissing: s,
                currentTheme: r
            } = e, i = n.Hooks.useServices(), h = n.Hooks.useIntl().locale, p = t.getHeadline(h), g = t.getButtonLabel(h), f = Boolean(p) && Boolean(g), {
                backgroundSource: b,
                handleBackgroundLoad: y,
                handleBackgroundError: v,
                isBackgroundLight: w,
                isBackgroundLoading: k
            } = function({
                banner: e,
                locale: t,
                theme: s,
                onBackgroundMissing: a
            }) {
                var o;
                const r = e.getImageUrl(t, s),
                    i = {
                        status: r ? "fetching" : "loaded",
                        imageUrl: r,
                        locale: t,
                        theme: s
                    },
                    c = d(i),
                    [l, u] = n.Hooks.useStateResettable(i, [c]),
                    m = c !== d(l),
                    h = "fetching" === l.status || "retrying" === l.status;
                return {
                    isBackgroundLight: "light" === l.theme,
                    isBackgroundLoading: h,
                    backgroundSource: null != (o = l.imageUrl) ? o : void 0,
                    handleBackgroundLoad: () => {
                        !m && h && u(Object.assign({}, l, {
                            status: "loaded"
                        }))
                    },
                    handleBackgroundError: () => {
                        if (!m && h) {
                            if ("fetching" === l.status && "light" !== l.theme) {
                                const s = e.getImageUrl(t, "light");
                                if (s) return void u(Object.assign({}, l, {
                                    status: "retrying",
                                    imageUrl: s
                                }))
                            }
                            a(), u(Object.assign({}, l, {
                                status: "error",
                                imageUrl: null
                            }))
                        }
                    }
                }
            }({
                banner: t,
                locale: h,
                theme: r,
                onBackgroundMissing: () => {
                    f || null == s || s()
                }
            }), x = b ? {
                source: b,
                onLoad: y,
                onError: v
            } : void 0, j = t.canBeHidden ? () => t.hide() : void 0, T = async () => {
                const {
                    name: e
                } = t;
                e ? i.api.telemetry.trackBanner(e) : n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Missing banner name"), await t.triggerAction()
            }, S = f ? (0, c.jsx)(l, {
                title: p,
                textColor: w ? "black" : "white",
                onPressButton: T,
                onClose: j,
                buttonLabel: g,
                shouldCloseOnPress: !1
            }) : k ? (0, c.jsx)("div", {
                className: u.backgroundLoadingOverlay,
                children: m || (m = (0, c.jsx)(a.default, {
                    size: "small"
                }))
            }) : null;
            return (0, c.jsx)(o.Z, {
                background: x,
                isCloseButtonDark: w || !b,
                shouldCloseOnPress: !1,
                onPress: T,
                onClose: j,
                children: S
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(94),
            o = s(11),
            r = s(40);
        s(2), s(3);
        const i = s(555);
        var c = s(1);
        const l = n.ReactUtils.lazy((() => s(22))),
            d = n.Hocs.compose(n.Hocs.memo, n.Hocs.withErrorBoundary({
                name: "RawBanner",
                render: "short"
            }))((e => {
                const {
                    onClose: t,
                    background: s,
                    onPress: d,
                    isCloseButtonDark: u = !0,
                    shouldCloseOnPress: m = !0,
                    children: h
                } = e, [p, g] = n.React.useState(!1), f = n.Hooks.useIntl(), b = (() => {
                    if (Array.isArray(s)) return (0, c.jsx)(r.default, {
                        className: i.illustration,
                        layers: s
                    });
                    if (s) {
                        const {
                            source: e,
                            onLoad: t,
                            onError: n
                        } = "string" == typeof s ? {
                            source: s
                        } : s;
                        return (0, c.jsx)(a.Z, {
                            className: i.image,
                            source: e,
                            cache: !0,
                            resizeMode: "cover",
                            onLoad: e => {
                                g(!0), null == t || t(e)
                            },
                            onError: n
                        })
                    }
                    return null
                })();
                return (0, c.jsxs)(o.Z, {
                    className: i.root,
                    style: p ? {
                        backgroundColor: "transparent"
                    } : {},
                    webComponent: "div",
                    onPress: () => {
                        null == d || d(), m && (null == t || t())
                    },
                    androidNoRipple: !0,
                    children: [b ? (0, c.jsx)("div", {
                        className: i.backgroundContainer,
                        children: b
                    }) : null, h, t ? (0, c.jsx)("div", {
                        className: i.iconContainer + (u ? " " + i.iconContainer_dark : ""),
                        children: (0, c.jsx)(l, {
                            name: "b",
                            accessibilityLabel: f.f.fh,
                            color: u ? "black" : "white",
                            size: 28,
                            iconSize: 22,
                            onPress: e => {
                                e.stopPropagation(), t()
                            }
                        })
                    }) : null]
                })
            }))
    }, , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(22),
            o = s(60);
        s(2), s(3);
        const r = s(560);
        var i = s(11);
        const c = s(561);
        var l = s(1);
        const d = n.Hocs.compose()((e => {
                const {
                    numberOfPages: t,
                    currentPage: s,
                    onPress: n
                } = e;
                return (0, l.jsx)("div", {
                    className: c.root,
                    children: Array.from({
                        length: t
                    }).map(((e, t) => (0, l.jsx)(i.Z, {
                        className: c.dot + (s === t ? " " + c.dotActive : ""),
                        onPress: () => n(t)
                    }, t)))
                })
            })),
            u = n.Hocs.compose()((e => {
                const {
                    children: t
                } = e, s = n.React.Children.toArray(t), [i, c] = n.React.useState(0), u = 0 === i, m = i === s.length - 1;
                n.React.useEffect((() => {
                    const e = Math.max(0, s.length - 1);
                    e < i && c(e)
                }), [s.length, i]);
                const [h, p] = n.React.useState(!1);
                return (0, l.jsxs)(o.tu, {
                    children: [(0, l.jsxs)("div", {
                        className: r.root,
                        onMouseEnter: () => {
                            p(!0)
                        },
                        onMouseLeave: () => {
                            p(!1)
                        },
                        children: [(0, l.jsx)("div", {
                            className: r.slider,
                            style: {
                                transform: "translateX(" + -100 * i + "%)"
                            },
                            children: s.map((e => (0, l.jsx)("div", {
                                className: r.bannerWrapper,
                                children: e
                            }, e.key)))
                        }), 1 < s.length ? (0, l.jsxs)(l.Fragment, {
                            children: [u ? null : (0, l.jsx)(a.default, {
                                className: r.iconButton,
                                style: {
                                    left: -5,
                                    opacity: h ? 1 : 0
                                },
                                name: "7",
                                accessibilityLabel: "",
                                onPress: () => {
                                    c(u ? s.length - 1 : i - 1)
                                },
                                size: 35,
                                color: "incoming"
                            }), m ? null : (0, l.jsx)(a.default, {
                                className: r.iconButton,
                                style: {
                                    right: -5,
                                    opacity: h ? 1 : 0
                                },
                                name: "9",
                                accessibilityLabel: "",
                                size: 35,
                                onPress: () => {
                                    c(m ? 0 : i + 1)
                                },
                                color: "incoming"
                            })]
                        }) : null]
                    }), 1 < s.length ? (0, l.jsx)(d, {
                        currentPage: i,
                        numberOfPages: s.length,
                        onPress: c
                    }) : null]
                })
            }))
    }, , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(554),
            o = s(358),
            r = s(1);
        const i = n.ReactUtils.lazy((() => s(1288))),
            c = n.Hocs.compose(n.Hocs.memo, n.Hocs.withErrorBoundary({
                name: "PromoBanner",
                render: "short"
            }))((e => {
                const {
                    promoSetting: t
                } = e, s = n.Hooks.useIntl(), c = n.Hooks.useServices(), {
                    currentTeam: l
                } = n.Hooks.useIdentity(), d = "ongoing_promo" === t.promo_code, u = e => {
                    const t = l.planInfo.canBeExtended && !l.isExpired ? "plan-extending-banner" : "plan-changing-banner";
                    c.payments.requirements.get(l).change(t, {
                        withPromotion: !0,
                        shouldDisplayBusinessOffer: e
                    })
                };
                return t.is_visible ? (0, r.jsx)(a.Z, {
                    onClose: () => {
                        d && c.ab.ongoingPromoBaseline.trackOnce("dismissed"), c.modelRoot.settings.updatePromoBanner({
                            team: l,
                            isVisible: !1
                        })
                    },
                    background: d ? t.image_url : (0, o.rt)(t.image_url, s.locale),
                    onPress: () => {
                        switch (d && (c.ab.ongoingPromoBaseline.trackOnce("clicked"), c.ab.ongoingPromoBaseline.trackEvery("clickedCount")), t.action) {
                            case "create_new_team":
                                return void c.uiState.addTeamModal.open();
                            case "buy_premium":
                                return void u(!1);
                            case "buy_business":
                                return void u(!0);
                            case "visit_url":
                                return void n.ReactUtils.openUrl(t.url)
                        }
                    },
                    isCloseButtonDark: !d,
                    shouldCloseOnPress: !1,
                    children: d ? (0, r.jsx)(i, {
                        promoSetting: t
                    }) : null
                }) : null
            }))
    }, , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(6),
            o = s(20),
            r = s(13),
            i = s(1);
        const c = () => (0, i.jsx)(r.default, {
                name: "9",
                color: "onBackground2"
            }),
            l = n.Hocs.compose((0, a.LU)({
                minWidth: 500
            }))((e => {
                const {
                    invitations: t
                } = e, s = n.Hooks.useServices(), r = n.Hooks.useIntl(), {
                    closeAnimated: l
                } = (0, a.vR)();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(a.u_.Header, {
                        children: r.f.Ew
                    }), (0, i.jsxs)(a.u_.Content, {
                        children: [(0, i.jsx)(a.u_.Paragraph, {
                            children: r.f.Ex
                        }), (0, i.jsx)(a.u_.Section, {
                            noGutter: !1,
                            children: t.map((e => (0, i.jsx)(o.Z, {
                                label: e.task_name,
                                bottomDescription: e.inviter_name,
                                icon: "ķ",
                                renderRight: c,
                                onPress: t => {
                                    s.appState.startAcceptingTaskInvitation(e.invitation_id), l(t)
                                }
                            }, e.invitation_id)))
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(6),
            o = s(20),
            r = s(13),
            i = s(1);
        const c = () => (0, i.jsx)(r.default, {
                name: "9",
                color: "onBackground2"
            }),
            l = n.Hocs.compose((0, a.LU)({
                minWidth: 500
            }))((e => {
                const {
                    invitations: t
                } = e, s = n.Hooks.useServices(), r = n.Hooks.useIntl(), {
                    closeAnimated: l
                } = (0, a.vR)();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(a.u_.Header, {
                        children: r.f.Eg
                    }), (0, i.jsxs)(a.u_.Content, {
                        children: [(0, i.jsx)(a.u_.Paragraph, {
                            children: r.f.Eh
                        }), (0, i.jsx)(a.u_.Section, {
                            noGutter: !1,
                            children: t.map((e => (0, i.jsx)(o.Z, {
                                label: e.project_name,
                                bottomDescription: e.team_name,
                                icon: "ķ",
                                renderRight: c,
                                onPress: t => {
                                    s.appState.startAcceptingProjectInvitation(e.invitation_id), l(t)
                                }
                            }, e.invitation_id)))
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(6),
            o = s(20),
            r = s(13),
            i = s(1);
        const c = () => (0, i.jsx)(r.default, {
                name: "9",
                color: "onBackground2"
            }),
            l = n.Hocs.compose((0, a.LU)({
                minWidth: 500
            }))((e => {
                const {
                    accountMerges: t
                } = e, s = n.Hooks.useServices(), r = n.Hooks.useIntl(), {
                    closeAnimated: l
                } = (0, a.vR)();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(a.u_.Header, {
                        children: r.f.Dh
                    }), (0, i.jsxs)(a.u_.Content, {
                        children: [(0, i.jsx)(a.u_.Paragraph, {
                            children: r.f.Dj
                        }), (0, i.jsx)(a.u_.Section, {
                            noGutter: !1,
                            children: t.map((e => (0, i.jsx)(o.Z, {
                                label: e.email,
                                bottomDescription: r.f.Di,
                                icon: "ķ",
                                renderRight: c,
                                onPress: t => {
                                    s.appState.startAcceptingAccountMerge(e), l(t)
                                }
                            }, e.merge_token_id)))
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n = s(0),
            a = s(203),
            o = s(79),
            r = s(103),
            i = s(62),
            c = s(96),
            l = s(50),
            d = s(92);
        s(2), s(3);
        const u = s(569);
        var m = s(1);
        const h = n.ReactUtils.lazy((() => s(550))),
            p = n.Hocs.compose(n.Hocs.memo, n.Hocs.withPersonalUI, n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                activeProjectsCount: e.activeProjects.observeCount()
            }))), n.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                hasCurrentMemberAdminPowers: e.hasAdminPowers
            }))))((e => {
                const t = n.Hooks.useIntl(),
                    {
                        projects: s,
                        switchSidebarContent: p,
                        aboveTheFoldCount: g = -1,
                        sort: f,
                        onAddNewProject: b,
                        activeProjectsCount: y,
                        showsCounters: v,
                        shouldRenderPersonalUI: w,
                        type: k = (w ? n.Model.SidebarBuiltinGroups.ProjectsActive : n.Model.SidebarBuiltinGroups.ProjectsFollowed),
                        groupDragHandle: x,
                        hasCurrentMemberAdminPowers: j
                    } = e,
                    {
                        currentTeam: T
                    } = n.Hooks.useIdentity(),
                    S = n.Hooks.useServices(),
                    P = n.Hooks.useModalState(),
                    [_, C] = (0, r.ND)(k),
                    R = y === T.limits.openProjects - 1,
                    A = y >= T.limits.openProjects,
                    I = T.isFree && j && (R || A),
                    N = {
                        [n.Model.SidebarBuiltinGroups.ProjectsFollowed]: t.f.EE,
                        [n.Model.SidebarBuiltinGroups.ProjectsActive]: t.f.EF
                    } [k],
                    E = k === n.Model.SidebarBuiltinGroups.ProjectsActive ? n.Misc.testIds.sidebar_projectsGroup : void 0;
                return (0, m.jsxs)("div", {
                    "data-testid": E,
                    children: [(0, m.jsx)(r.pF, {
                        title: N,
                        toggleSection: C,
                        isCollapsed: _,
                        onPlusIconPress: _ ? b : void 0,
                        plusTestId: n.Misc.testIds.sidebar_addProject,
                        allA11yLabel: t.f.Ej,
                        plusA11yLabel: t.f.Eb,
                        targetRef: P.target,
                        onThreeDotPress: P.open,
                        groupDragHandle: x
                    }), _ ? null : (0, m.jsxs)(m.Fragment, {
                        children: [(0, m.jsx)(o.Z, {
                            title: t.f.Eb,
                            onPress: b,
                            description: I && R ? t.f.Ec : void 0,
                            iconColor: I && A ? "onBackground2" : void 0,
                            icon: [{
                                iconName: "i",
                                color: "purple",
                                size: 22,
                                opacity: .1
                            }, {
                                iconName: "ū",
                                color: "purple",
                                size: 20
                            }],
                            testId: n.Misc.testIds.sidebar_addProject,
                            children: I ? (0, m.jsx)(d.Z, {
                                className: u.button,
                                label: t.f.fG,
                                color: "orange",
                                isOpaque: !0,
                                onPress: e => {
                                    n.ReactUtils.stopPropagation(e), S.payments.requirements.set(T, A ? "create-projects" : "plan-changing")
                                }
                            }) : null
                        }), (0, m.jsx)(i.Z, {
                            id: "project",
                            type: l.x.PROJECT,
                            children: s.map(((e, t) => (0, m.jsx)(c.Z, {
                                id: e.id,
                                position: t,
                                type: l.x.PROJECT,
                                isDisabled: (null == f ? void 0 : f.by) !== n.Model.SidebarGroupsSortBy.Custom,
                                children: () => (0, m.jsx)(a.default, {
                                    project: e,
                                    isBelowTheFold: t >= g,
                                    showCounter: v,
                                    showFavFollowIcon: !1
                                }, e.id)
                            }, e.id)))
                        })]
                    }), P.isOpen ? (0, m.jsx)(h, {
                        groupRoot: k,
                        closeMenu: P.close,
                        target: P.target,
                        sort: f,
                        switchSidebarContent: p,
                        isCustomSortSupported: !0,
                        onManagePress: void 0
                    }) : null]
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => re
        });
        var n = s(0),
            a = s(355),
            o = s(48),
            r = s(924),
            i = s(925),
            c = s(1541),
            l = s(44),
            d = s(66);
        s(2), s(3);
        const u = s(572);
        var m = s(1);
        const h = e => {
            const {
                children: t,
                itemConfig: s,
                cellRef: n
            } = e, a = "SECTION_HEADER" === s.type, {
                maxSectionHeaderHeight: o
            } = s.extraData, r = {
                scrollMarginTop: o
            };
            return a ? (0, m.jsxs)(m.Fragment, {
                children: [(0, m.jsx)("div", {
                    className: u.sticky + " " + (e.className || ""),
                    style: e.style,
                    children: t
                }), (0, m.jsx)("div", {
                    className: u.scrollOffsetter,
                    style: r,
                    ref: n
                })]
            }) : (0, m.jsx)("div", {
                className: e.className,
                style: Object.assign({}, r, e.style),
                ref: n,
                children: t
            })
        };
        var p = s(926),
            g = s(14),
            f = s(61),
            b = s(11),
            y = s(96),
            v = s(50),
            w = s(82);
        const k = s(23).identityElement;
        var x = s(87),
            j = s(29),
            T = s(361),
            S = s(161),
            P = s(53),
            _ = s(168),
            C = s(928),
            R = s(581),
            A = s(18),
            I = s(13),
            N = s(91);
        const E = s(583),
            O = (0, m.jsx)(I.default, {
                name: "Ĵ",
                color: "incoming",
                size: 16
            }),
            M = (0, m.jsx)(I.default, {
                name: "ŉ",
                color: "incoming",
                size: 16
            }),
            D = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                threadName: e.isThread ? e.observeThreadName() : n.Rx.of(null)
            }))))((e => {
                const {
                    task: {
                        name: t,
                        isEnded: s,
                        isThread: a,
                        doesNeedReview: o
                    },
                    showReviewIcon: r,
                    highlightRanges: i,
                    isDense: c,
                    threadName: l
                } = e, d = n.Hooks.useIntl(), u = r && o, h = a ? null != l ? l : d.f.q5 : t, p = a ? M : O;
                return (0, m.jsxs)("div", {
                    className: E.row + " " + E.titleRow,
                    children: [u ? p : null, (0, m.jsx)(A.default, {
                        className: E.text + (s ? " " + E.textEnded : "") + (u ? " " + E.textWithIcon : "") + (!r && o || a ? " " + E.needsAttention : "") + (r || o ? "" : " " + E.alreadyReviewed) + (c ? " " + E.textDense : ""),
                        children: i ? (0, m.jsx)(N.Z, {
                            ranges: i,
                            text: h
                        }) : h
                    })]
                })
            })),
            H = s(42).wx,
            F = n.ReactUtils.lazy((() => s(25))),
            Z = n.ReactUtils.lazy((() => s(226))),
            L = n.ReactUtils.lazy((() => s(1304))),
            B = n.ReactUtils.lazy((() => s(1305))),
            z = e => {
                const {
                    currentMember: t,
                    currentTeam: s
                } = n.Hooks.useIdentity(), a = n.Hooks.useIntl(), r = n.Hooks.useServices(), {
                    completeTask: i
                } = (0, o.dR)(e), c = e.responsible.id === t.id;
                return async (t = !1) => !!r.payments.remindExpired(s) || !(!e.isActive || !c && !t) && (r.native.haptics.success(), r.uiState.forTeam(s).toggleJustEndedTask(e, !0), await i(), await (0, x.markTaskAsReviewedWithSnackbar)(r, a, e, s), r.engager.onDidCompleteTask(), !0)
            },
            U = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                project: e.observeCurrentProject()
            }))))((e => {
                const {
                    task: t,
                    picker: s,
                    project: a
                } = e, o = n.Hooks.useIntl(), r = z(t);
                return (0, m.jsx)(H.Responsible, {
                    bundle$close: s.close,
                    onConfirm: e => {
                        e.isEmail ? t.do.shareWithEmail(e.email) : t.do.assignResponsible(e.member, e.shouldCheckAccess)
                    },
                    onClose: s.close,
                    currentResponsibleId: t.responsible.id,
                    target: s.target,
                    project: a,
                    task: t,
                    hasDueDate: !!t.dates.dueDate,
                    renderBottomActions: () => (0, m.jsx)(P.default, {
                        type: "normal",
                        label: o.f.mU,
                        onPress: () => {
                            s.close(), r(!0)
                        }
                    })
                })
            })),
            W = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam", "task"], (({
                currentTeam: e,
                task: t,
                services: s
            }) => ({
                isJustEnded: s.uiState.forTeam(e).observeIsJustEndedTask(t)
            }))))((e => {
                var t;
                const {
                    isOpened: s,
                    viewColor: a,
                    showReviewIcon: o,
                    shouldHighlightUnreadComments: r,
                    task: i,
                    task: {
                        status: c,
                        isGhost: l
                    },
                    isProjectVisible: d,
                    isSectionVisible: u,
                    isJustEnded: h,
                    markAsType: p,
                    highlightRanges: g,
                    isSelecting: f,
                    isListSelected: y,
                    isDense: v
                } = e, w = n.Hooks.useServices(), k = n.Hooks.useIntl(), P = n.Hooks.useModalState(), A = n.Hooks.useModalState(), {
                    currentMember: I,
                    currentTeam: N,
                    isLimitedAccount: E
                } = n.Hooks.useIdentity();
                n.Hooks.useModel(i);
                const O = i.responsible.id === I.id,
                    M = s || y,
                    H = z(i),
                    W = "activity" === p ? i.isUnread : !!i.reviewReason,
                    G = p && W,
                    V = G ? async e => {
                        n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), w.payments.remindExpired(N) || ("incoming" === p ? await (0, x.markTaskAsReviewedWithSnackbar)(w, k, i, N) : (await i.do.markAsRead(), w.uiState.pushSnackbar({
                            onButtonPress: async () => {
                                await i.do.markAsUnread(i.lastSeenActivityAt)
                            },
                            buttonColor: "activity",
                            message: k.g("Jf", {
                                taskName: t || (t = (0, m.jsx)(_.Z, {
                                    task: i
                                }))
                            })
                        })))
                    }: n.FP.noop;
                n.Hooks.useDebugRenderCount();
                return (0, m.jsxs)(m.Fragment, {
                    children: [f ? (0, m.jsx)(S.Z, {
                        isChecked: y,
                        isLarge: !0,
                        color: a
                    }) : null, (0, m.jsx)(b.Z, {
                        className: R.Z.iconContainer + (l || c === j.TE.ACTIVE || h || !O ? "" : " " + R.Z.iconEnded) + (M && O ? " " + R.Z.taskSelected : ""),
                        ref: P.target,
                        webComponent: "div",
                        onPress: i.isGhost || i.isThread ? void 0 : async e => {
                            if (n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), !await H() && await i.isInActiveProject())
                                if (i.isActive) P.open();
                                else {
                                    if (i.isGranted) return void A.open();
                                    const e = await i.do.restore();
                                    await (0, x.markTaskAsReviewedWithSnackbar)(w, k, i, N), w.uiState.forTeam(N).toggleJustEndedTask(i, !1), e && !i.responsible.id && P.open()
                                }
                        },
                        androidBorderless: !0,
                        usesRNGH: !0,
                        children: (0, m.jsx)(C.Z, {
                            isJustEnded: h,
                            task: i,
                            viewColor: a,
                            isSelected: M
                        })
                    }), P.isOpen ? (0, m.jsx)(U, {
                        picker: P,
                        task: i
                    }) : null, A.isOpen ? (0, m.jsx)(F, {
                        type: "confirm",
                        onConfirmPress: A.close,
                        onClose: A.close,
                        confirmButtonMessage: k.f.fy,
                        children: k.f.Jc
                    }) : null, (0, m.jsxs)("div", {
                        className: R.Z.middle,
                        style: {
                            opacity: i.isGhost ? .6 : 1
                        },
                        children: [(0, m.jsx)(D, {
                            task: i,
                            highlightRanges: g,
                            isDense: v,
                            showReviewIcon: o
                        }), i.isThread ? (0, m.jsx)(B, {
                            task: i,
                            isSelected: M,
                            viewColor: a
                        }) : (0, m.jsx)(L, {
                            task: i,
                            isSelected: M,
                            isProjectVisible: d,
                            isDense: v,
                            isSectionVisible: u,
                            showReviewIcon: o,
                            shouldHighlightUnreadComments: r,
                            viewColor: a
                        })]
                    }), (0, m.jsxs)("div", {
                        className: R.Z.right,
                        children: [p && G ? (0, m.jsx)(Z, {
                            type: p,
                            onPress: V
                        }) : null, E || l || i.isThread ? null : (0, m.jsx)("div", {
                            className: R.Z.iconContainer + (i.isEnded ? " " + R.Z.iconEnded : "") + (M && !i.isPriority ? " " + R.Z.taskSelected : ""),
                            children: (0, m.jsx)(T.Z, {
                                onPress: i.isGhost ? void 0 : async e => {
                                    n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), w.payments.remindExpired(N) || await i.isInActiveProject() && (await i.do.togglePriority(), await (0, x.markTaskAsReviewedWithSnackbar)(w, k, i, N))
                                },
                                isPriority: i.isPriority,
                                fillColor: a,
                                outlineColor: M ? "textPrimary" : "onBackground2",
                                taskListRippleWorkaround: !0,
                                usesRNGH: !0
                            })
                        })]
                    }), null, i.isUnread && !l ? (0, m.jsx)("div", {
                        className: R.Z.dot,
                        style: {
                            backgroundColor: i.isThread ? n.Styling.factoryColor("darkgreen") : n.Styling.factoryColor("activity")
                        }
                    }) : null]
                })
            })),
            G = s(612),
            V = {
                rootMargin: "0px 0px 100px 0px"
            },
            q = e => {
                const {
                    isOpened: t,
                    hasBottomBorder: s,
                    task: a,
                    isProjectVisible: o = !0,
                    isSectionVisible: r = o,
                    showReviewIcon: i,
                    shouldHighlightUnreadComments: c = !1,
                    move: l,
                    isDraggable: u,
                    markAsType: h,
                    onMarkAsSwipe: p,
                    withSwipeLeft: g,
                    testId: f,
                    rawPath: y,
                    isAboveTheFold: v,
                    highlightRanges: x,
                    isDragging: j,
                    dragIndex: T
                } = e, {
                    isInViewport: S,
                    targetRef: P
                } = n.Hooks.useShownInViewport(V, v), _ = e.viewColor || "purple", [C, R] = (0, d.Uq)(), A = C.ids.has(a.id), {
                    isSelecting: I
                } = C, N = n.Hooks.useDesktopLayout(), E = t && N || A, O = n.Hooks.useDense(), M = n.React.useCallback((() => {
                    l && l(T)
                }), [T, l]);
                return (0, m.jsx)(k, {
                    task: a,
                    withSwipeLeft: I ? void 0 : g,
                    onMarkAsSwipe: I ? void 0 : p,
                    markAsType: I ? void 0 : h,
                    className: e.className,
                    style: e.style,
                    children: (0, m.jsx)("div", {
                        className: G.rootWrapper + (E ? " " + G.isSelected : "") + (O ? " " + G.rootWrapperDense : "") + (j ? " " + G.isDragging : "") + " " + (e.className || ""),
                        style: Object.assign(Object.assign({
                            backgroundColor: E ? n.Styling.blendWithSurface(_, .1).toRgbString() : n.Styling.vars.color.surface,
                            borderColor: E ? n.Styling.blendWithSurface(_, .5).toRgbString() : n.Styling.vars.color.onBackground1
                        }, {}), e.style),
                        ref: P,
                        children: S ? (0, m.jsx)(w.Z, {
                            to: {
                                path: y
                            },
                            isDisabled: I,
                            children: (0, m.jsx)(b.Z, {
                                className: G.root + (O ? " " + G.rootDense : ""),
                                webComponent: "div",
                                title: a.isThread ? "" : a.name,
                                onLongPress: u ? M : void 0,
                                disableLongPressHaptics: !!u,
                                onPress: e => {
                                    !a.isThread && (I || e.metaKey || e.ctrlKey || e.shiftKey) && (e.preventDefault(), e.stopPropagation(), e.shiftKey ? R({
                                        type: "request_toggle_range",
                                        toId: a.id
                                    }) : R({
                                        type: "toggle",
                                        id: a.id
                                    }))
                                },
                                testId: f,
                                usesRNGH: !0,
                                children: (0, m.jsx)("div", {
                                    className: G.contentWrapper + (I ? " " + G.disablePresses : ""),
                                    children: (0, m.jsx)(W, {
                                        task: a,
                                        isOpened: t,
                                        viewColor: _,
                                        isProjectVisible: o,
                                        isSectionVisible: r,
                                        showReviewIcon: i,
                                        shouldHighlightUnreadComments: c,
                                        markAsType: h,
                                        highlightRanges: x,
                                        isSelecting: I,
                                        isListSelected: A,
                                        isDense: O
                                    })
                                })
                            })
                        }) : null
                    })
                })
            },
            Q = n.Hocs.compose((e => n.Hocs.memo(e, ((e, t) => {
                if (Object.keys(e).length !== Object.keys(t).length) return !1;
                for (const o in e)
                    if ("style" !== o) {
                        if (e[o] !== t[o]) return !1
                    } else if (s = e[o], a = t[o], s !== a && !n.FP.identicalArrays(s, a)) return !1;
                var s, a;
                return !0
            }))))((e => {
                const {
                    task: t,
                    dragIndex: s,
                    isDraggable: a,
                    isDragged: o
                } = e, r = e.isDragDisabled || t.isEnded || t.isGhost;
                return n.Hooks.useModel(t), a ? (0, m.jsx)(y.Z, {
                    id: t.id,
                    position: s,
                    isDisabled: r,
                    type: v.x.TASK,
                    children: ({
                        isDragging: t
                    }) => (0, m.jsx)(q, Object.assign({}, e, {
                        isDragging: o || t || !1
                    }))
                }) : (0, m.jsx)(q, Object.assign({
                    isDragging: !1
                }, e))
            }));
        var Y = s(246),
            J = s(60),
            K = s(121),
            $ = s(114);
        const X = s(613);
        var ee;
        const te = n.ReactUtils.lazy((() => s(926))),
            se = [],
            ne = (e, t) => {
                const s = n.FP.normalizeText(t).indexOf(e);
                return -1 === s ? [] : [
                    [s, s + e.length - 1]
                ]
            },
            ae = (e, t) => {
                const {
                    item: s,
                    index: a
                } = e;
                if ("NEW_TASK" === s.id) {
                    const n = 88;
                    return Object.assign({}, e, {
                        item: s,
                        type: "NEW_TASK",
                        layout: {
                            length: n,
                            offset: t + n,
                            index: a
                        }
                    })
                }
                if (s instanceof n.Model.Models.Task) {
                    const n = 64;
                    return Object.assign({}, e, {
                        item: s,
                        type: "TASK",
                        layout: {
                            length: n,
                            offset: t + n,
                            index: a
                        }
                    })
                }
                return n.Misc.PROD_CONSOLE(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL).warn("Unknown item type (getTypeForItem)"), s
            };
        const oe = n.React.forwardRef(((e, t) => {
                const s = n.Hooks.useDesktopLayout() ? 8 : 4;
                return (0, m.jsx)(h, Object.assign({}, e, {
                    cellRef: t,
                    style: {
                        paddingLeft: s,
                        paddingRight: s
                    }
                }))
            })),
            re = n.Hocs.compose((0, i.b)((({
                rootRecord: e
            }) => e.id)))((e => {
                var t;
                const {
                    taskGroups: s,
                    renderSectionItemsContainer: i,
                    rootRecord: u,
                    renderListHeader: h,
                    renderListFooter: y,
                    ContentWrapperWeb: v,
                    viewColor: w,
                    isProjectVisible: k,
                    isSectionVisible: x,
                    isDndEnabled: j,
                    renderSectionHeader: T,
                    onSetEndedTasksState: S,
                    onMarkAsSwipe: P,
                    withSwipeLeft: _,
                    newTaskFormProps: C,
                    showReviewIcon: R = !0,
                    shouldHighlightUnreadComments: A,
                    markAsType: I = null,
                    extraDistanceFromScreenTop: N = 0,
                    filterState: E,
                    newTaskDraft: O,
                    onNewTaskFormStateChange: M,
                    hasTasksOrSections: D,
                    getSectionHeaderLength: H
                } = e, F = n.Hooks.useParams(), Z = n.Hooks.useServices(), {
                    currentTeam: L,
                    isLimitedAccount: B
                } = n.Hooks.useIdentity();
                n.React.useEffect((() => {
                    Z.uiState.forTeam(L).clearJustEndedTasks()
                }), [Object.values(F).toString(), L]);
                const {
                    onSubmit: z,
                    inputRef: U,
                    newTaskFormState: W,
                    newTaskFormStateDispatch: G,
                    attachmentProps: V,
                    isNewTaskFocused: q,
                    setIsNewTaskFocused: re
                } = (0, r.I)({
                    newTaskFormProps: C,
                    onNewTaskFormStateChange: M,
                    draft: O,
                    rootRecord: u
                }), [ie] = (0, d.Uq)(), ce = !B && null != (t = e.hasMasterPlus) && t && (!C.isShown || !0), le = n.React.useMemo((() => (0, l.I)(s, C, U)), [C, s, U]), {
                    areFiltersActive: de
                } = n.React.useContext(c.o), ue = 56 + n.Hooks.useLayoutTopInset() + N, me = n.React.useMemo((() => ({
                    newTaskFormProps: C,
                    inputRef: U,
                    state: W,
                    dispatch: G,
                    onSubmit: z,
                    attachmentProps: V,
                    isNewTaskFocused: q,
                    setIsNewTaskFocused: re
                })), [U, C, V, W, G, z, q, re]), he = (({
                    onSetEndedTasksState: e,
                    renderSectionHeader: t,
                    isSectionVisible: s,
                    isProjectVisible: a,
                    viewColor: r,
                    showReviewIcon: i,
                    shouldHighlightUnreadComments: c,
                    markAsType: d,
                    onMarkAsSwipe: u,
                    withSwipeLeft: h,
                    isDndEnabled: p,
                    highlightedQuery: y,
                    hasTasksOrSections: v,
                    taskGroups: w,
                    isNewTaskFormShown: k
                }) => {
                    const x = n.Hooks.useDesktopLayout(),
                        j = (0, o.y)(),
                        T = n.React.useCallback((t => {
                            var s, n;
                            const a = w.find((e => e.root === t)),
                                o = "string" == typeof t ? t : null != (s = null == t ? void 0 : t.id) ? s : "NULL";
                            invariant(a, "Missing taskGroup for " + o), invariant(e, "You must provide onSetEndedTasksState for the footer");
                            const r = null == j || null == (n = j.groups) ? void 0 : n.get(a),
                                {
                                    nextEndedTasksState: i,
                                    endedTodayCounters: c
                                } = a;
                            return (0, m.jsxs)(b.Z, {
                                className: X.expander,
                                onPress: (0, l.M6)(a, e),
                                webComponent: "div",
                                children: ["showingEndedToday" === i ? (0, m.jsxs)(J.gq, {
                                    align: "center",
                                    children: [(0, m.jsxs)("span", {
                                        className: X.expanderContent,
                                        children: [0 < c.completed && 0 < c.abandoned ? (0, m.jsx)(f.Z, {
                                            id: "H0",
                                            values: {
                                                completedCount: c.completed,
                                                abandonedCount: c.abandoned
                                            }
                                        }) : null, 0 < c.completed && 0 === c.abandoned ? (0, m.jsx)(f.Z, {
                                            id: "H2",
                                            values: {
                                                completedCount: c.completed
                                            }
                                        }) : null, 0 < c.abandoned && 0 === c.completed ? (0, m.jsx)(f.Z, {
                                            id: "H1",
                                            values: {
                                                abandonedCount: c.abandoned
                                            }
                                        }) : null]
                                    }), r ? (0, m.jsx)(K.Z, {
                                        observables: {
                                            groupCounters: r
                                        },
                                        resetOn: [r],
                                        children: ({
                                            groupCounters: {
                                                endedTodayTasks: e
                                            }
                                        }) => (0, m.jsx)(Y.Z, {
                                            className: X.taskCounters,
                                            variant: "timeAttributesOnly",
                                            counters: e
                                        })
                                    }) : null]
                                }) : null, "number" == typeof i ? (0, m.jsx)("span", {
                                    className: X.expanderContent,
                                    children: ee || (ee = (0, m.jsx)(f.Z, {
                                        id: "H3"
                                    }))
                                }) : null]
                            })
                        }), [j, e, w]),
                        S = n.React.useMemo((() => y ? n.FP.normalizeText(y) : null), [y]),
                        P = n.React.useCallback(((e, t, o) => {
                            var l, f;
                            const {
                                section: b,
                                index: y,
                                position: {
                                    indexInSection: v,
                                    isFirst: w,
                                    isLast: j,
                                    isAboveTheFold: T
                                },
                                item: P,
                                extraData: {
                                    pathname: _
                                }
                            } = e, C = 1 === v, R = (null == (l = b.items[0]) ? void 0 : l.id) === $.U3, A = v === b.items.length - 2, I = (null == (f = b.items[b.items.length - 1]) ? void 0 : f.id) === $.U3, N = (j || A && I) && !b.hasFooter, E = _.replace(g.pathTaskIdRegex, ""), O = _.match(g.pathTaskIdRegex), M = O ? O[1] : null, D = P.id === M, H = E + "/tasks/" + P.id, F = D ? E : H, Z = w && !b.root || C && R, L = x ? 8 : 4;
                            return (0, m.jsx)(Q, {
                                className: (w || C && R ? X.isFirst : "") + (N ? " " + X.isLast : ""),
                                style: {
                                    marginTop: Z ? L : 0
                                },
                                task: P,
                                rawPath: x ? F : H,
                                isOpened: !!x && D,
                                isDraggable: p,
                                isDragDisabled: k,
                                isDragged: o,
                                dragIndex: v,
                                hasBottomBorder: N,
                                isAboveTheFold: T,
                                move: t,
                                showReviewIcon: !!i,
                                shouldHighlightUnreadComments: "function" == typeof c ? c(P) : c,
                                markAsType: d,
                                onMarkAsSwipe: u,
                                withSwipeLeft: h,
                                viewColor: r,
                                isProjectVisible: "function" == typeof a ? a(P) : a,
                                isSectionVisible: s,
                                testId: n.Misc.testIds.taskList_task,
                                highlightRanges: S ? ne(S, P.name) : se
                            })
                        }), [x, a, s, r, i, c, d, u, h, p, k, S]),
                        _ = n.React.useCallback(((e, t, s) => (0, m.jsx)(te, {
                            itemConfig: e,
                            beginDrag: t,
                            isDragged: s,
                            isDndEnabled: !!p,
                            hasTasksOrSections: v
                        })), [p, v]);
                    return n.React.useCallback(((e, s, n) => {
                        switch (e.type) {
                            case "SECTION_FOOTER":
                                return T(e.item);
                            case "SECTION_HEADER":
                                return invariant(t, "You must provide renderSectionHeader"), t(e.item, e.position.isAboveTheFold);
                            case "TASK":
                                return P(e, s, n);
                            case "NEW_TASK":
                                return _(e, s, n);
                            default:
                                return e
                        }
                    }), [_, T, t, P])
                })({
                    onSetEndedTasksState: S,
                    renderSectionHeader: T,
                    isSectionVisible: x,
                    isProjectVisible: k,
                    viewColor: w,
                    showReviewIcon: R,
                    shouldHighlightUnreadComments: A,
                    markAsType: I,
                    onMarkAsSwipe: P,
                    withSwipeLeft: _,
                    isDndEnabled: j && !ie.isSelecting,
                    highlightedQuery: null == E ? void 0 : E.filterName,
                    hasTasksOrSections: !!D,
                    taskGroups: s,
                    isNewTaskFormShown: C.isShown
                }), pe = (0, o.y)(), ge = n.React.useCallback((e => {
                    if (H) return H(e.root);
                    return !(null == pe || !pe.groups.get(e)) ? 72 : 56
                }), [H, pe]), fe = n.Hooks.useLocation(), {
                    pathname: be
                } = fe, ye = function({
                    rootRecord: e,
                    pathname: t,
                    handleRef: s
                }) {
                    const a = n.React.useRef(null),
                        o = n.React.useMemo((() => ({
                            scrollToTask: (e, t) => {
                                const s = a.current;
                                if (!s) return;
                                const n = s.getItemConfigs(),
                                    o = "string" == typeof e ? e : e.id,
                                    r = n.find((e => "TASK" === e.type && e.item.id === o));
                                r && s.scrollToIndex(r.index, t)
                            },
                            scrollToHeader: (e, t = {}) => {
                                const s = a.current;
                                if (!s) return;
                                const n = s.getItemConfigs().find((t => "SECTION_HEADER" === t.type && t.item === e));
                                n && s.scrollToIndex(n.index, Object.assign({
                                    scrollMode: "always",
                                    alignment: "top"
                                }, t))
                            },
                            scrollToTop: (e = !1) => {
                                var t;
                                null == (t = a.current) || t.scrollToTop({
                                    animated: e
                                })
                            }
                        })), []);
                    n.React.useImperativeHandle(s, (() => o));
                    const r = n.React.useMemo((() => {
                        const e = t.match(g.pathTaskIdRegex);
                        return e ? e[1] : null
                    }), [t]);
                    return n.React.useEffect((() => {
                        r && o.scrollToTask(r)
                    }), [r, o]), n.React.useEffect((() => {
                        r || o.scrollToTop()
                    }), [e, o]), a
                }({
                    rootRecord: u,
                    pathname: be,
                    handleRef: e.listHandleRef
                }), ve = n.React.useMemo((() => {
                    const e = le.filter((e => !!e.root));
                    return e.length ? Math.max(...e.map((e => ge(e)))) : 0
                }), [le, ge]), we = n.React.useMemo((() => ({
                    pathname: be,
                    maxSectionHeaderHeight: ve
                })), [be, ve]);
                return (0, m.jsx)(p.NewTaskContext.Provider, {
                    value: me,
                    children: (0, m.jsx)("div", {
                        className: X.root,
                        "data-testid": n.Misc.testIds.taskList,
                        children: (0, m.jsx)(a.Z, {
                            sections: le,
                            renderItem: he,
                            estimatedItemSize: 63,
                            createItemConfig: ae,
                            rootRecord: u,
                            renderListHeader: h,
                            renderListFooter: y,
                            renderSectionItemsContainer: i,
                            ContentWrapperWeb: v,
                            topBarInset: 0,
                            reachesTopOfScreen: !1,
                            bottomBarInset: ce ? 104 : 8,
                            distanceFromScreenTop: ue,
                            CellRendererComponent: oe,
                            getSectionFooterLength: l.B7,
                            getSectionHeaderLength: ge,
                            extraData: we,
                            shouldScrollToInput: !0,
                            listHandleRef: ye
                        })
                    })
                })
            }))
    }, , , , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0);
        s(5), s(4), s(8);

        function a(e, t) {
            return e.find((e => (null == e ? void 0 : e.id) !== t))
        }
        var o = s(1);
        const r = n.ReactUtils.lazy((() => s(56))),
            i = n.ReactUtils.lazy((() => s(106))),
            c = n.ReactUtils.lazy((() => s(929))),
            l = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                threadType: e.observeThreadType(),
                threadMembers: e.isThread ? e.observeThreadMembers() : n.Rx.of(null),
                team: e._taskAccesses.observe().pipe(n.Rx.switchMap((e => {
                    var t;
                    return n.Rx.wrap(null == (t = e.find((e => "team" === (null == e ? void 0 : e.granteeType)))) ? void 0 : t.grantee)
                }))),
                memberGroup: e._taskAccesses.observe().pipe(n.Rx.switchMap((e => {
                    var t;
                    return n.Rx.wrap(null == (t = e.find((e => "member_group" === (null == e ? void 0 : e.granteeType)))) ? void 0 : t.grantee)
                })))
            }))))((e => {
                const {
                    threadType: t,
                    team: s,
                    threadMembers: l,
                    size: d,
                    sideBySideAvatarSize: u = d,
                    memberGroup: m
                } = e, {
                    currentMember: h
                } = n.Hooks.useIdentity();
                return "team" === t && s && l ? (0, o.jsx)(i, {
                    team: s,
                    size: d
                }) : "member_group" === t && m && l ? (0, o.jsx)(c, {
                    members: l.filter((e => (null == e ? void 0 : e.id) !== h.id)),
                    avatarStyle: "message",
                    size: d,
                    sideBySideAvatarSize: u
                }) : (0, o.jsx)(r, {
                    avatarStyle: "message",
                    member: l ? a(l, h.id) : h,
                    size: d
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(582)
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            s: () => c
        });
        var n = s(0),
            a = s(13),
            o = s(18);
        s(2), s(3);
        const r = s(586);
        var i = s(1);

        function c({
            isSelected: e,
            isEnded: t,
            alreadyReviewed: s
        }) {
            const c = n.Hooks.useDesktopLayout(),
                l = t => e ? "textPrimary" : s ? "onBackground2" : t || "textSecondary",
                d = l(null);
            return s => {
                const {
                    iconName: u,
                    lock: m,
                    iconColor: h,
                    label: p,
                    isCrossedOut: g,
                    isFadedOut: f = t,
                    textColor: b,
                    onPress: y
                } = s, v = l(b);
                return (0, i.jsxs)("div", {
                    className: r.root + (e ? " " + r.taskSelected : "") + (f ? " " + r.taskEnded : ""),
                    onClick: y,
                    children: [(0, i.jsx)(a.default, {
                        name: u,
                        color: l(h),
                        size: 16
                    }), p ? (0, i.jsx)(o.default, {
                        className: r.caption + (y ? " " + r.hasHover : "") + (c ? "" : " " + r.captionWithMaxWidth) + (g ? " " + r.captionCrossed : ""),
                        style: {
                            color: n.Styling.factoryColor(v)
                        },
                        children: p
                    }) : null, m ? (0, i.jsx)(a.default, {
                        className: r.lockIcon,
                        name: "ŀ",
                        color: d,
                        size: 14
                    }) : null]
                }, s.key)
            }
        }
    }, , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(6);
        s(2), s(3);
        const o = s(590);
        var r = s(1);
        const i = n.ReactUtils.lazy((() => s(1544))),
            c = n.Hocs.compose()((e => {
                const {
                    title: t,
                    content: s,
                    header: c,
                    footer: l,
                    allowContentOverflow: d,
                    onClose: u
                } = e, m = n.React.useCallback((e => (0, r.jsx)(i, {
                    title: t,
                    content: e
                })), [t]), h = "function" == typeof s ? s({
                    renderInnerContent: m
                }) : m(s);
                return (0, r.jsxs)(a.u_, {
                    onClose: u,
                    size: "fullscreen",
                    children: [(0, r.jsx)(a.u_.Header, {
                        right: c,
                        children: t
                    }), (0, r.jsx)(a.u_.Content, {
                        className: o.content,
                        isStatic: !0,
                        children: (0, r.jsxs)("div", {
                            className: o.wrapper + (d ? " " + o.wrapperWithOverflow : ""),
                            children: [(0, r.jsx)("div", {
                                className: o.container,
                                children: h
                            }), l ? (0, r.jsx)("div", {
                                className: o.footer,
                                children: l
                            }) : null]
                        })
                    })]
                })
            }))
    }, , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(128);
        s(2), s(3);
        const o = s(602);
        var r = s(1);
        const i = /(http[^\]]+)\]\((http[^\[]+)\)$/,
            c = e => {
                const {
                    children: t,
                    url: s
                } = e, c = n.React.useMemo((() => {
                    const e = (s || "").match(i);
                    return e && e[1] === e[2] ? (0, a.Nm)(e[1]) : (0, a.Nm)(s)
                }), [s]);
                return (0, r.jsx)("a", {
                    className: o.root,
                    href: c,
                    target: "_blank",
                    onClick: e => {
                        n.ReactUtils.openUrl(c), e.preventDefault(), e.stopPropagation()
                    },
                    rel: "noopener noreferrer",
                    children: t
                })
            }
    }, , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n = s(0),
            a = s(35);
        s(2), s(3);
        const o = s(608);
        var r = s(1);
        const i = n.ReactUtils.lazy((() => s(1313))),
            c = (e, t, s, o) => e ? e.preferredName : t ? n.Rx.of(n.Styling.getMemberGroupName(t, o)) : s && (0, a.sU)(s) ? n.Rx.of((0, a.fb)(s, o)) : n.Rx.of(""),
            l = n.Hocs.compose(n.Hocs.withIntl, n.Hocs.withServices, n.Hocs.withObservables(["memberId", "comment", "groupMentionId"], (({
                memberId: e,
                comment: t,
                services: s,
                groupMentionId: o
            }) => ({
                member: e ? s.collections.get(n.Model.Tables.teamMembers).findAndObserve(e).pipe(n.Rx.catchError((() => n.Rx.of(null)))) : n.Rx.of(null),
                task: t && "disposable" !== t.syncStatus ? t.task : n.Rx.of(null),
                commentAuthor: t ? t.author.observe().pipe(n.Rx.switchMap((e => e ? e.user.observe() : n.Rx.of(null)))) : n.Rx.of(null),
                group: o && !(0, a.sU)(o) ? s.collections.get(n.Model.Tables.memberGroups).findAndObserve(o).pipe(n.Rx.catchError((() => n.Rx.of(null)))) : n.Rx.of(null)
            }))), n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                project: e ? e.observeCurrentProject() : n.Rx.of(null)
            }))), n.Hocs.withObservables(["member", "group", "groupMentionId"], (({
                member: e,
                group: t,
                groupMentionId: s,
                intl: a
            }) => ({
                label: c(e, t, s, a),
                mentionedUser: e ? e.user : n.Rx.of(null)
            }))), n.Hocs.withObservables(["group"], (({
                group: e
            }) => ({
                amIInGroup: e ? e.allMembers.observe().pipe(n.Rx.switchMap((e => n.Rx.combineLatest(e.map((e => e.user.observe()))))), n.Rx.map((e => e.some((e => e.isMe))))) : n.Rx.of(!1)
            }))))((e => {
                const {
                    label: t,
                    member: s,
                    groupMentionId: a,
                    group: c,
                    mentionedUser: l,
                    amIInGroup: d,
                    task: u,
                    project: m,
                    commentAuthor: h
                } = e, p = ((e, t, s, n) => {
                    const {
                        commentAuthor: a,
                        task: o,
                        project: r
                    } = n;
                    return e ? e.isMe : "following" === t ? Boolean(((null == r ? void 0 : r.isFollowed) || (null == o ? void 0 : o.isFollowed)) && !(null != a && a.isMe)) : "all" === t ? !(null != a && a.isMe) : !!t && s
                })(l, a, d, {
                    task: u,
                    project: m,
                    commentAuthor: h
                }), g = Boolean(null == s ? void 0 : s.isArchived), f = n.Hooks.useModalState();
                return (0, r.jsxs)("div", {
                    className: o.root,
                    children: [(0, r.jsx)("span", {
                        className: o.mention + (p ? " " + o.me : "") + (g ? " " + o.archived : ""),
                        onClick: e => {
                            n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), f.open()
                        },
                        ref: f.target,
                        children: "@" + t
                    }), f.isOpen ? (0, r.jsx)(i, {
                        onClose: f.close,
                        member: s,
                        groupMentionId: a,
                        group: c,
                        target: f.target
                    }) : null]
                })
            }))
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => re
        });
        var n = s(5),
            a = s(4),
            o = s(8),
            r = (s(154), s(54), s(17)),
            i = s(36),
            c = s(23),
            l = s(19);
        const d = a.is(Boolean);
        class u {
            constructor(e) {
                this.adjacentTasks = new o.BehaviorSubject({
                    next: null,
                    previous: null
                }), this._justEndedTasks = new o.BehaviorSubject([]), this.justEndedTasks = this._justEndedTasks.pipe(o.switchMap((e => m(e, this._team.db))), o.distinctUntilChanged(a.identicalArrays)), this._justReadTasks = new o.BehaviorSubject([]), this.justReadTasks = this._justReadTasks.pipe(o.switchMap((e => m(e, this._team.db))), o.distinctUntilChanged(a.identicalArrays)), this._justReviewedTasks = new o.BehaviorSubject(new Map), this.justReviewedTasks = this._justReviewedTasks.pipe(o.switchMap((e => m(Array.from(e.keys()), this._team.db).pipe(o.map((t => new Map(t.map((t => [t, e.get(t)])))))))), o.distinctUntilChanged(((e, t) => a.identicalArrays(Array.from(e.entries()), Array.from(t.entries()))))), this._team = e
            }
            observeIsJustEndedTask(e) {
                return this.justEndedTasks.pipe(o.map(a.identicalContains(e)), o.distinctUntilChanged())
            }
            toggleJustEndedTask(e, t) {
                const s = this._justEndedTasks.getValue(),
                    n = (d(t) ? !t : s.includes(e)) ? a.reject(a.identical(e), s) : a.append(e, s);
                this._justEndedTasks.next(n)
            }
            addJustReadTask(e) {
                const t = this._justReadTasks.getValue();
                t.includes(e) || this._justReadTasks.next(a.append(e, t))
            }
            removeJustReadTasks(e) {
                const t = this._justReadTasks.getValue().filter((t => !e.includes(t)));
                this._justReadTasks.next(t)
            }
            clearJustReadTasks() {
                this._justReadTasks.next([])
            }
            addJustReviewedTasks(e) {
                const t = this._justReviewedTasks.getValue();
                e.forEach((e => {
                    t.set(e, e.reviewReason)
                })), this._justReviewedTasks.next(t)
            }
            removeJustReviewedTasks(e) {
                const t = this._justReviewedTasks.getValue(),
                    s = new Map;
                t.forEach(((t, n) => {
                    e.includes(n) || s.set(n, t)
                })), this._justReviewedTasks.next(s)
            }
            clearJustReviewedTasks() {
                this._justReviewedTasks.next(new Map)
            }
            clearJustEndedTasks() {
                this._justEndedTasks.next([])
            }
        }

        function m(e, t) {
            return t.collections.get(r.Tables.tasks).query(l.Q.where(r.Columns.id, l.Q.oneOf(a.pluckIds(e)))).observe()
        }
        var h = s(414);
        class p {
            constructor() {
                this._teamStates = new WeakMap, this.addTeamModal = new h.Z, this.referralModal = new h.Z, this.newsFeedModal = new h.Z, this.reviewModal = new h.Z, this.quickAddModal = new h.Z, this.shortcutsModal = new h.Z, this.npImporterModal = new h.Z, this.jumpToModal = new h.Z, this.accountUpgradeModal = new h.Z, this.appSettingsModal = new h.Z, this.teamSettingsModal = new h.Z, this.businessSettingsModal = new h.Z, this.contactFormModal = new h.Z, this.taskActionEventModal = new h.Z, this.moveTasksModal = new h.Z, this.isNativeOnboardingShown = new o.BehaviorSubject(!1).pipe(o.distinctUntilChanged()), this.snackbarStack = new o.BehaviorSubject([]), this.isNewTaskCancelOnBlurPrevented = new o.BehaviorSubject(!1), this.isAutoTaskOpenPrevented = new o.BehaviorSubject(!1), this.usesDenseLayout = new o.BehaviorSubject(!1)
            }
            forTeam(e) {
                let t = this._teamStates.get(e);
                return t || (t = new u(e), this._teamStates.set(e, t)), t
            }
            pushSnackbar(e) {
                var t;
                const s = null == (t = this.snackbarStack) ? void 0 : t.getValue(),
                    a = Object.assign({}, e, {
                        _id: n.nextTag()
                    });
                this.snackbarStack.next([...s, a])
            }
            removeSnackbarFromStack(e) {
                const t = this.snackbarStack.getValue();
                this.snackbarStack.next(t.filter((t => t._id !== e)))
            }
        }
        var g = s(80),
            f = s(128),
            b = s(14),
            y = s(37),
            v = s(825);

        function w(e) {
            return {
                path: (0, f.Nm)(e.path),
                hash: e.hash ? String(e.hash) : ""
            }
        }
        const k = y.d.lastRoute;
        class x {
            constructor({
                localStorage: e,
                native: t,
                onLocationUpdate: s
            }) {
                const a = n.isElectron ? (0, v.PP)() : (0, v.lX)({});
                this._history = a, this._localStorage = new y.a(e), this._native = t, this._onLocationUpdate = s, this.currentLocation = a.location, this.currentPath = new o.BehaviorSubject(a.location.pathname + a.location.search), a.listen((e => {
                    this._onHistoryLocationChange(e)
                }))
            }
            _onHistoryLocationChange(e) {
                try {
                    const t = this.currentPath.getValue(),
                        s = e.pathname + e.search;
                    this._setLastRoute(s), this.currentLocation = e, this.currentPath.next(s), this._setCurrentUserActivity(s);
                    (0, this._onLocationUpdate)(e, t)
                } catch (t) {
                    (0, n.logError)("safe message", t.message), "/" !== e.pathname && this._push(b.pathToRoot)
                }
            }
            matchesPath(e) {
                const t = (null == e ? void 0 : e.path) || e;
                return this.currentPath.pipe(o.map((e => !!(0, g.matchPath)(e, {
                    path: t
                }))), o.distinctUntilChanged())
            }
            typeOfCurrentView(e) {
                return this.currentPath.pipe(o.map((t => (0, g.matchPath)(t, {
                    path: b.routeToMessagesThread
                }) ? "messageDetails" : b.taskRoutes.some((e => (0, g.matchPath)(t, {
                    path: e
                }))) ? "taskDetails" : (0, g.matchPath)(t, {
                    path: (0, b.pathToPriority)(e).path
                }) ? "priority" : (0, g.matchPath)(t, {
                    path: (0, b.pathToIncoming)(e).path
                }) ? "incoming" : (0, g.matchPath)(t, {
                    path: (0, b.pathToActivity)(e).path
                }) ? "activity" : (0, g.matchPath)(t, {
                    path: (0, b.pathToSingleTasks)(e).path
                }) ? "singleTasks" : (0, g.matchPath)(t, {
                    path: (0, b.pathToCalendar)(e).path
                }) ? "calendar" : (0, g.matchPath)(t, {
                    path: b.routeToMember
                }) ? "member" : (0, g.matchPath)(t, {
                    path: b.routeToMessages
                }) ? "messages" : (0, g.matchPath)(t, {
                    path: b.routeToTag
                }) ? "tag" : (0, g.matchPath)(t, {
                    path: b.routeToProject
                }) ? "project" : "other")), o.distinctUntilChanged())
            }
            _push(e, t, s) {
                const n = this.currentPath.getValue(),
                    {
                        path: a,
                        hash: o
                    } = w(e);
                (a !== n || t || s) && this._history.push("" + a + o, t)
            }
            replace(e, t) {
                const s = this.currentPath.getValue(),
                    {
                        path: n,
                        hash: a
                    } = w(e);
                (n !== s || t) && this._history.replace("" + n + a, t)
            }
            unsafePushWithoutPrefetch(e, t) {
                const s = (0, f.Nm)(e);
                this._history.push(s, t)
            }
            async restoreLastRoute() {
                const e = this.currentPath.getValue();
                if ("/" === e) {
                    const e = await this._getLastRoute() || "/";
                    this._history.push(e)
                } else await this._setLastRoute(e)
            }
            goBack() {
                this._history.goBack()
            }
            isFirstRoute() {
                return n.isElectron && this._history.canGo ? !this._history.canGo(-2) : 1 === globalThis.history.length
            }
            isLastRoute() {
                return !!this._history.canGo && !this._history.canGo(1)
            }
            clean() {
                this._localStorage.remove(k)
            }
            redirectAfterLogin() {
                this.loginRedirectPath && (this._push({
                    path: this.loginRedirectPath
                }), this.loginRedirectPath = null)
            }
            isActionRoute(e) {
                return e.startsWith("/third_party") || e.startsWith("/promotion") || e.includes("/quick_add") || e.endsWith("/jump_to") || e.startsWith("/join_project") || e.startsWith("/join_task") || e.startsWith("/invite") || e.startsWith("/join/") || e.startsWith("/j/")
            }
            async _setLastRoute(e) {
                this.isActionRoute(e) || await this._localStorage.set(y.d.lastRoute, e)
            }
            async _getLastRoute() {
                const e = await this._localStorage.getSlowly(y.d.lastRoute);
                return !e || this.isActionRoute(e) ? null : e
            }
            _setCurrentUserActivity(e) {
                this._native.setCurrentUserActivity({
                    path: e,
                    fallbackUrl: "" + c.webAppUrl + e,
                    isSearchable: !1
                })
            }
        }
        class j {
            constructor(...e) {
                this.onLocationUpdate = () => {}, this.showSidebar = () => {}
            }
            get hasNavigatedToSidebar() {
                return o.of(!0)
            }
        }

        function T(e) {
            return e.reduce(((e, t) => (e.push(...S(t)), e)), [])
        }

        function S(e) {
            const t = [];
            return e.items.forEach((e => {
                e.items ? t.push(...S(e)) : e.id && t.push(e)
            })), t
        }

        function P(e, t, s) {
            return !(e.key !== s || !e.modifiers || e.modifiers.length !== t.length || !e.modifiers.every((e => t.includes(e)))) || !!e.alternativeShortcuts && e.alternativeShortcuts.some((e => P(e, t, s)))
        }
        class _ {
            get allShortcuts() {
                return {
                    groups: this._groups,
                    providers: this._providers
                }
            }
            constructor(e) {
                this._groups = [], this._allItems = [], this._providers = [], this._suppressors = 0, this._updateScheduled = !1, this._scene = e, this._scene.webWindow.addEventListener("focus", (() => {
                    this._update()
                }))
            }
            setShortcuts(e) {
                this._groups = e, this._allItems = T(this._groups), this._update()
            }
            updateActionProviders(e) {
                this._providers.push(...e), this._update()
            }
            removeActionProviders(e) {
                const t = a.pluckIds(e);
                this._providers = this._providers.filter((e => !t.includes(e.id))), this._update()
            }
            invoke(e) {
                const t = this._providers.find((({
                    id: t
                }) => t === e));
                t && !this._isDisabled && t.action()
            }
            findAction(e, t) {
                if (this._isDisabled) return null;
                return this._allItems.find((s => P(s, e, t)))
            }
            findActionById(e) {
                if (this._isDisabled) return null;
                return this._allItems.find((t => t.id === e))
            }
            get _isDisabled() {
                return 0 < this._suppressors
            }
            suppress() {
                this._suppressors += 1
            }
            unsuppress() {
                this._suppressors -= 1
            }
            _update() {
                this._updateScheduled || (setTimeout((() => {
                    var e, t;
                    this._updateScheduled = !1, this._scene, e = {
                        isDisabled: this._isDisabled,
                        items: this._allItems,
                        groups: this._groups,
                        providers: this._providers
                    }, null == (t = globalThis.electron) || t.updateMenu(e)
                }), 5), this._updateScheduled = !0)
            }
        }
        const C = () => {
                throw new Error("unimplemented")
            },
            R = {
                multiple: !0,
                mimeType: "*/*",
                type: "files"
            },
            A = e => {
                const {
                    dataTransfer: t
                } = e;
                return t.types.includes("Files")
            };
        class I {
            constructor(e) {
                this._window = e.webWindow
            }
            async pickFile(e, t) {
                const s = Object.assign({}, R, t || {}),
                    n = this._window.document.createElement("input");
                n.type = "file", s.multiple && (n.multiple = !0), s.mimeType && (n.accept = s.mimeType), n.onchange = t => e(Array.from(t.target.files)), n.oncancel = () => e(null), n.click()
            }
            async openFile() {
                return C()
            }
            async requestStoreReview() {
                C()
            }
            canOpenPhotoLibrary() {
                return !1
            }
            get hasDroppableFiles() {
                return e = this._window, o.Observable.create((t => {
                    let s = !1;
                    t.next(!1);
                    const n = e => {
                        e !== s && (s = e, setTimeout((() => t.next(e)), 0))
                    };
                    let a = null;
                    const o = () => {
                            clearTimeout(a), n(!1), a = null
                        },
                        r = e => {
                            !a && A(e) && n(!0), e.preventDefault(), clearTimeout(a), a = setTimeout(o, 500)
                        },
                        i = e => {
                            A(e) && e.preventDefault(), o()
                        };
                    return e.addEventListener("dragover", r, !0), e.addEventListener("drop", i, !0), () => {
                        e.removeEventListener("dragover", r, !0), e.removeEventListener("drop", i, !0)
                    }
                }));
                var e
            }
        }
        class N {
            constructor() {}
            setOptionsAtLevel() {}
        }
        var E = s(52);
        const O = e => t => (t.teamId ? "teams/" + t.teamId : "personal") + "/" + ("function" == typeof e ? e(t) : e),
            M = {
                login: "login",
                signup: "signup",
                migrate_np: "migrate_np",
                password_reset: "password_reset",
                "apple-signin": "apple-signin",
                "google-signin": "google-signin",
                "nozbe-signin": "nozbe-signin",
                finish_signup: e => "signup/" + e.registerId,
                invite: e => "join/" + e.inviteId,
                join: e => "j/" + e.joinCode,
                confirm_signup: e => "confirm/" + e.confirmId,
                confirm_password_reset: e => "password_reset/" + e.confirmId,
                confirm_email: e => "confirm_email/" + e.confirmId,
                third_party: e => "third_party/" + e.thirdPartyName,
                priority: O("priority"),
                incoming: O("incoming"),
                activity: O("activity"),
                single_tasks: O("single_tasks"),
                calendar: O("calendar"),
                search: O("search"),
                devtools: O("devtools"),
                messages: O("messages"),
                project: O((e => "projects/" + e.projectId)),
                tag: O((e => "tags/" + e.tagId)),
                member: O((e => "members/" + e.memberId)),
                task_redirect: O((e => "task_id/" + e.taskId)),
                task: e => "tasks/" + e.taskId
            };
        const D = ["login", "signup", "password_reset", "apple-signin", "google-signin", "nozbe-signin", "migrate_np"],
            H = e => {
                const [t, s] = e;
                if (1 === e.length) {
                    if (D.includes(t)) return [{
                        type: t
                    }]
                } else {
                    if ("teams" === t && s) return L(s, e.slice(2));
                    if ("personal" === t) return L(null, e.slice(1));
                    if (".well-known" === t && "change-password" === s) return [{
                        type: "password_reset"
                    }];
                    if (s) {
                        if ("signup" === t) return [{
                            type: "finish_signup",
                            registerId: s
                        }];
                        if ("join" === t) return [{
                            type: "invite",
                            inviteId: s
                        }];
                        if ("j" === t) return [{
                            type: "join",
                            joinCode: s
                        }];
                        if ("confirm" === t) return [{
                            type: "confirm_signup",
                            confirmId: s
                        }];
                        if ("password_reset" === t) return [{
                            type: "confirm_password_reset",
                            confirmId: s
                        }];
                        if ("confirm_email" === t) return [{
                            type: "confirm_email",
                            confirmId: s
                        }];
                        if ("third_party" === t) return [{
                            type: "third_party",
                            thirdPartyName: s
                        }]
                    }
                }
                return null
            },
            F = ["devtools"],
            Z = ["priority", "incoming", "activity", "single_tasks", "calendar", "messages", "search"],
            L = (e, t) => {
                const [s, n] = t;
                if (F.includes(s)) return [{
                    type: s,
                    teamId: e
                }];
                if (Z.includes(s)) return [{
                    type: s,
                    teamId: e
                }, ...B(t.slice(1))];
                if (n) {
                    if ("projects" === s) return [{
                        type: "project",
                        teamId: e,
                        projectId: n
                    }, ...B(t.slice(2))];
                    if ("tags" === s) return [{
                        type: "tag",
                        teamId: e,
                        tagId: n
                    }, ...B(t.slice(2))];
                    if ("members" === s) return [{
                        type: "member",
                        teamId: e,
                        memberId: n
                    }, ...B(t.slice(2))];
                    if ("task_id" === s) return [{
                        type: "task_redirect",
                        teamId: e,
                        taskId: n
                    }]
                }
                return null
            },
            B = e => {
                const [t, s] = e;
                return "tasks" === t && s ? [{
                    type: "task",
                    taskId: s
                }] : []
            },
            z = ["path"];
        class U {
            constructor({
                history: e,
                navigation: t,
                app: s
            }) {
                this._history = e, this._navigation = t, this._app = s
            }
            goTo(e, t, s) {
                var n;
                this._app._addDebugLog("[ROUTER] opening path: " + e.path + ", hash: " + (null != (n = e.hash) ? n : "null"));
                const {
                    path: a
                } = e, o = (0, E.Z)(e, z);
                if (this._history.isActionRoute(a)) this._history._push(e, t, s);
                else {
                    const e = function(e) {
                        const t = (e => e.startsWith("/") ? e.slice(1).split("/") : e.split("/"))(e);
                        return t.length ? H(t) : null
                    }(a);
                    if (e) {
                        const n = function(e) {
                            return "/" + e.map((e => {
                                const t = M[e.type];
                                return "string" == typeof t ? t : "function" == typeof t ? t(e) : ""
                            })).join("/")
                        }(e);
                        this._history._push(Object.assign({
                            path: n
                        }, o), t, s)
                    } else this._history._push(b.pathToRoot, t, s)
                }
            }
            replace(e, t) {
                this._history.replace(e, t)
            }
            goBack() {
                this._history.goBack()
            }
            async handleExternalUrl(e) {
                const {
                    pathname: t,
                    search: o,
                    hash: r,
                    host: i,
                    protocol: c
                } = a.parseUrl(e);
                "goto" === i || "nozbe4:" !== c ? this._history._push({
                    path: "" + t + o + r
                }) : "x-callback-url" === i ? await s(1317).Z(this._app, e) : n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR).warn("Unknown external URL: " + e)
            }
        }
        var W, G, V, q = s(69),
            Q = s(24);
        class Y {
            constructor({
                currentPath: e,
                layout: t
            }) {
                this.areOpen = new o.ReplaySubject(1), this.areMaximized = new o.ReplaySubject(1), this._maximizeToggle = new o.BehaviorSubject(!1), this._currentPath = e, this._layout = t, this.reset()
            }
            minimize() {
                this._maximizeToggle.next(!1)
            }
            maximize() {
                this._maximizeToggle.next(!0)
            }
            reset() {
                var e;
                null == (e = this._subscriptions) || e.forEach((e => e.unsubscribe())), this._subscriptions = [], this._subscriptions.push(this._observeOpenState()), this._subscriptions.push(this._observeMaximizeState())
            }
            _observeOpenState() {
                return this._currentPath.pipe(o.distinctUntilChanged(), o.map((e => function(e) {
                    return b.taskRoutes.some((t => (0, g.matchPath)(e, {
                        path: t
                    })))
                }(e)))).subscribe(this.areOpen)
            }
            _observeMaximizeState() {
                const e = this._layout.pipe(o.distinctUntilKeysChanged(["variant", "isDesktop"]), o.map((e => function({
                    variant: e,
                    isDesktop: t
                }) {
                    return t && "narrow" === e
                }(e)))).pipe(o.switchMap((e => e ? o.of(!0) : this._maximizeToggle)));
                return o.combineLatest(this.areOpen, e).pipe(o.map((([e, t]) => e && t)), o.distinctUntilChanged()).subscribe(this.areMaximized)
            }
        }
        let J = (W = n.lazy, V = ((e, t, s, n = null) => (0, Q.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        }))(G = class {
            get isFloating() {
                return this._layoutState.pipe(o.map((e => function(e) {
                    const {
                        layout: {
                            variant: t,
                            isDesktop: s
                        },
                        areTaskDetailsMaximized: n
                    } = e;
                    if (!s || n) return !1;
                    if (i.isLayoutWiderThan(t, "standard")) return !1;
                    return !0
                }(e))), o.distinctUntilChanged())
            }
            constructor({
                taskDetails: e,
                currentPath: t,
                layout: s,
                getUserCollapse: n,
                getCurrentLocation: a
            }) {
                this.isCollapsed = new o.ReplaySubject(1), this._collapseToggle = new o.Subject, (0, q.Z)(this, "_layoutState", V, this), this._taskDetails = e, this._currentPath = t, this._layout = s, this._getUserCollapse = n, this._getCurrentLocation = a, this.reset()
            }
            open() {
                this._collapseToggle.next(!1)
            }
            close() {
                this._collapseToggle.next(!0)
            }
            reset() {
                var e;
                null == (e = this._subscriptions) || e.forEach((e => e.unsubscribe())), this._subscriptions = [], this._subscriptions.push(this._observeCollapseState())
            }
            _observeCollapseState() {
                const e = o.from(this._calculateCollapseState()),
                    t = this._layout.pipe(o.skip(1), o.distinctUntilKeysChanged(["variant", "isDesktop"]), o.switchMap((() => this._calculateCollapseState()))),
                    s = this._currentPath.pipe(o.skip(1), o.distinctUntilChanged(), o.filter((() => {
                        const {
                            state: e
                        } = this._getCurrentLocation(), {
                            keepSidebarOpen: t
                        } = e || {};
                        return !t
                    })), o.switchMap((() => this._calculateCollapseState()))),
                    n = this._taskDetails.areMaximized.pipe(o.skip(1), o.distinctUntilChanged(), o.switchMap((() => this._calculateCollapseState()))),
                    a = o.merge(t, s, n, this._collapseToggle);
                return e.pipe(o.concat(a), o.distinctUntilChanged()).subscribe(this.isCollapsed)
            }
            async _calculateCollapseState() {
                return function(e, t) {
                    const {
                        layout: {
                            variant: s,
                            isDesktop: n
                        },
                        areTaskDetailsMaximized: a
                    } = e;
                    if (!n) return !1;
                    if (!a && i.isLayoutWiderThan(s, "standard")) return t;
                    return !0
                }(await o.takeFirst(this._layoutState), this._getUserCollapse())
            }
        }, "_layoutState", [W], (function() {
            return o.combineLatestObject({
                layout: this._layout,
                areTaskDetailsOpen: this._taskDetails.areOpen,
                areTaskDetailsMaximized: this._taskDetails.areMaximized
            })
        })), G);
        var K, $, X, ee, te;
        const se = (e, t, s, n = null) => (0, Q.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let ne = (K = n.lazy, $ = n.lazy, ee = se(X = class {
            get areTaskDetailsMaximized() {
                return this._taskDetails.areMaximized
            }
            get isSidebarCollapsed() {
                return this._sidebar.isCollapsed
            }
            get isSidebarFloating() {
                return this._sidebar.isFloating
            }
            constructor(e, t) {
                this._layout = new o.ReplaySubject(1), (0, q.Z)(this, "_taskDetails", ee, this), (0, q.Z)(this, "_sidebar", te, this), this._localStorage = new y.a(e), this._history = t
            }
            update(e) {
                this._layout.next(e)
            }
            reset() {
                this._taskDetails.reset(), this._sidebar.reset()
            }
            maximizeTaskDetails() {
                this._taskDetails.maximize()
            }
            minimizeTaskDetails() {
                this._taskDetails.minimize()
            }
            async openSidebar(e = !1) {
                this._sidebar.open(), e && await this._writeSidebarCollapse(!1)
            }
            async closeSidebar(e = !1) {
                this._sidebar.close(), e && await this._writeSidebarCollapse(!0)
            }
            async toggleSidebar(e = !1) {
                const t = await o.takeFirst(this._sidebar.isCollapsed);
                t ? this._sidebar.open() : this._sidebar.close(), e && await this._writeSidebarCollapse(!t)
            }
            _readSidebarCollapse() {
                return !!this._localStorage.get(y.d.sidebarCollapsed)
            }
            async _writeSidebarCollapse(e) {
                await this._localStorage.set(y.d.sidebarCollapsed, e)
            }
        }, "_taskDetails", [K], (function() {
            return new Y({
                currentPath: this._history.currentPath,
                layout: this._layout
            })
        })), te = se(X, "_sidebar", [$], (function() {
            return new J({
                currentPath: this._history.currentPath,
                layout: this._layout,
                taskDetails: this._taskDetails,
                getUserCollapse: () => this._readSidebarCollapse(),
                getCurrentLocation: () => this._history.currentLocation
            })
        })), X);
        var ae = s(849);
        class oe {
            constructor({
                localStorage: e,
                settings: t,
                getCurrentUIState: s,
                nativeScene: n
            }) {
                this._localStorage = e, this._settings = t, this._getCurrentUIState = s, this._nativeScene = n
            }
            get _uiState() {
                return this._getCurrentUIState()
            }
            onDidCompleteTask() {
                this._triggerEngagementOpportunity()
            }
            onDidEndProject() {
                this._triggerEngagementOpportunity()
            }
            _triggerEngagementOpportunity() {
                this._requestNPSSurvey()
            }
            async _requestNPSSurvey() {
                var e, t;
                const s = Date.now(),
                    n = await (async e => {
                        const t = null != (e = await this._localStorage.get(y.d.lastPromptedForNPSSurveyAt)) ? e : 0;
                        return 0 === t ? (await this._localStorage.set(y.d.lastPromptedForNPSSurveyAt, s), s) : t
                    })(),
                    a = await this._settings.npsRatingSetting.fetch(),
                    o = null != (e = null == a ? void 0 : a.rating) ? e : -1,
                    r = null != (t = null == a ? void 0 : a.ratedAt) ? t : 0;
                (0, ae.Z)(s, Math.max(r, n)) >= (-1 === o ? 1 : o < 9 ? 12 : 24) && (this._uiState.reviewModal.open(), await this._localStorage.set(y.d.lastPromptedForNPSSurveyAt, s))
            }
            async requestNativeStoreReview() {
                await this._nativeScene.requestStoreReview(), await this._localStorage.set(y.d.lastPromptedForReviewAt, Date.now())
            }
        }
        class re {
            get id() {
                return this._id
            }
            get webWindow() {
                return invariant(this._webWindow, "Missing web window in scene"), this._webWindow
            }
            constructor({
                app: e,
                id: t,
                webWindow: s
            }) {
                this._app = e, this._id = t, this._webWindow = s, this.history = new x({
                    localStorage: this._app.localStorage,
                    native: this._app.native,
                    onLocationUpdate: (t, s) => {
                        e.performance.markPageLoadStarted(), this.navigation.onLocationUpdate(t, s)
                    }
                }), this.uiState = new p, this.navigation = new j({
                    history: this.history
                }), this.router = new U({
                    history: this.history,
                    navigation: this.navigation,
                    app: e
                }), this.shortcuts = new _(this), this.nativeScene = new I(this), this.statusBar = new N(t), this.layout = new ne(this._app.localStorage, this.history), this.engager = new oe({
                    localStorage: this._app.localStorage,
                    settings: this._app.modelRoot.settings,
                    nativeScene: this.nativeScene,
                    getCurrentUIState: () => this.uiState
                }), this._app.connectScene(t, this)
            }
            disconnectScene() {
                n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_ID).log("[Services] Good bye, scene " + this._id + "!"), this._app._disconnectScene(this._id, this)
            }
            _forceLogOut() {
                this.uiState = new p, this.layout.reset()
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            vs: () => A,
            uc: () => N,
            j$: () => E,
            Fe: () => C
        });
        var n = s(0),
            a = s(14),
            o = s(11);
        s(2), s(3);
        const r = s(616);
        var i = s(1);
        const c = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            isFloating: e.layout.isSidebarFloating
        }))))((e => {
            const {
                children: t,
                isCollapsed: s,
                isFloating: a,
                isDark: c
            } = e, l = n.Hooks.useServices();
            return (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(o.Z, {
                    className: r.overlay + (a && !s ? " " + r.overlayActive : ""),
                    onPress: () => l.layout.closeSidebar()
                }), (0, i.jsx)("div", {
                    className: r.root + (s ? " " + r.rootCollapsed : "") + (a ? " " + r.rootFloating : "") + (c ? " " + r.rootDark : ""),
                    style: {
                        top: a && n.Misc.isElectron ? 48 : void 0
                    },
                    "data-theme": c ? "dark" : void 0,
                    children: t
                })]
            })
        }));
        var l = s(103);
        const d = n.ReactUtils.lazy((() => s(1318))),
            u = s(230).wx,
            m = ({
                sidebarContentType: e,
                switchSidebarContent: t,
                usesDarkSidebar: a,
                isShowingTeamSwitch: o
            }) => {
                const r = () => t(null, "main");
                switch (e) {
                    case "projects":
                    case "projectsEnded":
                    case "projectsSearch":
                    case "projectsGroups":
                    case "projectsFollowed": {
                        const s = ["projectsGroups", "projectsFollowed"].includes(e);
                        return (0, i.jsx)(u.SidebarInnerProjects, {
                            bundle$close: r,
                            switchSidebarContent: t,
                            shouldShowGroups: s,
                            shouldFocusOnEnded: "projectsEnded" === e,
                            shouldOpenSearch: "projectsSearch" === e,
                            shouldFocusOnFollowed: "projectsFollowed" === e,
                            usesDarkSidebar: a
                        })
                    }
                    case "projectsTemplates":
                        return (0, i.jsx)(u.SidebarInnerProjectsTemplates, {
                            bundle$close: r,
                            switchSidebarContent: t
                        });
                    case "tags":
                        return (0, i.jsx)(u.SidebarInnerTags, {
                            bundle$close: r,
                            switchSidebarContent: t
                        });
                    case "team":
                    case "teamGroups":
                        return (0, i.jsx)(u.SidebarInnerTeam, {
                            bundle$close: r,
                            switchSidebarContent: t,
                            shouldShowGroups: "teamGroups" === e,
                            usesDarkSidebar: a
                        });
                    case "main": {
                        const e = s(516).default;
                        return (0, i.jsx)(e, {
                            switchSidebarContent: t,
                            isShowingTeamSwitch: o
                        })
                    }
                    default:
                        return n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL, "unreachable"), null
                }
            },
            h = n.Hocs.compose(n.Hocs.memo, n.Hocs.withErrorBoundary({
                name: "SidebarDefaultLayout",
                render: "short"
            }), n.Hocs.withCloakOnLimitedAccounts, n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isCollapsed: e.layout.isSidebarCollapsed,
                isDarkSidebarEnabled: e.modelRoot.settings.isDarkSidebarEnabled.observe()
            }))))((e => {
                const {
                    isCollapsed: t,
                    isDarkSidebarEnabled: s,
                    services: o
                } = e, [u, h] = n.React.useState("main"), {
                    isNarrowerThan: p
                } = n.Hooks.useLayoutVariant(), g = n.React.useCallback(((e, t) => {
                    h(t)
                }), []), f = s && n.Styling.theme.isLight();
                return (0, i.jsx)(l.lK.Provider, {
                    value: f,
                    children: (0, i.jsxs)(c, {
                        isCollapsed: t,
                        isDark: f,
                        children: [(0, i.jsx)("div", {
                            className: r.wrapper + (f ? " " + r.wrapperDark : ""),
                            children: m({
                                sidebarContentType: u,
                                switchSidebarContent: g,
                                usesDarkSidebar: f,
                                isShowingTeamSwitch: !0
                            })
                        }), (0, i.jsx)(d, {
                            setDisplayedTeam: (e, t) => {
                                h("main"), o.router.goTo(a.pathToPriority(t), {
                                    keepSidebarOpen: p("wide")
                                })
                            }
                        })]
                    })
                })
            }));
        var p, g = s(37),
            f = s(80),
            b = s(257);
        const y = (0, b.Ar)((() => (0, i.jsxs)(f.Switch, {
                children: [p || (p = (0, i.jsx)(f.Route, {
                    exact: !0,
                    path: a.routeToRoot,
                    component: b.c2
                })), b.zg.map((([e, t]) => (0, i.jsx)(f.Route, {
                    path: e,
                    component: t
                }, e)))]
            }))),
            v = (0, b.Ar)((() => (0, i.jsx)(f.Switch, {
                children: b.Ix.map((([e, t]) => (0, i.jsx)(f.Route, {
                    path: e,
                    component: t
                }, e)))
            }))),
            w = s(766),
            k = n.ReactUtils.lazy((() => s(942))),
            x = e => {
                const {
                    sidebar: t,
                    content: s
                } = e, a = (0, i.jsxs)("div", {
                    className: w.root,
                    style: {
                        height: n.Misc.isElectron ? void 0 : "100%"
                    },
                    children: [t, (0, i.jsx)("div", {
                        className: w.contentWrapper,
                        children: s
                    })]
                });
                return n.Misc.isElectron ? (0, i.jsx)(k, {
                    children: a
                }) : a
            };
        var j = s(131);

        function T() {
            const e = n.Hooks.useIntl(),
                t = n.React.useMemo((() => (e => [{
                    id: "global",
                    title: e.f.lf,
                    items: [n.Misc.isElectron ? {
                        id: "global.newWindow",
                        title: e.f.ls,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "N"
                    } : null, {
                        id: "global.quickAdd",
                        title: e.f.Ce,
                        modifiers: [j.DC.cmdOrCtrl, j.DC.alt],
                        key: "N"
                    }, {
                        id: "global.sync",
                        title: e.f.lt,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "S"
                    }, {
                        id: "global.shortucts_help",
                        title: e.f.lo,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: j.sr.slash
                    }, null].filter(Boolean)
                }, {
                    title: e.f.lQ,
                    items: [{
                        id: "teams.team_1",
                        title: "Team 1",
                        modifiers: [j.DC.shift],
                        key: j.sr.one,
                        isHiddenIfDisabled: !0
                    }, {
                        id: "teams.team_2",
                        title: "Team 2",
                        modifiers: [j.DC.shift],
                        key: j.sr.two,
                        isHiddenIfDisabled: !0
                    }, {
                        id: "teams.team_3",
                        title: "Team 3",
                        modifiers: [j.DC.shift],
                        key: j.sr.three,
                        isHiddenIfDisabled: !0
                    }, {
                        id: "teams.team_4",
                        title: "Team 4",
                        modifiers: [j.DC.shift],
                        key: j.sr.four,
                        isHiddenIfDisabled: !0
                    }, {
                        id: "teams.team_5",
                        title: "Team 5",
                        modifiers: [j.DC.shift],
                        key: j.sr.five,
                        isHiddenIfDisabled: !0
                    }]
                }, {
                    title: e.f.lp,
                    items: [{
                        id: "list.new_task",
                        title: e.f.lr,
                        modifiers: [],
                        key: "N"
                    }, {
                        id: "list.new_task_close",
                        title: e.f.lq,
                        modifiers: [],
                        key: j.sr.esc,
                        allowInsideInput: !0
                    }]
                }, {
                    title: e.f.lu,
                    items: [{
                        id: "task.complete",
                        title: e.f.lH,
                        modifiers: [j.DC.alt],
                        key: "D"
                    }, {
                        id: "task.restore",
                        title: e.f.lI,
                        modifiers: [j.DC.alt],
                        key: "D"
                    }, {
                        id: "task.abandon",
                        title: e.f.lv,
                        modifiers: [j.DC.alt],
                        key: "X"
                    }, {
                        id: "task.star",
                        title: e.f.lM,
                        modifiers: [j.DC.alt],
                        key: "S"
                    }, j.Cl, {
                        id: "task.rename",
                        title: e.f.lL,
                        modifiers: [j.DC.alt],
                        key: "R"
                    }, {
                        id: "task.set_project",
                        title: e.f.lz,
                        modifiers: [j.DC.alt],
                        key: j.sr.one
                    }, {
                        id: "task.set_section",
                        title: e.f.lB,
                        modifiers: [j.DC.alt],
                        key: j.sr.two
                    }, {
                        id: "task.set_responsible",
                        title: e.f.lx,
                        modifiers: [j.DC.alt],
                        key: j.sr.three
                    }, {
                        id: "task.set_tags",
                        title: e.f.lC,
                        modifiers: [j.DC.alt],
                        key: j.sr.four
                    }, {
                        id: "task.set_due_date",
                        title: e.f.ly,
                        modifiers: [j.DC.alt],
                        key: j.sr.five
                    }, {
                        id: "task.set_reminders",
                        title: e.f.lA,
                        modifiers: [j.DC.alt],
                        key: j.sr.six
                    }, {
                        id: "task.set_time_needed",
                        title: e.f.lD,
                        modifiers: [j.DC.alt],
                        key: j.sr.seven
                    }, {
                        id: "task.set_time_spent",
                        title: e.f.lE,
                        modifiers: [j.DC.alt],
                        key: j.sr.eight
                    }, j.Cl, {
                        id: "task.add_comment",
                        title: e.f.lw,
                        modifiers: [j.DC.alt],
                        key: "M"
                    }, {
                        id: "task.toggle_comment_preview",
                        title: e.f.lO,
                        modifiers: [j.DC.cmdOrCtrl, j.DC.shift],
                        key: "P"
                    }, {
                        id: "task.toggle_bold",
                        title: e.f.lN,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "B"
                    }, {
                        id: "task.toggle_italic",
                        title: e.f.lP,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "I"
                    }, j.Cl, {
                        id: "task.previous",
                        title: e.f.lK,
                        modifiers: [j.DC.alt],
                        key: j.sr.up,
                        alternativeShortcuts: [{
                            modifiers: [j.DC.alt],
                            key: "J"
                        }]
                    }, {
                        id: "task.next",
                        title: e.f.lJ,
                        modifiers: [j.DC.alt],
                        key: j.sr.down,
                        alternativeShortcuts: [{
                            modifiers: [j.DC.alt],
                            key: "K"
                        }]
                    }, {
                        id: "task.close",
                        title: e.f.lF,
                        modifiers: [j.DC.alt],
                        key: j.sr.right,
                        alternativeShortcuts: [{
                            modifiers: [j.DC.alt],
                            key: "L"
                        }]
                    }, j.Cl, {
                        id: "task.toggle_fullscreen",
                        title: e.f.lG,
                        modifiers: [j.DC.alt],
                        key: "F"
                    }].filter(Boolean)
                }, {
                    title: e.f.lg,
                    items: [...n.Misc.isElectron ? [{
                        id: "go.back",
                        title: e.f.fd,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "["
                    }, {
                        id: "go.forward",
                        title: e.f.ll,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "]"
                    }, j.Cl] : [], {
                        id: "global.jumpTo",
                        title: e.f.lm,
                        modifiers: [j.DC.cmdOrCtrl],
                        key: "K"
                    }, j.Cl, {
                        id: "go.priority",
                        title: e.f.zV,
                        modifiers: [],
                        key: j.sr.one
                    }, {
                        id: "go.incoming",
                        title: e.f.ny,
                        modifiers: [],
                        key: j.sr.two
                    }, {
                        id: "go.activity",
                        title: e.f.y,
                        modifiers: [],
                        key: j.sr.three
                    }, {
                        id: "go.single_tasks",
                        title: e.f.EO,
                        modifiers: [],
                        key: j.sr.four
                    }, j.Cl, {
                        id: "go.search",
                        title: e.f.ln,
                        modifiers: [],
                        key: "F"
                    }, {
                        id: "go.next_30_days",
                        title: e.f.Ed,
                        modifiers: [],
                        key: "D"
                    }, {
                        id: "go.messages",
                        title: e.f.Kc,
                        modifiers: [],
                        key: "M"
                    }, j.Cl, {
                        id: "go.favorite_1",
                        title: e.f.lh,
                        modifiers: [],
                        key: j.sr.five
                    }, {
                        id: "go.favorite_2",
                        title: e.f.li,
                        modifiers: [],
                        key: j.sr.six
                    }, {
                        id: "go.favorite_3",
                        title: e.f.lj,
                        modifiers: [],
                        key: j.sr.seven
                    }, {
                        id: "go.favorite_4",
                        title: e.f.lk,
                        modifiers: [],
                        key: j.sr.eight
                    }].filter(Boolean)
                }])(e)), [e]);
            n.Hooks.useShortcuts(t)
        }
        var S, P, _;
        const C = () => {
                n.React.useEffect((() => {
                    const e = globalThis.matchMedia("(prefers-color-scheme: light)"),
                        t = () => (e => {
                            const t = globalThis.document.querySelector("meta[name=theme-color]");
                            null == t || t.setAttribute("content", n.Styling.factoryColor(e))
                        })(e.matches ? "onBackground1" : "gray6");
                    return t(), e.addListener(t), () => e.removeListener(t)
                }), []);
                const e = n.Hooks.useServices();
                n.React.useEffect((() => {
                    if (globalThis.electron && 0 === e.scene.id) {
                        const t = globalThis.electron.addListenerUrl((t => {
                            e.router.handleExternalUrl(t)
                        }));
                        return () => t()
                    }
                    return () => {}
                }), [e]), n.Hooks.useAsyncEffect((async () => {
                    if (globalThis.electron) {
                        const t = await e.localStorage.get(g.d.quickAddHotkey);
                        if (!t) return await e.localStorage.set(g.d.quickAddHotkey, "CTRL+SHIFT+N"), void globalThis.electron.setGlobalShortcut("CTRL+SHIFT+N");
                        globalThis.electron.setGlobalShortcut(t)
                    }
                }), [e])
            },
            R = ["", null, void 0, "button"],
            A = () => (T(), (() => {
                const e = n.Hooks.useServices();
                n.Hooks.useEventListener({
                    eventName: "keydown",
                    handler: t => {
                        const {
                            key: s,
                            target: a
                        } = t, o = !R.includes(a.type);
                        if (["Control", "Shift", "Meta", "Alt"].includes(s) || o) return;
                        const r = t.shiftKey,
                            i = t.metaKey,
                            c = t.ctrlKey,
                            l = t.altKey,
                            d = "Windows" === n.ReactUtils.getDeviceOS() && t.getModifierState("AltGraph"),
                            u = [...r ? ["shift"] : [], ...i ? ["cmd"] : [], ...c || d ? ["ctrl"] : [], ...l || d ? ["alt"] : []],
                            m = t.code;
                        if (!m) return;
                        const h = m.startsWith("Key") ? m.slice(3) : m,
                            p = e.shortcuts.findAction(u, h);
                        p && (e.shortcuts.invoke(p.id), t.preventDefault(), t.stopPropagation())
                    }
                })
            })(), S || (S = (0, i.jsx)(x, {
                sidebar: (0, i.jsx)(h, {}),
                content: (0, i.jsx)(y, {})
            }))),
            I = n.ReactUtils.lazy((() => s(942))),
            N = () => n.Misc.isElectron ? P || (P = (0, i.jsx)(I, {
                hideButtons: !0,
                children: (0, i.jsx)(v, {})
            })) : _ || (_ = (0, i.jsx)(v, {})),
            E = () => globalThis.electron ? globalThis.electron.getInitialUrl() : null
    }, , , , , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(30),
            i = s(1);
        const c = n.ReactUtils.lazy((() => s(1322))),
            l = n.ReactUtils.lazy((() => s(1324))),
            d = n.ReactUtils.lazy((() => s(1325))),
            u = n.Hocs.compose()((e => {
                var t, s;
                const {
                    onClose: u,
                    token: m,
                    onInvalidToken: h
                } = e, {
                    isLimitedAccount: p
                } = n.Hooks.useIdentity(), g = n.Hooks.useIntl(), [{
                    closeAnimated: f
                }, b] = (0, a.P9)(), y = n.Hooks.useErrorHandler({
                    [n.Misc.BuiltInErrorCodes.TokenExpired]: g.f.Jr,
                    [n.Misc.BuiltInErrorCodes.NotFound]: g.f.Jr
                }), {
                    joinCode: v,
                    inviteId: w
                } = m, [k, x] = (0, r.ji)({
                    joinCode: v,
                    inviteId: w
                });
                return invariant("team_invitations" === (null == k ? void 0 : k.type) || "team_code" === (null == k ? void 0 : k.type), "Unexpected token type in TeamInvitationModal"), (0, i.jsxs)(a.u_, {
                    onClose: u,
                    ref: b,
                    minWidth: 400,
                    children: [(0, i.jsx)(a.u_.Header, {
                        children: g.f.jp
                    }), (0, i.jsx)(a.u_.Content, {
                        children: (0, i.jsx)(a.u_.Loader, {
                            isLoading: "not_checked" === k.status,
                            isSuccess: "valid" === k.status || "conflict" === k.status,
                            isError: "invalid" === k.status,
                            renderSuccess: () => {
                                if (invariant("valid" === k.status || "conflict" === k.status, "Invalid token for rendering success state"), p) return t || (t = (0, i.jsx)(d, {
                                    token: k
                                }));
                                if ("team_invitations" === k.type) {
                                    const {
                                        payload: {
                                            teamId: e = "fake",
                                            teamName: t,
                                            teamAvatarUrl: s,
                                            inviterEmail: n,
                                            inviterName: a,
                                            inviterAvatarUrl: o
                                        }
                                    } = k;
                                    invariant(w, "Expected invite ID for `team_invitations` token"), invariant(e, "Expected team ID for `team_invitations` token");
                                    const r = {
                                        inviteId: w,
                                        teamName: t,
                                        teamId: e,
                                        inviterEmail: n,
                                        inviterName: a,
                                        inviterAvatarUrl: o,
                                        teamAvatarUrl: s
                                    };
                                    return (0, i.jsx)(c, {
                                        invitation: r,
                                        onClose: f
                                    })
                                }
                                return s || (s = (0, i.jsx)(l, {
                                    joinCode: v,
                                    onClose: f
                                }))
                            },
                            renderError: () => {
                                var e;
                                const t = null == (e = k.error) ? void 0 : e.code,
                                    s = t === n.Misc.BuiltInErrorCodes.NotFound || t === n.Misc.BuiltInErrorCodes.TokenExpired;
                                return (0, i.jsxs)(i.Fragment, {
                                    children: [(0, i.jsx)(a.u_.Error, {
                                        children: y.translate(k.error)
                                    }), (0, i.jsx)(a.u_.Buttons, {
                                        children: s ? (0, i.jsx)(o.default, {
                                            label: g.f.fy,
                                            onPress: async e => {
                                                await (null == h ? void 0 : h()), f(e)
                                            }
                                        }) : (0, i.jsxs)(i.Fragment, {
                                            children: [(0, i.jsx)(o.default, {
                                                label: g.f.fh,
                                                onPress: f
                                            }), (0, i.jsx)(o.default, {
                                                label: g.f.f4,
                                                onPress: x
                                            })]
                                        })
                                    })]
                                })
                            }
                        })
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = s(23).identityElement
    }, , (e, t, s) => {
        e.exports = s.p + "static/img/hands-day.gStGYn.jpg"
    }, (e, t, s) => {
        e.exports = s.p + "static/img/hands-night.LLx2hN.jpg"
    }, , , (e, t, s) => {
        e.exports = s.p + "static/img/logo.AFhU9Q.png"
    }, , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            V: () => i,
            X: () => r
        });
        var n = s(0),
            a = s(12),
            o = s(1);
        const r = ({
                intl: e,
                onPress: t
            }) => (0, o.jsx)(a.default, {
                iconName: "/",
                label: e.f.jk,
                variant: "opaque",
                color: n.Styling.theme.isLight() ? "black" : "white",
                iconPadding: 4,
                onPress: t,
                marginTop: "medium"
            }),
            i = ({
                intl: e,
                onPress: t
            }) => (0, o.jsx)(a.default, {
                iconName: "¹",
                label: e.f.jo,
                variant: "opaque",
                color: "blue",
                marginTop: "medium",
                onPress: t
            })
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            MI: () => r,
            Mh: () => i,
            oQ: () => c
        });
        var n = s(0),
            a = s(37),
            o = s(30);

        function r({
            token: e,
            onStart: t,
            onError: s,
            onConflict: a,
            onSuccess: r
        }) {
            const i = n.Hooks.useServices(),
                c = e && ((0, o.PA)(e) || "account_upgrade" === e.type) ? e.id : null,
                l = "team_code" === (null == e ? void 0 : e.type);
            return {
                signInWithApple: async () => {
                    t && t("apple");
                    try {
                        const e = await i.account.requestSignInWithApple({
                            invitationId: c,
                            isInviteCode: l
                        });
                        if (null != e && e.conflict) return void a("apple");
                        r("apple", e)
                    } catch (e) {
                        s && s("apple")
                    }
                },
                signInWithGoogle: async () => {
                    t && t("google");
                    try {
                        const e = await i.account.requestGoogleSignIn({
                            invitationId: c,
                            isInviteCode: l
                        });
                        if (null != e && e.conflict) return void a("google");
                        r("google", e)
                    } catch (e) {
                        s && s("google")
                    }
                }
            }
        }

        function i({
            token: e,
            onStart: t,
            onError: s,
            onAppleSignIn: a,
            onGoogleSignIn: o,
            onSuccess: r
        }) {
            const i = n.Hooks.useServices();
            n.Hooks.useAsyncEffect((async () => {
                if ("login_providers" !== (null == e ? void 0 : e.type) || "valid" !== e.status) return;
                let n;
                t();
                try {
                    n = await i.account.retrieveLoginProvider(e.id)
                } catch (e) {
                    return void s()
                }
                switch (n) {
                    case "google":
                        o();
                        break;
                    case "apple":
                        a();
                        break;
                    default:
                        throw new Error('Unhandled provider "' + n + '"')
                }
                r()
            }), [null == e ? void 0 : e.id, null == e ? void 0 : e.type])
        }

        function c({
            token: e,
            isSyncing: t,
            onStart: s,
            onError: r,
            onSuccess: i
        }) {
            const c = n.Hooks.useServices(),
                l = n.React.useCallback((e => c.account.signInAsGuest(e)), [c]),
                {
                    submit: d
                } = (0, o.f0)({
                    signIn: l,
                    isSyncing: t,
                    notificationState: null,
                    onSuccessfulLogin: async () => {
                        invariant("valid" === (null == e ? void 0 : e.status), "Missing valid token after login"), await c.localStorage.set(a.d.taskInvitationId, e.id), c.appState.startAcceptingTaskInvitation(e.id)
                    }
                });
            return n.Hooks.useAsyncEffect((async () => {
                if ("task_invitations" !== (null == e ? void 0 : e.type) || "valid" !== e.status) return;
                const t = e.payload;
                if ("accepted" === t.status && t.acceptedByGuest) try {
                    s();
                    if (!await d(t)) throw new Error("Unsuccessful guest user login")
                } catch (e) {
                    r()
                }
            }), [e]), {
                acceptInvitationAsGuest: async () => {
                    if ("task_invitations" === (null == e ? void 0 : e.type)) {
                        s();
                        try {
                            if (e) {
                                const {
                                    locale: t
                                } = c.app.localization.currentSettings, {
                                    taskId: s,
                                    authorization: n
                                } = await c.api.share.acceptTaskInvitation({
                                    token: e.id,
                                    locale: t
                                });
                                invariant(n, "Accepted task as guest but got no API key in return"), d({
                                    status: "accepted",
                                    acceptedByGuest: !0,
                                    taskId: s,
                                    authorization: n
                                })
                            }
                            i()
                        } catch (e) {
                            r()
                        }
                    }
                }
            }
        }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            i: () => o
        });
        s(0), s(2), s(3);
        const n = s(649);
        var a = s(1);
        const o = e => (0, a.jsx)("div", {
            className: n.wrapper,
            children: e.children
        })
    }, , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => f
        });
        var n = s(0),
            a = s(80),
            o = s(626),
            r = (s(45), s(20)),
            i = s(12),
            c = s(6),
            l = s(25),
            d = s(14),
            u = s(30);
        s(2), s(3);
        const m = s(652);
        var h = s(1);
        const p = "code",
            g = n.ReactUtils.createQueryParamParser(p),
            f = n.Hocs.compose()((({
                thirdPartyName: e
            }) => {
                const {
                    history: t
                } = n.Hooks.useServices(), {
                    thirdPartyName: s = e
                } = n.Hooks.useParams(), f = (e => {
                    const t = g(e);
                    return invariant(t, "Missing intergation code"), t
                })(t.currentPath.getValue()), b = n.Hooks.useIntl(), y = n.Hooks.useServices(), [v, w] = n.React.useState(!1), [k, x] = n.React.useState(null), [j, T] = n.React.useState(""), S = n.Hooks.useModalState(), [P, _] = n.React.useState(!1);
                invariant(s, "Missing third party integration name"), n.React.useEffect((() => {
                    if (!n.Misc.isElectron) {
                        const e = (0, a.generatePath)(d.routeToThirdParty, {
                                thirdPartyName: s
                            }),
                            t = encodeURIComponent(f);
                        n.ReactUtils.openUrl("nozbe4://goto" + e + "?" + p + "=" + t, "_self")
                    }
                }), []);
                const C = n.Hooks.useIsMounted(),
                    R = async (e, t, n) => {
                        await y.account.pickTeamForThirdParty({
                            teamId: e.team_id,
                            authenticationToken: t,
                            patchToken: n,
                            thirdPartyName: s
                        }), C.current && _(!0)
                    }, A = async () => {
                        const e = await y.history._getLastRoute() || "/";
                        y.history._history.push(e)
                    }, I = async (e, t) => {
                        invariant(k && k.authenticationToken && k.patchToken, "missing result when trying to hook up team");
                        const {
                            authenticationToken: s,
                            patchToken: n
                        } = k;
                        R(t, s, n)
                    };
                return (0, h.jsxs)(u.xD, {
                    children: [(0, h.jsx)("div", {
                        className: m.root,
                        children: (0, h.jsxs)(o.Z, {
                            keyboardVerticalOffset: 20,
                            children: [(0, h.jsx)("span", {
                                className: m.message,
                                children: b.g("J9", {
                                    thirdPartyName: s
                                })
                            }), (0, h.jsx)(u.U0, {
                                canSubmit: !v,
                                onFocus: () => {},
                                resetBusyState: () => w(!1),
                                buttonLabel: v ? b.f.e$ : b.f.J6,
                                onSubmit: async ({
                                    email: e,
                                    password: t,
                                    otp: a
                                }) => {
                                    try {
                                        w(!0);
                                        const o = await y.account.authThirdParty({
                                                email: n.FP.trim(e),
                                                password: n.FP.trim(t),
                                                serverUrl: j,
                                                integrationToken: f,
                                                thirdPartyName: s || "",
                                                otp: a
                                            }),
                                            {
                                                teams: r,
                                                patchToken: i,
                                                authenticationToken: c,
                                                needsOTP: l
                                            } = o;
                                        return r && i && c && C.current && x(o), l || (r && 1 === r.length ? (invariant(o && c && i, "missing result when trying to hook up team"), R(r[0], c, i)) : (S.open(), n.ReactUtils.dismissKeyboard())), {
                                            needsOTP: l
                                        }
                                    } catch (e) {
                                        return C.current && w(!1), null
                                    }
                                }
                            }), (0, h.jsx)(i.default, {
                                onPress: A,
                                label: b.f.fd,
                                marginTop: "big"
                            }), null]
                        })
                    }), S.isOpen ? (0, h.jsx)(c.u_, {
                        onClose: S.close,
                        children: (0, h.jsxs)(c.u_.Content, {
                            children: [(0, h.jsx)(c.u_.Header, {
                                children: b.f.J$
                            }), k && k.teams ? k.teams.map((e => (0, h.jsx)(r.Z, {
                                label: e.team_name,
                                onPress: I,
                                onPressExtraParam: e
                            }, e.team_id))) : null]
                        })
                    }) : null, P ? (0, h.jsx)(l.default, {
                        onClose: A,
                        onConfirmPress: A,
                        type: "accept",
                        children: b.f.J_
                    }) : null]
                })
            }))
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => b
        });
        var n = s(0),
            a = s(43),
            o = s(45),
            r = s(93),
            i = s(12),
            c = s(1460),
            l = s(1546),
            d = s(30),
            u = s(176);
        s(2), s(3);
        const m = s(659);
        var h = s(1);
        const p = n.Hocs.compose()((e => {
                const {
                    label: t,
                    onPress: s,
                    isTeam: a
                } = e, o = n.Styling.factoryAvatarSize("entry"), r = a ? 28 : 1e3;
                return (0, h.jsx)(u.ej, {
                    style: {
                        height: o,
                        maxHeight: o,
                        width: o,
                        borderRadius: r
                    },
                    onPress: s,
                    children: (0, h.jsx)("span", {
                        className: m.buttonText,
                        children: t
                    })
                })
            })),
            g = s(660),
            f = s(42).wx,
            b = n.Hocs.compose()((e => {
                const {
                    goToNext: t,
                    goBack: s,
                    name: u,
                    setName: m,
                    avatarModalProps: b,
                    label: y,
                    description: v,
                    placeholder: w,
                    autoCompleteType: k,
                    isTeam: x,
                    avatarButtonLabel: j,
                    children: T
                } = e, {
                    avatar: S,
                    pickAvatarFile: P,
                    pickedAvatarPreview: _,
                    clearAvatarPreview: C
                } = b, R = n.Hooks.useIntl(), A = n.Hooks.useValidation({
                    name: [u, [a.C1]]
                }), I = A.isValid ? t : void 0, N = n.React.useRef(), E = n.Hooks.useModalState(), O = n.Hooks.useIsMounted();
                n.React.useEffect((() => {
                    N.current && setTimeout((() => {
                        var e;
                        O.current && (null == (e = N.current) || e.focus())
                    }), 10)
                }), [S.result, O]);
                const M = S.isLoading;
                return n.React.useEffect((() => {
                    M || E.isOpen || N.current && N.current.focus()
                }), [M, E.isOpen]), (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsxs)("div", {
                        className: g.avatarContainer,
                        children: [(0, h.jsx)("div", {
                            className: g.container,
                            children: _ ? (0, h.jsxs)(h.Fragment, {
                                children: [(0, h.jsx)(r.default, {
                                    name: u || "🙂",
                                    color: "avatarColor1",
                                    source: _,
                                    size: "entry",
                                    isTeam: x
                                }), (0, h.jsx)(i.default, {
                                    className: g.button,
                                    label: R.f.fL,
                                    onPress: C,
                                    marginTop: "big"
                                })]
                            }) : (0, h.jsx)(p, {
                                label: j || R.f.fU,
                                onPress: () => {
                                    P()
                                },
                                isTeam: x
                            })
                        }), S.error ? (0, h.jsx)("span", {
                            className: g.errorMessage,
                            children: (0, l.zu)(S.error, R)
                        }) : null]
                    }), (0, h.jsx)(d.bu, {
                        label: y,
                        description: v
                    }), (0, h.jsx)(o.default, {
                        placeholder: w,
                        inputRef: N,
                        autoFocus: !0,
                        autoComplete: k,
                        onChange: m,
                        value: u,
                        returnKeyType: "next",
                        errors: A.name.errors,
                        onSubmit: I,
                        blurOnSubmit: !0,
                        forEntryViews: !0
                    }), E.isOpen ? null : (0, h.jsxs)(c.Z, {
                        paddingToKeyboard: 12,
                        children: [(0, h.jsx)(i.default, {
                            onPress: t,
                            isDisabled: !A.isValid,
                            marginTop: "huge",
                            variant: "opaque",
                            color: "purple",
                            label: R.f.fD
                        }), T]
                    }), (0, h.jsx)(i.default, {
                        onPress: s,
                        marginTop: "big",
                        label: R.f.fd
                    }), E.isOpen ? (0, h.jsx)(f.FileType, {
                        bundle$close: E.close,
                        onClose: E.close,
                        onSelect: P
                    }) : null]
                })
            }))
    }, , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            o: () => n
        });
        s(0);
        const n = (e, t) => "offline" === e ? t.f.i_ : "invalid" === e ? t.f.kb : ""
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => b
        });
        var n = s(0),
            a = s(18),
            o = s(67),
            r = s(56),
            i = s(106),
            c = s(169),
            l = s(22),
            d = s(11),
            u = s(121);
        s(2), s(3);
        const m = s(675);
        var h, p = s(1);
        const g = s(158).wx,
            f = n.ReactUtils.lazy((() => s(1337))),
            b = n.Hocs.compose(n.Hocs.withObservables(["author"], (({
                author: e
            }) => ({
                author: e || n.Rx.of(null)
            }))))((e => {
                var t, s;
                const {
                    author: b,
                    children: y,
                    onMenuPress: v,
                    onTriggerEdit: w,
                    isEditingDisabled: k,
                    menuTarget: x,
                    isAvatarPressDisabled: j,
                    isMenuOpen: T,
                    importedCommentMetadata: S,
                    isInitiallyRendered: P,
                    isRenderedInSearch: _,
                    comment: C,
                    shouldShowUserCard: R = !(null != C && C.isTeam),
                    hasDraft: A,
                    avatarStyle: I
                } = e, {
                    currentMember: N
                } = n.Hooks.useIdentity(), E = n.Hooks.useIntl(), O = n.Hooks.useModalState(), M = !R || !b || null != C && C.isTeam ? void 0 : O.open, {
                    isInViewport: D,
                    targetRef: H
                } = n.Hooks.useShownInViewport({}, P), F = S ? new Date(S.createdAt) : e.createdAt, Z = (t => {
                    if (!D) return null;
                    const s = null == S ? void 0 : S.editedAt,
                        n = null != (t = e.editedAt) ? t : s ? new Date(s) : null;
                    return n ? E.formatDate(n, {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                        hour: "numeric",
                        minute: "numeric"
                    }) : null
                })(), L = S ? (0, p.jsx)(a.default, {
                    className: m.name,
                    children: E.g("g5", {
                        name: S.authorName
                    })
                }) : (0, p.jsxs)(p.Fragment, {
                    children: [(0, p.jsx)(d.Z, {
                        className: m.touchable + (M ? " " + m.withPointer : ""),
                        onPress: M,
                        webComponent: "div",
                        isDisabled: j,
                        androidNoRipple: !0,
                        ref: O.target,
                        children: null != C && C.isTeam && b ? (0, p.jsx)(u.Z, {
                            observables: {
                                authoringTeam: b.team.observe()
                            },
                            resetOn: [b],
                            children: ({
                                authoringTeam: e
                            }) => (0, p.jsxs)(p.Fragment, {
                                children: [(0, p.jsx)(i.default, {
                                    team: e
                                }), (0, p.jsx)(a.default, {
                                    className: m.name,
                                    children: e.name
                                })]
                            })
                        }) : (0, p.jsxs)(p.Fragment, {
                            children: [t || (t = (0, p.jsx)(r.default, {
                                member: b,
                                avatarStyle: I
                            })), (0, p.jsx)(o.default, {
                                className: m.name,
                                member: b,
                                shouldRenderYou: !!b && b.id === N.id
                            })]
                        })
                    }), _ && C ? s || (s = (0, p.jsx)(f, {
                        comment: C
                    })) : null]
                });
                return (0, p.jsxs)("div", {
                    className: m.root + (_ ? " " + m.rootInSearch : ""),
                    ref: H,
                    children: [(0, p.jsx)("div", {
                        className: m.body,
                        children: y
                    }), D ? (0, p.jsxs)("div", {
                        className: m.header + (k ? "" : " " + m.enableEditing) + (T ? " " + m.menuIsVisible : "") + (_ ? " " + m.headerInSearch : ""),
                        children: [(0, p.jsx)("div", {
                            className: m.authorInfo,
                            children: L
                        }), F ? (0, p.jsx)(p.Fragment, {
                            children: A ? (0, p.jsx)(d.Z, {
                                onPress: e => {
                                    C && (null == w || w(e, C))
                                },
                                children: (0, p.jsx)(a.default, {
                                    className: m.upperRightText + " " + m.draftMessage,
                                    children: E.f.g6
                                })
                            }) : (0, p.jsxs)(a.default, {
                                className: m.upperRightText,
                                children: [(0, p.jsx)(c.Z, {
                                    date: F
                                }), Z ? (0, p.jsxs)("span", {
                                    title: Z,
                                    children: [h || (h = (0, p.jsx)("span", {
                                        children: " • "
                                    })), E.f.g4]
                                }) : null]
                            })
                        }) : null, k ? null : (0, p.jsx)("div", {
                            className: m.iconContainer,
                            children: (0, p.jsx)(l.default, {
                                name: "Ʀ",
                                size: 24,
                                hitSlop: {
                                    left: 12,
                                    top: 12,
                                    right: 12,
                                    bottom: 12
                                },
                                onPress: v,
                                color: "textPrimary",
                                accessibilityLabel: E.f.mu
                            })
                        }), R && O.isOpen && b ? (0, p.jsx)(g.UserCard, {
                            bundle$close: O.close,
                            closeMenu: O.close,
                            member: b,
                            target: O.target
                        }) : null, x ? (0, p.jsx)("div", {
                            className: m.menuTarget,
                            ref: x
                        }) : null]
                    }) : null]
                })
            }))
    }, , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => y
        });
        var n = s(0),
            a = s(35),
            o = s(673),
            r = s(255),
            i = s(11),
            c = s(13);
        s(2), s(3);
        const l = s(679);
        var d = s(1);
        const u = n.ReactUtils.lazy((() => s(1338))),
            m = n.ReactUtils.lazy((() => s(1342))),
            h = n.Hocs.compose(n.Hocs.withObservables(["comment"], (({
                comment: e
            }) => ({
                task: e.task
            }))))((e => {
                const {
                    comment: t,
                    openMenu: s,
                    isUnread: o,
                    parserContext: h,
                    isHighlighted: p,
                    isInitiallyRendered: g,
                    isRenderedInSearch: f,
                    onPress: b,
                    scrollRef: y,
                    task: v
                } = e, {
                    isPinned: w
                } = t, k = n.Hooks.useIntl(), {
                    currentTeam: x
                } = n.Hooks.useIdentity(), {
                    isInViewport: j,
                    targetRef: T
                } = n.Hooks.useShownInViewport({}, g), {
                    isThread: S
                } = v, P = (0, a.kx)(t.reactions) && !x.isExpired || S;
                n.Hooks.useDebugRenderCount();
                return (0, d.jsxs)(i.Z, {
                    className: l.root + (f ? " " + l.rootInSearch : "") + (w ? " " + l.rootPinned : "") + (p ? " " + l.rootHighlighted : ""),
                    style: w && !n.Styling.theme.isLight() ? {
                        backgroundColor: n.Styling.rgba(n.Styling.vars.color.pinnedBackground, .06)
                    } : void 0,
                    ref: T,
                    onPress: b,
                    onContextMenu: void 0,
                    onPressExtraParam: t,
                    onLongPress: s,
                    activeOpacity: 1,
                    webComponent: "div",
                    testId: p ? n.Misc.testIds.task_comments_highlighted : void 0,
                    children: [p ? (0, d.jsx)("div", {
                        className: l.scrollIntoViewOffsetter,
                        ref: y
                    }) : null, w ? (0, d.jsxs)("div", {
                        className: l.pinnedContainer,
                        children: [(0, d.jsx)(c.default, {
                            name: "Ũ",
                            size: 16,
                            color: "pinned"
                        }), (0, d.jsx)("span", {
                            className: l.pinnedText,
                            children: n.FP.toUpper(k.f.g0)
                        })]
                    }) : null, t.isDeleted ? (0, d.jsx)("span", {
                        className: l.placeholder,
                        children: k.f.gZ
                    }) : (0, d.jsxs)(d.Fragment, {
                        children: [(0, r.Z)(t, h), f ? null : (0, d.jsxs)(d.Fragment, {
                            children: [(0, d.jsx)(u, {
                                comment: t
                            }), P ? (0, d.jsx)("div", {
                                className: l.reactionsWrapper,
                                children: j ? (0, d.jsx)(m, {
                                    comment: t,
                                    onLongPress: s
                                }) : null
                            }) : null]
                        })]
                    }), null, o ? (0, d.jsx)("div", {
                        className: l.dot
                    }) : null]
                })
            })),
            p = n.ReactUtils.identityElement,
            g = s(690),
            f = n.ReactUtils.lazy((() => s(1343))),
            b = n.Hocs.compose(n.Hocs.memo, n.Hocs.withErrorBoundary({
                name: "Comment",
                render: "short"
            }), n.Hocs.withObservables(["comment"], (({
                comment: e
            }) => ({
                draft: e.draft,
                isThread: e.task.observe().pipe(n.Rx.map((e => e.isThread)))
            }))))((e => {
                const {
                    comment: t,
                    isBeingEdited: s,
                    isUnread: r,
                    markAsUnread: i,
                    parserContext: c,
                    onTriggerEdit: l,
                    onTriggerReply: u,
                    isInitiallyRendered: m,
                    draft: b,
                    isRenderedInSearch: y,
                    isHighlighted: v,
                    onBodyPress: w,
                    isThread: k,
                    __forwardedRef: x
                } = e, j = n.Hooks.useIntl();
                n.Hooks.useModel(t);
                const T = n.Hooks.useModalState(),
                    S = e.isEditingDisabled || t.isDeleted && !t.isRestorable;
                return (0, d.jsx)(p, {
                    children: (0, d.jsxs)(o.Z, {
                        avatarStyle: k ? "message" : "round",
                        author: t.author,
                        createdAt: t.createdAt,
                        editedAt: t.editedAt,
                        hasDraft: !!b,
                        importedCommentMetadata: (0, a._i)(t.body),
                        onMenuPress: T.open,
                        onTriggerEdit: l,
                        isRenderedInSearch: y,
                        comment: t,
                        isEditingDisabled: S,
                        menuTarget: T.target,
                        isMenuOpen: T.isOpen,
                        isInitiallyRendered: m,
                        children: [(0, d.jsx)(h, {
                            scrollRef: x,
                            comment: t,
                            openMenu: T.open,
                            onPress: w,
                            isRenderedInSearch: y,
                            isUnread: r,
                            isHighlighted: v,
                            parserContext: c,
                            isInitiallyRendered: m
                        }), s ? (0, d.jsx)("div", {
                            className: g.editOverlay,
                            children: (0, d.jsx)("span", {
                                className: g.editOverlayText,
                                children: j.f.g2
                            })
                        }) : null, !S && T.isOpen ? (0, d.jsx)(f, {
                            comment: t,
                            closeMenu: T.close,
                            onPressEdit: l,
                            onPressReply: u,
                            target: T.target,
                            isRenderedInSearch: y,
                            markAsUnread: i
                        }) : null]
                    })
                })
            })),
            y = n.React.forwardRef(((e, t) => (0, d.jsx)(b, Object.assign({}, e, {
                __forwardedRef: t
            }))))
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(1552),
            o = s(204);
        var r = s(1);
        const i = n.ReactUtils.lazy((() => s(25))),
            c = n.ReactUtils.lazy((() => s(1339))),
            l = n.ReactUtils.lazy((() => s(1341))),
            d = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["latestVersion"], (({
                latestVersion: e
            }) => ({
                latestVersion: e
            }))), n.Hocs.withObservables(["latestVersion"], (({
                latestVersion: e
            }) => ({
                hasRemoteThumbnail: n.Rx.of(Boolean(null == e ? void 0 : e.hasRemoteThumbnail))
            }))), n.Hocs.withWebLazyRender((({
                hasRemoteThumbnail: e
            }) => ({
                forceShowAfterDelayMs: 2500,
                spacerHeight: e ? 252 : 52
            }))))((e => {
                var t, s;
                const {
                    latestVersion: d,
                    comment: u,
                    hasRemoteThumbnail: m,
                    removeButton: h
                } = e, p = n.Hooks.useIntl(), [g, f] = n.Hooks.useStateMachine("idle"), {
                    downloadRequest: b,
                    downloadFile: y,
                    downloadProgress: v
                } = function() {
                    const e = n.Hooks.useServices(),
                        [t, s] = n.React.useState(0),
                        a = n.Hooks.useAsyncState();
                    return {
                        downloadRequest: a,
                        downloadFile: n.Hooks.useAsyncFetcherWithParams(a, (async ({
                            params: t,
                            isPending: n
                        }) => {
                            const {
                                attachment: a
                            } = t;
                            let r;
                            invariant((0, o.Hn)(a), "Expected a downloadable attachment");
                            const i = e => {
                                n() && s(e)
                            };
                            i(0);
                            try {
                                const [s, n] = await (0, o.Ve)(t.attachment, e);
                                r = n.subscribe(i), await s
                            } finally {
                                var c;
                                null == (c = r) || c.unsubscribe()
                            }
                        })),
                        downloadProgress: t
                    }
                }(), w = b.isBusy ? {
                    state: "downloading",
                    progress: v
                } : void 0;
                if (!d) return null;
                const k = f("idle"),
                    x = (0, o.yL)(d, p),
                    j = async () => {
                        await y({
                            params: {
                                attachment: d
                            },
                            onError: () => f("downloadError")()
                        })
                    };
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(a.Z, {
                        attachmentVersion: d,
                        onPress: async () => {
                            if ("idle" !== g.current || b.isBusy);
                            else if ((0, o.Rw)(d)) f("preview")();
                            else if (1 === x.length) {
                                const [e] = x;
                                e.trigger()
                            } else(0, o.Hn)(d) ? await j() : n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_ID, "Failed to handle attachment " + d.id)
                        },
                        showThumbnail: m,
                        downloadStatus: w,
                        removeButton: h
                    }), g.map({
                        preview: () => t || (t = (0, r.jsx)(c, {
                            attachmentVersion: d,
                            comment: u,
                            openers: x,
                            onClose: k
                        })),
                        menu: () => s || (s = (0, r.jsx)(l, {
                            attachment: d,
                            openers: x,
                            onDownload: j,
                            onClose: k
                        })),
                        downloadError: () => (0, r.jsx)(i, {
                            type: "confirm",
                            confirmButtonMessage: p.f.fF,
                            onConfirmPress: k,
                            onClose: k,
                            children: p.f.eK
                        })
                    })]
                })
            }))
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => T
        });
        var n = s(0),
            a = s(35),
            o = s(71),
            r = s(13),
            i = s(11);
        s(2), s(3);
        const c = s(684),
            l = n.ReactUtils.identityElement;
        var d = s(1);
        const u = e => {
                const {
                    onPress: t
                } = e;
                return (0, d.jsx)(l, {
                    children: (0, d.jsx)(i.Z, {
                        className: c.root,
                        onPress: t,
                        androidBorderless: !0,
                        children: (0, d.jsx)(r.default, {
                            name: "ū",
                            color: "textSecondary",
                            size: 18
                        })
                    })
                })
            },
            m = s(685),
            h = e => {
                const {
                    children: t,
                    hasAbsoluteFill: s
                } = e;
                return (0, d.jsx)("div", {
                    className: m.root + (s ? " " + m.absoluteFill : ""),
                    children: t
                })
            };
        var p = s(40);
        s(36);
        const g = (e, t) => {
                switch (e) {
                    case "up":
                        return [{
                            iconName: "Ŝ",
                            size: t,
                            color: "dodgerblue"
                        }];
                    case "down":
                        return [{
                            iconName: "Ŕ",
                            size: t,
                            color: "dustpink"
                        }];
                    case "heart":
                        return [{
                            iconName: "Á",
                            size: t,
                            color: "red"
                        }];
                    case "laugh":
                        return [{
                            iconName: "Ÿ",
                            size: t,
                            color: "lightningYellow"
                        }, {
                            iconName: "Ļ",
                            size: t,
                            color: "darkRed"
                        }, {
                            iconName: "ļ",
                            size: t,
                            color: "white"
                        }];
                    case "sad":
                        return [{
                            iconName: "Ÿ",
                            size: t,
                            color: "aqua"
                        }, {
                            iconName: "Ƃ",
                            size: t,
                            color: "spectra"
                        }, {
                            iconName: "ƃ",
                            size: t,
                            color: "spectra",
                            opacity: .5
                        }];
                    default:
                        return []
                }
            },
            f = {
                up: "dodgerblue",
                down: "dustpink",
                heart: "red",
                sad: "aqua",
                laugh: "lightningYellow"
            },
            b = s(686),
            y = 18,
            v = n.Hocs.compose()((e => {
                const {
                    type: t,
                    size: s = y
                } = e;
                return (0, d.jsx)("div", {
                    className: b.root,
                    style: {
                        width: s,
                        height: s
                    },
                    type: t,
                    children: (0, d.jsx)(p.default, {
                        layers: g(t, s)
                    })
                })
            })),
            w = s(687),
            k = n.Hocs.compose()((e => {
                const {
                    label: t,
                    type: s,
                    onReactionPress: a,
                    openPicker: o,
                    isLabelHighlighted: r = !1,
                    isLabelVisible: c = !0,
                    children: u,
                    isHighlighted: m = !1,
                    iconSize: h = 18
                } = e, p = f[s], g = n.Styling.factoryColor(p), b = t ? (0, d.jsx)("span", {
                    className: w.text,
                    style: {
                        color: m && r ? g : n.Styling.factoryColor("textSecondary")
                    },
                    children: t
                }) : u;
                return (0, d.jsx)(l, {
                    children: (0, d.jsxs)(i.Z, {
                        className: w.root,
                        style: m ? {
                            backgroundColor: n.Styling.rgba(g, .1),
                            borderColor: g
                        } : {
                            "--hover-border-color": g,
                            "--active-background-color": n.Styling.rgba(g, .2)
                        },
                        onPress: a,
                        onLongPress: o,
                        isDisabled: !a,
                        onPressExtraParam: s,
                        androidBorderless: !0,
                        children: [(0, d.jsx)(v, {
                            type: s,
                            size: h
                        }), c ? b : null]
                    })
                })
            })),
            x = s(688);
        var j;
        const T = n.Hocs.compose(n.Hocs.withObservables(["comment"], (({
            comment: e
        }) => ({
            comment: e
        }))))((e => {
            const {
                comment: t,
                comment: {
                    reactions: s
                },
                hasAbsoluteFill: r,
                areUnselectedHidden: i,
                pickerStyle: c,
                isLabelVisible: l = !0,
                openPicker: m,
                onReactionPress: p,
                iconSize: g
            } = e, f = n.Hooks.useIntl(), {
                currentMember: b
            } = n.Hooks.useIdentity(), [y, v] = ((e => {
                n.FP.piped(a._6, n.FP.map((t => (e[t] || []).length)), n.FP.apply(n.FP.anyFalse))
            })(s), n.FP.partition((e => {
                var s;
                return !(null == (s = t.reactions[e]) || !s.length)
            }), a._6)), w = c ? a._6 : y;
            return (0, d.jsxs)(h, {
                children: [w.map((s => {
                    const n = t.reactions[s] || [],
                        c = n.includes(b.id);
                    return n.length || !i ? (0, d.jsx)(o.default, {
                        renderLabel: (0, a.hw)({
                            comment: e.comment,
                            type: s,
                            currentMember: b,
                            intl: f
                        }),
                        children: (0, d.jsx)("div", {
                            className: x.iconContainer + (r ? " " + x.justifyCenter : ""),
                            children: (0, d.jsx)(k, {
                                type: s,
                                openPicker: m,
                                label: n.length,
                                isLabelVisible: l && !!n.length,
                                isHighlighted: c,
                                isLabelHighlighted: c,
                                onReactionPress: p,
                                iconSize: g
                            })
                        })
                    }, s) : null
                })), null, !v.length || i || c ? null : (0, d.jsxs)("div", {
                    className: x.rightSide,
                    children: [(0, d.jsx)("div", {
                        className: x.webUnusedConatiner,
                        children: v.map(((s, n) => {
                            const c = t.reactions[s] || [],
                                u = c.includes(b.id);
                            return c.length || !i ? (0, d.jsx)(o.default, {
                                renderLabel: (0, a.hw)({
                                    comment: e.comment,
                                    type: s,
                                    currentMember: b,
                                    intl: f
                                }),
                                children: (0, d.jsx)("div", {
                                    className: x.iconContainer + (r ? " " + x.justifyCenter : ""),
                                    style: {
                                        transitionDelay: .05 * (v.length - n) + "s"
                                    },
                                    children: (0, d.jsx)(k, {
                                        type: s,
                                        openPicker: m,
                                        label: c.length,
                                        isLabelVisible: l && !!c.length,
                                        isHighlighted: u,
                                        isLabelHighlighted: u,
                                        onReactionPress: p,
                                        iconSize: g
                                    })
                                })
                            }, s) : null
                        }))
                    }), (0, d.jsx)("div", {
                        className: x.iconContainer + (r ? " " + x.justifyCenter : ""),
                        children: j || (j = (0, d.jsx)(u, {}))
                    })]
                })]
            })
        }))
    }, , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(22),
            o = s(1);
        const r = {
                top: 20,
                right: 10,
                bottom: 20,
                left: 10
            },
            i = n.Hocs.compose()((e => {
                const {
                    icon: t,
                    accessibilityLabel: s,
                    color: n = "onBackground2",
                    onPress: i
                } = e;
                return (0, o.jsx)(a.default, {
                    name: t,
                    size: 20,
                    accessibilityLabel: s,
                    color: n,
                    onPress: i,
                    hitSlop: r
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            i: () => n
        });
        const n = s(0).ReactUtils.identityElement
    }, , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(704)
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            au: () => p,
            oF: () => g,
            CI: () => f
        });
        var n = s(0),
            a = s(11),
            o = s(13);
        s(2), s(3);
        const r = s(706);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                isActive: t,
                onPress: s,
                color: c,
                icon: l,
                accessibilityLabel: d,
                withAnimation: u,
                target: m,
                children: h,
                text: p,
                areColorsInverted: g
            } = e, [f, b] = n.React.useState(!1), y = t ? 1 : .1 + (f ? .2 : 0), v = n.FP.xor(t, !!g) ? "white" : c;
            return (0, i.jsx)("div", {
                className: r.rootBackgroundFix,
                children: (0, i.jsxs)(a.Z, {
                    className: r.root,
                    style: {
                        backgroundColor: n.Styling.rgba(n.Styling.factoryColor(g ? "white" : c), y)
                    },
                    onPress: s,
                    androidBorderless: !0,
                    ref: m,
                    onMouseEnter: () => b(!0),
                    onMouseLeave: () => b(!1),
                    children: [(0, i.jsx)(o.default, {
                        className: r.iconContainer + (u && t ? " " + r.iconRotation : ""),
                        name: l,
                        color: v,
                        size: 22,
                        accessibilityLabel: d
                    }), p ? (0, i.jsx)("span", {
                        className: r.iconMarkText,
                        style: {
                            color: n.Styling.factoryColor(v)
                        },
                        children: p
                    }) : null, h]
                })
            })
        }));
        var l = s(40),
            d = (s(22), s(6)),
            u = s(12);
        const m = s(707),
            h = n.Hocs.compose(n.Hocs.withIntl)((e => {
                const {
                    onClose: t,
                    target: s,
                    intl: a,
                    icon: o,
                    color: r,
                    text: c,
                    onButtonPress: h,
                    buttonLabel: p,
                    modalRef: g,
                    topIcon: f
                } = e, [{
                    closeAnimated: b
                }, y] = (0, d.P9)(g), v = [{
                    iconName: o,
                    color: r,
                    size: 54
                }, ...f ? [{
                    iconName: f,
                    color: r,
                    size: 54
                }] : []];
                return (0, i.jsx)(d.u_, {
                    ref: y,
                    onClose: t,
                    target: s,
                    size: "content",
                    isDesktopModal: !1,
                    children: (0, i.jsx)(d.u_.Content, {
                        children: (0, i.jsxs)("div", {
                            className: m.content,
                            children: [null, (0, i.jsx)("div", {
                                className: m.iconBackground,
                                style: {
                                    backgroundColor: n.Styling.rgba(n.Styling.factoryColor(r), .2)
                                },
                                children: (0, i.jsx)(l.default, {
                                    layers: v
                                })
                            }), (0, i.jsx)("span", {
                                className: m.text,
                                children: c
                            }), h && p ? (0, i.jsx)("div", {
                                className: m.buttonContainer,
                                children: (0, i.jsx)(u.default, {
                                    label: p,
                                    onPress: h,
                                    color: r
                                })
                            }) : null]
                        })
                    })
                })
            })),
            p = n.Hocs.compose()((e => {
                const {
                    reviewReason: t,
                    markAsReviewed: s
                } = e, a = n.Hooks.useIntl(), o = n.Hooks.useModalState(), r = {
                    overdue: {
                        text: a.f.Gj,
                        icon: "s",
                        topIcon: "t"
                    },
                    due_date: {
                        text: a.f.Gg,
                        icon: "R"
                    },
                    reminder: {
                        text: a.f.Gk,
                        icon: "ź"
                    },
                    delegated: {
                        text: a.f.Gf,
                        icon: "ƶ"
                    },
                    mention: {
                        text: a.f.Gh,
                        icon: "ŉ"
                    },
                    newly_added: {
                        text: a.f.Gi,
                        icon: "Ĵ"
                    }
                } [t];
                return (0, i.jsx)(c, {
                    accessibilityLabel: a.f.mW,
                    color: "incoming",
                    icon: "Ĵ",
                    onPress: o.open,
                    isActive: o.isOpen,
                    target: o.target,
                    withAnimation: !1,
                    children: o.isOpen ? (0, i.jsx)(h, {
                        onClose: o.close,
                        target: o.target,
                        color: "incoming",
                        icon: r.icon,
                        topIcon: r.topIcon,
                        text: r.text,
                        buttonLabel: a.f.I5,
                        onButtonPress: s
                    }) : null
                })
            })),
            g = n.Hocs.compose()((e => {
                const {
                    toggleShowPinnedOnly: t,
                    isShowingPinnedOnly: s,
                    numberOfPinnedComments: a,
                    color: o,
                    areColorsInverted: r
                } = e, l = n.Hooks.useIntl();
                return (0, i.jsx)(c, {
                    accessibilityLabel: l.f.mX,
                    color: null != o ? o : "pinned",
                    icon: "Ũ",
                    onPress: t,
                    isActive: s,
                    withAnimation: !0,
                    text: a.toString(),
                    areColorsInverted: r
                })
            })),
            f = n.Hocs.compose()((e => {
                const {
                    count: t
                } = e, s = n.Hooks.useIntl(), a = n.Hooks.useModalState();
                return (0, i.jsx)(c, {
                    accessibilityLabel: s.f.mY,
                    color: "red",
                    icon: "ż",
                    onPress: a.open,
                    isActive: a.isOpen,
                    target: a.target,
                    withAnimation: !0,
                    text: t.toString(),
                    children: a.isOpen ? (0, i.jsx)(h, {
                        onClose: a.close,
                        target: a.target,
                        icon: "ż",
                        color: "red",
                        text: s.g("Gx", {
                            times: t
                        })
                    }) : null
                })
            }));
        var b = s(78);
        const y = s(42).wx;
        n.Hocs.compose(n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            taskReminders: e.dates.reminders
        }))))((e => {
            const {
                task: t,
                project: a,
                showActiveReminderText: o,
                taskReminders: r
            } = e, l = n.Hooks.useIntl(), d = n.Hooks.useServices(), {
                currentTeam: u
            } = n.Hooks.useIdentity(), m = n.Hooks.useModalState(), h = t.dates.dueDate, p = r.some((e => !e.isRelative || !!h)), g = t.isGhost || a.isEnded, f = n.React.useMemo((() => n.FP.capitalize((0, b.Ne)({
                taskReminders: (0, b.Fv)(r, h),
                taskHasDueDate: !!h,
                intl: l,
                format: "short"
            }))), [r, h, l]);
            return (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(c, {
                    accessibilityLabel: l.f.lA,
                    color: "onBackground3",
                    icon: "Ŗ",
                    onPress: m.open,
                    isActive: p,
                    withAnimation: !1,
                    text: o ? f : void 0,
                    target: m.target
                }), m.isOpen && (0, i.jsx)(y.Reminders, {
                    bundle$close: m.close,
                    onConfirm: async e => {
                        if (await t.dates.do.updateReminders(e), e.added.length || e.removed.length) {
                            const {
                                markTaskAsReviewedWithSnackbar: e
                            } = s(87);
                            await e(d, l, t, u)
                        }
                        m.close()
                    },
                    target: m.target,
                    onClose: m.close,
                    removeOnly: g,
                    currentReminders: r.map((e => e.remindAt)),
                    currentDueDate: h
                })]
            })
        }))
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(25),
            o = s(1);
        const r = n.Hocs.compose(n.Hocs.withObservables(["team"], (({
            team: e
        }) => ({
            teamsCurrentMember: e.currentMember
        }))))((e => {
            const {
                onClose: t,
                team: s,
                teamsCurrentMember: r
            } = e, i = n.Hooks.useIntl(), c = n.Hooks.useServices(), l = n.FP.formatBytes(s.limits.maxAttachmentSize), d = () => {
                c.payments.proposeUpgrade(s, "attachment-limit")
            };
            return s.isFree ? (0, o.jsx)(a.default, {
                type: "confirm",
                confirmButtonMessage: r.isOwner ? i.f.f5 : i.f.fE,
                onClose: t,
                onConfirmPress: d,
                fullWidthButton: !0,
                maxWidth: 400,
                children: i.g("eN", {
                    maxSize: l
                })
            }) : (0, o.jsx)(a.default, {
                type: "confirm",
                confirmButtonMessage: i.f.fF,
                onConfirmPress: t,
                onClose: t,
                children: i.g("eO", {
                    maxSize: l
                })
            })
        }))
    }, , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        s(0);
        var n = s(742);
        s(2), s(3);
        const a = s(744);
        var o = s(1);
        const r = e => (0, o.jsx)(n.Z, {
            className: a.messageBox + (e.isDesktop ? " " + a.desktop : "") + " " + (e.className || ""),
            style: e.style,
            bodyText: e.bodyText,
            headerText: e.headerText,
            buttonIconName: e.buttonIconName,
            onButtonPress: e.onButtonPress,
            children: e.children
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            e: () => l,
            Z: () => d
        });
        var n = s(0),
            a = s(22),
            o = s(13),
            r = s(11);
        s(2), s(3);
        const i = s(743);
        var c = s(1);
        const l = e => (0, c.jsx)("span", {
                className: i.text + " " + (e.className || ""),
                style: e.style,
                children: e.children
            }),
            d = e => {
                const {
                    onPress: t,
                    headerText: s = "",
                    headerIcon: d,
                    headerIconColor: u,
                    bodyText: m = "",
                    onButtonPress: h,
                    buttonIconName: p = "b",
                    buttonIconColor: g = "onBackground3",
                    children: f
                } = e, b = n.Hooks.useIntl(), y = f || (0, c.jsx)(l, {
                    children: m
                });
                return (0, c.jsxs)("div", {
                    className: i.root + " " + (e.className || ""),
                    style: e.style,
                    children: [s ? (0, c.jsxs)("div", {
                        className: i.header,
                        children: [d ? (0, c.jsx)(o.default, {
                            className: i.headerIcon,
                            name: d,
                            color: u,
                            size: 20
                        }) : null, (0, c.jsx)("span", {
                            className: i.title,
                            children: s
                        }), h ? (0, c.jsx)(a.default, {
                            name: p,
                            color: g,
                            accessibilityLabel: b.f.mq,
                            size: 28,
                            iconSize: 22,
                            hitSlop: {
                                top: 12,
                                bottom: 12,
                                left: 12,
                                right: 12
                            },
                            onPress: h
                        }) : null]
                    }) : null, t ? (0, c.jsx)(r.Z, {
                        onPress: t,
                        webComponent: "div",
                        androidBorderless: !0,
                        children: y
                    }) : y]
                })
            }
    }, , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(601),
            o = s(221);
        var r = s(1);
        const i = e => {
            const {
                project: {
                    description: t
                }
            } = e, s = n.React.useMemo((() => (e => {
                const t = [];
                let s = (null != e ? e : "").trim(),
                    n = 0;
                for (; s;) {
                    const e = (0, o.Vz)(s);
                    if (!e) {
                        t.push({
                            type: "text",
                            content: s,
                            index: n
                        });
                        break
                    }
                    e.precedingText && (t.push({
                        type: "text",
                        content: e.precedingText,
                        index: n
                    }), n += e.precedingText.length), t.push({
                        type: "url",
                        content: e.label,
                        url: e.url,
                        index: n
                    }), n += e.label.length, s = e.restOfText
                }
                return t
            })(t)), [t]);
            return (0, r.jsx)("span", {
                className: e.className,
                style: e.style,
                children: s.map((e => "text" === e.type ? (0, r.jsx)("span", {
                    children: e.content
                }, "text-" + e.index) : (0, r.jsx)(a.Z, {
                    url: e.url,
                    children: e.content
                }, "link-" + e.index)))
            })
        }
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n = s(0),
            a = s(97),
            o = s(13),
            r = s(1);
        const i = n.ReactUtils.lazy((() => s(750))),
            c = [],
            l = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["counters"], (({
                counters: e
            }) => ({
                counters: n.Rx.wrap(e)
            }))))((e => {
                const {
                    project: t,
                    right: s,
                    toggleCollapse: l,
                    isCollapsed: d,
                    hasActivity: u,
                    needsReview: m,
                    counters: h,
                    tasks: p,
                    viewColor: g,
                    onAddTask: f
                } = e, b = n.Hooks.useIntl(), y = n.Hooks.useModalState();
                return n.Hooks.useModel(t), (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(a.Z, {
                        left: (0, r.jsx)(o.default, {
                            name: n.Styling.getProjectIcon(t),
                            color: n.Styling.defaultTextSecondary(t.color)
                        }),
                        right: s,
                        hasActivity: u,
                        needsReview: m,
                        onCollapsePress: l,
                        isCollapsed: d,
                        isEnded: t.isEnded,
                        menuTarget: y.target,
                        onMenuPress: y.open,
                        hasThreeDots: !0,
                        counters: null == h ? void 0 : h.activeTasks,
                        tasks: p || c,
                        viewColor: g,
                        children: n.Styling.getProjectName(t, b)
                    }), y.isOpen ? (0, r.jsx)(i, {
                        project: t,
                        closeMenu: y.close,
                        target: y.target,
                        onAddTaskPress: f
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n, a, o = s(0),
            r = s(14),
            i = s(82),
            c = s(32),
            l = s(170),
            d = s(20),
            u = s(1);
        const m = o.Hocs.compose(o.Hocs.memo, o.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            project: e,
            team: e.currentTeam
        }))), o.Hocs.withPersonalUI)((e => {
            const {
                target: t,
                closeMenu: s,
                project: m,
                onAddTaskPress: h,
                team: p,
                shouldRenderPersonalUI: g
            } = e, f = o.Hooks.useIntl(), [{
                closeAnimated: b
            }, y] = (0, c.XH)();
            return (0, u.jsxs)(c.ZP, {
                ref: y,
                onClose: s,
                target: t,
                minWidth: 320,
                children: [h ? (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsx)(d.Z, {
                        icon: "ū",
                        label: f.f.CX,
                        onPress: o.ReactUtils.callBoth(s, h)
                    }), n || (n = (0, u.jsx)(c.ZP.Separator, {}))]
                }) : null, (0, u.jsx)(i.Z, {
                    to: (0, r.smartPathToProject)(p, m),
                    children: (0, u.jsx)(d.Z, {
                        icon: "»",
                        label: f.f.AN,
                        onPress: b
                    })
                }), !m.isSingleTasks && m.isActive ? (0, u.jsxs)(u.Fragment, {
                    children: [a || (a = (0, u.jsx)(c.ZP.Separator, {})), g ? null : (0, u.jsx)(l.Z, {
                        variant: "follow",
                        isActive: m.isFollowed,
                        onChange: async () => {
                            m.isFollowed ? await m.unfollow() : await m.follow()
                        }
                    }), (0, u.jsx)(l.Z, {
                        variant: "favorite",
                        isActive: m.isFavorite,
                        onChange: async () => {
                            m.isFavorite ? await m.unfavorite() : await m.favorite()
                        }
                    })]
                }) : null]
            })
        }))
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            m: () => c
        });
        var n = s(0);

        function a(e, t, s, a) {
            return n.FP.sortWith([n.FP.ascend((e => {
                var t;
                const s = a[e.id];
                return null != (t = null == s ? void 0 : s.position) ? t : 0
            })), n.FP.descend((e => e.isActive || s.includes(e))), ...e, n.FP.descend((e => e.projectPosition)), n.FP.ascend((e => n.FP.toLower(e.name))), n.FP.ascend((e => e.id))])(t)
        }
        const o = (e, t, s) => a([n.FP.ascend((e => e.dates._isAllDay)), n.FP.descend((e => e.dates._dueAt))], e, t, s),
            r = (e, t, s) => a([n.FP.ascend((e => e.dates._dueAt))], e, t, s),
            i = (e, t, s) => a([n.FP.ascend(n.FP.prop("reviewTriggeredAt"))], e, t, s);

        function c(e, t, s, n) {
            const a = function(e) {
                switch (e) {
                    case "due_date":
                        return o;
                    case "overdue":
                        return r;
                    case "delegated":
                    case "mention":
                    case "reminder":
                    case "newly_added":
                        return i;
                    default:
                        return null
                }
            }(e);
            return a ? a(t, s, n) : t
        }
    }, , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(419), s.e(840)]).then(s.bind(s, 1507))))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(60),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["currentMember"], (({
            currentMember: e
        }) => ({
            preferredName: e.preferredName
        }))))((e => {
            const {
                setUseCase: t,
                preferredName: s
            } = e, c = n.Hooks.useIntl();
            return (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(a.u_.Header, {
                    helpPageUrl: n.ReactUtils.helpUrl(c, "taskmanagement/interface/#interface_intro"),
                    children: c.g("sP", {
                        userName: s
                    })
                }), (0, i.jsxs)(a.u_.Content, {
                    children: [(0, i.jsx)(a.u_.Paragraph, {
                        centered: !0,
                        children: c.f.so
                    }), (0, i.jsxs)(a.u_.Buttons, {
                        direction: "row",
                        children: [(0, i.jsxs)(r.tu, {
                            children: [(0, i.jsx)(a.u_.IconStack, {
                                stack: [{
                                    iconName: "Ă",
                                    color: "blue",
                                    size: 170
                                }, {
                                    iconName: "ă",
                                    color: "blue",
                                    opacity: .6,
                                    size: 170
                                }, {
                                    iconName: "Ą",
                                    color: "blue",
                                    opacity: .3,
                                    size: 170
                                }]
                            }), (0, i.jsx)(o.default, {
                                color: "dodgerblue",
                                variant: "opaque",
                                label: c.f.sm,
                                onPress: () => t("business")
                            })]
                        }), (0, i.jsxs)(r.tu, {
                            children: [(0, i.jsx)(a.u_.IconStack, {
                                stack: [{
                                    iconName: "Û",
                                    color: "white",
                                    size: 170
                                }, {
                                    iconName: "Ü",
                                    color: "purple",
                                    opacity: .3,
                                    size: 170
                                }, {
                                    iconName: "Ý",
                                    color: "purple",
                                    size: 170
                                }]
                            }), (0, i.jsx)(o.default, {
                                color: "purple",
                                label: c.f.sp,
                                onPress: () => t("personal")
                            })]
                        })]
                    })]
                })]
            })
        }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(176);
        s(2), s(3);
        const o = s(775);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                color: t,
                variant: s,
                isDisabled: n,
                label: i,
                onPress: c,
                onPressExtraParam: l
            } = e, d = (0, a.uu)(t, s);
            return (0, r.jsx)(a.ej, {
                className: o.touchable,
                color: t,
                variant: s,
                isDisabled: n,
                onPress: c,
                onPressExtraParam: l,
                children: (0, r.jsx)(a.oD, {
                    className: o.text,
                    label: i,
                    color: d,
                    isDisabled: e.isDisabled
                })
            })
        }))
    }, , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";

        function n() {
            return !0 === globalThis.navigator.standalone || globalThis.matchMedia("(display-mode: standalone)").matches
        }
        s.d(t, {
            Z: () => n
        })
    }, , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = s(141).qC
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = s(141).Wf
    }, e => {
        e.exports = {
            "en-US": {
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                weekdaysLong: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                weekdaysShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
            },
            pl: {
                months: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
                weekdaysLong: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
                weekdaysShort: ["Nd", "Pn", "Wt", "Śr", "Cz", "Pt", "So"]
            },
            "es-ES": {
                months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
                weekdaysLong: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"],
                weekdaysShort: ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sá"]
            },
            "de-DE": {
                months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
                weekdaysLong: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
                weekdaysShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]
            },
            ja: {
                months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
                weekdaysLong: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
                weekdaysShort: ["日", "月", "火", "水", "木", "金", "土"]
            },
            nl: {
                months: ["Januari", "Februari", "Maart", "April", "Mei", "Juni", "Juli", "Augustus", "September", "Oktober", "November", "December"],
                weekdaysLong: ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"],
                weekdaysShort: ["zo", "ma", "di", "wo", "do", "vr", "za"]
            },
            fr: {
                months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
                weekdaysLong: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
                weekdaysShort: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."]
            },
            "zh-CN": {
                months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
                weekdaysLong: ["星期天", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
                weekdaysShort: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"]
            },
            uk: {
                months: ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"],
                weekdaysLong: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П’ятниця", "Субота"],
                weekdaysShort: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"]
            }
        }
    }, , , (e, t, s) => {
        "use strict";

        function n(e) {
            const t = new Error(e);
            return t.framesToPop = 1, t.name = "Diagnostic error", t
        }
        s.d(t, {
            Z: () => n
        })
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            LV: () => r,
            _d: () => a
        });
        const n = /^(b?)(\d+)([my])$/,
            a = e => {
                const t = n.exec(e);
                if (!t) return null;
                const [, s, a, o] = t;
                return {
                    isBusiness: "b" === s,
                    maxTeamMembers: parseInt(a, 10),
                    isMonthly: "m" === o,
                    isYearly: "y" === o
                }
            },
            o = e => +(e / 100).toFixed(2),
            r = e => {
                const t = e.plan_type,
                    s = a(t);
                return invariant(s, "Invalid plan type: " + t), {
                    id: t,
                    maxTeamMembers: s.maxTeamMembers,
                    isMonthly: s.isMonthly,
                    nativeLocalizedPrice: "",
                    priceMonthly: o(e.price_monthly),
                    priceYearly: o(e.price_yearly),
                    priceDaily: o(e.price_daily),
                    priceUser: o(e.price_user),
                    webUrlOrNativeId: e.url || "",
                    trialWebUrlOrNativeId: e.trial_url || null,
                    expiresAt: new Date(e.expires_at || 0)
                }
            }
    }, , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            B: () => a,
            I: () => n
        });
        const n = e => ({
                deactivate: e.f.iD,
                deactivateError: e.f.iE,
                title: e.f.iB,
                getActivated: t => e.g("iC", {
                    email: t
                })
            }),
            a = e => ({
                deactivate: e.f.iw,
                deactivateError: e.f.ix,
                title: e.f.iu,
                getActivated: t => e.g("iv", {
                    email: t
                })
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            r: () => n
        });
        const n = e => e ? "string" == typeof e ? e : e.id : "none-tag"
    }, , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(20);
        const o = n.FP.omit(["isSelected"]),
            r = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    isSelected: t,
                    color: s = "purple"
                } = e;
                return n.React.createElement(a.Z, Object.assign({}, o(e), {
                    icon: t ? "ŷ" : "Ŷ",
                    iconColor: t ? s : "textPrimary",
                    textColor: t ? s : "textPrimary",
                    isActive: t
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d,
            R: () => u
        });
        var n = s(0),
            a = s(13),
            o = s(90),
            r = s(22),
            i = s(1);
        const c = (e, t) => (0, i.jsx)(r.default, {
            color: "onBackground3",
            name: "%",
            onPress: e,
            accessibilityLabel: t.f.mI
        });
        s(2), s(3);
        const l = s(436),
            d = e => {
                const {
                    onQueryChange: t,
                    query: s,
                    onCancelSearch: r,
                    onFocus: d,
                    onSubmit: u,
                    canCancelSearch: m = !0,
                    autoCorrect: h,
                    inputProps: p
                } = e, g = n.Hooks.useIntl(), f = n.Styling.factoryColor("onBackground3"), [b, y] = n.React.useState(!0);
                return (0, i.jsxs)("div", {
                    className: l.root,
                    children: [(0, i.jsxs)("div", {
                        className: l.inputContainer,
                        children: [(0, i.jsx)("div", {
                            className: l.icon,
                            children: (0, i.jsx)(a.default, {
                                name: "ƅ",
                                size: 16,
                                color: "onBackground3"
                            })
                        }), (0, i.jsx)(o.Z, Object.assign({
                            className: l.input,
                            placeholder: g.f.fT,
                            placeholderTextColor: f,
                            autoFocus: !0,
                            onChange: t,
                            onFocus: e => {
                                d && d(e), y(!0)
                            },
                            autoCorrect: h,
                            onBlur: () => {
                                y(!1)
                            },
                            onSubmit: u,
                            isFocused: b,
                            value: s
                        }, p))]
                    }), m ? c((async e => {
                        y(!1), r && await r(e), n.ReactUtils.dismissKeyboard()
                    }), g) : null]
                })
            },
            u = e => {
                const [t, s] = n.React.useState(e || !0), [a, o] = n.React.useState(""), r = () => s(!0), i = () => {
                    s(!1), o("")
                }, c = n.ReactUtils.unlessImeEvent((e => {
                    "Escape" !== e.key || !0 !== t ? (48 <= e.keyCode && 90 >= e.keyCode || 96 <= e.keyCode && 111 >= e.keyCode || 160 <= e.keyCode && 165 >= e.keyCode || 170 === e.keyCode || 186 <= e.keyCode && 223 >= e.keyCode || 231 <= e.keyCode && 244 >= e.keyCode) && !1 === t && r() : i()
                }));
                return {
                    isSearchOpen: t,
                    openSearch: r,
                    searchKeyEventHandler: c,
                    closeSearch: i,
                    queryText: a,
                    onQueryChange: o
                }
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(20),
            o = s(202),
            r = s(1);
        const i = n.FP.omit(["isChecked", "color"]),
            c = n.Hocs.compose(n.Hocs.memo)((e => n.React.createElement(a.Z, Object.assign({}, i(e), {
                renderRight: () => (0, r.jsxs)(r.Fragment, {
                    children: [e.renderLeftToCheckbox && e.renderLeftToCheckbox(), (0, o.j)(e, {
                        isOnRight: !0
                    })()]
                })
            }))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            __: () => m,
            ND: () => u,
            ZP: () => g
        });
        var n = s(0),
            a = s(215),
            o = s(151),
            r = s(106),
            i = s(18),
            c = s(91);
        s(2), s(3);
        const l = s(790);
        var d = s(1);
        const u = "small",
            m = e => (0, d.jsx)(i.default, {
                className: l.label,
                children: e.children
            }),
            h = (e, t) => {
                var s;
                return () => s || (s = (0, d.jsx)(r.default, {
                    team: e,
                    showDots: t,
                    size: u
                }))
            },
            p = ({
                team: e,
                highlightRanges: t
            }, s) => () => (0, d.jsx)(m, {
                children: (0, d.jsx)(c.Z, {
                    text: n.Styling.getTeamName(e, s),
                    ranges: t
                })
            }),
            g = n.Hocs.compose(n.Hocs.withObservables(["team", "showBusinessMark"], (({
                team: e,
                showBusinessMark: t
            }) => ({
                business: t ? e.business : n.Rx.of(null)
            }))), n.Hocs.withObservables(["team", "showMembersCount"], (({
                team: e,
                showMembersCount: t
            }) => ({
                teamMembersCount: t ? e.members.observeCount() : n.Rx.of(0)
            }))))((e => {
                const {
                    team: t,
                    business: s,
                    showDots: r,
                    teamMembersCount: i,
                    showMembersCount: c
                } = e, u = n.Hooks.useIntl();
                return (0, d.jsx)(o.Z, Object.assign({}, e, {
                    renderLeft: h(t, r),
                    renderLabel: p(e, u),
                    bottomDescription: c ? u.g("Jy", {
                        membersCount: i
                    }) : void 0,
                    children: s ? (0, d.jsx)("div", {
                        className: l.businessMarkContainer,
                        children: (0, d.jsx)(a.Z, {
                            business: s
                        })
                    }) : null
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(12),
            o = s(1529);
        s(2), s(3);
        const r = s(484);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                children: t,
                isSaveDisabled: s,
                onSave: c,
                onCancel: l,
                hasChanges: d
            } = e, u = n.Hooks.useIntl(), {
                pendingChanges: m,
                setPendingChanges: h,
                closeMenu: p
            } = (0, o.K)(), g = n.React.useRef(null), f = n.React.useRef(null);
            n.React.useEffect((() => {
                g.current = c, f.current = s, !!m.hasChanges != !!d && h({
                    hasChanges: !!d,
                    handler: e => {
                        f.current || g.current && g.current(e)
                    }
                })
            }));
            const b = () => {
                    c && c(p)
                },
                y = !!c || !!l;
            return (0, i.jsxs)("div", {
                className: r.root,
                children: [(0, i.jsx)("div", {
                    className: r.content + (y ? " " + r.contentWithFooter : ""),
                    children: t
                }), y ? (0, i.jsx)("div", {
                    className: r.footer,
                    children: b ? (0, i.jsx)(a.default, {
                        className: r.footerButton,
                        label: u.f.fr,
                        variant: "opaque",
                        color: "purple",
                        isDisabled: s,
                        onPress: b
                    }) : null
                }) : null]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = s(6),
            o = (s(22), s(1529)),
            r = s(865);
        s(2), s(3);
        const i = s(485);

        function c(e) {
            return !e.type || "item" === e.type
        }
        var l = s(1);
        const d = n.Hocs.compose()((e => {
            const {
                onClose: t,
                onBack: s,
                header: d,
                initialPane: u,
                maxHeight: m = 600,
                minHeight: h = m,
                level: p,
                skipMenuOnNative: g,
                helpPageUrl: f,
                _skipPaneWrapper: b,
                contentOptions: y,
                leftHeaderIcon: v,
                shouldAnimateOverlay: w = !0
            } = e, [k, x] = (n.Hooks.useIntl(), n.React.useState({
                hasChanges: !1,
                handler: n.FP.noop
            })), j = e.items.filter(Boolean), T = j.filter((e => c(e))), S = T.map((e => e.id)), P = (() => {
                if (u && S.includes(u)) return u;
                const e = T.find((e => e.pane));
                return null == e ? void 0 : e.id
            })(), [_, C] = n.Hooks.useStateMachine(P), R = C(P), A = j.map((e => {
                if (c(e)) {
                    const s = (t = e.id, () => {
                            const e = C(t);
                            k.hasChanges ? k.handler((() => {
                                x({
                                    hasChanges: !1,
                                    handler: n.FP.noop
                                }), e()
                            })) : e()
                        }),
                        a = e.id === _.current,
                        o = e.list(s, a);
                    return n.React.cloneElement(o, {
                        key: e.id
                    })
                } {
                    const {
                        label: t
                    } = e;
                    return (0, l.jsx)(a.u_.Heading, {
                        className: i.heading,
                        children: t
                    }, t)
                }
                var t
            })), [{
                closeAnimated: I
            }, N] = (0, a.P9)(), E = Object.fromEntries([null, ...T.map((e => {
                const {
                    pane: t
                } = e;
                return t ? [e.id, () => {
                    var s, n, a;
                    const o = t(R);
                    return b ? o : (0, l.jsx)(r.Z, {
                        title: d,
                        contentStatic: null != (s = e.contentStatic) ? s : null == y ? void 0 : y.contentStatic,
                        contentSize: null != (n = e.contentSize) ? n : null == y ? void 0 : y.contentSize,
                        containsScroll: null != (a = e.containsScroll) ? a : null == y ? void 0 : y.containsScroll,
                        onCancel: void 0,
                        children: o
                    })
                }] : null
            }))].filter(Boolean)), O = _.map(E);
            return (0, l.jsxs)(a.u_, {
                onClose: () => {
                    k.hasChanges ? k.handler(t) : t()
                },
                minWidth: 800,
                maxHeight: m,
                minHeight: h,
                level: p,
                shouldAnimateOverlay: w,
                children: [(0, l.jsx)(a.u_.Header, {
                    leftIcon: v,
                    helpPageUrl: f,
                    children: d
                }), (0, l.jsxs)(a.u_.Content, {
                    className: i.content,
                    isStatic: !0,
                    children: [(0, l.jsx)("div", {
                        className: i.pane + " " + i.leftPane,
                        children: A
                    }), (0, l.jsx)("div", {
                        className: i.pane + " " + i.rightPane,
                        children: (0, l.jsx)(o.n.Provider, {
                            value: {
                                pendingChanges: k,
                                setPendingChanges: x,
                                closeMenu: t
                            },
                            children: O
                        })
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n = s(52),
            a = s(0),
            o = s(20);
        s(2), s(3);
        const r = s(491);
        var i = s(1);
        const c = ["rightDescription"],
            l = a.Hocs.compose()((e => {
                const {
                    rightDescription: t
                } = e, s = (0, n.Z)(e, c), {
                    isActive: l,
                    iconColor: d
                } = s, u = l ? "priority" : void 0, m = t ? () => (0, i.jsx)("span", {
                    className: r.rightDescription,
                    style: {
                        color: a.Styling.rgba(a.Styling.factoryColor(u || "textSecondary"), .6)
                    },
                    children: t
                }) : null;
                return (0, i.jsx)(o.Z, Object.assign({
                    activeColor: u,
                    iconColor: d || u,
                    contentHeight: 34,
                    contentRadius: 12,
                    isTextBolded: !1,
                    renderRight: m,
                    hasArrow: !1
                }, s))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(91),
            o = s(20),
            r = s(1);
        const i = n.FP.omit(["project"]),
            c = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                isPrivate: e.permissions.isPrivate
            }))))((e => {
                const {
                    project: t,
                    isPrivate: s,
                    highlightRanges: c
                } = e, l = n.Hooks.useIntl();
                return n.React.createElement(o.Z, Object.assign({}, i(e), {
                    hoverText: n.Styling.getProjectName(t, l),
                    label: (0, r.jsx)(a.Z, {
                        text: n.Styling.getProjectName(t, l),
                        ranges: c
                    }),
                    icon: n.Styling.getProjectIcon(t),
                    iconColor: n.Styling.defaultTextSecondary(t.color),
                    isPrivate: s
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c,
            f: () => i
        });
        s(0);
        var n = s(18);
        s(2), s(3);
        const a = s(486);
        var o = s(1);
        const r = e => {
            const {
                children: t,
                hoverText: s
            } = e;
            return (0, o.jsx)(n.default, {
                className: a.root + " " + (e.className || ""),
                style: e.style,
                numberOfLines: 1,
                hoverText: s,
                children: t
            })
        };

        function i(e) {
            var t;
            return () => t || (t = (0, o.jsx)(r, {
                hoverText: e,
                children: e
            }))
        }
        const c = r
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            l: () => i,
            A: () => r
        });
        s(0);
        var n = s(12);
        s(2), s(3);
        const a = s(531);
        var o = s(1);
        const r = Object.freeze({
                User: "user",
                "2fa": "2fa",
                Language: "language",
                Integration: "integration",
                Calendars: "calendars",
                Evernote: "evernote",
                Dropbox: "dropbox",
                GoogleDrive: "gdrive",
                OneDrive: "onedrive",
                Appearance: "appearance",
                Biometric: "biometric",
                Notifications: "notifications",
                EmailReports: "emailReports",
                Advanced: "advanced",
                AppVersion: "appVersion"
            }),
            i = e => (0, o.jsx)(n.default, {
                className: a.button + " " + (e.className || ""),
                style: e.style,
                onPress: e.onPress,
                label: e.label,
                isFullWidth: e.isFullWidth,
                children: e.children
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            G: () => i,
            M: () => r
        });
        s(0);
        var n = s(6);
        s(2), s(3);
        const a = s(643);
        var o = s(1);
        const r = e => (0, o.jsx)("div", {
                className: a.iconContainer,
                children: e.children
            }),
            i = e => (0, o.jsx)(n.u_.Section, {
                className: a.headerSection,
                children: e.children
            })
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(0),
            a = s(11),
            o = s(22),
            r = s(329),
            i = s(18),
            c = s(13),
            l = s(138),
            d = s(130);
        s(2), s(3);
        const u = s(520);
        var m = s(1);
        const h = n.Hocs.compose()((e => {
            const {
                title: t,
                isDisabled: s,
                isCollapsed: h,
                toggleSection: p,
                targetRef: g,
                onPlusIconPress: f,
                plusIconBadge: b,
                leftIcon: y,
                leftIconColor: v,
                onThreeDotPress: w,
                isPrivate: k,
                plusTestId: x,
                plusA11yLabel: j,
                groupDragHandle: T,
                onLongPress: S,
                rootTestId: P
            } = e, _ = n.Hooks.useIntl(), C = n.Hooks.useDesktopLayout(), R = w ? e => {
                n.ReactUtils.stopPropagation(e), e.preventDefault(), w(e)
            } : void 0, A = n.React.useContext(d.l);
            return (0, m.jsxs)("div", Object.assign({
                className: u.root + (A ? " " + u.rootDark : ""),
                ref: g,
                "data-testid": P
            }, T, {
                children: [(0, m.jsxs)(a.Z, {
                    className: u.titleContainer,
                    onPress: p,
                    onLongPress: S,
                    disableLongPressHaptics: !0,
                    webComponent: "div",
                    isDisabled: s || !p,
                    children: [p ? (0, m.jsx)(r.Z, {
                        toggleSection: p,
                        isCollapsed: h,
                        size: 16,
                        iconSize: 16
                    }) : null, y ? (0, m.jsx)(c.default, {
                        name: y,
                        color: n.Styling.defaultTextSecondary(v)
                    }) : null, (0, m.jsx)(i.default, {
                        className: u.title + (C ? " " + u.desktopTitle : ""),
                        children: t
                    }), k ? (0, m.jsx)(c.default, {
                        name: "ŀ",
                        color: "onBackground3"
                    }) : null, w ? (0, m.jsx)(l.Z, {
                        onPress: R
                    }) : null]
                }), f ? (0, m.jsx)(o.default, {
                    className: u.plusIconButton,
                    accessibilityLabel: null != j ? j : _.f.fn,
                    name: "ū",
                    iconSize: 28,
                    badge: b,
                    color: "onBackground3",
                    onPress: f,
                    testId: x
                }) : null, null]
            }))
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(11);
        s(2), s(3);
        const o = s(544);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                title: t,
                isFirst: s,
                isLast: n,
                right: i,
                onPress: c,
                onPressExtraParam: l,
                isDisabled: d
            } = e;
            return (0, r.jsxs)(a.Z, {
                className: o.root + (s ? " " + o.first : "") + (n ? " " + o.last : ""),
                isDisabled: d || !c,
                onPress: c,
                onPressExtraParam: l,
                webComponent: "div",
                children: [s ? null : (0, r.jsx)("div", {
                    className: o.hairline + " " + o.topHairline
                }), (0, r.jsx)("div", {
                    className: o.title,
                    children: (0, r.jsx)("span", {
                        className: o.text,
                        children: t
                    })
                }), i ? (0, r.jsx)("div", {
                    className: o.rightContainer,
                    children: i
                }) : null, n ? null : (0, r.jsx)("div", {
                    className: o.hairline + " " + o.bottomHairline
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0);
        s(2), s(3);
        const a = s(547);
        var o = s(1);
        const r = e => {
            const {
                isActive: t,
                onChange: s,
                isDisabled: r,
                colorActive: i,
                colorInactive: c
            } = e, {
                current: l
            } = n.React.useRef("id-" + n.Misc.randomId()), d = n.Styling.theme.isLight() ? "green" : "darkgreen", u = t ? i || d : c || "onBackground1";
            return (0, o.jsxs)("div", {
                className: a.root,
                onClick: r ? n.FP.noop : e => {
                    e.stopPropagation(), e.preventDefault(), s(!t)
                },
                children: [(0, o.jsx)("input", {
                    className: a.checkbox,
                    type: "checkbox",
                    onChange: n.FP.noop,
                    disabled: r,
                    id: l,
                    checked: t
                }), (0, o.jsx)("label", {
                    className: a.switcher + (r ? " " + a.disabled : ""),
                    style: {
                        backgroundColor: n.Styling.factoryColor(u)
                    },
                    htmlFor: l
                })]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            o2: () => S,
            Hk: () => c,
            so: () => h,
            zm: () => d,
            rD: () => k
        });
        var n = s(0),
            a = s(150),
            o = s(13),
            r = s(1);
        const i = s(42).wx,
            c = n.Hocs.compose()((e => {
                const {
                    project: t,
                    onProjectChange: s,
                    hideSingleTasks: c,
                    team: l
                } = e, d = n.Hooks.useIntl(), u = n.Hooks.useModalState();
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(a.NW, {
                        label: n.Styling.getProjectName(t, d),
                        topDescription: d.f.gQ,
                        icon: n.Styling.getProjectIcon(t),
                        iconColor: t.color,
                        contentHeight: 56,
                        onPress: u.open,
                        modalWebTarget: u.target,
                        renderRight: () => (0, r.jsx)(o.default, {
                            name: "9",
                            color: "onBackground2"
                        })
                    }), u.isOpen ? (0, r.jsx)(i.Project, {
                        bundle$close: u.close,
                        onConfirm: s,
                        currentProjectId: t.id,
                        hideSingleTasks: c,
                        onClose: u.close,
                        target: u.target,
                        level: 100,
                        isSearchOpen: !0,
                        placement: "right",
                        team: l
                    }) : null]
                })
            })),
            l = s(42).wx,
            d = n.Hocs.compose()((e => {
                const {
                    section: t,
                    onSectionChange: s,
                    project: i
                } = e, c = n.Hooks.useIntl(), d = n.Hooks.useModalState();
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(a.NW, {
                        label: t ? t.name : c.f.zr,
                        topDescription: c.f.gR,
                        icon: "Ɔ",
                        modalWebTarget: d.target,
                        contentHeight: 56,
                        onPress: d.open,
                        renderRight: () => (0, r.jsx)(o.default, {
                            name: "9",
                            color: "onBackground2"
                        })
                    }), d.isOpen ? (0, r.jsx)(l.Section, {
                        bundle$close: d.close,
                        onClose: d.close,
                        level: 100,
                        placement: "right",
                        target: d.target,
                        project: i,
                        currentSectionId: null == t ? void 0 : t.id,
                        isSearchOpen: !0,
                        onConfirm: s
                    }) : null]
                })
            }));
        var u = s(123);
        const m = s(42).wx,
            h = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withIntl, n.Hocs.withObservables(["members", "currentMember"], (({
                members: e,
                currentMember: t,
                intl: s
            }) => ({
                responsibleNames: e ? (0, u.uM)(e, s, t) : n.Rx.of([])
            }))))((e => {
                const {
                    responsibleNames: t,
                    onMembersChange: s,
                    project: i,
                    members: c
                } = e, l = n.Hooks.useIntl(), {
                    currentTeam: d
                } = n.Hooks.useIdentity(), u = n.Hooks.useModalState();
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(a.NW, {
                        label: t.join(", "),
                        topDescription: l.f.IA,
                        icon: "ƶ",
                        contentHeight: 56,
                        onPress: u.open,
                        modalWebTarget: u.target,
                        renderRight: () => (0, r.jsx)(o.default, {
                            name: "9",
                            color: "onBackground2"
                        })
                    }), u.isOpen ? (0, r.jsx)(m.MembersMultiple, {
                        bundle$close: u.close,
                        team: d,
                        selectedMembers: c,
                        target: u.target,
                        placement: "right",
                        level: 100,
                        onClose: u.close,
                        onConfirm: s,
                        project: i,
                        showUnassigned: !0,
                        description: l.f.IB,
                        isSearchOpen: !0,
                        defaultToUnassigned: !0
                    }) : null]
                })
            }));
        s(21);
        var p = s(6),
            g = s(77),
            f = s(20),
            b = s(336),
            y = s(125);
        s(2), s(3);
        const v = s(714),
            w = s(42).wx,
            k = n.Hocs.compose()((e => {
                const {
                    onlyActiveTasks: t,
                    toggleOnlyActiveTasks: s,
                    onlyPinnedComments: a,
                    toggleOnlyPinnedComments: o,
                    referenceDate: i,
                    setReferenceDate: c
                } = e, l = n.Hooks.useIntl(), d = n.Hooks.useModalState();
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsxs)(p.u_.Section, {
                        className: v.switchSection + " " + (e.className || ""),
                        style: e.style,
                        children: [o ? (0, r.jsx)(g.Z, {
                            label: l.f.gN,
                            isActive: !!a,
                            onChange: o,
                            contentHeight: 40
                        }) : null, s ? (0, r.jsx)(g.Z, {
                            label: l.f.gM,
                            isActive: !!t,
                            onChange: s,
                            contentHeight: 40
                        }) : null, c && i ? (0, r.jsxs)("div", {
                            className: v.referenceDateContainer,
                            children: [(0, r.jsx)(f.Z, {
                                label: l.f.gO,
                                onPress: d.open,
                                contentHeight: 40,
                                hasHairline: !1,
                                renderRight: () => (0, r.jsx)(b.Z, {
                                    onPress: d.open,
                                    buttonRef: d.target,
                                    children: l.formatDate(i.local, {
                                        year: "numeric",
                                        month: "numeric",
                                        day: "numeric"
                                    })
                                })
                            }), (0, r.jsx)(y.Z, {
                                className: v.referenceDateHint,
                                hint: l.f.gP,
                                helpPageUrl: n.ReactUtils.helpUrl(l, "taskmanagement/project-templates/#template_due")
                            })]
                        }) : null]
                    }), d.isOpen ? (0, r.jsx)(w.Date, {
                        bundle$close: d.close,
                        target: d.target,
                        title: l.f.ys,
                        onClose: d.close,
                        onCancel: d.close,
                        currentDateTime: i,
                        onDayPress: n.FP.noop,
                        onConfirm: e => (c && c(e), {
                            shouldClose: !0
                        }),
                        level: 2,
                        boundTo: "left"
                    }) : null]
                })
            }));
        var x, j = s(12);
        const T = [{
                iconName: "Ï",
                color: "orange",
                opacity: .3,
                size: 100
            }, {
                iconName: "Ð",
                color: "orange",
                opacity: 1,
                size: 100
            }],
            S = n.Hocs.compose()((e => {
                const {
                    header: t,
                    description: s,
                    children: a,
                    onClonePress: o,
                    isCloneButtonDisabled: i,
                    helpPageUrl: c
                } = e, l = n.Hooks.useIntl();
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(p.u_.Header, {
                        helpPageUrl: c,
                        children: t
                    }), (0, r.jsxs)(p.u_.Content, {
                        children: [x || (x = (0, r.jsx)(p.u_.IconStack, {
                            stack: T
                        })), (0, r.jsx)(p.u_.Paragraph, {
                            children: s
                        }), a, (0, r.jsx)(p.u_.Buttons, {
                            children: (0, r.jsx)(j.default, {
                                label: l.f.fg,
                                color: "incoming",
                                variant: "opaque",
                                isDisabled: i,
                                onPress: o
                            })
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => S
        });
        var n = s(0),
            a = s(14),
            o = s(225),
            r = s(56),
            i = s(67),
            c = s(32),
            l = s(82),
            d = s(20),
            u = s(132),
            m = s(1557);
        s(2), s(3);
        const h = s(751);
        var p = s(899),
            g = s(157),
            f = s(35),
            b = s(349),
            y = s(83);

        function v(e) {
            const {
                value: t
            } = e, s = (0, g.useCopyButtonState)({
                label: t,
                valueToCopy: t
            }), a = {
                label: s.label,
                action: s.copy
            };
            return function(e) {
                if ("email" !== e.type) return null;
                const t = e.value.trim();
                if (!y.Ej.test(t)) return null;
                return {
                    label: t,
                    action: () => n.ReactUtils.openEmailUrl({
                        to: t
                    })
                }
            }(e) || function(e) {
                return e.type, null;
                const t = e.value.trim().replace(/[\s-]/g, "");
                if (!b.C3.test(t)) return null;
                return {
                    label: e.value,
                    action: () => {
                        n.ReactUtils.openUrl("tel:" + t)
                    }
                }
            }(e) || function(e) {
                if ("misc" !== e.type) return null;
                const t = (0, f.Gu)(e.value.trim());
                if (!n.FP.isUrl(t)) return null;
                return {
                    label: e.value,
                    action: () => {
                        n.ReactUtils.openUrl(t)
                    }
                }
            }(e) || a
        }
        var w = s(1);
        const k = n.Hocs.compose()((e => {
            const {
                contact: t
            } = e, {
                action: s,
                label: a
            } = v(t);
            return (0, w.jsx)(d.Z, {
                label: a,
                icon: n.Styling.getContactInfoIcon(t),
                onPress: s
            }, t.id)
        }));
        var x, j, T;
        const S = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            member: e
        }))), n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            user: e.user,
            groups: e.groups,
            memberTeam: e.team
        }))), n.Hocs.withObservables(["member", "intl"], (({
            member: e,
            intl: t
        }) => ({
            memberStatus: (0, o.k)(e, t)
        }))))((e => {
            const {
                member: t,
                user: s,
                memberTeam: o,
                memberStatus: g,
                intl: f,
                closeMenu: b,
                isProfileView: y,
                children: v,
                groups: S
            } = e, {
                currentTeam: P,
                currentMember: _
            } = n.Hooks.useIdentity(), C = n.Hooks.useServices(), R = (0, a.smartPathToMember)(P, t), A = t.isArchived, I = o.isShared, N = (0, m.l)(s);
            return (0, w.jsxs)("div", {
                className: h.root + (y ? " " + h.rootProfile : ""),
                children: [(0, w.jsxs)("div", {
                    className: h.memberInfo + (y ? " " + h.memberInfoInProfile : ""),
                    children: [(0, w.jsxs)("div", {
                        className: h.top + (y ? " " + h.topProfile : ""),
                        children: [(0, w.jsx)("div", {
                            className: h.avatarContainer + (y ? " " + h.avatarContainerInProfile : ""),
                            children: (0, w.jsx)(r.default, {
                                size: "large",
                                member: t
                            })
                        }), (0, w.jsxs)("div", {
                            className: y ? h.textContainer : "",
                            children: [(0, w.jsx)(i.default, {
                                className: h.name + (y ? " " + h.nameInProfile : ""),
                                member: t,
                                shouldRenderYou: s.isMe
                            }), g ? (0, w.jsx)("span", {
                                className: h.memberStatus + (t.isWaitingForActivation ? " " + h.waitingForActivation : "") + (y ? " " + h.memberStatusInProfile : "") + (t.isExpired ? " " + h.expired : ""),
                                children: g
                            }) : null]
                        })]
                    }), N || t.description ? (0, w.jsxs)(w.Fragment, {
                        children: [x || (x = (0, w.jsx)(c.ZP.Separator, {})), (0, w.jsxs)("div", {
                            className: h.descriptionSection,
                            children: [t.description ? (0, w.jsx)("span", {
                                className: h.description,
                                children: t.description
                            }) : null, N ? (0, w.jsx)(p.Z, {
                                user: s
                            }) : null]
                        })]
                    }) : null]
                }), 0 < t.contactInfo.length ? (0, w.jsxs)(w.Fragment, {
                    children: [j || (j = (0, w.jsx)(c.ZP.Separator, {})), t.contactInfo.map((e => (0, w.jsx)(k, {
                        contact: e
                    }, e.id)))]
                }) : null, A || y ? null : (0, w.jsxs)(w.Fragment, {
                    children: [T || (T = (0, w.jsx)(c.ZP.Separator, {})), (0, w.jsx)(d.Z, {
                        icon: "ơ",
                        label: f.f.En,
                        isDisabled: !S.length,
                        onPress: n.FP.noop,
                        bottomDescription: (0, u.v)(S, f)
                    }), I ? null : (0, w.jsx)(l.Z, {
                        to: R,
                        children: (0, w.jsx)(d.Z, {
                            label: f.f.Kq,
                            icon: "ƶ",
                            onPress: b || n.FP.noop,
                            textColor: "textPrimary"
                        })
                    }), t.isActive && t !== _ && !I ? (0, w.jsx)(d.Z, {
                        onPress: async () => {
                            const e = await o.do.findOrCreateThread({
                                    member: t
                                }),
                                s = {
                                    teamId: o.id,
                                    taskListName: "messages"
                                },
                                n = (0, a.getPathToTaskDetails)(s, e);
                            C.router.goTo(n, {
                                openEditor: !0
                            })
                        },
                        label: f.f.Kp,
                        icon: "Ķ",
                        textColor: "textPrimary"
                    }) : null, I || t === _ ? null : (0, w.jsx)(d.Z, {
                        onPress: () => {
                            C.router.goTo(R, {
                                shouldOpenNewTask: !0
                            })
                        },
                        label: f.f.Ko,
                        icon: "\\",
                        textColor: "textPrimary"
                    })]
                }), v]
            })
        }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            v2: () => i,
            $r: () => n.$,
            S$: () => l,
            V1: () => c
        });
        var n = s(1527),
            a = s(5),
            o = s(4),
            r = s(830);

        function i(e) {
            var t;
            const s = null != (t = null == e ? void 0 : e.toUpperCase()) ? t : null,
                n = "GOOGLE" === s,
                a = "APPLE" === s;
            return {
                provider: s,
                isProvidedBy2CO: "2CO" === s,
                isProvidedByPEP: "PEP" === s,
                isProvidedManually: "MANUAL" === s,
                isProvidedByStripe: "STRIPE" === s,
                isProvidedByP24: "P24" === s,
                isProvidedByApple: a,
                isProvidedByGoogle: n,
                isProvidedByIAP: a || n
            }
        }

        function c(e) {
            var t;
            const s = (null == e ? void 0 : e.expires_at) || 0,
                n = s < Date.now(),
                {
                    provider: c,
                    isProvidedBy2CO: l,
                    isProvidedByPEP: d,
                    isProvidedByGoogle: u,
                    isProvidedByApple: m,
                    isProvidedByIAP: h,
                    isProvidedManually: p,
                    isProvidedByStripe: g,
                    isProvidedByP24: f
                } = i(null == e ? void 0 : e.provider),
                b = o.defaultTo("free", e && e.plan_type),
                y = (0, r._d)(b),
                v = "free" === b,
                w = Boolean(e && e.is_trial),
                k = v || w,
                x = null != (t = null == y ? void 0 : y.isBusiness) && t,
                j = l || d || g || f,
                T = a.isMAS,
                S = h && !a.isMAS;
            return {
                currency: o.defaultTo("usd", e && e.currency),
                type: b,
                maxTeamMembers: (null == y ? void 0 : y.maxTeamMembers) || 0,
                lastRenewedAt: new Date(e && e.last_renewed_at || 0),
                expiresAt: new Date(s),
                version: o.defaultTo(0, e && e.version),
                isTrial: w,
                isFree: v,
                isFreeOrTrial: k,
                isRecurring: Boolean(e && e.is_recurring),
                canBeExtended: !w && (j || p),
                canBeChanged: !0,
                canUseReferralCredits: !x && (k || j),
                canUpdatePaymentInfo: !n && j,
                canBeAutomaticallyRenewed: !w && !n && j,
                canUsePaylessChange: !w && (j || p),
                hasBusinessPlans: g || f,
                shouldUseIAP: v ? T : !!h && !n,
                provider: c,
                canSwitchToOurPayments: S,
                isProvidedByIAP: h,
                isExpired: n,
                isBusiness: x,
                isMonthly: (null == y ? void 0 : y.isMonthly) || !1,
                isYearly: (null == y ? void 0 : y.isYearly) || !1
            }
        }

        function l(e) {
            if (!e) return null;
            if (!e.type || "card" === e.type) {
                if (!e.card_type || !e.card_last_digits || !e.card_expiration_date) return null;
                const [t, s] = e.card_expiration_date.split("/").map((e => parseInt(e, 10)));
                return {
                    type: "card",
                    cardType: e.card_type,
                    cardLastDigits: e.card_last_digits,
                    cardExpirationDate: new Date(s, t - 1),
                    extra: ""
                }
            }
            return e.extra ? {
                type: e.type,
                cardType: "",
                cardLastDigits: "",
                cardExpirationDate: null,
                extra: e.extra
            } : null
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(68),
            o = s(1);
        const r = (e, t) => e.reduce((({
                cells: e,
                count: s
            }, n, a) => {
                const {
                    cells: o,
                    count: r
                } = ((e, t, s, n) => {
                    const {
                        renderGroupContainer: a,
                        renderItem: o
                    } = e, r = t.root ? o({
                        record: t.root,
                        type: "HEADER",
                        id: "header_" + s
                    }, 0, {
                        indexInSection: 0,
                        isFirst: !0,
                        isLast: !0,
                        isAboveTheFold: n < (e.estimatedAboveTheFoldItems || 0),
                        list: t.items,
                        sectionRoot: t.root
                    }) : null, {
                        cells: i,
                        count: c
                    } = t.isCollapsed ? {
                        cells: [],
                        count: t.items.length
                    } : (({
                        renderItem: e,
                        renderSectionItemsContainer: t,
                        estimatedAboveTheFoldItems: s
                    }, n, a) => {
                        const o = n.items.map(((t, o) => e(t, o, {
                            indexInSection: o,
                            isFirst: 0 === o,
                            isLast: o + 1 === n.items.length,
                            isAboveTheFold: a + o < (s || 0),
                            list: n.items,
                            sectionRoot: n.root,
                            sectionHasFooter: n.hasFooter
                        })));
                        return {
                            cells: t ? [t(n, o)] : o,
                            count: o.length
                        }
                    })(e, t, n + Number(!!r)), l = t.hasFooter && !t.isCollapsed ? o({
                        record: t.root,
                        type: "FOOTER",
                        id: "footer_" + s
                    }, 1, {
                        indexInSection: 0,
                        isFirst: !1,
                        isLast: !1,
                        isAboveTheFold: !0,
                        list: t.items,
                        sectionRoot: t.root
                    }) : null, d = [r, ...i, l].filter(Boolean);
                    return {
                        cells: a ? [a(d)] : d,
                        count: c + Number(!!r) + Number(!!l)
                    }
                })(t, n, a, s);
                return e.push(...o), {
                    cells: e,
                    count: s + r
                }
            }), {
                cells: [],
                count: 0
            }).cells,
            i = e => {
                const {
                    className: t,
                    groups: s,
                    style: i,
                    scrollRef: c,
                    rootRecord: l,
                    renderListHeader: d,
                    renderListFooter: u,
                    contentContainerStyle: m,
                    rowRenderer: h,
                    CellRendererComponent: p,
                    ContentWrapperWeb: g,
                    getLayoutTypeForItem: f
                } = e, b = n.Hooks.useKeyMapper(l), y = Object.assign({}, e, {
                    renderItem: (e, t, s) => {
                        const n = f(e),
                            a = h({
                                type: n,
                                item: e,
                                index: t,
                                position: s
                            });
                        return p ? (0, o.jsx)(p, {
                            children: a
                        }, b((null == e ? void 0 : e.id) || t)) : a
                    }
                }), v = g || n.React.Fragment, w = r(s, y);
                return (0, o.jsx)(a.Z, {
                    className: t,
                    contentContainerStyle: m,
                    style: i,
                    scrollRef: c,
                    children: (0, o.jsxs)(v, {
                        children: [d && l ? d(l) : null, w, u && l ? u(l) : null]
                    })
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0);
        s(2), s(3);
        const a = s(545);
        var o = s(1);
        const r = n.Hocs.compose()((e => (0, o.jsx)("div", {
            className: a.root + " " + (e.className || ""),
            style: e.style
        })))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(13);
        s(2), s(3);
        const o = s(642);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                left: t,
                right: s
            } = e;
            return (0, r.jsxs)("div", {
                className: o.root,
                children: [t, (0, r.jsx)(a.default, {
                    name: "8",
                    size: 45,
                    color: "onBackground2"
                }), s]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => f
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(57),
            i = s(14),
            c = s(645),
            l = s(209),
            d = s(30);
        s(2), s(3);
        const u = s(646),
            m = ({
                children: e
            }) => e;
        var h, p, g = s(1);
        const f = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withErrorBoundary({
            name: "LogIn",
            render: "screen"
        }), n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            isSyncing: e.sync.isSyncing,
            notificationState: n.Rx.from(e.notifications.areNotificationsEnabled())
        }))))((e => {
            var t, s;
            const {
                services: f,
                isSyncing: b,
                notificationState: y,
                message: v,
                preFilledEmail: w,
                preFilledPassword: k,
                token: x
            } = e, j = n.Hooks.useIntl(), [T, S] = n.React.useState(v || !x ? v : ((e, t) => {
                switch (e.type) {
                    case "team_code":
                        return t.f.iY;
                    case "team_invitations":
                        return "conflict" === e.status ? t.g("iU", {
                            teamName: (0, g.jsx)(a.u_.Emphasis, {
                                children: e.payload.teamName
                            }, "team_name"),
                            inviterEmail: (0, g.jsx)(a.u_.Emphasis, {
                                children: e.payload.inviterEmail
                            }, "inviter_email"),
                            inviterName: (0, g.jsx)(a.u_.Emphasis, {
                                children: e.payload.inviterName
                            }, "inviter_name")
                        }) : null;
                    case "project_invitations":
                        return "conflict" === e.status ? t.g("i0", {
                            inviterEmail: (0, g.jsx)(a.u_.Emphasis, {
                                children: e.payload.inviterEmail
                            }, "inviter_email")
                        }) : null;
                    case "task_invitations":
                        return "conflict" === e.status ? t.g("i3", {
                            inviterEmail: (0, g.jsx)(a.u_.Emphasis, {
                                children: e.payload.inviterEmail
                            }, "inviter_email")
                        }) : null;
                    case "account_upgrade":
                        return t.f.iM;
                    default:
                        return null
                }
            })(x, j)), P = n.React.useRef(null), _ = async () => {
                invariant(x, "Missing token when accepting team invitation"), await f.api.account.resolveTeamInvitation({
                    inviteToken: x.id,
                    accept: !0
                })
            }, {
                isSyncingNice: C,
                isSubmitting: R,
                submit: A,
                scrollRef: I,
                error: N,
                clearError: E,
                resetBusyState: O,
                renderNotificationExplainModal: M
            } = (0, d.f0)({
                isSyncing: b,
                notificationState: y,
                signIn: ({
                    email: e,
                    password: t,
                    otp: s
                }) => (P.current = {
                    email: e,
                    password: t
                }, f.account.basicSignIn({
                    email: n.FP.trim(e),
                    password: n.FP.trim(t),
                    serverUrl: n.FP.trim(L),
                    userId: n.FP.trim(z),
                    apiToken: "valid" === (null == x ? void 0 : x.status) && "account_upgrade" === x.type ? x.payload.apiToken : void 0,
                    otp: s,
                    onBeforeFirstSync: async () => {
                        if ("conflict" !== (null == x ? void 0 : x.status) || "team_invitations" !== x.type) {
                            if ("valid" === (null == x ? void 0 : x.status)) switch (x.type) {
                                case "team_invitations":
                                    await _();
                                    break;
                                case "team_code":
                                    await f.api.account.requestJoinTeam({
                                        joinCode: x.id
                                    });
                                    break;
                                case "project_invitations":
                                    f.appState.startAcceptingProjectInvitation(x.id);
                                    break;
                                case "task_invitations":
                                    f.appState.startAcceptingTaskInvitation(x.id);
                                    break;
                                case "account_upgrade":
                                    break;
                                default:
                                    throw new Error('Unknown token type to handle before first sync: "' + x.type + '"')
                            }
                        } else await _()
                    }
                })),
                onSuccessfulLogin: async () => {
                    if ("valid" === (null == x ? void 0 : x.status) && "account_upgrade" === x.type) {
                        const e = (await f.modelRoot.settings.accountMerge.fetchAll()).find((e => e.email === x.payload.email));
                        e && f.appState.startAcceptingAccountMerge(e)
                    }
                }
            }), {
                signInWithApple: D,
                signInWithGoogle: H
            } = (0, c.MI)({
                token: x,
                onConflict: () => {
                    f.api.telemetry.trackSignupProcess("oauth_conflict"), S(j.f.jf)
                },
                onSuccess: (e, t) => {
                    if (n.Misc.platform.isMacElectron && t) {
                        const s = Object.assign({}, t, {
                            provider: e
                        });
                        switch (e) {
                            case "apple":
                                f.router.goTo(i.pathToAppleSignInRedirect, s);
                                break;
                            case "google":
                                f.router.goTo(i.pathToGoogleSignInRedirect, s);
                                break;
                            default:
                                throw new Error('Unhandled success callback for provider "' + e + '"')
                        }
                    }
                }
            }), [F, Z] = (0, d.F4)(), [L, B] = n.React.useState(""), [z, U] = n.React.useState(""), W = (0, d.Rg)(x), G = (0, d.AG)();
            n.Hooks.useBackButton((() => (W(), !0)));
            const V = f.history.currentPath.getValue();
            (0, d.tZ)("login");
            const q = (0, g.jsxs)(d.xD, {
                children: [h || (h = (0, g.jsx)(d.TR, {
                    size: "medium",
                    withFlex: !0
                })), (0, g.jsx)("span", {
                    className: u.text,
                    children: j.f.jD
                }), (0, g.jsx)(o.default, {
                    variant: "opaque",
                    color: "Android" === n.ReactUtils.getDeviceOS() ? "green" : "blue",
                    iconName: "}",
                    marginTop: "small",
                    onPress: () => {
                        switch (n.ReactUtils.getDeviceOS()) {
                            case "iOS":
                                n.ReactUtils.openUrl("https://apps.apple.com/pl/app/nozbe-teams/id1457232572");
                                break;
                            case "Android":
                                n.ReactUtils.openUrl("market://details?id=com.nozbe4&referrer=" + encodeURIComponent(V))
                        }
                    },
                    label: j.f.jC
                }), (0, g.jsx)("span", {
                    className: u.text,
                    children: j.f.jB
                }), (0, g.jsx)(o.default, {
                    variant: "opaque",
                    marginTop: "small",
                    iconName: "»",
                    color: "purple",
                    onPress: () => {
                        n.ReactUtils.openUrl("nozbe4://goto" + V)
                    },
                    label: j.f.jA
                }), (0, g.jsx)(o.default, {
                    onPress: () => W(),
                    isDisabled: R,
                    marginTop: "big",
                    label: j.f.fd
                })]
            });
            return F && !x ? q : (0, g.jsxs)(g.Fragment, {
                children: [(0, g.jsx)(d.xD, {
                    scrollRef: I,
                    title: C ? void 0 : j.f.i4,
                    children: (0, g.jsxs)(m, {
                        children: [F ? (0, g.jsx)(d.si, {
                            onClose: () => Z(!1)
                        }) : null, G ? (0, g.jsx)(d.TR, {
                            size: C ? "medium" : "small",
                            withFlex: !1
                        }) : null, C ? (0, g.jsxs)(g.Fragment, {
                            children: [(0, g.jsx)(d.v0, {
                                text: j.f.jb,
                                atBottom: !1
                            }), p || (p = (0, g.jsx)(r.default, {}))]
                        }) : (0, g.jsxs)(g.Fragment, {
                            children: [T ? (0, g.jsx)("div", {
                                children: (0, g.jsx)(d.v0, {
                                    className: u.loginMessage,
                                    text: T,
                                    atBottom: !1
                                })
                            }) : null, N ? (0, g.jsx)(a.u_.Error, {
                                className: u.errorContainer,
                                noGutter: !0,
                                children: N
                            }) : null, (0, g.jsx)(d.U0, {
                                onFocus: E,
                                canSubmit: !R,
                                preFilledEmail: P.current ? P.current.email : w || (null == x || null == (t = x.payload) ? void 0 : t.email),
                                preFilledPassword: P.current ? P.current.password : k || void 0,
                                provider: null == x || null == (s = x.payload) || null == (s = s.providers) ? void 0 : s.at(0),
                                resetBusyState: O,
                                buttonLabel: R ? j.f.e$ : j.f.i4,
                                onSubmit: A,
                                signInWithApple: D,
                                signInWithGoogle: H
                            }), (0, g.jsx)(o.default, {
                                onPress: () => {
                                    var e;
                                    const t = !!x && (0, l._O)(x) && "conflict" === x.status && !(null == (e = x.payload) || null == (e = e.providers) || !e.length);
                                    W({
                                        state: {
                                            preventRedirectingToLoginOnConflict: t
                                        }
                                    })
                                },
                                isDisabled: R,
                                label: null != x && x.payload ? j.f.jx : j.f.fd
                            }), null]
                        })]
                    })
                }), M()]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(12),
            o = s(6),
            r = s(30),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            isLoggedIn: e.appState.isLoggedIn
        }))))((e => {
            const {
                services: t,
                isLoggedIn: s
            } = e, {
                confirmId: c
            } = n.Hooks.useParams();
            invariant(c, "Missing confirm ID");
            const [l, d] = n.React.useState(void 0), u = n.Hooks.useIntl(), m = n.Hooks.useIsMounted(), h = (0, r.Rg)();
            n.Hooks.useBackButton((() => (h(), !0)));
            const p = async () => {
                try {
                    await t.account.confirmEmailChange({
                        confirmId: c,
                        intl: u
                    })
                } catch (e) {
                    m.current && d("error")
                }
            };
            n.React.useEffect((() => {
                s && (d("busy"), p())
            }), []);
            const g = "busy" === l;
            return (0, i.jsx)(r.xD, {
                children: s && l ? (0, i.jsx)(r.v0, {
                    text: {
                        error: u.f.iO,
                        busy: u.f.iN
                    } [l]
                }) : (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(r.v0, {
                        text: u.f.iP
                    }), "error" === l ? (0, i.jsx)(o.u_.Error, {
                        noGutter: !0,
                        children: u.f.iO
                    }) : null, (0, i.jsx)(r.U0, {
                        onSubmit: async ({
                            email: e,
                            password: s,
                            otp: n
                        }) => {
                            d("busy");
                            try {
                                const {
                                    needsOTP: a
                                } = await t.api.account.basicAuthenticate({
                                    email: e,
                                    password: s,
                                    otp: n
                                });
                                return a || await p(), {
                                    needsOTP: a
                                }
                            } catch (e) {
                                return m.current && d("error"), null
                            }
                        },
                        onFocus: () => d(void 0),
                        resetBusyState: () => d(void 0),
                        buttonLabel: g ? u.f.e$ : u.f.i4,
                        canSubmit: !g
                    }), (0, i.jsx)(a.default, {
                        onPress: () => h(),
                        isDisabled: g,
                        marginTop: "small",
                        label: g ? u.f.e$ : u.f.fd
                    })]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(0),
            a = s(43),
            o = s(14),
            r = s(45),
            i = s(127),
            c = s(12),
            l = s(57),
            d = s(30);
        s(2), s(3);
        const u = s(647);
        var m = s(1);
        const h = n.Hocs.compose()((e => {
            var t;
            const {
                preFilledEmail: s
            } = e, h = n.Hooks.useIntl(), p = n.Hooks.useServices(), [g, f] = n.React.useState(s || ""), [b, y] = n.React.useState(""), [v, w] = n.React.useState(""), k = n.Hooks.useValidation({
                email: [g, [a.C1, a.Jh]],
                password: [b, [a.C1]]
            }), x = n.Hooks.useAsyncState(), j = n.Hooks.useAsyncState(), T = n.Hooks.useErrorHandler({
                InvalidCredentials: h.f.jr,
                MigrationAlreadyCompleted: h.f.jt
            }), S = n.Hooks.useAsyncFetcher(x, (async () => {
                const e = await async function(e, t) {
                    const s = await fetch("https://webapp.nozbe.com/sync3/login", {
                            method: "POST",
                            body: JSON.stringify({
                                email: e,
                                password: t
                            })
                        }),
                        n = await s.json(),
                        a = null == n ? void 0 : n.key;
                    return a
                }(g, b);
                if (!e) throw T.boom(T.ErrorCodes.InvalidCredentials);
                return e
            })), P = n.Hooks.useAsyncFetcherWithParams(j, (async ({
                params: {
                    apiKey: e
                }
            }) => {
                const t = await async function(e, t) {
                    return fetch("https://api4.nozbe.com/v1/np_import", {
                        method: "POST",
                        body: JSON.stringify({
                            np_auth_token: e,
                            locale: t
                        }),
                        headers: {
                            "Content-Type": "application/json",
                            "API-VERSION": "Current"
                        }
                    })
                }(e, h.locale);
                if (409 === t.status) throw T.boom(T.ErrorCodes.MigrationAlreadyCompleted);
                if (!t.ok) throw T.boom(T.ErrorCodes.Unknown)
            }));

            function _() {
                S({
                    onSuccess: e => P({
                        params: {
                            apiKey: e
                        }
                    })
                })
            }
            const C = x.isError ? T.translate(x.error) : j.isError ? T.translate(j.error) : j.isSuccess ? h.f.ju : x.isRetrying || x.hasSucceeded ? null : h.f.jq,
                R = x.isBusy || j.isBusy,
                A = (null == (t = j.error) ? void 0 : t.code) === T.ErrorCodes.MigrationAlreadyCompleted || j.isSuccess;
            return (0, m.jsxs)(d.xD, {
                title: h.f.jw,
                children: [(0, m.jsxs)("div", {
                    className: u.messageContainer,
                    children: [C ? (0, m.jsx)("span", {
                        className: u.message + (x.isError ? " " + u.error : ""),
                        children: C
                    }) : null, (0, m.jsx)(c.default, {
                        label: h.f.fC,
                        isFullWidth: !1,
                        onPress: () => {
                            n.ReactUtils.openUrl("https://nozbe.com/migrator")
                        }
                    })]
                }), A ? null : (0, m.jsxs)(m.Fragment, {
                    children: [(0, m.jsx)("div", {
                        className: u.formContainer,
                        children: (0, m.jsxs)(i.Z, {
                            onSubmit: _,
                            children: [(0, m.jsx)(d.bu, {
                                label: h.f.uf
                            }), (0, m.jsx)(r.default, {
                                placeholder: h.f.iR,
                                autoFocus: !0,
                                autoComplete: "username",
                                type: "email",
                                onChange: f,
                                value: g,
                                returnKeyType: "next",
                                errors: k.email.errors,
                                blurOnSubmit: !1,
                                forEntryViews: !0,
                                autoCorrect: !0,
                                isDisabled: R
                            }), (0, m.jsx)(d.bu, {
                                label: h.f.up,
                                hasTopMargin: !0
                            }), (0, m.jsx)(r.default, {
                                placeholder: h.f.j5,
                                autoComplete: "current-password",
                                type: "password",
                                onChange: y,
                                value: b,
                                returnKeyType: "next",
                                errors: k.password.errors,
                                blurOnSubmit: !1,
                                forEntryViews: !0,
                                helpText: h.f.jv,
                                isDisabled: R
                            }), null]
                        })
                    }), (0, m.jsx)(c.default, {
                        onPress: _,
                        marginTop: "big",
                        isDisabled: !k.isValid || R,
                        variant: "opaque",
                        color: "green",
                        label: h.f.js,
                        right: R ? (0, m.jsx)(l.default, {
                            size: "small",
                            color: "backgroundPrimary",
                            style: {
                                marginLeft: 0
                            }
                        }) : void 0
                    })]
                }), (0, m.jsx)(c.default, {
                    marginTop: "big",
                    onPress: function() {
                        p.router.goTo(o.pathToRoot)
                    },
                    label: h.f.fd,
                    isDisabled: R
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n, a = s(0),
            o = s(12),
            r = s(216),
            i = s(30),
            c = s(1);
        const l = (e, t, s) => {
                switch (e) {
                    case "join":
                        return s.f.iW;
                    case "invite":
                        return s.g("iV", {
                            teamName: (0, c.jsx)(i.fy, {
                                children: t
                            }, "signup-redirect-" + (t || "teamName"))
                        });
                    case "confirm":
                        return s.f.ki;
                    default:
                        return ""
                }
            },
            d = a.Hocs.compose()((() => {
                const e = a.Hooks.useIntl(),
                    t = a.Hooks.useServices(),
                    {
                        search: s
                    } = a.Hooks.useLocation(),
                    d = (e => {
                        if (e.inviteId) return "invite";
                        if (e.confirmId) return "confirm";
                        if (e.joinCode) return "join";
                        throw new Error("Unknown token type in SignupRedirect")
                    })(a.Hooks.useParams()),
                    u = s ? (0, i.Qp)(s) : null,
                    m = (0, i.Rg)(),
                    h = () => (m(), !0);
                a.Hooks.useBackButton(h);
                const p = (0, i.AG)();
                return (0, i.tZ)("signup_redirect"), (0, c.jsxs)(i.xD, {
                    children: [p ? n || (n = (0, c.jsx)(i.TR, {})) : null, (0, c.jsx)(i.v0, {
                        text: l(d, u, e)
                    }), (0, c.jsx)(o.default, {
                        onPress: () => (0, r.Z)({
                            services: t,
                            intl: e,
                            shouldPushHistory: !1
                        }),
                        variant: "opaque",
                        color: "purple",
                        marginTop: "big",
                        label: e.f.cU
                    }), (0, c.jsx)(o.default, {
                        onPress: h,
                        marginTop: "big",
                        label: e.f.fd
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => S
        });
        var n = s(0),
            a = s(14),
            o = s(6),
            r = s(12),
            i = s(30),
            c = s(43),
            l = s(60),
            d = s(209),
            u = s(638);
        s(2), s(3);
        const m = s(653);
        var h = s(1);
        const p = n.ReactUtils.lazy((() => s(22))),
            g = n.ReactUtils.lazy((() => s(45)));
        const f = n.Hocs.compose()((e => {
                const {
                    onAppleSignIn: t,
                    onGoogleSignIn: s,
                    goToState: o
                } = e, i = n.Hooks.useIntl(), f = (0, h.jsx)(u.X, {
                    intl: i,
                    onPress: t
                }), b = (0, h.jsx)(u.V, {
                    intl: i,
                    onPress: s
                }), y = n.Hooks.useServices(), v = (e = {}) => {
                    y.api.telemetry.trackSignupProcess("signup_with_email"), y.router.goTo(a.pathToSignup, Object.assign({}, o, e))
                }, [w, k] = n.React.useState(!1), [x, j] = n.React.useState(!1), [T, S] = n.React.useState((() => {
                    var e;
                    return null != (e = function(e) {
                        var t;
                        const {
                            token: s
                        } = e;
                        return !s || !(0, d._O)(s) && "project_invitations" !== s.type || "valid" !== s.status && "conflict" !== s.status ? null : null == (t = s.payload) ? void 0 : t.email
                    }(o)) ? e : ""
                })), P = n.Hooks.useValidation({
                    email: [T, [c.C1, c.Jh]]
                }), [_, C] = n.React.useState(""), R = () => {
                    var e;
                    n.Misc.PROD_CONSOLE(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL).log("Check email button pressed");
                    const {
                        token: t
                    } = o;
                    !("valid" !== (null == t ? void 0 : t.status) && "conflict" !== (null == t ? void 0 : t.status) || "team_code" !== t.type && "team_invitations" !== t.type || null == (e = t.payload) || !e.apiToken) ? v({
                        preFilledEmail: T
                    }): N({
                        onError: e => {
                            n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Check email error: " + e.message)
                        }
                    })
                }, A = n.Hooks.useAsyncState(), I = n.Hooks.useErrorHandler(), N = n.Hooks.useAsyncFetcher(A, (async () => {
                    const e = await y.api.account.checkEmailAvailability({
                        email: T
                    });
                    e.isAvailable ? e.isRegisteredInNP ? k(!0) : v({
                        preFilledEmail: T
                    }) : ((e = {}) => {
                        y.router.goTo(a.pathToLogin, Object.assign({}, o, e))
                    })({
                        preFilledEmail: T,
                        preFilledPassword: _
                    })
                })), E = x ? (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsxs)(l.gq, {
                        justify: "center",
                        align: "center",
                        style: {
                            marginTop: 8
                        },
                        children: [(0, h.jsx)(g, {
                            placeholder: i.f.iR,
                            autoFocus: !0,
                            onSubmit: R,
                            autoComplete: "username",
                            autoCorrect: !1,
                            type: "email",
                            onChange: S,
                            value: T,
                            returnKeyType: "send",
                            errors: P.email.errors,
                            blurOnSubmit: !0,
                            forEntryViews: !1,
                            testId: n.Misc.testIds.loginModal_username
                        }), (0, h.jsx)(p, {
                            className: m.iconButton,
                            color: "backgroundPrimary",
                            name: "9",
                            onPress: R,
                            isDisabled: !T,
                            accessibilityLabel: i.f.fj
                        })]
                    }), null, A.isError ? (0, h.jsx)("span", {
                        className: m.errorMessage,
                        children: I.translate(A.error)
                    }) : null]
                }) : (0, h.jsx)(r.default, {
                    variant: "opaque",
                    marginTop: "medium",
                    color: "heather",
                    iconName: "¥",
                    onPress: () => j(!0),
                    label: i.f.jm
                }), O = n.Misc.isMAS;
                return (0, h.jsx)(h.Fragment, {
                    children: w ? (0, h.jsxs)(h.Fragment, {
                        children: [(0, h.jsx)("span", {
                            className: m.migrationDescription,
                            children: i.f.j1
                        }), (0, h.jsxs)("div", {
                            className: m.buttonsContainer,
                            children: [(0, h.jsx)(r.default, {
                                variant: "opaque",
                                color: "darkgreen",
                                onPress: () => n.ReactUtils.openUrl("https://nozbe.com/login-en"),
                                label: i.f.j2,
                                marginTop: "medium",
                                iconName: "Ř"
                            }), (0, h.jsx)(r.default, {
                                variant: "opaque",
                                marginTop: "medium",
                                color: "green",
                                onPress: () => ((e = {}) => {
                                    y.router.goTo(a.pathToMigrateNP, Object.assign({}, o, e))
                                })({
                                    preFilledEmail: T
                                }),
                                label: i.f.j3,
                                iconName: "Ś"
                            }), (0, h.jsx)(r.default, {
                                variant: "opaque",
                                color: "heather",
                                onPress: () => v({
                                    preFilledEmail: T
                                }),
                                label: i.f.j4,
                                marginTop: "medium",
                                iconName: "."
                            })]
                        })]
                    }) : (0, h.jsxs)(h.Fragment, {
                        children: [O ? f : b, O ? b : f, E, null]
                    })
                })
            })),
            b = n.ReactUtils.lazy((() => s(258))),
            y = n.Hocs.compose()((e => {
                const {
                    token: t,
                    onAppleSignIn: s,
                    onGoogleSignIn: a
                } = e, r = n.Hooks.useIntl();
                n.Hooks.useServices();
                const i = n.Hooks.useModalState();
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(f, {
                        onAppleSignIn: () => {
                            s()
                        },
                        onGoogleSignIn: a,
                        goToState: {
                            token: t
                        }
                    }), i.isOpen ? (0, h.jsxs)(o.u_, {
                        onClose: i.close,
                        children: [(0, h.jsx)(o.u_.Header, {
                            showLeftIcon: !1,
                            children: r.f.ky
                        }), (0, h.jsx)(o.u_.Content, {
                            children: (0, h.jsx)(o.u_.Section, {
                                children: (0, h.jsx)(b, {
                                    goToNext: () => {
                                        s(), i.close()
                                    },
                                    setMarketingConsent: n.FP.noop
                                })
                            })
                        })]
                    }) : null]
                })
            })),
            v = s(654),
            w = e => (0, h.jsx)("span", {
                className: v.inviteMessage + (e.isCentered ? " " + v.inviteMessageCentered : ""),
                children: e.children
            });
        var k = s(645);
        const x = s(655),
            j = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isSyncing: e.sync.isSyncing
            }))))((e => {
                const {
                    token: t,
                    isSyncing: s
                } = e, r = n.Hooks.useIntl(), i = n.Hooks.useServices(), c = "valid" === (null == t ? void 0 : t.status) && "task_invitations" === t.type && !!t.payload.canAcceptAsGuest, [l, d, u, m, p] = n.Hooks.useLoadingState(), g = t ? ((e, t, s) => {
                    switch (e.type) {
                        case "team_code":
                            return t.f.iX;
                        case "team_invitations":
                            return "valid" === e.status || "conflict" === e.status ? t.g("iT", {
                                teamName: (0, h.jsx)(o.u_.Emphasis, {
                                    children: e.payload.teamName
                                }, "team_name"),
                                inviterEmail: (0, h.jsx)(o.u_.Emphasis, {
                                    children: e.payload.inviterEmail
                                }, "inviter_email"),
                                inviterName: (0, h.jsx)(o.u_.Emphasis, {
                                    children: e.payload.inviterName
                                }, "inviter_name")
                            }) : null;
                        case "project_invitations":
                            return "valid" === e.status ? t.g("iZ", {
                                inviterEmail: (0, h.jsx)(o.u_.Emphasis, {
                                    children: e.payload.inviterEmail
                                }, "inviter_email")
                            }) : null;
                        case "task_invitations":
                            return s || "valid" !== e.status ? null : "accepted" === e.payload.status ? t.f.i2 : t.g("i1", {
                                inviterEmail: (0, h.jsx)(o.u_.Emphasis, {
                                    children: e.payload.inviterEmail
                                }, "inviter_email")
                            });
                        case "account_upgrade":
                            return t.f.iL;
                        default:
                            return null
                    }
                })(t, r, c) : null, f = !!g, {
                    signInWithApple: b,
                    signInWithGoogle: v
                } = (0, k.MI)({
                    token: t,
                    onStart: e => {
                        i.api.telemetry.trackSignupProcess("oauth_start_" + e), d()
                    },
                    onConflict: () => {
                        i.api.telemetry.trackSignupProcess("oauth_conflict"), m(r.f.jf)
                    },
                    onError: m,
                    onSuccess: (e, t) => {
                        if (u(), n.Misc.platform.isMacElectron && t) {
                            const s = Object.assign({}, t, {
                                provider: e
                            });
                            switch (e) {
                                case "apple":
                                    i.router.goTo(a.pathToAppleSignInRedirect, s);
                                    break;
                                case "google":
                                    i.router.goTo(a.pathToGoogleSignInRedirect, s);
                                    break;
                                default:
                                    throw new Error('Unhandled success callback for provider "' + e + '"')
                            }
                        }
                    }
                }), {
                    acceptInvitationAsGuest: j
                } = (0, k.oQ)({
                    token: t,
                    isSyncing: s,
                    onStart: d,
                    onError: m,
                    onSuccess: u
                });
                return (0, k.Mh)({
                    token: t,
                    onStart: d,
                    onError: m,
                    onSuccess: u,
                    onAppleSignIn: b,
                    onGoogleSignIn: v
                }), n.Hooks.useAsyncEffect((async () => {
                    c && await j()
                }), [c]), (0, h.jsxs)(h.Fragment, {
                    children: [f ? (0, h.jsx)("div", {
                        className: x.inviteMessageContainer,
                        children: (0, h.jsx)(w, {
                            children: g
                        })
                    }) : null, c ? null : (0, h.jsx)("div", {
                        className: x.authButtonsContainer + (f ? "" : " " + x.authButtonsContainerCentered),
                        children: (0, h.jsx)(y, {
                            token: t,
                            onAppleSignIn: b,
                            onGoogleSignIn: v
                        })
                    }), l.isLoading || l.isError ? (0, h.jsxs)(o.u_, {
                        onClose: p,
                        isClosingDisabled: l.isLoading,
                        children: [(0, h.jsx)(o.u_.Header, {
                            children: r.f.jb
                        }), (0, h.jsx)(o.u_.Content, {
                            children: (0, h.jsx)(o.u_.Loader, {
                                isLoading: l.isLoading,
                                isError: l.isError,
                                errorMsg: l.error || void 0
                            })
                        })]
                    }) : null]
                })
            })),
            T = (e, t) => {
                switch (null == e ? void 0 : e.type) {
                    case "project_invitations":
                        return t.f.kq;
                    case "login_providers":
                        return t.f.kp;
                    default:
                        return t.f.kB
                }
            },
            S = e => {
                const {
                    inviteId: t,
                    joinCode: s,
                    projectInvitationToken: c,
                    taskInvitationToken: l,
                    registerId: d,
                    loginProviderToken: u,
                    accountUpgradeToken: m
                } = e, p = n.Hooks.useIntl(), g = n.Hooks.useServices(), f = n.Hooks.useLocation(), {
                    teamCodeToken: b,
                    teamInvitationToken: y,
                    preventRedirectingToLoginOnConflict: v
                } = f.state || {}, k = (0, i.AG)(), [x] = (0, i.ji)({
                    inviteId: t,
                    joinCode: s,
                    projectInvitationToken: c,
                    taskInvitationToken: l,
                    registerId: d,
                    loginProviderToken: u,
                    teamCodeToken: b,
                    teamInvitationToken: y,
                    accountUpgradeToken: m
                });
                n.React.useEffect((() => {
                    var e;
                    "conflict" === (null == x ? void 0 : x.status) && null != (e = x.payload) && null != (e = e.providers) && e.length && !v && g.router.goTo(a.pathToLogin, {
                        token: x
                    })
                }), [g, x, v]), n.React.useEffect((() => {
                    "signup_invitations" !== (null == x ? void 0 : x.type) || "valid" !== x.status && "conflict" !== x.status || g.router.goTo(a.pathToSignup, {
                        token: x
                    })
                }), [g, x]), (0, i.tZ)(x ? "token_validation_" + x.type : "entry_menu"), n.React.useEffect((() => {}), [g.api]);
                const S = (0, i.Rg)(x),
                    P = f.pathname === a.routeToRoot ? i.oO : S;
                return n.Hooks.useBackButton((() => (P(), !0))), (0, h.jsx)(h.Fragment, {
                    children: (0, h.jsxs)(i.xD, {
                        forceNoScroll: !0,
                        withTermsLink: !0,
                        children: [k ? (0, h.jsx)(i.Q0, {
                            withTermsLink: !0,
                            showText: !x
                        }) : null, (0, h.jsx)(o.u_.Loader, {
                            isLoading: "not_checked" === (null == x ? void 0 : x.status),
                            isError: "invalid" === (null == x ? void 0 : x.status),
                            loadingMsg: p.f.kA,
                            renderError: () => (0, h.jsxs)(h.Fragment, {
                                children: [(0, h.jsx)(w, {
                                    isCentered: !0,
                                    children: T(x, p)
                                }), (0, h.jsx)(r.default, {
                                    onPress: () => P(),
                                    label: p.f.fd
                                })]
                            }),
                            children: (0, h.jsx)(j, {
                                token: x
                            })
                        })]
                    })
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => E
        });
        var n = s(0),
            a = s(14),
            o = s(83),
            r = s(1546),
            i = (s(11), s(13), s(30));
        s(2), s(3);
        const c = s(656);
        var l = s(1);
        const d = e => {
            const {
                steps: t,
                currentStep: s
            } = e, n = t.filter((e => !e.shouldSkip)), a = n.findIndex((e => e.name === s.name));
            return (0, l.jsx)("div", {
                className: c.root,
                children: n.map(((e, t) => (0, l.jsx)("div", {
                    className: c.stepBar + (t <= a ? " " + c.currentStep : "")
                }, "step-" + e.name)))
            })
        };
        s(5);

        function u(e, t) {
            switch (e) {
                case "team_invitations":
                case "team_code":
                    return t.f.jp;
                case "project_invitations":
                    return t.f.ji;
                case "account_upgrade":
                    return t.f.l;
                default:
                    return t.f.jl
            }
        }
        const m = (e, t) => ({
            name: e,
            shouldSkip: t
        });

        function h({
            tokenType: e,
            isSkippingTeam: t,
            isSkippingName: s
        }) {
            switch (e) {
                case "team_code":
                case "team_invitations":
                    return [m("email_password", !1), m("member_name", s), m("terms", !1), m("submit", !1)];
                default:
                    return [m("email_password", !1), m("member_name", s), m("team_name", t), m("invite_members", t), m("terms", !1), m("submit", !1)]
            }
        }

        function p(e, t) {
            const s = t.findIndex((t => t.name === e.name));
            if (0 === s || s === t.length - 1) return null;
            const n = t[s - 1];
            return n.shouldSkip ? p(n, t) : n
        }

        function g(e, t) {
            const s = t.findIndex((t => t.name === e.name));
            if (s === t.length - 1) return null;
            const n = t[s + 1];
            return n.shouldSkip ? g(n, t) : n
        }

        function f(e) {
            const t = h(e),
                s = t[0];
            if (invariant(s, "Register form has no first step"), s.shouldSkip) {
                const e = g(s, t);
                invariant(e, "Register form has no valid steps")
            }
            return s
        }
        const b = s(657);

        function y(e, t) {
            switch (t.type) {
                case "set_email":
                    return Object.assign({}, e, {
                        email: t.payload
                    });
                case "set_password":
                    return Object.assign({}, e, {
                        password: t.payload
                    });
                case "set_name":
                    return Object.assign({}, e, {
                        name: t.payload
                    });
                case "set_team_name":
                    return Object.assign({}, e, {
                        isSkippingTeam: !0,
                        teamName: t.payload
                    });
                case "set_members":
                    return Object.assign({}, e, {
                        members: t.payload
                    });
                case "set_marketing_consent":
                    return Object.assign({}, e, {
                        marketingConsent: t.payload
                    });
                case "set_server_url":
                    return Object.assign({}, e, {
                        serverUrl: t.payload
                    });
                case "set_signup_busy":
                    return Object.assign({}, e, {
                        signUpState: {
                            status: "busy",
                            error: null
                        }
                    });
                case "set_signup_confirmation_required":
                    return Object.assign({}, e, {
                        signUpState: {
                            status: "confirmation_required",
                            error: null
                        }
                    });
                case "set_signup_error":
                    return Object.assign({}, e, {
                        signUpState: {
                            status: "error",
                            error: t.payload
                        }
                    });
                case "set_current_step":
                    return Object.assign({}, e, {
                        currentStep: t.payload
                    });
                case "skip_team":
                    return Object.assign({}, e, {
                        isSkippingTeam: !0,
                        currentStep: t.payload,
                        teamName: ""
                    });
                default:
                    return e
            }
        }
        var v = s(17),
            w = s(4);

        function k(e, t) {
            return o.Ej.test(e) ? {
                name: x(e).slice(0, v.MaxLengths.users.name),
                teamName: S(e, t).slice(0, v.MaxLengths.teams.name)
            } : {
                name: "",
                teamName: ""
            }
        }

        function x(e) {
            const t = e.split("@")[0];
            invariant(t, "Expected a valid email to guess name");
            const s = t.replace(/\+[^\+]+$/, "").split(/[\._-]/g).filter(Boolean);
            return 1 === s.length ? w.capitalize(s[0]) : s.map(((e, t) => {
                const n = t === s.length - 1,
                    a = 3 < e.length || 0 === t || n ? w.capitalize(e) : e;
                return n ? a.replace(/\d+$/, "") : a
            })).join(" ")
        }
        const j = ["gmail.com", "icloud.com", "hey.com", "fastmail.com", "outlook.com", "hotmail.com", "privaterelay.appleid.com", "wp.pl", "onet.pl", "o2.pl", "interia.pl", "gazeta.pl"],
            T = ["com", "net", "gov", "edu", "org", "co"];

        function S(e, t) {
            const s = e.split("@")[1];
            if (j.includes(s.toLowerCase())) return t;
            const [n, ...a] = s.split(".").filter(Boolean);
            return (1 < a.length ? [n, ...P(a)] : [n]).map((e => e.split(/[-_]/))).flat().filter(Boolean).map((e => w.capitalize(e))).join(" ")
        }

        function P(e) {
            if (1 >= e.length) return [];
            const t = T.includes(e[e.length - 2].toLowerCase());
            return e.slice(0, t ? -2 : -1)
        }
        const _ = n.ReactUtils.lazy((() => s(1547))),
            C = n.ReactUtils.lazy((() => s(1548))),
            R = n.ReactUtils.lazy((() => s(1331))),
            A = n.ReactUtils.lazy((() => s(1333))),
            I = n.ReactUtils.lazy((() => s(1549))),
            N = n.ReactUtils.lazy((() => s(258))),
            E = n.Hocs.compose(n.Hocs.withErrorBoundary({
                name: "RegisterForm",
                render: "screen"
            }), n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isSyncing: e.sync.isSyncing,
                notificationState: n.Rx.from(e.notifications.areNotificationsEnabled())
            }))))((e => {
                const {
                    token: t,
                    preFilledEmail: s,
                    notificationState: c,
                    isSyncing: m
                } = e, v = n.Hooks.useServices(), w = n.Hooks.useIntl(), {
                    tokenId: x,
                    tokenType: j,
                    initialEmail: T = s,
                    isEmailUsed: S
                } = n.React.useMemo((() => {
                    if (t) {
                        var e;
                        const s = null == (e = t.payload) ? void 0 : e.email;
                        return {
                            tokenId: t.id,
                            tokenType: t.type,
                            initialEmail: s && (0, o.T)(s) ? s : void 0,
                            isEmailUsed: !!(0, i._O)(t) && "conflict" === t.status
                        }
                    }
                    return {
                        tokenId: void 0,
                        tokenType: void 0,
                        initialEmail: void 0,
                        isEmailUsed: !1
                    }
                }), [t]), P = w.f.jT, E = n.React.useMemo((() => {
                    const e = !S && T || "";
                    return Object.assign({
                        currentStep: f({
                            tokenType: j,
                            isSkippingName: !1,
                            isSkippingTeam: !1
                        }),
                        email: e
                    }, k(e, P))
                }), [P, T, S, j]), [{
                    email: O,
                    password: M,
                    name: D,
                    teamName: H,
                    members: F,
                    marketingConsent: Z,
                    serverUrl: L,
                    signUpState: B,
                    currentStep: z,
                    isSkippingTeam: U
                }, W] = (G = E, n.React.useReducer(y, Object.assign({
                    email: "",
                    password: "",
                    name: "",
                    teamName: "",
                    members: [],
                    marketingConsent: !1,
                    serverUrl: "",
                    isSkippingTeam: !0,
                    signUpState: {
                        status: "busy",
                        error: null
                    }
                }, G)));
                var G;
                const V = (0, r.ZP)(),
                    q = V.avatar.result,
                    Q = (0, r.ZP)(),
                    Y = Q.avatar.result,
                    J = e => W({
                        type: "set_email",
                        payload: e
                    }),
                    K = e => W({
                        type: "set_name",
                        payload: e
                    }),
                    {
                        shouldSkipName: $
                    } = {
                        shouldSkipName: !1
                    },
                    {
                        submit: X,
                        isSyncingNice: ee,
                        renderNotificationExplainModal: te
                    } = (0, i.f0)({
                        signIn: async () => {
                            W({
                                type: "set_signup_busy"
                            });
                            const e = await (e => {
                                const s = {
                                    email: O,
                                    name: D,
                                    password: M,
                                    teamName: H || (U ? P : void 0),
                                    teamMembers: F.length ? F : void 0,
                                    isSkippingTeam: U,
                                    marketingConsent: Z
                                };
                                return v.account.signUp(Object.assign({}, s, {
                                    inviteId: x,
                                    isInviteCode: "team_code" === j,
                                    apiToken: null == t || null == (e = t.payload) ? void 0 : e.apiToken
                                }), {
                                    serverUrl: L,
                                    skipRemovingCaches: !1
                                })
                            })();
                            if ("error" === e.status) return W({
                                type: "set_signup_error",
                                payload: 443 === e.errorCode && "team_invitations" === j ? "account_exists" : "unknown"
                            }), {
                                needsConfirmation: !0
                            };
                            if ("ok" === e.status) return {
                                needsConfirmation: !1
                            };
                            try {
                                await Promise.all([q ? v.api.attachments.uploadAvatarWithToken(q, e.avatarUploadToken) : Promise.resolve(), Y ? v.api.attachments.uploadAvatarWithToken(Y, e.teamAvatarUploadToken) : Promise.resolve()])
                            } catch (e) {
                                console.error("Avatars upload failed", e)
                            }
                            return W({
                                type: "set_signup_confirmation_required"
                            }), {
                                needsConfirmation: !0
                            }
                        },
                        isSyncing: m,
                        notificationState: c,
                        onSuccessfulLogin: async () => {
                            const e = await n.Rx.takeFirst(v.modelRoot.currentUser);
                            invariant(e, "Current User missing after login"), Promise.all([Y ? (async t => {
                                const s = await e.ownedTeams.fetch();
                                invariant(1 === s.length, "Account is not new");
                                const n = s[0];
                                return v.api.attachments.uploadAvatar(t, n)
                            })(Y) : Promise.resolve(), q ? v.api.attachments.uploadAvatar(q) : Promise.resolve()]).then((() => {
                                v.sync.synchronize()
                            })), v.history.loginRedirectPath || (v.history.loginRedirectPath = a.pathToRoot.path), "valid" === (null == t ? void 0 : t.status) && "task_invitations" === t.type && v.appState.startAcceptingTaskInvitation(t.id)
                        }
                    }),
                    se = n.React.useMemo((() => h({
                        tokenType: j,
                        isSkippingTeam: U,
                        isSkippingName: $
                    })), [j, U, $]),
                    ne = E.currentStep;
                (0, i.tZ)(ne.name);
                const ae = async e => {
                    v.api.telemetry.trackSignupProcess(e.name), W({
                        type: "set_current_step",
                        payload: e
                    })
                }, oe = (0, i.Rg)(t), re = () => {
                    const e = p(z, se);
                    e ? ae(e) : oe()
                }, ie = () => {
                    const e = g(z, se);
                    e ? ae(e) : oe()
                };
                n.Hooks.useBackButton((() => (re(), !0)));
                z.name;
                return (0, l.jsxs)(i.xD, {
                    title: u(j, w),
                    children: [(0, l.jsxs)("div", {
                        className: b.top,
                        children: [null, (0, l.jsx)(d, {
                            steps: se,
                            currentStep: z
                        }), null]
                    }), (0, l.jsx)("div", {
                        className: b.content,
                        children: "submit" !== z.name ? (0, l.jsx)(l.Fragment, {
                            children: {
                                email_password: (0, l.jsx)(_, {
                                    goToNext: () => {
                                        const e = k(O, P);
                                        D || W({
                                            type: "set_name",
                                            payload: e.name
                                        }), H || W({
                                            type: "set_team_name",
                                            payload: e.teamName
                                        }), ie()
                                    },
                                    initialEmail: T,
                                    isEmailUsed: S,
                                    email: O,
                                    onEmailChange: J,
                                    password: M,
                                    onPasswordChange: e => W({
                                        type: "set_password",
                                        payload: e
                                    }),
                                    serverUrl: L,
                                    setServerUrl: e => W({
                                        type: "set_server_url",
                                        payload: e
                                    }),
                                    goBack: re
                                }),
                                team_name: (0, l.jsx)(C, {
                                    goToNext: ie,
                                    name: H,
                                    setName: e => W({
                                        type: "set_team_name",
                                        payload: e
                                    }),
                                    goBack: re,
                                    avatarModalProps: Q,
                                    skipTeam: async e => {
                                        const t = g(z, h({
                                            tokenType: j,
                                            isSkippingTeam: !0,
                                            isSkippingName: $
                                        }));
                                        t && (v.api.telemetry.trackSignupProcess(t.name), Q.clearAvatarPreview(e), W({
                                            type: "skip_team",
                                            payload: t
                                        }))
                                    }
                                }),
                                member_name: (0, l.jsx)(I, {
                                    goToNext: ie,
                                    name: D,
                                    avatarModalProps: V,
                                    setName: K,
                                    goBack: re
                                }),
                                invite_members: (0, l.jsx)(R, {
                                    goToNext: ie,
                                    setMembers: e => W({
                                        type: "set_members",
                                        payload: e
                                    }),
                                    initialMembers: F,
                                    goBack: re
                                }),
                                terms: (0, l.jsx)(N, {
                                    goToNext: ie,
                                    goBack: re,
                                    setMarketingConsent: e => W({
                                        type: "set_marketing_consent",
                                        payload: e
                                    })
                                })
                            } [z.name]
                        }) : (0, l.jsx)(A, {
                            onBack: () => ae(ne),
                            onSubmit: X,
                            email: O,
                            members: F,
                            signUpStatus: ee ? "busy" : B.status,
                            signUpError: B.error
                        })
                    }), te()]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(0),
            a = s(14),
            o = s(12),
            r = s(57),
            i = s(30),
            c = s(367);
        s(2), s(3);
        const l = s(665);
        var d, u, m = s(1);
        n.ReactUtils.lazy((() => s(45)));
        const h = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "RegisterConfirm",
            render: "screen"
        }), n.Hocs.withServices, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            isSyncing: e.sync.isSyncing,
            notificationState: n.Rx.from(e.notifications.areNotificationsEnabled())
        }))))((e => {
            const {
                confirmId: t,
                isSyncing: s,
                notificationState: h
            } = e, p = n.Hooks.useIntl(), [g, f] = (0, i.F4)(), [b, y] = n.React.useState(!1), [v, w] = (0, c.eC)(), [k, x] = n.React.useState(""), j = n.Hooks.useServices(), {
                submit: T,
                isSubmitting: S,
                error: P,
                isSyncingNice: _,
                renderNotificationExplainModal: C
            } = (0, i.f0)({
                isSyncing: s,
                notificationState: h,
                signIn: async () => {
                    const {
                        email: e
                    } = await j.api.account.getAccountToken({
                        tokenId: t,
                        tokenType: "confirmations",
                        serverUrl: k
                    });
                    try {
                        return await j.account.confirmEmail({
                            confirmId: t,
                            inviteCode: v,
                            serverUrl: k
                        })
                    } catch (t) {
                        var s, n;
                        if (444 === (null == (s = t.originalResponse) ? void 0 : s.status)) return y(!0), {
                            needsInviteCode: !0
                        };
                        if (446 === (null == (n = t.originalResponse) ? void 0 : n.status)) return j.router.goTo(a.pathToLogin, {
                            message: p.f.kd,
                            preFilledEmail: e
                        }), {
                            needsInviteCode: !0
                        };
                        throw t
                    }
                },
                onSuccessfulLogin: () => {
                    j.history.loginRedirectPath || (j.history.loginRedirectPath = a.pathToRoot.path)
                }
            });
            n.React.useEffect((() => {
                !1 === g && t && T()
            }), [t, g]);
            const R = (0, i.Rg)(),
                A = () => (R(), !0);
            n.Hooks.useBackButton(A);
            const I = (0, i.AG)();
            return (0, m.jsxs)(m.Fragment, {
                children: [(0, m.jsxs)(i.xD, {
                    isCentered: !b,
                    children: [g ? (0, m.jsx)(i.si, {
                        onClose: () => f(!1)
                    }) : null, I ? d || (d = (0, m.jsx)(i.TR, {
                        size: "medium"
                    })) : null, (0, m.jsxs)("div", {
                        className: l.wrapper,
                        children: [S || _ ? (0, m.jsxs)(m.Fragment, {
                            children: [(0, m.jsx)(i.v0, {
                                text: _ ? p.f.jb : p.f.kc,
                                atBottom: !1
                            }), u || (u = (0, m.jsx)(r.default, {}))]
                        }) : (0, m.jsx)(m.Fragment, {
                            children: b ? (0, m.jsx)(c.ZP, {
                                title: p.f.kh,
                                inviteCode: v,
                                setInviteCode: w,
                                goBack: A,
                                onDonePress: () => {
                                    T()
                                }
                            }) : null
                        }), P ? (0, m.jsxs)(m.Fragment, {
                            children: [(0, m.jsx)(i.v0, {
                                text: p.f.ke,
                                atBottom: !1
                            }), (0, m.jsx)(o.default, {
                                marginTop: "big",
                                onPress: () => T(),
                                label: p.f.f4
                            }), null, (0, m.jsx)(o.default, {
                                marginTop: "big",
                                onPress: A,
                                label: p.f.fd
                            })]
                        }) : null]
                    })]
                }), C()]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => f
        });
        var n = s(0),
            a = s(14),
            o = s(12),
            r = s(57),
            i = s(30),
            c = s(43),
            l = s(45),
            d = s(127),
            u = s(666);
        s(2), s(3);
        const m = s(667);
        var h = s(1);
        const p = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            isSyncing: e.sync.isSyncing,
            notificationState: n.Rx.from(e.notifications.areNotificationsEnabled())
        }))))((e => {
            const {
                tokenId: t,
                notificationState: s,
                isSyncing: r
            } = e, p = n.Hooks.useIntl(), g = n.Hooks.useServices(), f = n.Hooks.useIsMounted(), [b, y] = n.React.useState(!1), [v, w] = n.React.useState(""), [k, x] = n.React.useState(""), [j, T] = n.React.useState(null), S = n.Hooks.useValidation({
                newPassword: [v, c.dZ],
                newPasswordRepeat: [k, [(0, c.x_)("newPassword")]]
            }), P = () => T(null), {
                submit: _,
                isSubmitting: C,
                isSyncingNice: R,
                renderNotificationExplainModal: A
            } = (0, i.f0)({
                isSyncing: r,
                notificationState: s,
                signIn: async () => {
                    P();
                    try {
                        const e = await g.account.changePasswordWithResetAndLogin({
                            newPassword: v,
                            tokenId: t
                        });
                        return f.current && y(!0), {
                            needsConfirmation: !e
                        }
                    } catch (e) {
                        f.current && T(e.isNetworkErrorLikely ? "offline" : "invalid")
                    }
                    return {
                        needsConfirmation: !0
                    }
                },
                onSuccessfulLogin: () => {
                    g.history.loginRedirectPath || (g.history.loginRedirectPath = a.pathToRoot.path)
                }
            }), I = S.isValid && !C && !R, N = I ? _ : void 0;
            return b ? (0, h.jsx)(i.v0, {
                text: p.f.j$
            }) : (0, h.jsxs)(h.Fragment, {
                children: [j ? (0, h.jsx)(l.ErrorsContainer, {
                    children: (0, h.jsx)(l.Error, {
                        children: (0, u.o)(j, p)
                    })
                }) : null, (0, h.jsxs)(d.Z, {
                    className: m.form,
                    onSubmit: async () => {
                        N && await N()
                    },
                    children: [(0, h.jsx)(l.default, {
                        placeholder: p.f.dq,
                        autoFocus: !0,
                        onFocus: P,
                        autoComplete: "new-password",
                        type: "password",
                        onChange: w,
                        value: v,
                        returnKeyType: "next",
                        errors: S.newPassword.errors,
                        blurOnSubmit: !0,
                        forEntryViews: !0
                    }), (0, h.jsx)(l.default, {
                        placeholder: p.f.dr,
                        onFocus: P,
                        hasTopMargin: !0,
                        autoComplete: "new-password",
                        type: "password",
                        onChange: x,
                        value: k,
                        returnKeyType: "next",
                        errors: S.newPasswordRepeat.errors,
                        blurOnSubmit: !0,
                        forEntryViews: !0
                    })]
                }), (0, h.jsx)(o.default, {
                    onPress: _,
                    isDisabled: !I,
                    marginTop: "big",
                    variant: "opaque",
                    color: "purple",
                    label: C ? p.f.e$ : p.f.j9
                }), A()]
            })
        }));
        var g;
        const f = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "ResetPassword",
            render: "screen"
        }))((e => {
            const {
                tokenId: t
            } = e, s = n.Hooks.useIntl(), [c, l] = (0, i.F4)(), d = n.Hooks.useIsMounted(), u = n.Hooks.useServices(), [m, f] = n.React.useState("not_checked");
            n.React.useEffect((() => {
                (async () => {
                    if (!1 === c) try {
                        await u.api.validateToken({
                            tokenType: "password_resets",
                            tokenId: t
                        }), d.current && f("valid")
                    } catch (e) {
                        d.current && f("invalid")
                    }
                })()
            }), [t, c, u, d]);
            const b = () => u.router.goTo(a.pathToLogin);
            n.Hooks.useBackButton((() => (b(), !0)));
            const y = (0, i.AG)();
            return (0, h.jsxs)(i.xD, {
                isCentered: "not_checked" === m,
                children: [c ? (0, h.jsx)(i.si, {
                    onClose: () => l(!1)
                }) : null, y ? (0, h.jsx)(i.TR, {
                    withFlex: "not_checked" !== m
                }) : null, "not_checked" === m ? (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(i.v0, {
                        text: s.f.ka,
                        atBottom: !1
                    }), g || (g = (0, h.jsx)(r.default, {}))]
                }) : (0, h.jsxs)(h.Fragment, {
                    children: ["invalid" === m ? (0, h.jsx)(i.v0, {
                        text: s.f.kb
                    }) : null, "valid" === m ? (0, h.jsx)(p, {
                        tokenId: t
                    }) : null, (0, h.jsx)(o.default, {
                        onPress: b,
                        marginTop: "small",
                        label: s.f.fd
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => g
        });
        var n = s(0),
            a = s(30),
            o = s(43),
            r = s(14),
            i = s(45),
            c = s(12),
            l = s(366),
            d = s(666);
        s(2), s(3);
        const u = s(668);
        var m = s(1);
        const h = n.Hocs.compose(n.Hocs.memo)((() => {
            const e = n.Hooks.useIntl(),
                t = n.Hooks.useServices(),
                [s, h] = n.React.useState(!1),
                [p, g] = n.React.useState(!1),
                [f, b] = n.React.useState(""),
                [y, v] = n.React.useState(null),
                w = n.Hooks.useValidation({
                    email: [f, [o.C1, o.Jh]]
                }),
                k = () => v(null),
                x = w.isValid && !p,
                j = n.Hooks.useIsMounted(),
                T = async () => {
                    try {
                        k(), g(!0), await t.api.account.resetPassword({
                            email: n.FP.trim(f)
                        }), j.current && h(!0)
                    } catch (e) {
                        j.current && v(e.isNetworkErrorLikely ? "offline" : "invalid")
                    } finally {
                        j.current && g(!1)
                    }
                }, S = x ? T : void 0, P = (0, a.AG)(), _ = () => t.router.goTo(r.pathToLogin);
            return n.Hooks.useBackButton((() => (_(), !0))), s ? (0, m.jsx)(l.Z, {
                title: e.f.j7,
                email: f,
                onSendAgain: T
            }) : (0, m.jsxs)(m.Fragment, {
                children: [P ? (0, m.jsx)(a.TR, {
                    withFlex: !1,
                    size: void 0
                }) : null, (0, m.jsxs)("div", {
                    className: u.root,
                    children: [(0, m.jsx)(a.v0, {
                        text: e.f.j_,
                        atBottom: !1
                    }), y ? (0, m.jsx)(i.ErrorsContainer, {
                        children: (0, m.jsx)(i.Error, {
                            children: (0, d.o)(y, e)
                        })
                    }) : null, (0, m.jsx)(i.default, {
                        placeholder: e.f.iR,
                        autoFocus: !0,
                        onFocus: k,
                        autoComplete: "username",
                        type: "email",
                        onChange: b,
                        value: f,
                        returnKeyType: "next",
                        errors: w.email.errors,
                        onSubmit: S,
                        blurOnSubmit: !0,
                        forEntryViews: !0
                    }), (0, m.jsx)(c.default, {
                        onPress: T,
                        marginTop: "big",
                        label: p ? e.f.e$ : e.f.j9,
                        variant: "opaque",
                        color: "purple",
                        isDisabled: !x
                    }), (0, m.jsx)(c.default, {
                        onPress: _,
                        marginTop: "small",
                        label: e.f.fd
                    })]
                })]
            })
        }));
        var p;
        const g = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "ResetPasswordRequest",
            render: "screen"
        }))((() => {
            const e = n.Hooks.useIntl(),
                [t, s] = (0, a.F4)();
            return (0, a.tZ)("password_reset"), (0, m.jsxs)(a.xD, {
                title: e.f.jg,
                children: [t ? (0, m.jsx)(a.si, {
                    onClose: () => s(!1)
                }) : null, p || (p = (0, m.jsx)(h, {}))]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n, a = s(0),
            o = s(162),
            r = s(1);
        const i = a.Hocs.compose()((e => {
            const {
                projectName: t
            } = e, s = a.Hooks.useServices(), i = a.Hooks.useIntl(), [c, l] = a.React.useState(!1);
            return a.React.useEffect((() => {
                c || setTimeout((() => l(!0)), 0)
            }), [c]), c ? (0, r.jsx)(r.Fragment, {
                children: (0, r.jsx)(o.ZP, {
                    onFinish: () => {
                        s.modelRoot.settings.sawProjectFollowOnboarding.set(!0)
                    },
                    steps: [{
                        testId: a.Misc.testIds.taskList_follow,
                        title: i.g("ti", {
                            projectName: (0, r.jsx)(o.Em, {
                                style: {
                                    fontWeight: "bold"
                                },
                                children: t
                            }, "em1")
                        }),
                        content: (0, r.jsxs)(r.Fragment, {
                            children: [i.g("tg", {
                                follow: (0, r.jsx)(o.cK, {
                                    children: i.f.fx
                                }, "strong1")
                            }), n || (n = (0, r.jsx)(o.SS, {})), i.g("th", {
                                activity: (0, r.jsx)(o.cK, {
                                    children: i.f.y
                                }, "strong1")
                            })]
                        }),
                        native_placement: "belowCard"
                    }]
                })
            }) : null
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n, a, o = s(0),
            r = s(162),
            i = s(1);
        const c = o.Hocs.compose(o.Hocs.withServices, o.Hocs.withObservables(["services"], (({
            services: e
        }) => ({
            declaredUseCase: e.modelRoot.settings.declaredUseCase.observe()
        }))))((e => {
            const {
                onDidRequestTour: t,
                isReady: s,
                onBeforeBegin: c,
                declaredUseCase: l
            } = e, d = o.Hooks.useServices(), u = o.Hooks.useIntl();
            o.React.useEffect((() => {
                t()
            }), [t]);
            const [m, h] = o.React.useState(!1), p = o.React.useRef(!1);
            o.React.useEffect((() => {
                s && !p.current && (p.current = !0, c().then((() => {
                    h(!0)
                })))
            }), [c, s]);
            const g = m && s;
            return o.React.useEffect((() => {
                g && d.ab.projectPresetsBaseline.trackOnce("taskDetailsRendered")
            }), [d.ab, g]), g ? (0, i.jsx)(i.Fragment, {
                children: (0, i.jsx)(r.ZP, {
                    onFinish: e => {
                        d.modelRoot.settings.sawTaskDetailsOnboarding.set(!0), d.ab.projectPresetsBaseline.trackOnce(e ? "taskDetailsComplete" : "taskDetailsSkip")
                    },
                    native_onBefore: async () => {
                        await o.FP.delay(0)
                    },
                    steps: "personal" === l ? [{
                        testId: o.Misc.testIds.task_dueDate,
                        title: u.f.tt,
                        content: u.f.ts
                    }, {
                        testId: o.Misc.testIds.task_commentPrompt,
                        title: u.f.to,
                        content: u.f.tn,
                        native_placement: "scrollBelowCard"
                    }, {
                        testId: o.Misc.testIds.task_complete,
                        title: u.f.tq,
                        content: u.f.tp
                    }] : [{
                        testId: o.Misc.testIds.task_responsible,
                        title: u.f.tw,
                        content: (0, i.jsxs)(i.Fragment, {
                            children: [u.f.tu, n || (n = (0, i.jsx)(r.SS, {})), u.f.tv]
                        })
                    }, {
                        testId: o.Misc.testIds.task_dueDate,
                        title: u.f.tt,
                        content: u.f.tr
                    }, {
                        testId: o.Misc.testIds.task_commentPrompt,
                        title: u.f.to,
                        content: u.f.tn,
                        native_placement: "scrollBelowCard"
                    }, {
                        testId: o.Misc.testIds.task_commentPrompt,
                        title: u.f.tm,
                        content: (0, i.jsxs)(i.Fragment, {
                            children: [u.g("tj", {
                                em1: (0, i.jsx)(r.cK, {
                                    children: u.f.tk
                                }, "em1")
                            }), a || (a = (0, i.jsx)(r.SS, {})), u.f.tl]
                        }),
                        native_placement: "belowCard"
                    }, {
                        testId: o.Misc.testIds.task_complete,
                        title: u.f.tq,
                        content: u.f.tp
                    }]
                })
            }) : null
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(152),
            o = s(202);
        const r = n.FP.omit(["isTextBolded", "isActive", "color"]),
            i = n.Hocs.compose(n.Hocs.memo)((e => n.React.createElement(a.Z, Object.assign({
                renderRight: (0, o.j)(e, {
                    isOnRight: !0
                })
            }, r(e)))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(713)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => ve
        });
        var n = s(0),
            a = s(6);
        s(2), s(3);
        const o = s(727);
        var r = s(1);
        const i = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                onChange: t,
                placeholder: s,
                value: n,
                textAreaRef: a,
                onKeyDown: i,
                isFocusModeEnabled: c
            } = e;
            return (0, r.jsx)("textarea", {
                className: o.textarea,
                style: {
                    height: c ? "auto" : a.current && n && a.current.scrollHeight + "px" || "58px",
                    maxHeight: c ? "none" : "50vh",
                    flex: c ? "1" : "none"
                },
                ref: a,
                value: n,
                onChange: e => t(e.target.value),
                onKeyDown: i,
                placeholder: s,
                autoFocus: !0
            })
        }));
        var c = s(224),
            l = s.n(c);
        const d = (e, t) => {
                const s = (e => {
                    const t = globalThis.document.createElement("span");
                    return t.innerText = e, t
                })(t);
                e.appendChild(s)
            },
            u = (e, t) => {
                const {
                    body: s
                } = globalThis.document;
                invariant(s, "no body");
                const n = (e => {
                    const t = globalThis.document.createElement("div"),
                        s = globalThis.getComputedStyle(e);
                    return [...s].forEach((e => {
                        t.style.setProperty(e, s.getPropertyValue(e))
                    })), t
                })(e);
                return ((e, t) => {
                    l()(t).forEach((t => {
                        d(e, t)
                    })), d(e, "")
                })(n, t), s.appendChild(n), ((e, t) => {
                    const {
                        left: s,
                        top: n
                    } = e.getBoundingClientRect(), {
                        offsetTop: a = 0,
                        offsetLeft: o = 0
                    } = globalThis.visualViewport;
                    t.style.setProperty("left", s + o + 15 + "px"), t.style.setProperty("top", n + a - 20 + "px")
                })(e, n), n.scrollTop = e.scrollTop, n.style.setProperty("z-index", "-10000000"), n.style.setProperty("position", "absolute"), n.style.setProperty("visibility", "hidden"), n
            },
            m = (e, t, s) => {
                const a = n.React.useRef(),
                    o = n.React.useRef(),
                    r = () => {
                        a.current && a.current.remove(), a.current = null, o.current = null
                    };
                if (n.React.useEffect((() => r), [a]), e.current && s && !a.current) {
                    const s = e.current,
                        n = l()(t.substring(0, s.selectionStart)).length;
                    a.current = u(s, t), o.current = a.current.children[n]
                } else s || r();
                return o
            };
        var h = s(227),
            p = s(228),
            g = s(68),
            f = s(82),
            b = s(22);
        const y = s(728),
            v = n.Hocs.compose()((e => {
                const {
                    icon: t,
                    accessibilityLabel: s,
                    iconColor: a = "onBackground3",
                    isDisabled: o,
                    onPress: i,
                    menuTarget: c
                } = e;
                return (0, r.jsxs)("div", {
                    className: y.root,
                    children: [(0, r.jsx)(b.default, {
                        className: y.iconButton,
                        name: t,
                        color: a,
                        iconSize: 24,
                        accessibilityLabel: s,
                        size: 36,
                        isDisabled: o,
                        __webFixBlurEventOrder: !0,
                        onPress: e => {
                            i && (n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), i(e))
                        },
                        withHover: !0,
                        androidRippleRadius: 20,
                        tooltipActivationTime: 750
                    }), (0, r.jsx)("div", {
                        className: y.menuTarget,
                        ref: c
                    })]
                })
            }));
        var w = s(32),
            k = s(20);
        const x = e => {
            const {
                target: t,
                onPressAttachFile: s,
                onPressEvernote: a,
                onPressDropbox: o,
                onPressGoogleDrive: i,
                onPressOneDrive: c,
                onClose: l
            } = e, d = n.Hooks.useIntl();
            return (0, r.jsxs)(w.ZP, {
                target: t,
                onClose: l,
                hasArrow: !0,
                level: 90,
                children: [(0, r.jsx)(k.Z, {
                    label: d.f.l_,
                    icon: "=",
                    onPress: () => s("files")
                }), (0, r.jsx)(k.Z, {
                    label: d.f.mg,
                    icon: "©",
                    onPress: a
                }), (0, r.jsx)(k.Z, {
                    label: d.f.mf,
                    icon: "¢",
                    onPress: o
                }), null, (0, r.jsx)(k.Z, {
                    label: d.f.mm,
                    icon: "ŝ",
                    onPress: c
                })]
            })
        };
        var j = s(109),
            T = s(35),
            S = s(299),
            P = s(87);
        const _ = (e, t) => (0, S.o)(e, t);

        function C(e) {
            return !!e.trim()
        }
        const R = async (e, t, s) => {
            return t || (e ? (a = e)._bodyJSON ? (0, T.Ds)(a._bodyJSON, !0) : a._bodyText : s ? (async e => {
                const t = e._bodyJSON ? (0, T.Ds)(e._bodyJSON) : e._bodyText,
                    s = "> " + n.FP.splitLines(t).join("\n> ") + "  \n\n",
                    a = await e.author.fetch();
                if (!e.isTeam && a) return s + "@" + await n.Rx.takeFirst(a.preferredName) + " ";
                return s
            })(s) : "");
            var a
        }, A = n.Hocs.compose(n.Hocs.withObservables(["task", "editedComment", "initialDraft"], (({
            task: e,
            editedComment: t,
            initialDraft: s
        }) => ({
            taskAccess: e ? e.taskAccess : n.Rx.of(null),
            task: e || n.Rx.of(null),
            initialDraft: n.Rx.from((async () => s || (t ? t.getDraft() : e ? e.timeline.getNewCommentDraft() : void 0))())
        }))), n.Hocs.withObservables(["editedComment", "replyComment", "initialDraft"], (({
            editedComment: e,
            replyComment: t,
            initialDraft: s
        }) => ({
            initialBody: n.Rx.from(R(e, s, t))
        }))), n.Hocs.withObservables(["task", "project"], (({
            task: e,
            project: t
        }) => ({
            project: (() => {
                if (e) return e.observeCurrentProject();
                if (t) return t;
                throw new Error("task or project expected in CommentEdit")
            })()
        }))), n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            isProjectPrivate: e.permissions.isPrivate
        }))), n.Hocs.withHooks((({
            isProjectPrivate: e,
            taskAccess: t
        }) => ({
            canUseMentions: Boolean(!e || t)
        }))), n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            threadMembers: null != e && e.isThread ? e.observeThreadMembers() : n.Rx.of([]),
            threadName: null != e && e.isThread ? e.observeThreadName() : n.Rx.of(null)
        }))), n.Hocs.withIdentity, n.Hocs.withHooks((({
            task: e,
            editedComment: t,
            attachmentProps: {
                attachedFiles: s,
                addExternalAttachments: a
            },
            onSave: o,
            embededStyle: r,
            initialBody: i,
            threadName: c,
            isPreviewModeEnabled: l
        }) => {
            const {
                currentTeam: d
            } = n.Hooks.useIdentity(), u = n.Hooks.useIntl(), m = n.Hooks.useServices(), h = n.React.useRef(!1), [p, g] = n.React.useState((() => ((e, t) => "string" == typeof e ? (0, S.t)(e, t) : (0, T.Ds)(e, !0))(i, u))), f = n.React.useRef(void 0), b = n.React.useRef(void 0), y = n.React.useRef(void 0), v = n.React.useCallback((() => {
                t ? t.removeDraft() : e && e.timeline.removeNewCommentDraft()
            }), [t, e]), w = n.React.useCallback((() => {
                const n = f.current;
                if (n !== b.current)
                    if (b.current = n, n && C(n)) {
                        const a = _(n, u);
                        t ? t.saveDraft(a) : e ? e.timeline.saveNewCommentDraft(a) : r && o(a, s)
                    } else v()
            }), [u, t, e, r, o, s, v]);
            n.React.useEffect((() => () => {
                clearTimeout(y.current), w()
            }), [w]);
            const k = (() => {
                    const e = (0, T.LJ)(p) || null,
                        t = !!s.length;
                    if (!(!!e && C(e) || t)) return {
                        canSave: !1,
                        commentBody: null
                    };
                    const n = null != e ? e : u.g("gY", {
                        attachmentCount: s.length
                    });
                    return {
                        canSave: !0,
                        commentBody: _(n, u)
                    }
                })(),
                x = l ? null != e && e.isThread ? u.f.Kb : u.f.ho : t ? u.f.g3 : null != e && e.isThread ? u.g("Ka", {
                    threadName: c
                }) : u.f.gX;
            return {
                editorValue: p,
                onEditorChange: e => {
                    if (!h.current)
                        if (f.current = e, r) o(e, s);
                        else {
                            !!y.current || (y.current = setTimeout((() => {
                                y.current = void 0, w()
                            }), 2e3))
                        } g(e)
                },
                onPickEvernoteNotes: e => {
                    const t = e.map((e => (0, j.dK)(e)));
                    a(t)
                },
                onPickDropboxFiles: e => {
                    const t = e.map((e => (0, j.lG)(e)));
                    a(t)
                },
                onPickGoogleDriveFiles: e => {
                    const t = e.map((e => (0, j.nT)(e)));
                    a(t)
                },
                onPickOneDriveFiles: e => {
                    const t = e.map((e => (0, j.gm)(e)));
                    a(t)
                },
                onSave: async () => {
                    h.current || (h.current = !0, y.current && (clearTimeout(y.current), y.current = void 0, f.current = void 0), v(), setTimeout((() => {
                        v()
                    }), 350), k.canSave && (o(k.commentBody, s), e && await (0, P.markTaskAsReviewedWithSnackbar)(m, u, e, d)), g(""))
                },
                canSave: k.canSave,
                modalTitle: x
            }
        }))), I = s(729), N = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
            services: e,
            currentTeam: t
        }) => ({
            isEvernoteConnected: e.modelRoot.settings.observeIntegrationState(t, "evernote_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled)))),
            isDropboxConnected: e.modelRoot.settings.observeIntegrationState(t, "dropbox_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled)))),
            isGoogleDriveConnected: e.modelRoot.settings.observeIntegrationState(t, "gdrive_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled)))),
            isOneDriveConnected: e.modelRoot.settings.observeIntegrationState(t, "onedrive_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled))))
        }))))((e => {
            const {
                isMentionIconHidden: t,
                isFocusModeEnabled: s,
                embededStyle: a,
                canSave: o,
                onSave: i,
                toggleList: c,
                onPressAttachFile: l,
                onPressMention: d,
                onPressLinkMention: u,
                onPressFocusMode: m,
                onPressEvernote: h,
                onPressDropbox: p,
                onPressGoogleDrive: g,
                onPressOneDrive: b,
                isEvernoteConnected: y,
                isDropboxConnected: w,
                isGoogleDriveConnected: k,
                isOneDriveConnected: j,
                isPreviewModeEnabled: T
            } = e, S = n.Hooks.useIntl(), P = n.Hooks.useModalState(), _ = n.Hooks.usePrevious(T);
            n.React.useEffect((() => {
                T !== _ && P.isOpen && P.close()
            }), [T, _, P]);
            const C = c("- [ ] "),
                R = c("1. "),
                A = c("- ");
            return (0, r.jsxs)("div", {
                className: I.row + " " + I.root,
                children: [(0, r.jsxs)("div", {
                    className: I.row + " " + I.menu,
                    children: [y || w || k || j ? (0, r.jsx)(v, {
                        menuTarget: P.target,
                        icon: "ū",
                        accessibilityLabel: S.f.l$,
                        onPress: P.open
                    }) : (0, r.jsx)(v, {
                        accessibilityLabel: S.f.l_,
                        icon: "=",
                        onPress: () => l("files")
                    }), T ? (0, r.jsxs)(r.Fragment, {
                        children: [(0, r.jsx)("div", {
                            className: I.seperator
                        }), (0, r.jsx)("span", {
                            className: I.hintPrefix,
                            children: S.g("hn", {
                                markdown: (0, r.jsx)(f.Z, {
                                    to: "https://nozbe.help/taskcommunication/comments/#comments_markdown",
                                    children: (0, r.jsx)("span", {
                                        className: I.hintLink,
                                        children: S.f.uh
                                    })
                                })
                            })
                        })]
                    }) : (0, r.jsxs)(r.Fragment, {
                        children: [t ? null : (0, r.jsx)(v, {
                            icon: "ŉ",
                            accessibilityLabel: S.f.mj,
                            onPress: d
                        }), (0, r.jsx)(v, {
                            icon: "Ơ",
                            accessibilityLabel: S.f.mk,
                            onPress: u
                        }), (0, r.jsx)("div", {
                            className: I.seperator
                        }), (0, r.jsx)(v, {
                            icon: "[",
                            accessibilityLabel: S.f.me,
                            onPress: C
                        }), (0, r.jsx)(v, {
                            icon: "P",
                            accessibilityLabel: S.f.mc,
                            onPress: A
                        }), (0, r.jsx)(v, {
                            icon: "ś",
                            accessibilityLabel: S.f.ml,
                            onPress: R
                        })]
                    }), m ? (0, r.jsxs)(r.Fragment, {
                        children: [(0, r.jsx)("div", {
                            className: I.seperator
                        }), (0, r.jsx)(v, {
                            icon: s ? "ŋ" : "Ň",
                            accessibilityLabel: S.f.mh,
                            onPress: m
                        })]
                    }) : null, P.isOpen ? (0, r.jsx)(x, {
                        target: P.target,
                        onPressAttachFile: n.ReactUtils.callBoth(P.close, l),
                        onPressEvernote: n.ReactUtils.callBoth(P.close, h),
                        onPressDropbox: n.ReactUtils.callBoth(P.close, p),
                        onPressGoogleDrive: n.ReactUtils.callBoth(P.close, g),
                        onPressOneDrive: n.ReactUtils.callBoth(P.close, b),
                        onClose: P.close,
                        isEvernoteConnected: y,
                        isDropboxConnected: w,
                        isGoogleDriveConnected: k,
                        isOneDriveConnected: j
                    }) : null]
                }), (0, r.jsx)("div", {
                    className: I.row + " " + I.send,
                    children: (0, r.jsx)(v, {
                        icon: a ? "Ƶ" : "ƈ",
                        iconColor: o ? "purple" : void 0,
                        accessibilityLabel: S.f.mo,
                        isDisabled: !o,
                        onPress: i
                    })
                })]
            })
        })), E = s(730), O = n.ReactUtils.lazy((() => s(1356))), M = n.ReactUtils.lazy((() => s(1358))), D = n.ReactUtils.lazy((() => s(1360))), H = n.ReactUtils.lazy((() => s(1362))), F = e => {
            const {
                embededStyle: t,
                canSave: s,
                onSave: a,
                canUseMentions: o,
                isFocusModeEnabled: i,
                onPickEvernoteNotes: c,
                onPickDropboxFiles: l,
                onPickGoogleDriveFiles: d,
                onPickOneDriveFiles: u,
                toggleList: m,
                onPressAttachFile: f,
                onPressMention: b,
                onPressLinkMention: y,
                onPressFocusMode: v,
                attachmentProps: {
                    attachedFiles: w,
                    confirmRemoveAttachedFile: k
                },
                isPreviewModeEnabled: x
            } = e, j = n.Hooks.useIntl(), T = n.Hooks.useModalState(), S = n.Hooks.useModalState(), P = n.Hooks.useModalState(), _ = n.Hooks.useModalState();
            return (0, r.jsxs)("div", {
                className: E.root,
                children: [w.length && !x ? (0, r.jsx)(g.Z, {
                    className: E.attachments,
                    isAbsoluteFilled: !1,
                    topBarInset: 0,
                    reachesTopOfScreen: !1,
                    reachesBottomOfScreen: !1,
                    keyboardDismissMode: "none",
                    children: w.map((e => {
                        const {
                            id: t,
                            name: s
                        } = e, n = (0, p.WG)(e), a = (0, p.mQ)(e);
                        return (0, r.jsx)(h.default, {
                            name: s,
                            icon: n,
                            infoText: a,
                            removeButton: {
                                onPress: () => k(t),
                                accessibilityLabel: j.g("mb", {
                                    fileName: s
                                })
                            }
                        }, t)
                    }))
                }) : null, (0, r.jsx)(N, {
                    canSave: s,
                    onSave: a,
                    toggleList: m,
                    isMentionIconHidden: !o,
                    embededStyle: t,
                    isFocusModeEnabled: i,
                    onPressAttachFile: f,
                    onPressMention: b,
                    onPressLinkMention: y,
                    onPressFocusMode: v,
                    onPressEvernote: T.open,
                    onPressDropbox: S.open,
                    onPressGoogleDrive: P.open,
                    onPressOneDrive: _.open,
                    isPreviewModeEnabled: x
                }), T.isOpen ? (0, r.jsx)(O, {
                    onPickNotes: c,
                    onClose: T.close,
                    level: 90
                }) : null, S.isOpen ? (0, r.jsx)(M, {
                    onPickFiles: l,
                    onClose: S.close,
                    level: 90
                }) : null, P.isOpen ? (0, r.jsx)(D, {
                    onPickFiles: d,
                    onClose: P.close,
                    level: 90
                }) : null, _.isOpen ? (0, r.jsx)(H, {
                    onPickFiles: u,
                    onClose: _.close,
                    level: 90
                }) : null]
            })
        };
        var Z, L = s(60),
            B = s(25),
            z = s(152);

        function U({
            canSave: e,
            save: t,
            onClose: s,
            focus: o,
            blur: i,
            task: c,
            project: l,
            editedComment: d,
            editorValue: u
        }) {
            const m = n.Hooks.useServices(),
                h = n.Hooks.useIntl(),
                p = n.React.useRef(!1),
                g = async () => {
                    if (!p.current) {
                        p.current = !0;
                        try {
                            e && (await t(), s(n.ReactUtils.nullEvent()))
                        } finally {
                            p.current = !1
                        }
                    }
                }, f = n.Hooks.useModal((e => {
                    const [t, ...s] = e.context;
                    invariant(t, "Expected at least on save confirmation to display the modal");
                    const n = (() => {
                        switch (t.reason) {
                            case "mentioned_all":
                                return (0, r.jsx)(B.default.Paragraph, {
                                    children: h.f.hp
                                });
                            case "mentioned_following":
                                return (0, r.jsx)(B.default.Paragraph, {
                                    children: h.f.hq
                                });
                            case "mentioned_members_on_vacation":
                                return (0, r.jsxs)(L.tu, {
                                    children: [Z || (Z = (0, r.jsx)(B.default.Paragraph, {
                                        children: "The following members are currently on vacation and might not respond to your comment until the end of their vacation."
                                    })), (0, r.jsx)(a.u_.Section, {
                                        hasGutter: !0,
                                        children: t.members.map((e => (0, r.jsx)(z.Z, {
                                            member: e
                                        }, e.id)))
                                    })]
                                });
                            default:
                                return t.reason
                        }
                    })();
                    return (0, r.jsx)(B.default, {
                        type: "confirm",
                        onClose: b,
                        onBackPress: b,
                        onConfirmPress: () => {
                            0 < s.length ? e.open(s) : (e.close(), g())
                        },
                        closeOnConfirm: !1,
                        hasTextContent: !1,
                        children: n
                    })
                })), b = () => {
                    f.close(), o()
                };
            return {
                confirmAndSave: async () => {
                    var e, t;
                    const s = await n.Rx.takeFirst((0, T.bo)({
                            services: m,
                            project: l,
                            task: c
                        })),
                        a = null != (e = null == s || null == (t = s.membersWithNames) ? void 0 : t.map((({
                            member: e
                        }) => e))) ? e : [],
                        o = await async function({
                            project: e,
                            projectMembers: t,
                            currentCommentBody: s,
                            editedCommentBody: a
                        }) {
                            if (await n.Rx.takeFirst(e.permissions.isPrivate)) return null;
                            const o = W(s),
                                r = a ? W(a) : [],
                                i = r.length ? o.filter((e => !r.includes(e))) : o;
                            if (0 === i.length) return null;
                            const c = [];
                            if (i.includes("all")) c.push({
                                reason: "mentioned_all"
                            });
                            else if (i.includes("following")) c.push({
                                reason: "mentioned_following"
                            });
                            else if (t.length) {
                                const e = await async function(e, t) {
                                    const s = t.filter((e => "all" !== e && "following" !== e)),
                                        a = e.filter((e => s.includes(e.id)));
                                    return n.FP.filterAsync((e => n.Rx.takeFirst(e.isAwayOnVacation)), a)
                                }(t, i);
                                0 < e.length && c.push({
                                    reason: "mentioned_members_on_vacation",
                                    members: e
                                })
                            }
                            return 0 < c.length ? c : null
                        }({
                            project: l,
                            projectMembers: a,
                            currentCommentBody: G({
                                value: u,
                                intl: h,
                                parserContext: s
                            }),
                            editedCommentBody: null == d ? void 0 : d.getBodyForCheapoWysiwyg(s)
                        });
                    var r;
                    o ? (r = o, f.open(r), i()) : g()
                },
                renderSaveConfirm: f.render
            }
        }

        function W(e) {
            return n.FP.unique((0, T.tz)(e.document.nodes, (e => "inline" === e.object && "mention" === e.type)).map((e => e.data.memberId ? e.data.memberId : "all" === e.data.groupMentionId || "following" === e.data.groupMentionId ? e.data.groupMentionId : null)).filter(Boolean))
        }

        function G({
            value: e,
            intl: t,
            parserContext: s
        }) {
            return (0, T.OU)(_(e, t), s)
        }
        const V = n.ReactUtils.lazy((() => s(733))),
            q = n.ReactUtils.lazy((() => s(25))),
            Q = e => {
                const {
                    attachmentProps: {
                        uploadLimitModal: t,
                        removeAttachmentConfirm: s,
                        removeAttachedFileAfterConfirm: a
                    }
                } = e, {
                    currentTeam: o
                } = n.Hooks.useIdentity(), i = n.Hooks.useIntl();
                return (0, r.jsxs)(r.Fragment, {
                    children: [t.isOpen ? (0, r.jsx)(V, {
                        onClose: t.close,
                        team: o
                    }) : null, s.isOpen ? (0, r.jsx)(q, {
                        type: "delete",
                        onConfirmPress: a,
                        onBackPress: s.close,
                        onClose: s.close,
                        children: i.f.e2
                    }) : null]
                })
            };
        var Y = s(936),
            J = s(937);
        const K = s(42).wx,
            $ = async (e, t) => {
                const s = await (0, Y.M)({
                    item: e,
                    currentTeam: await t.getCurrentTeam(),
                    usesShortTaskLink: !0
                });
                return "" + n.ReactUtils.webAppUrl + s.path
            }, X = async (e, t) => (0, J.sE)(e) ? n.Rx.takeFirst(e.memberUser[0].preferredName) : (0, J.vR)(e) ? e.predefinedGroupMention.translation : (0, J.n0)(e) ? n.Styling.getMemberGroupName(e.group, t) : null;

        function ee({
            focus: e
        }) {
            const t = n.Hooks.useIntl(),
                s = n.Hooks.useModalState(),
                a = n.Hooks.useModalState(),
                o = s.isOpen || a.isOpen,
                [i, c] = n.React.useState(""),
                l = {
                    mention: s,
                    link: a,
                    isAnyOpen: o,
                    queryText: i,
                    setQueryText: c,
                    hide: () => {
                        s.close(), a.close(), c(""), e()
                    },
                    render: e => function(e, t, {
                        cursorRef: s,
                        task: n,
                        project: a,
                        insertMention: o,
                        insertLink: i
                    }) {
                        return (0, r.jsxs)(r.Fragment, {
                            children: [e.mention.isOpen ? (0, r.jsx)(K.Mention, {
                                bundle$close: e.hide,
                                onClose: e.hide,
                                target: s,
                                level: 90,
                                hasArrow: !0,
                                queryText: e.queryText,
                                onConfirm: async e => {
                                    const s = await X(e, t);
                                    s && o(s)
                                },
                                task: n,
                                project: a
                            }) : null, e.link.isOpen ? (0, r.jsx)(K.LinkMention, {
                                bundle$close: e.hide,
                                onClose: e.hide,
                                target: s,
                                level: 90,
                                hasArrow: !0,
                                queryText: e.queryText,
                                onConfirm: async e => {
                                    const t = await $(e, a);
                                    t && i(t)
                                }
                            }) : null]
                        })
                    }(l, t, e)
                };
            return l
        }
        const te = (e, t, s) => s ? e.f.gW : t ? e.f.gV : e.f.gU;
        var se = s(255),
            ne = s(88);
        const ae = s(734),
            oe = n.ReactUtils.lazy((() => s(680)));

        function re(e) {
            const {
                content: t
            } = e;
            if ("local" === t.source) {
                const {
                    file: e
                } = t;
                if (e && (0, p.TO)(e)) return {
                    state: "loaded",
                    file: e
                }
            }
            return null
        }
        const ie = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(["task", "project", "editorValue"], (({
            services: e,
            task: t,
            project: s,
            editorValue: n
        }) => ({
            commentParserContext: (0, T.bo)({
                services: e,
                task: t,
                project: s,
                commentEditorValue: n
            })
        }))))((e => {
            const {
                task: t,
                editedComment: s,
                editorValue: o,
                confirmAndSave: i,
                closePreviewMode: c,
                commentParserContext: l,
                services: d,
                attachedFiles: u = [],
                confirmRemoveAttachedFile: m,
                isFocusModeEnabled: g
            } = e, f = n.Hooks.useIntl();
            n.Hooks.useEventListener({
                eventName: "keydown",
                handler: n.ReactUtils.unlessImeEvent((e => {
                    const t = (e => {
                        const {
                            key: t,
                            shiftKey: s
                        } = e, a = n.ReactUtils.hasCommandModifier(e);
                        switch (t) {
                            case "Escape":
                                return c;
                            case "Enter":
                                return a ? i : null;
                            case "p":
                            case "P":
                                return a && s ? c : null;
                            default:
                                return null
                        }
                    })(e);
                    t && (n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), t())
                }))
            });
            const b = (0, ne.up)(u),
                y = e => {
                    if (m) return {
                        onPress: () => m(e.id),
                        accessibilityLabel: f.g("mb", {
                            fileName: e.name
                        })
                    }
                };
            return (0, r.jsxs)(a.u_.Content, {
                className: ae.preview + (g ? " " + ae.previewFocusMode : ""),
                children: [(0, se.Z)(d.database.collections.get(n.Model.Tables.comments).disposableFromDirtyRaw({
                    id: null == s ? void 0 : s.id,
                    body: (0, S.o)(o, f),
                    task_id: null == t ? void 0 : t.id
                }), l), s ? b.uploaded.map((e => (0, r.jsx)(oe, {
                    latestVersion: e.version,
                    comment: s,
                    removeButton: y(e)
                }, e.id))) : null, b.pending.map((e => (0, r.jsx)(h.default, {
                    name: e.name,
                    infoText: (0, p.mQ)(e),
                    icon: (0, p.WG)(e),
                    thumbnail: re(e),
                    removeButton: y(e)
                }, e.id)))]
            })
        }));
        var ce = s(374);
        const le = /(?:^|\s)@(?!\s)([^@\r\n\+]*)$|(?:^|\s)\+{2}(?!\s)([^@\r\n\+]*)$/,
            de = /\s/,
            ue = /^(?:(\([\+\-]\))|(-\s\[[\sx]\])|(\d+\.)|(-))\s/,
            me = new RegExp(ue.source + "(.*)"),
            he = /^\d\.\s/,
            pe = (e, t) => {
                const s = n.FP.splitLines(e.substring(0, t.start)).length - 1,
                    a = n.FP.splitLines(e.substring(0, t.end)).length - 1,
                    o = n.FP.splitLines(e),
                    r = o.slice(s, a + 1),
                    i = o.slice(0, s),
                    c = o.slice(a + 1),
                    l = n.FP.dropWhileRight((e => ue.test(e)), i).length,
                    d = n.FP.dropWhile((e => ue.test(e)), c),
                    u = a + (c.length - d.length),
                    m = o.slice(l, u + 1);
                return {
                    lines: o,
                    selectedLines: r,
                    selectedListRangeStart: l,
                    selectedListRangeEnd: u,
                    selectionStartLineNumber: s,
                    selectionEndLineNumber: a,
                    selectedListLines: m
                }
            },
            ge = e => {
                const [, t, s, n, a, o] = e || [];
                if (o) {
                    if (t) return "(-) ";
                    if (s) return "- [ ] ";
                    if (n) return parseInt(n, 10) + 1 + ". ";
                    if (a) return "- "
                }
                return ""
            },
            fe = ({
                value: e,
                selection: t,
                listSymbol: s
            }) => {
                const {
                    lines: n,
                    selectedListLines: a,
                    selectedListRangeStart: o,
                    selectedListRangeEnd: r
                } = pe(e, t), i = (n[r], ((e, t) => {
                    const s = e.every((e => ue.test(e))),
                        n = s && me.exec(e[0]),
                        a = ge(n),
                        o = he.test(t);
                    return e.map(((e, n) => {
                        const r = o ? n + 1 + ". " : t,
                            i = a === t || o && he.test(a);
                        return s ? e.replace(ue, i ? "" : r) : e.startsWith(r) ? e : r + e
                    }))
                })(a, s)), c = i.every((e => ue.test(e))), l = n[o - 1], d = n[r + 1], u = !c || ["", void 0].includes(l) ? [] : "", m = !c || ["", void 0].includes(d) ? [] : "", h = n.slice(0, o), p = n.slice(r + 1), g = (i.length, "" === u || "" === m || 0 < h.length || 0 < p.length || 1 < i.length), f = h.concat(u).concat(i).concat(m).concat("").join(g ? "\n" : ""), b = "" === m ? 2 : g ? 1 : 0, y = f.length - b;
                return {
                    value: f + p.join("\n"),
                    selection: y
                }
            },
            be = {
                b: "**",
                i: "_"
            };

        function ye({
            textAreaRef: e,
            editorValue: t,
            onEditorChange: s,
            pickers: a,
            confirmAndSave: o,
            openPreviewMode: r,
            onClose: i
        }) {
            const c = n.React.useRef(null),
                l = ((e, t) => {
                    const s = n.React.useRef(0),
                        [a, o] = n.React.useState(new Number(0)),
                        r = t => {
                            e && (s.current = e.scrollTop), o(new Number(t))
                        };
                    return n.React.useEffect((() => {
                        e && (e.focus(), e.setSelectionRange(Number(a), Number(a)), e.scrollTop = s.current)
                    }), [a]), n.React.useEffect((() => {
                        setTimeout((() => {
                            r(t.length)
                        }), 0)
                    }), []), r
                })(e.current, t),
                d = ({
                    value: e,
                    selection: t
                }) => {
                    s(e), l(t)
                },
                u = n.ReactUtils.unlessImeEvent((t => {
                    const {
                        key: s,
                        shiftKey: l
                    } = t, d = n.ReactUtils.hasCommandModifier(t);
                    if ("Enter" !== s) {
                        if (!a.isAnyOpen) switch (s) {
                            case "Escape":
                                return void i(t);
                            case "@":
                                return void a.mention.open();
                            case "+":
                                return void a.link.open();
                            case "b":
                            case "i":
                                return void(d && !l && (n.ReactUtils.preventDefault(t), n.ReactUtils.stopPropagation(t), f(be[s])));
                            case "p":
                            case "P":
                                return void(d && l && (n.ReactUtils.preventDefault(t), n.ReactUtils.stopPropagation(t), r()));
                            default:
                                return
                        }
                        if ("Backspace" === s) {
                            const {
                                current: t
                            } = e, s = t && t.value[t.selectionStart - 1];
                            "@" === s ? a.mention.close() : "+" === s && a.link.close()
                        }
                    } else d ? (n.ReactUtils.preventDefault(t), n.ReactUtils.stopPropagation(t), o()) : a.isAnyOpen || (c.current = s)
                }));
            n.Hooks.useShortcutProviders([{
                id: "task.toggle_bold",
                action: () => f(be.b)
            }, {
                id: "task.toggle_italic",
                action: () => f(be.i)
            }]);
            const m = t => {
                    const n = e.current;
                    invariant(n, "Expected textarea");
                    const {
                        selectionStart: o,
                        selectionEnd: r
                    } = n, i = (e => {
                        var t;
                        const {
                            value: s,
                            selectionStart: n
                        } = e, a = s.substring(0, n).match(le);
                        if (!a) return null;
                        const [, o, r] = a;
                        return null != (t = null != o ? o : r) ? t : ""
                    })(n);
                    null != i ? a.setQueryText(i) : a.isAnyOpen && a.hide(), "Enter" === c.current ? d(((e, t) => {
                        const s = pe(e, t),
                            {
                                lines: n,
                                selectionEndLineNumber: a,
                                selectionStartLineNumber: o
                            } = s,
                            r = n[a],
                            i = n[o - 1],
                            c = !!i && me.exec(i),
                            l = c && c[5],
                            d = ge(c) + r,
                            u = c && !(d || l),
                            m = u ? o - 1 : o,
                            h = 0 !== m || u ? n.slice(0, m) : n,
                            p = n.slice(a + 1),
                            g = h.concat(u ? "" : []).concat(d).join("\n"),
                            f = r ? -r.length : 0,
                            b = g.length + f;
                        return {
                            value: g + [""].concat(p).join("\n"),
                            selection: b
                        }
                    })(t, {
                        start: o,
                        end: r
                    })) : s(t), c.current = null
                },
                h = ({
                    value: e,
                    selection: t
                }) => {
                    m(e), l(t)
                },
                p = (t, s) => {
                    const n = e.current;
                    invariant(n, "Expected textarea"), h(((e, t) => {
                        const {
                            selectionStart: s,
                            value: n
                        } = e, a = n.substring(0, s), o = n.substring(s), r = a[a.length - 1], i = 0 === s || de.test(r) ? "" : " ";
                        return {
                            value: "" + a + i + t + (o.length && " " !== o[0] ? " " : "") + o,
                            selection: a.length + i.length + t.length
                        }
                    })(n, t)), a.setQueryText(""), s.open()
                },
                g = (t, s) => {
                    const n = e.current;
                    invariant(n, "Expected textarea"), h(((e, t, s, n) => {
                        const {
                            value: a,
                            selectionStart: o
                        } = e, r = a.substring(0, o - (s.length + t.length)), i = n + " ";
                        return {
                            value: "" + r + i + a.substring(o),
                            selection: r.length + i.length
                        }
                    })(n, t, a.queryText, s)), a.hide()
                },
                f = t => {
                    const s = e.current;
                    invariant(s, "Expected textarea"), d(((e, t) => {
                        const {
                            value: s,
                            selectionStart: n,
                            selectionEnd: a
                        } = e, o = t.length, r = n !== a, i = r ? n - o : 0, c = r ? a + o : s.length, l = s.substring(i, n), d = s.substring(a, c), u = l.lastIndexOf(t), m = d.indexOf(t);
                        if (-1 !== u && -1 !== m) {
                            const e = i + u,
                                t = a + m,
                                c = s.substring(e + o, t);
                            return {
                                value: "" + s.substring(0, e) + c + s.substring(t + o),
                                selection: r ? a - o : n - o
                            }
                        }
                        if (r) {
                            const e = s.substring(n, a);
                            return {
                                value: "" + s.substring(0, n) + t + e + t + s.substring(a),
                                selection: a + 2 * o
                            }
                        }
                        return {
                            value: "" + s.substring(0, n) + t + t + s.substring(n),
                            selection: n + o
                        }
                    })(s, t))
                };
            return {
                onKeyDown: u,
                onChange: m,
                toggleList: t => () => {
                    const s = e.current;
                    invariant(s, "Expected textarea");
                    const {
                        value: n,
                        selectionStart: a,
                        selectionEnd: o
                    } = s;
                    d(fe({
                        value: n,
                        listSymbol: t,
                        selection: {
                            start: a,
                            end: o
                        }
                    }))
                },
                beginMention: () => p("@", a.mention),
                beginLink: () => p("++", a.link),
                insertMention: e => g("@", "@" + e),
                insertLink: e => g("++", e)
            }
        }
        const ve = n.Hocs.compose(A)((e => {
            const {
                editorValue: t,
                onEditorChange: s,
                onClose: c,
                onPickEvernoteNotes: l,
                onPickDropboxFiles: d,
                onPickGoogleDriveFiles: u,
                onPickOneDriveFiles: h,
                task: p,
                canSave: g,
                project: f,
                editedComment: b,
                alwaysFocusMode: y,
                attachmentProps: v,
                canUseMentions: w,
                embededStyle: k,
                modalTitle: x,
                isPreviewModeEnabled: j,
                togglePreviewMode: T
            } = e, S = n.Hooks.useIntl(), P = n.Hooks.useForceUpdate(), _ = n.React.useRef(), C = () => {
                var e;
                return null == (e = _.current) ? void 0 : e.focus()
            }, R = ee({
                focus: C
            }), A = m(_, t, R.isAnyOpen);
            n.Hooks.useEventListener({
                target: _.current,
                eventName: "paste",
                handler: v.pasteAttachments
            });
            const {
                confirmAndSave: I,
                renderSaveConfirm: N
            } = U({
                canSave: g,
                save: e.onSave,
                onClose: c,
                focus: C,
                blur: () => {
                    var e;
                    return null == (e = _.current) ? void 0 : e.blur()
                },
                task: p,
                project: f,
                editedComment: b,
                editorValue: t
            }), E = ye({
                textAreaRef: _,
                editorValue: t,
                onEditorChange: s,
                pickers: R,
                confirmAndSave: I,
                openPreviewMode: () => {
                    j || T()
                },
                onClose: c
            }), [O, M] = n.React.useState(y), D = () => {
                R.isAnyOpen && R.hide(), T()
            };
            return n.React.useEffect((() => {
                if (!j && _.current) {
                    const {
                        length: e
                    } = _.current.value;
                    _.current.setSelectionRange(e, e), P()
                }
            }), [j, P]), n.Hooks.useShortcutProviders([{
                id: "task.toggle_comment_preview",
                action: D
            }]), (0, r.jsxs)("div", {
                className: o.root + (O ? " " + o.rootFocused : ""),
                style: k ? {
                    border: 0
                } : void 0,
                children: [(0, r.jsxs)("div", {
                    className: o.container,
                    children: [k ? null : (0, r.jsx)(a.u_.Header, {
                        isPickerHeader: !0,
                        right: (0, r.jsx)(ce.Z, {
                            isActive: j,
                            onPress: D
                        }),
                        showLeftIcon: !0,
                        leftIcon: "b",
                        onLeftIconPress: c,
                        leftIconColor: "onBackground3",
                        leftIconAccessibilityLabel: S.f.fh,
                        children: x
                    }), (0, r.jsx)("div", {
                        className: o.editorContainer,
                        children: (0, r.jsxs)(r.Fragment, {
                            children: [j ? (0, r.jsx)(ie, {
                                task: p,
                                project: f,
                                editedComment: b,
                                editorValue: t,
                                attachedFiles: v.attachedFiles,
                                confirmRemoveAttachedFile: v.confirmRemoveAttachedFile,
                                confirmAndSave: I,
                                closePreviewMode: () => {
                                    j && T()
                                },
                                isFocusModeEnabled: O
                            }) : (0, r.jsx)(i, {
                                textAreaRef: _,
                                value: t,
                                onChange: E.onChange,
                                placeholder: te(S, w, null == p ? void 0 : p.isThread),
                                onKeyDown: E.onKeyDown,
                                isFocusModeEnabled: O
                            }), (0, r.jsx)(F, {
                                canSave: g,
                                embededStyle: k,
                                onSave: I,
                                isFocusModeEnabled: O,
                                canUseMentions: w,
                                onPickEvernoteNotes: l,
                                onPickDropboxFiles: d,
                                onPickGoogleDriveFiles: u,
                                onPickOneDriveFiles: h,
                                toggleList: E.toggleList,
                                attachmentProps: v,
                                onPressMention: E.beginMention,
                                onPressLinkMention: E.beginLink,
                                onPressAttachFile: v.pickAttachments,
                                onPressFocusMode: y || k ? void 0 : () => {
                                    M(!O), C()
                                },
                                isPreviewModeEnabled: j
                            })]
                        })
                    })]
                }), (0, r.jsx)("div", {
                    className: o.overlay
                }), R.render({
                    cursorRef: A,
                    task: p,
                    project: f,
                    insertMention: E.insertMention,
                    insertLink: E.insertLink
                }), N(), (0, r.jsx)(Q, {
                    attachmentProps: v
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n = s(0),
            a = s(178),
            o = s(6),
            r = s(12),
            i = s(77),
            c = s(370);
        s(2), s(3);
        const l = s(731);
        var d, u = s(1);
        const m = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
            services: e,
            currentTeam: t
        }) => ({
            integrationState: e.modelRoot.settings.observeIntegrationState(t, "evernote_integration")
        }))))((e => {
            const {
                integrationState: t,
                onCancel: s
            } = e, m = Boolean(null == t ? void 0 : t.enabled), h = Boolean(null == t ? void 0 : t.reminders_enabled), p = n.Hooks.useServices(), g = n.Hooks.useIntl(), {
                currentTeam: f
            } = n.Hooks.useIdentity(), b = (0, a.R)({
                team: f,
                state: t,
                connectUrl: e => p.api.integrations.getEvernoteConnectUrl(f, e),
                disconnect: e => p.api.integrations.disconnectEvernote(e ? null : f)
            });
            return (0, u.jsxs)(u.Fragment, {
                children: [d || (d = (0, u.jsx)(o.u_.IconStack, {
                    stack: c.Z
                })), (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsx)(o.u_.Heading, {
                        helpPageUrl: n.ReactUtils.helpUrl(g, "advancedfeatures/evernote"),
                        children: g.f.nL
                    }), (0, u.jsx)(o.u_.Paragraph, {
                        children: g.f.kZ
                    }), m ? (0, u.jsx)(o.u_.Section, {
                        className: l.switchSection,
                        children: (0, u.jsx)(i.Z, {
                            label: g.f.k0,
                            isActive: h,
                            colorActive: "avatarColor4",
                            isDisabled: !m || b.request.isBusy,
                            onChange: async () => {
                                await p.modelRoot.settings.integrationSettingQuery(null != t && t.is_for_all_spaces ? null : f, "evernote_integration").set({
                                    enabled: !0,
                                    reminders_enabled: !h
                                })
                            }
                        })
                    }) : null, (0, u.jsxs)(o.u_.Buttons, {
                        children: [m ? (0, u.jsx)(r.default, {
                            label: g.f.n3,
                            color: "red",
                            isDisabled: b.request.isBusy,
                            onPress: b.disconnect
                        }) : (0, u.jsx)(r.default, {
                            label: g.f.nz,
                            variant: "opaque",
                            color: "avatarColor4",
                            isDisabled: b.request.isBusy,
                            onPress: b.connect
                        }), null]
                    }), b.render()]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => S
        });
        var n = s(0),
            a = s(14),
            o = s(29),
            r = s(65),
            i = s(89),
            c = s(70),
            l = s(47),
            d = s(74),
            u = s(48),
            m = s(44),
            h = s(1364),
            p = s(17),
            g = (s(877), s(75)),
            f = s(749),
            b = s(22),
            y = s(1);
        const v = (e, t, s, n, a, o, r, i) => c => {
                invariant(c instanceof p.Models.Project, "Unexpected project is not instance of Project");
                const l = o.find((e => e.root === c)),
                    d = l ? null == r ? void 0 : r.groups.get(l) : null,
                    u = a + ":" + c.id,
                    m = n.includes(u),
                    h = () => s(u),
                    g = i && c.isActive;
                return (0, y.jsx)(f.Z, {
                    project: c,
                    isCollapsed: m,
                    toggleCollapse: h,
                    needsReview: null == l ? void 0 : l.items.some((e => e.doesNeedReview)),
                    hasActivity: null == l ? void 0 : l.items.some((e => e.isUnread)),
                    right: g ? (0, y.jsx)(b.default, {
                        name: "ū",
                        iconSize: 28,
                        accessibilityLabel: t.f.mJ,
                        color: "onBackground3",
                        onPress: t => {
                            m && h(), e(t, c)
                        }
                    }) : void 0,
                    counters: d,
                    tasks: null == l ? void 0 : l.items,
                    onAddTask: void 0
                }, "section_header-" + c.id)
            },
            w = e => null,
            k = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity)((e => {
                const {
                    member: t,
                    taskGroups: s,
                    onSetEndedTasksState: a,
                    currentMember: o,
                    newTaskFormProps: r,
                    taskDetailsProps: i,
                    toggleSectionCollapse: c,
                    collapsedSectionsStates: l,
                    filterState: d,
                    isShowingMyTasks: h
                } = e, p = n.Hooks.useIntl(), f = (0, m.aO)(r.onShow, i), b = (0, u.y)();
                return (0, y.jsx)(g.Z, {
                    taskGroups: s,
                    filterState: d,
                    onSetEndedTasksState: a,
                    rootRecord: t,
                    renderListHeader: w,
                    hasMasterPlus: t !== o,
                    renderSectionHeader: v(((e, t) => {
                        r.setPositionGroup({
                            position: "top",
                            section: t
                        }), f()
                    }), p, c, l, t.id, s, b, h),
                    isProjectVisible: !1,
                    isSectionVisible: !0,
                    newTaskFormProps: r,
                    withSwipeLeft: !0
                })
            })),
            x = n.ReactUtils.lazy((() => s(1375))),
            j = e => null === e.root || 0 < e.items.length,
            T = {
                by: "projectPosition",
                order: "ascending"
            },
            S = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIntl, n.Hocs.withIdentity, n.Hocs.withErrorBoundary({
                name: "Member",
                onReset: ({
                    services: e,
                    currentTeam: t,
                    isLimitedAccount: s
                }) => {
                    e.router.goTo((0, a.getPathToCurrentTeamRoot)(t, s))
                }
            }), n.Hocs.withHooks((({
                match: e
            }) => ({
                memberId: e.params.memberId
            }))), n.Hocs.withObservables(["memberId"], (({
                memberId: e,
                services: t
            }) => ({
                member: t.collections.get(n.Model.Tables.teamMembers).findAndObserve(e)
            }))), n.Hocs.withHooks((({
                member: e,
                services: t,
                currentTeam: s,
                isLimitedAccount: o
            }) => (n.Hooks.useAsyncEffect((async () => {
                await e.isSharedTeamMember && (n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL, "Can't display shared member"), t.router.goTo((0, a.getPathToCurrentTeamRoot)(s, o)))
            }), [e]), {}))), n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                currentMembersSingleTasks: t.singleTasks,
                justEndedTasks: e.uiState.forTeam(t).justEndedTasks
            }))), n.Hocs.withHooks((({
                member: e,
                currentTeam: t,
                isLimitedAccount: s,
                services: o
            }) => {
                n.React.useEffect((() => {
                    e.isArchived ? o.router.goTo((0, a.getPathToCurrentTeamRoot)(t, s)) : e.openOnSidebar()
                }), [e]);
                return (0, m.Nk)(e)
            })), (0, c.hp)((({
                member: e
            }) => ({
                viewId: e.id,
                initialState: {
                    filterResponsibles: [e.id],
                    disabledOptions: ["responsible", "groupBy"]
                }
            }))), n.Hocs.withObservables(["member", "isShowingThePast", "filterState", "justEndedTasks"], (({
                member: e,
                isShowingThePast: t,
                filterState: s,
                justEndedTasks: a
            }) => {
                var r, l;
                return {
                    tasks: t ? e.allTasksResponsibleForInProjects.extend(...(0, i.Z)((0, c.LB)(s))).pipe((0, o.EF)(a, null != (r = s.sort) ? r : T, !!s.sort)) : e.tasksResponsibleForInProjects.extend(...(0, i.Z)((0, c.LB)(s))).pipe((0, o.EF)(a, null != (l = s.sort) ? l : T, !!s.sort)),
                    grantedTasksIds: e.taskAccesses.observe().pipe(n.Rx.map(n.FP.map((e => e.task.id)))),
                    preferredName: e.preferredName,
                    isAwayOnVacation: e.isAwayOnVacation
                }
            })), n.Hocs.withObservables(["tasks", "currentMembersSingleTasks", "isShowingThePast"], (({
                tasks: e,
                currentMembersSingleTasks: t,
                isShowingThePast: s,
                services: {
                    database: n
                },
                intl: a
            }) => ({
                projects: (0, r.Dp)(n, e, t, a, {
                    withEnded: s
                })
            }))), n.Hocs.withFeatureBadges({
                placement: "member_menu_button"
            }))((e => {
                const {
                    setEndedTasksState: t,
                    preferredName: s,
                    isAwayOnVacation: o,
                    isShowingThePast: r,
                    toggleShowThePast: i,
                    member: c,
                    currentMember: p,
                    currentMembersSingleTasks: g,
                    endedTasksStates: f,
                    justEndedTasks: b,
                    projects: v,
                    filterState: w,
                    setFilterState: T,
                    tasks: S,
                    featureBadges: P
                } = e, _ = n.Hooks.useServices(), C = n.Hooks.useIntl(), R = n.Hooks.useModalState();
                n.React.useEffect((() => {
                    var t;
                    null != (t = e.location.state) && t.shouldOpenMenu && R.open()
                }), [e.match]);
                const {
                    collapsedSectionsStates: A,
                    toggleSectionCollapse: I
                } = (0, m.SK)(), {
                    taskGroups: N,
                    sortedTasks: E
                } = (0, h.U)({
                    sections: [null, ...v],
                    groupTasksBySection: () => (0, m.f5)(S, g),
                    getTasksForSection: (e, t) => t.get(null == e ? void 0 : e.id) || [],
                    justEndedTasks: b,
                    listRootId: c.id,
                    collapsedSectionsStates: A,
                    isShowingThePast: r,
                    endedTasksStates: f,
                    shouldRenderSection: j
                }), O = (0, m.Or)(a.routeToMemberTask), {
                    newTaskFormProps: M,
                    newTaskFormVisibility: D
                } = (0, m.G8)({
                    rootRecord: c,
                    defaultProject: g,
                    taskGroups: N,
                    defaultResponsible: c,
                    shouldCheckAccess: !0
                }), H = c === p, F = (0, l.x)(E, s), Z = (0, u.W$)(N), {
                    stats: L,
                    renderStatsModal: B
                } = (0, u.bB)({
                    root: c,
                    tasks: S,
                    taskGroups: N,
                    filterState: w
                }), z = c.isExpired ? "red" : c.isPending ? "orange" : null, U = H ? {
                    style: "quickAdd",
                    onPress: () => {
                        _.uiState.quickAddModal.open()
                    }
                } : {
                    label: C.f.Ko,
                    displayMasterPlusButtonIcon: !1
                };
                return (0, y.jsx)(u.MV, {
                    counters: Z,
                    children: (0, y.jsx)(u.aq, {
                        stats: L,
                        children: (0, y.jsx)(d.Z, {
                            rootRecord: c,
                            taskDetailsProps: O,
                            title: n.Styling.createMemberName(s, C, {
                                isAwayOnVacation: o
                            }),
                            leftIcon: "ƶ",
                            activeTasksCounter: c.activeTasksResponsibleFor.observeCount(),
                            color: z,
                            openViewMenu: R.open,
                            menuTarget: R.target,
                            menuBadge: P.placementBadge,
                            newTaskFormVisibility: D,
                            displayMasterPlusButton: !0,
                            displayMasterPlusButtonIcon: U.displayMasterPlusButtonIcon,
                            masterPlusButtonStyle: U.style,
                            onMasterPlusPress: U.onPress,
                            masterPlusLabel: U.label,
                            sortedTasks: E,
                            filterState: w,
                            setFilterState: T,
                            children: (0, y.jsxs)(y.Fragment, {
                                children: [(0, y.jsx)(k, {
                                    member: c,
                                    taskGroups: N,
                                    filterState: w,
                                    collapsedSectionsStates: A,
                                    toggleSectionCollapse: I,
                                    onSetEndedTasksState: t,
                                    isShowingMyTasks: H,
                                    newTaskFormProps: M,
                                    taskDetailsProps: O
                                }), R.isOpen ? (0, y.jsx)(x, {
                                    member: c,
                                    isShowingThePast: r,
                                    onToggleThePast: i,
                                    saveToCSV: F,
                                    closeMenu: R.close,
                                    target: R.target
                                }) : null, B()]
                            })
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0);
        const a = s(853).qN;
        s(2), s(3);
        const o = s(752);
        var r = s(1);
        const i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (() => ({
            currentTime: n.Rx.nowAndEveryMinute().pipe(n.Rx.map((() => new Date)))
        }))))((e => {
            const {
                user: t,
                currentTime: s
            } = e, i = n.Hooks.useIntl();
            return t.timeZone ? (0, r.jsx)("div", {
                className: o.timeZoneContainer + " " + (e.className || ""),
                style: e.style,
                children: (0, r.jsxs)("span", {
                    className: o.timeZone,
                    children: [i.f.Kn, ":", " ", (0, r.jsx)(a, {
                        value: s,
                        timeZone: t.timeZone
                    })]
                })
            }) : null
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => E
        });
        var n = s(0),
            a = s(14),
            o = s(171),
            r = s(29),
            i = s(74),
            c = s(48),
            l = s(1364),
            d = s(168),
            u = s(47),
            m = s(89),
            h = s(70),
            p = s(44),
            g = s(75),
            f = s(62),
            b = s(50),
            y = s(61),
            v = s(1);
        const w = {
            due_date: {
                icon: "R",
                title: (0, v.jsx)(y.Z, {
                    id: "nq"
                })
            },
            overdue: {
                icon: "š",
                title: (0, v.jsx)(y.Z, {
                    id: "nx"
                })
            },
            reminder: {
                icon: "ź",
                title: (0, v.jsx)(y.Z, {
                    id: "uu"
                })
            },
            delegated: {
                icon: "Ƹ",
                title: (0, v.jsx)(y.Z, {
                    id: "np"
                })
            },
            mention: {
                icon: "ŉ",
                title: (0, v.jsx)(y.Z, {
                    id: "nt"
                })
            },
            newly_added: {
                icon: "ƈ",
                title: (0, v.jsx)(y.Z, {
                    id: "nu"
                })
            }
        };
        var k = s(97),
            x = s(13),
            j = s(226);
        const T = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["counters"], (({
                counters: e
            }) => ({
                counters: n.Rx.wrap(e)
            }))))((e => {
                const {
                    tasks: t,
                    iconName: s,
                    markAllAsReviewed: n,
                    children: a,
                    counters: o
                } = e;
                return (0, v.jsx)(k.Z, {
                    left: (0, v.jsx)(x.default, {
                        name: s,
                        color: "onBackground3"
                    }),
                    right: (0, v.jsx)(j.default, {
                        type: "incoming",
                        initialColor: "onBackground3",
                        onPress: n,
                        onPressExtraParam: t
                    }),
                    counters: null == o ? void 0 : o.activeTasks,
                    viewColor: "incoming",
                    tasks: t,
                    children: a
                })
            })),
            S = (e, t) => s => {
                invariant("string" == typeof s, "Incoming header groupType is not a string");
                const {
                    taskGroups: a,
                    markAllAsReviewed: o
                } = e, r = n.FP.find((e => e.root === s), a), i = r ? null == t ? void 0 : t.groups.get(r) : null, c = w[s], {
                    icon: l,
                    title: d
                } = c;
                return (0, v.jsx)(T, {
                    iconName: l,
                    tasks: null == r ? void 0 : r.items,
                    markAllAsReviewed: o,
                    counters: i,
                    children: d
                }, "section_header-" + s)
            },
            P = (e, t) => {
                const {
                    root: s
                } = e;
                return invariant("string" == typeof s, "Incoming groupType is not a string"), (0, v.jsx)(f.Z, {
                    id: "" + b.M.droppable + s,
                    type: b.x.TASK,
                    children: t
                }, "droppable-" + s)
            },
            _ = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                singleTasks: e.singleTasks
            }))))((e => {
                const {
                    taskGroups: t,
                    currentTeam: s,
                    filterState: a,
                    singleTasks: o
                } = e, r = n.Hooks.useIntl(), i = (0, c.y)(), {
                    newTaskFormProps: l
                } = (0, p.G8)({
                    rootRecord: null,
                    defaultProject: o,
                    taskGroups: t
                });
                return (0, v.jsx)(v.Fragment, {
                    children: (0, v.jsx)(g.Z, {
                        taskGroups: t,
                        filterState: a,
                        rootRecord: s,
                        viewColor: "incoming",
                        renderSectionHeader: S(e, i),
                        renderSectionItemsContainer: P,
                        showReviewIcon: !1,
                        markAsType: "incoming",
                        hasMasterPlus: !0,
                        withSwipeLeft: !0,
                        emptyListTitle: r.f.ns,
                        emptyListMessage: r.f.nr,
                        isDndEnabled: !0,
                        newTaskFormProps: l
                    })
                })
            }));
        var C = s(754);

        function R(e, t, s, a) {
            const o = ((e, t) => {
                const s = {
                    due_date: [],
                    overdue: [],
                    reminder: [],
                    delegated: [],
                    mention: [],
                    newly_added: []
                };
                return e.forEach((e => {
                    const a = e.reviewReason || t.get(e);
                    if (!a) return void n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_ID, "Task " + e.id + " in incoming without review reason");
                    const o = s[a];
                    o || (n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_ID, "Unknown task review type: " + (a || "nil") + " for " + e.id), s.newly_added.push(e)), o.push(e)
                })), s
            })(e, t);
            return Object.entries(o).reduce(((e, [t, n]) => (e[t] = (0, C.m)(t, n, s, a), e)), {})
        }
        const A = n.ReactUtils.lazy((() => s(1379))),
            I = ["due_date", "overdue", "reminder", "delegated", "mention", "newly_added"],
            N = e => 0 < e.items.length,
            E = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity, n.Hocs.withServices, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                justReviewedTasks: e.uiState.forTeam(t).justReviewedTasks,
                justEndedTasks: e.uiState.forTeam(t).justEndedTasks
            }))), n.Hocs.withHooks((({
                currentTeam: e
            }) => ({
                viewId: e.id + "/incoming"
            }))), (0, h.hp)((({
                viewId: e
            }) => ({
                viewId: e,
                initialState: {
                    disabledOptions: ["sort", "groupBy"]
                }
            }))), n.Hocs.withObservables(["filterState", "viewId"], (({
                services: e,
                filterState: t,
                viewId: s
            }) => ({
                tasksPositionMap: t.sort ? n.Rx.of({}) : (0, o.C)(s, e.collections)
            }))), n.Hocs.withObservables(["currentTeam", "justReviewedTasks", "filterState"], (({
                currentTeam: e,
                justReviewedTasks: t,
                filterState: s
            }) => ({
                tasks: e.incomingTasks.pipe(n.Rx.switchMap((e => e.extend(...(0, m.Z)((0, h.LB)(s))).pipe(r.ct).pipe(n.Rx.map((e => (0, h.MF)(s) ? e : n.FP.concatUnique(e, Array.from(t.keys()))))))))
            }))))((e => {
                const {
                    services: t,
                    currentTeam: s,
                    tasks: r,
                    justReviewedTasks: m,
                    justEndedTasks: h,
                    filterState: g,
                    setFilterState: f,
                    tasksPositionMap: b,
                    viewId: y
                } = e, w = n.Hooks.useIntl(), k = n.Hooks.useModalState();
                n.React.useEffect((() => {
                    t.uiState.forTeam(s).clearJustReviewedTasks()
                }), [t.uiState, s]);
                const x = n.React.useMemo((() => R(r, m, h, b)), [r, m, h, b]),
                    j = n.React.useCallback((e => x[e]), [x]),
                    T = (0, p.Or)(a.routeToTaskListTask),
                    {
                        taskGroups: S,
                        sortedTasks: P
                    } = (0, l.U)({
                        sections: I,
                        getTasksForSection: j,
                        endedTasksStates: null,
                        shouldRenderSection: N
                    }),
                    C = n.React.useCallback((async (e, n) => {
                        t.native.haptics.success(), t.uiState.forTeam(s).removeJustReviewedTasks(n), await s.do.markTasksAsReviewed(n);
                        const a = 1 === n.length ? w.g("Jj", {
                            taskName: (0, v.jsx)(d.Z, {
                                task: n[0]
                            })
                        }) : w.g("Jk", {
                            numberOfTasks: n.length
                        });
                        t.uiState.pushSnackbar({
                            message: a,
                            buttonColor: "incoming",
                            onButtonPress: async () => {
                                await s.do.markTasksAsNotReviewed(n)
                            }
                        })
                    }), [s, w, t.native.haptics, t.uiState]),
                    E = n.Rx.of(P.filter((e => e.doesNeedReview)).length),
                    O = (0, c.W$)(S),
                    M = (0, u.x)(P, w.f.ny, (e => {
                        switch (e.reviewReason) {
                            case "overdue":
                                return w.f.nx;
                            case "due_date":
                                return w.f.nq;
                            case "reminder":
                                return w.f.uu;
                            case "delegated":
                                return w.f.np;
                            case "mention":
                                return w.f.nt;
                            case "newly_added":
                                return w.f.nu;
                            default:
                                return ""
                        }
                    }));
                return (0, v.jsx)(c.MV, {
                    counters: O,
                    children: (0, v.jsxs)(i.Z, {
                        rootRecord: s,
                        title: w.f.ny,
                        color: "incoming",
                        displayMasterPlusButton: !0,
                        masterPlusButtonStyle: "quickAdd",
                        onMasterPlusPress: () => t.uiState.quickAddModal.open(),
                        leftIcon: "Ĵ",
                        onDragEnd: async e => {
                            const {
                                destination: s,
                                source: n
                            } = e;
                            if (!s || !n || s.droppableId !== n.droppableId) return;
                            const a = S.find((e => e.root === n.droppableId)),
                                r = S.find((e => e.root === s.droppableId));
                            if (!a || !r) return;
                            const i = a.items[e.source.index];
                            invariant(i, "Unexpected missing draggedTask");
                            const c = (0, o.A)(i, r.items, s.index, b, y);
                            await t.database.write((() => t.database.batch(c)))
                        },
                        taskDetailsProps: T,
                        menuTarget: k.target,
                        openViewMenu: k.open,
                        activeTasksCounter: E,
                        sortedTasks: P,
                        filterState: g,
                        setFilterState: f,
                        children: [(0, v.jsx)(_, {
                            taskGroups: S,
                            filterState: g,
                            currentTeam: s,
                            markAllAsReviewed: C
                        }), k.isOpen ? (0, v.jsx)(A, {
                            closeMenu: k.close,
                            target: k.target,
                            saveToCSV: M
                        }) : null]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => Z
        });
        var n = s(0),
            a = s(14),
            o = s(74),
            r = s(75),
            i = s(48),
            c = s(168),
            l = s(47),
            d = s(44),
            u = (s(1364), s(9)),
            m = (s(17), s(5), s(4), s(8), s(29)),
            h = s(114);
        const p = (e, t, s) => {
                if ("hidden" === e) return t ? "showingEndedToday" : s ? h.VH : null;
                if ("showingEndedToday" === e && s) return h.VH;
                if ("number" == typeof e && s) {
                    const t = e,
                        s = Math.floor(t / 5);
                    return t + h.VH + s
                }
                return null
            },
            g = e => ({
                completed: e.filter((e => e.isCompleted)).length,
                abandoned: e.filter((e => e.isAbandoned)).length
            }),
            f = (e, t, s, n) => ("hidden" === e && "showingEndedToday" === t || "number" == typeof t) && !n && 0 < s.length,
            b = ({
                sections: e,
                groupTasksBySection: t,
                listRootId: s,
                isShowingThePast: n = !1,
                endedTasksStates: a,
                collapsedSectionsStates: o,
                justEndedTasks: r = [],
                shouldRenderSection: i,
                forceShowMoreEndedTasks: c
            }) => {
                const l = u.useMemo((() => t()), [t]),
                    h = e.map((e => {
                        var t;
                        const i = e && "object" == typeof e ? e.id : e || null,
                            u = null != (t = l.get(i)) ? t : [],
                            h = !!s && !(null == o || !o.some((e => s + ":" + (i || "") === e)));
                        if (!a) return Object.assign({
                            root: e,
                            tasks: u,
                            items: u,
                            isCollapsed: h,
                            hasFooter: !1
                        }, (0, d.xr)());
                        invariant(void 0 !== r && void 0 !== n, "justEndedTasks and isShowingThePast parameters are required for taskGroups with endedTasksStates");
                        const {
                            endedTodayTasks: b,
                            endedBeforeTodayTasks: y,
                            activeAndJustEndedTasks: v
                        } = (0, m.rq)(u, r), w = null == a ? void 0 : a.find((e => e.groupId === i)), k = 0 < v.length, x = ((e, t, s, n, a) => {
                            const o = 0 < s.length,
                                r = "number" == typeof e ? e : 0,
                                i = n.length > r || !!a;
                            return {
                                endedTasksState: e,
                                nextEndedTasksState: p(e, o, i),
                                hasEndedToday: o,
                                isCollapsed: t,
                                endedTodayCounters: g(s)
                            }
                        })(w ? w.state : "hidden", h, k ? b : [], y, c), j = x.endedTasksState ? ((e, t, s, n) => {
                            const {
                                activeAndJustEndedTasks: a,
                                endedTodayTasks: o,
                                endedBeforeTodayTasks: r
                            } = (0, m.rq)(e, s);
                            return n ? [...a, ...o, ...r] : "number" == typeof t ? [...a, ...o, ...r.slice(0, t)] : "showingEndedToday" === t ? [...a, ...o] : a
                        })(u, x.endedTasksState, r, n) : u;
                        return Object.assign({
                            root: e,
                            items: j,
                            tasks: u
                        }, x, {
                            isCollapsed: h,
                            hasFooter: f(x.endedTasksState, x.nextEndedTasksState, j, n)
                        })
                    })),
                    b = i ? h.filter(i) : h,
                    [v, w] = u.useState([]),
                    k = function(e, t) {
                        if (e.length !== t.length) return !0;
                        return e.some(((e, s) => {
                            return n = e, a = t[s], Object.keys(a).some((e => {
                                switch (e) {
                                    case "root":
                                        return a.root !== n.root;
                                    case "tasks":
                                        return y(a.tasks, n.tasks);
                                    case "items":
                                        return y(a.items, n.items);
                                    case "isCollapsed":
                                        return a.isCollapsed !== n.isCollapsed;
                                    case "hasFooter":
                                        return a.hasFooter !== n.hasFooter;
                                    case "hasEndedToday":
                                        return a.hasEndedToday !== n.hasEndedToday;
                                    case "endedTasksState":
                                        return a.endedTasksState !== n.endedTasksState;
                                    case "nextEndedTasksState":
                                        return a.nextEndedTasksState !== n.nextEndedTasksState;
                                    case "endedTodayCounters":
                                        return a.endedTodayCounters.completed !== n.endedTodayCounters.completed || a.endedTodayCounters.abandoned !== n.endedTodayCounters.abandoned;
                                    default:
                                        return e
                                }
                            }));
                            var n, a
                        }))
                    }(v, b),
                    x = k ? b : v;
                k && w(b);
                const j = u.useMemo((() => (e => e.reduce(((e, t) => [...e, ...t.items]), []))(x)), [x]);
                return {
                    taskGroups: x,
                    sortedTasks: j
                }
            };

        function y(e, t) {
            return t.length !== e.length || t.some(((t, s) => t !== e[s]))
        }
        var v = s(65),
            w = s(1556),
            k = s(40),
            x = s(226),
            j = s(97);
        const T = Object.freeze({
            ResponsibleFor: "responsible_for",
            ParticipatedIn: "participated_in"
        });
        var S = s(1);
        const P = n.Hocs.compose(n.Hocs.withObservables(["counters"], (({
            counters: e
        }) => ({
            counters: n.Rx.wrap(e)
        }))))((e => {
            const {
                type: t,
                tasks: s,
                isLast: a,
                markGroupAsRead: o,
                counters: r
            } = e, [i, c] = function(e) {
                const t = n.Hooks.useIntl();
                return {
                    [T.ResponsibleFor]: [t.f.x, "ƶ"],
                    [T.ParticipatedIn]: [t.f.w, "Á"]
                } [e]
            }(t);
            return (0, S.jsx)(j.Z, {
                left: (0, S.jsx)(k.default, {
                    layers: [{
                        iconName: c,
                        color: "textSecondary",
                        size: 24
                    }]
                }),
                right: (0, S.jsx)(x.default, {
                    type: "activity",
                    initialColor: "onBackground3",
                    onPress: () => {
                        o(s)
                    }
                }),
                hasHairline: !a && !s.length,
                adjustsFontSizeToFit: !0,
                counters: null == r ? void 0 : r.activeTasks,
                tasks: s,
                viewColor: "activity",
                children: i
            })
        }));
        async function _(e, t, s) {
            const a = await t.author.fetch();
            if (a) {
                const e = await n.Rx.takeFirst(a.preferredName);
                switch (t.type) {
                    case "created":
                        return s.g("q", {
                            authorName: e
                        });
                    case "restored":
                        return s.g("v", {
                            authorName: e
                        });
                    case "ended":
                        return s.g("s", {
                            authorName: e
                        });
                    default:
                        throw new Error("Unknown event type: " + t.type)
                }
            }
            const o = {
                    created: s.f.p,
                    restored: s.f.u,
                    ended: s.f.r
                } [t.type],
                r = e.isFollowed ? null : s.f.t;
            return (0, i.sY)(o, r)
        }
        const C = {
            created: "Ů",
            restored: "Ű",
            ended: "ŭ"
        };

        function R(e, t) {
            return t ? C[t.type] : n.Styling.getProjectIcon(e)
        }
        const A = n.ReactUtils.lazy((() => s(750))),
            I = n.ReactUtils.lazy((() => s(1380))),
            N = ["created", "restored"],
            E = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withWebLazyRender((({
                isAboveTheFold: e,
                event: t,
                project: s
            }) => ({
                forceShow: e,
                spacerHeight: t || !s.isFollowed ? 72 : 56
            }))), n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                project: e
            }))), n.Hocs.withObservables(["project", "event", "intl"], (({
                project: e,
                event: t,
                intl: s
            }) => ({
                description: t ? n.Rx.from(_(e, t, s)) : n.Rx.of("")
            }))), n.Hocs.withObservables(["counters"], (({
                counters: e
            }) => ({
                counters: n.Rx.wrap(e)
            }))))((e => {
                const {
                    project: t,
                    tasks: s,
                    isLast: a,
                    event: o,
                    counters: r,
                    description: i
                } = e, c = n.Hooks.useIntl(), l = o ? N.includes(o.type) : t.isActive, d = l && !!s.length, u = n.Hooks.useModalState(), m = n.Hooks.useModalState(), h = l && o ? m : u, p = (() => {
                    const e = {
                            iconName: "Ŭ",
                            color: n.Styling.defaultTextSecondary(t.color),
                            size: 24,
                            opacity: .2
                        },
                        s = [...o ? [e] : [], {
                            iconName: R(t, o),
                            color: n.Styling.defaultTextSecondary(t.color),
                            size: 24
                        }];
                    return (0, S.jsx)(k.default, {
                        layers: s
                    })
                })();
                return (0, S.jsxs)(S.Fragment, {
                    children: [(0, S.jsx)(j.Z, {
                        left: p,
                        right: (0, S.jsx)(x.default, {
                            type: "activity",
                            initialColor: "onBackground3",
                            onPress: async () => {
                                await e.markGroupAsRead(s, t)
                            }
                        }),
                        description: i,
                        isEnded: t.isEnded,
                        hasHairline: !a && !s.length,
                        menuTarget: h.target,
                        onMenuPress: h.open,
                        hasThreeDots: !0,
                        counters: d ? null == r ? void 0 : r.activeTasks : null,
                        tasks: s,
                        viewColor: "activity",
                        children: n.Styling.getProjectName(t, c)
                    }), u.isOpen ? (0, S.jsx)(A, {
                        project: t,
                        target: u.target,
                        closeMenu: u.close
                    }) : null, m.isOpen && o ? (0, S.jsx)(I, {
                        project: t,
                        eventType: o.type,
                        onClose: m.close
                    }) : null]
                })
            }));

        function O(e) {
            return e.isEnded && !e.isThread
        }

        function M(e, t) {
            return e.length !== t.length || e.some(((e, s) => e !== t[s]))
        }
        const D = n.ReactUtils.lazy((() => s(1381))),
            H = ["responsible_for", "participated_in"],
            F = e => !H.includes(e.root) || 0 < e.items.length,
            Z = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withIdentity, n.Hocs.withServices, n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                singleTasks: e.singleTasks
            }))), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e,
                services: t
            }) => ({
                justReadTasks: t.uiState.forTeam(e).justReadTasks,
                justEndedTasks: t.uiState.forTeam(e).justEndedTasks
            }))), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e,
                services: t,
                singleTasks: s,
                intl: a
            }) => ({
                tasks: e.activityTasks.pipe(n.Rx.switchMap((e => e.pipe(m.ct)))),
                eventsWithProjects: e.projectEventsInUnseenProjects.pipe(n.Rx.switchMap((e => e.observe())), n.Rx.switchMap((e => {
                    const o = e.slice(0, 150),
                        r = n.FP.groupBy((e => e.project.id), o);
                    return (0, v.Dp)(t.database, o, s, a).pipe(n.Rx.map((e => {
                        const t = {
                            events: [],
                            projects: []
                        };
                        return e.forEach((e => {
                            const s = (0, w.m)(e)(r[e.id]);
                            s && (t.events.push(s), t.projects.push(e))
                        })), t
                    })))
                })))
            }))), n.Hocs.withHooks((({
                tasks: e,
                currentMember: t,
                justReadTasks: s,
                justEndedTasks: a
            }) => {
                const o = n.React.useMemo((() => (0, m.aZ)(n.FP.descend(n.FP.prop("projectPosition")), n.FP.unique([...s, ...a, ...e]), a, !1)), [s, a, e]),
                    {
                        assignedTasks: r,
                        followedTasks: i,
                        otherTasks: c
                    } = n.React.useMemo((() => o.reduce(((e, s) => {
                        var n;
                        return (null == (n = s.responsible) ? void 0 : n.id) === t.id ? e.assignedTasks.push(s) : s.isFollowed ? e.followedTasks.push(s) : e.otherTasks.push(s), e
                    }), {
                        assignedTasks: [],
                        followedTasks: [],
                        otherTasks: []
                    })), [o, t]);
                return {
                    assignedTasks: r,
                    followedTasks: i,
                    otherTasks: c
                }
            })), n.Hocs.withObservables(["otherTasks", "singleTasks"], (({
                otherTasks: e,
                singleTasks: t,
                services: {
                    database: s
                },
                intl: n
            }) => ({
                taskProjects: (0, v.Dp)(s, e, t, n)
            }))))((e => {
                const {
                    currentTeam: t,
                    eventsWithProjects: s,
                    taskProjects: u,
                    assignedTasks: h,
                    followedTasks: p,
                    otherTasks: g,
                    services: f,
                    singleTasks: y
                } = e, v = n.Hooks.useIntl(), w = n.Hooks.useModalState();
                n.React.useEffect((() => {
                    f.uiState.forTeam(t).clearJustReadTasks()
                }), [f.uiState, t]);
                const {
                    events: k,
                    projects: x
                } = s, j = n.React.useMemo((() => n.FP.unique([...x, ...u])), [x, u]), T = n.React.useMemo((() => [...H, ...j]), [j]), {
                    taskGroups: _,
                    sortedTasks: C
                } = (n.React.useCallback(((e, t) => "responsible_for" === e ? h : "participated_in" === e ? p : (invariant(e instanceof n.Model.Models.Project, "Section root is not an instance of a Project"), t.get(e.id) || [])), [h, p]), b({
                    sections: T,
                    groupTasksBySection: () => {
                        const e = (0, d.f5)(g, y);
                        return e.set("responsible_for", h), e.set("participated_in", p), e
                    },
                    endedTasksStates: null,
                    shouldRenderSection: F
                })), R = function(e, t) {
                    const [s, a] = n.React.useState({
                        assignedTasks: e,
                        followedTasks: t
                    });
                    (M(s.assignedTasks, e) || M(s.followedTasks, t)) && a({
                        assignedTasks: e,
                        followedTasks: t
                    });
                    const o = n.React.useMemo((() => {
                        const e = new Map;
                        return s.assignedTasks.forEach((t => {
                            e.set(t, !0)
                        })), s.followedTasks.forEach((t => {
                            e.set(t, !0)
                        })), e
                    }), [s]);
                    return n.React.useCallback((e => o.has(e)), [o])
                }(h, p), A = function() {
                    const {
                        native: e,
                        uiState: t,
                        database: s
                    } = n.Hooks.useServices(), {
                        currentTeam: a
                    } = n.Hooks.useIdentity(), o = n.Hooks.useIntl(), r = n.React.useCallback((async (t, n) => {
                        e.haptics.success(), n ? await n.do.markAsNotSeenWithTasks(t) : await (0, m.gq)(t, s)
                    }), [s, e]);
                    return n.React.useCallback((async (i, l) => {
                        if (e.haptics.success(), t.forTeam(a).removeJustReadTasks(i), l) await l.do.markAsSeenWithTasks(i), t.pushSnackbar({
                            message: o.g("Jh", {
                                projectName: n.Styling.getProjectName(l, o)
                            }),
                            buttonColor: "activity",
                            onButtonPress: () => {
                                r(i, l)
                            }
                        });
                        else {
                            await (0, m.kQ)(i, s);
                            const e = 1 === i.length ? o.g("Jf", {
                                taskName: (0, S.jsx)(c.Z, {
                                    task: i[0]
                                })
                            }) : o.g("Jg", {
                                numberOfTasks: i.length
                            });
                            t.pushSnackbar({
                                message: e,
                                buttonColor: "activity",
                                onButtonPress: () => {
                                    r(i, l)
                                }
                            })
                        }
                    }), [a, s, e, t, o, r])
                }(), I = (0, l.x)(C, v.f.y), N = n.Rx.of(C.filter((e => e.isUnread)).length), Z = (0, i._d)(_), L = (0, d.Or)(a.routeToTaskListTask), {
                    newTaskFormProps: B
                } = (0, d.G8)({
                    rootRecord: null,
                    defaultProject: y,
                    taskGroups: _
                }), z = n.React.useCallback((e => {
                    f.uiState.pushSnackbar({
                        onButtonPress: async () => {
                            await e.do.markAsUnread(e.lastSeenActivityAt)
                        },
                        buttonColor: "activity",
                        message: v.g("Jf", {
                            taskName: (0, S.jsx)(c.Z, {
                                task: e
                            })
                        })
                    })
                }), [v, f]), U = n.React.useCallback((e => (e && "string" != typeof e ? k.find((t => t.project.id === e.id)) : null) ? 72 : 56), [k]), W = n.React.useCallback(((e, t) => {
                    const s = _.find((({
                            root: t
                        }) => t === e)),
                        a = function(e) {
                            return null === e ? "NULL" : "string" == typeof e ? e : e.id
                        }(e);
                    invariant(s, "Unexpected missing group for " + a);
                    const o = null == Z ? void 0 : Z.groups.get(s),
                        r = n.FP.isLastOnList(_.indexOf(s), _);
                    if ("string" != typeof e) {
                        invariant(e instanceof n.Model.Models.Project, "Matched project group to a non-project activity header");
                        const a = k.find((t => t.project.id === e.id)),
                            {
                                items: i
                            } = s;
                        return (0, S.jsx)(E, {
                            event: a,
                            tasks: i,
                            project: e,
                            isLast: r,
                            markGroupAsRead: A,
                            isAboveTheFold: t,
                            counters: o
                        }, "section_header-" + e.id)
                    }
                    const {
                        items: i
                    } = s;
                    return (0, S.jsx)(P, {
                        type: e,
                        tasks: i,
                        isLast: r,
                        markGroupAsRead: A,
                        counters: o
                    }, "section_header-" + e)
                }), [k, _, A, Z]);
                return (0, S.jsx)(i.MV, {
                    counters: Z,
                    children: (0, S.jsxs)(o.Z, {
                        rootRecord: t,
                        taskDetailsProps: L,
                        menuTarget: w.target,
                        openViewMenu: w.open,
                        title: v.f.y,
                        leftIcon: "±",
                        activeTasksCounter: N,
                        displayMasterPlusButton: !0,
                        masterPlusButtonStyle: "quickAdd",
                        onMasterPlusPress: () => f.uiState.quickAddModal.open(),
                        color: "activity",
                        sortedTasks: C,
                        children: [(0, S.jsx)(r.Z, {
                            taskGroups: _,
                            filterState: null,
                            rootRecord: t,
                            viewColor: "activity",
                            getSectionHeaderLength: U,
                            renderSectionHeader: W,
                            isProjectVisible: R,
                            shouldHighlightUnreadComments: O,
                            isSectionVisible: !0,
                            hasMasterPlus: !0,
                            markAsType: "activity",
                            onMarkAsSwipe: z,
                            withSwipeLeft: !0,
                            emptyListTitle: v.f.n,
                            emptyListMessage: v.f.m,
                            newTaskFormProps: B
                        }), w.isOpen ? (0, S.jsx)(D, {
                            closeMenu: w.close,
                            target: w.target,
                            saveToCSV: I
                        }) : null]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => be
        });
        var n = s(0),
            a = s(189),
            o = s(21),
            r = s(903),
            i = s(14),
            c = s(171),
            l = s(70),
            d = s(29),
            u = s(74),
            m = s(75),
            h = s(48),
            p = s(44),
            g = s(1364),
            f = s(1558),
            b = s(47),
            y = s(278),
            v = s(41),
            w = s(1471),
            k = s(146),
            x = s(64),
            j = s(272),
            T = s(192),
            S = s(1472),
            P = s(856),
            _ = s(1473),
            C = s(120),
            R = s(1468),
            A = s(274),
            I = s(102),
            N = s(1466),
            E = s(89),
            O = s(78),
            M = s(318);
        const {
            Tables: D,
            Columns: H,
            Q: F
        } = n.Model;

        function Z(e, t) {
            const s = {};
            return e.forEach((e => {
                const n = t(e);
                n && (s[e.id] = n)
            })), {
                tasks: e,
                tasksDateMap: s
            }
        }

        function L(e) {
            return t => {
                const s = B(e);
                return t.extend(...s).observeWithColumns(d.yw)
            }
        }

        function B(e) {
            return (0, E.Z)((0, l.LB)(e))
        }

        function z(e, t, s, a, r = !0) {
            return i => {
                const [c, l, u] = i, m = n.FP.uniqWith(((e, t) => e.id === t.id), [...c.tasks, ...l.tasks, ...u.tasks]), h = Object.assign({}, l.tasksDateMap, u.tasksDateMap, c.tasksDateMap);
                return (0, d.c_)(e, t, m, s, a).pipe(n.Rx.map((e => e.reduce(((e, s) => {
                    const n = h[s.id];
                    if (!n) return e;
                    const a = (e => (0, o.isDayBeforeDay)(e, new Date))(n) && (s.dates.isOverdue || t.includes(s) || "reminder" === s.reviewReason),
                        i = a && r ? M.k.OVERDUE : U(n);
                    return e[i] ? e[i].push(s) : e[i] = [s], e
                }), {}))))
            }
        }

        function U(e) {
            return (0, v.Z)(e).getTime().toString()
        }
        var W = s(62),
            G = s(50),
            V = s(1);
        const q = n.ReactUtils.lazy((() => s(1388))),
            Q = n.ReactUtils.lazy((() => s(1389))),
            Y = ({
                toggleSectionCollapse: e,
                isSectionCollapsed: t,
                taskGroups: s,
                newTaskFormProps: {
                    setPositionGroup: n,
                    onShow: a
                },
                taskDetailsProps: o,
                counters: r
            }) => i => {
                invariant("string" == typeof i, "Calendar header groupType is not a string");
                const c = s.find((e => e.root === i)),
                    l = c ? null == r ? void 0 : r.groups.get(c) : null,
                    d = i === M.k.OVERDUE || (0, T.Z)(new Date(Number(i)), (0, v.Z)(new Date)),
                    u = t(i),
                    m = () => e(i),
                    h = d ? void 0 : () => {
                        u && m(), a(), n({
                            position: "top",
                            section: i
                        })
                    };
                return (0, V.jsx)(q, {
                    groupRoot: i,
                    onNewTaskFormShow: h,
                    taskGroup: c,
                    counters: l,
                    taskDetailsProps: o,
                    isCollapsed: u,
                    onToggleCollapse: m
                })
            },
            J = (e, t) => {
                const {
                    root: s
                } = e;
                return invariant("string" == typeof s, "Calendar groupType is not a string"), (0, V.jsx)(W.Z, {
                    id: "" + G.M.droppable + s,
                    type: G.x.TASK,
                    children: t
                }, "droppable-" + s)
            };
        var K = s(188),
            $ = s(87),
            X = s(114);
        const ee = (e, t, s, a, r, i) => {
            const l = n.Hooks.useServices(),
                {
                    currentTeam: u
                } = n.Hooks.useIdentity(),
                m = n.Hooks.useIntl(),
                h = n.React.useCallback((async n => {
                    if (l.payments.remindExpired(u)) return;
                    const {
                        destination: h,
                        draggableId: p
                    } = n;
                    if (!h) return;
                    const g = e.find((e => e.root === n.source.droppableId));
                    invariant(g, "Unexpected missing sourceSection");
                    const f = e.find((e => e.root === h.droppableId));
                    if (!f) return;
                    if (p === X.U3) return void s(f.root);
                    if (f.root === M.k.OVERDUE && g.root !== M.k.OVERDUE) return;
                    const b = g.items[n.source.index];
                    invariant(b, "Unexpected missing draggedTask");
                    const y = async () => {
                        if (r) return;
                        const e = (0, c.A)(b, f.items, h.index, a, i);
                        await l.database.write((() => l.database.batch(e)))
                    }, v = async (e, s) => {
                        e ? t((async () => {
                            await s()
                        })) : await s()
                    }, w = async e => {
                        const t = b.reviewTriggeredAt;
                        await e();
                        const s = b.reviewTriggeredAt;
                        (null == t ? void 0 : t.getTime()) === (null == s ? void 0 : s.getTime()) && await (0, $.markTaskAsReviewedWithSnackbar)(l, m, b, u)
                    }, k = async e => {
                        v((0, d.GY)(e), (async () => {
                            await y(), (0, o.dateTimeEquals)(e, b.dates.dueDate) || w((() => b.dates.do.updateDueDate(e)))
                        }))
                    }, {
                        dueDate: x
                    } = b.dates;
                    if (f.root === g.root) return void await y();
                    const S = o.DateTime.onDay(new Date(Number(f.root)));
                    if (g.root === M.k.OVERDUE) {
                        if (x) return void k(te(x, S));
                        const e = o.DateTime.onDay(new Date);
                        return S.equals(e) || S.isBefore(e) ? void k(S) : (await y(), void w((() => b.dates.do.updateReminders({
                            added: [{
                                at: S
                            }],
                            removed: []
                        }))))
                    }
                    const P = o.DateTime.onDay(new Date(Number(g.root)));
                    if (x && (0, C.Z)(x.local, P.local)) return void k(te(x, S));
                    const _ = await b.dates.reminders.fetch(),
                        R = (0, O.Fv)(_, b.dates.dueDate).find((e => {
                            const t = (0, O.lM)(e.remindAt, b.dates.dueDate);
                            return (0, C.Z)(t, P.local)
                        })),
                        A = R ? function(e, t, s, n) {
                            const a = function(e, t, s) {
                                if (e.isRelative) {
                                    const n = s.local.getTime() - t.local.getTime(),
                                        a = e.remindAt.dueDateOffset;
                                    return invariant(a, "Missing dueDateOffset for relative reminder"), {
                                        dueDateOffset: a + n
                                    }
                                }
                                const n = e.remindAt.at;
                                return invariant(n, "Missing remindAt for absolute reminder"), {
                                    at: te(n, s)
                                }
                            }(e, t, s);
                            if (((e, t) => {
                                    if (e.at) {
                                        const t = e.at.isAllDay ? (0, I.Z)(new Date) : new Date;
                                        return (0, T.Z)(e.at.local, t)
                                    }
                                    invariant(t, "Relative reminder without due date");
                                    const {
                                        dueDateOffset: s
                                    } = e, n = t.isAllDay ? (0, I.Z)(new Date) : new Date;
                                    return (0, T.Z)((0, K.Z)(t.local, s), n)
                                })(a, n)) {
                                if ((0, C.Z)(s.local, new Date)) {
                                    const e = (0, j.Z)(new Date, 30);
                                    return {
                                        at: s.withTime([e.getHours(), e.getMinutes()])
                                    }
                                }
                                return null
                            }
                            return a
                        }(R, P, S) : {
                            at: S
                        };
                    A && v(!1, (async () => {
                        await y(), R && (0, O.nd)(R.remindAt, A) || w((() => b.dates.do.updateReminders({
                            added: [A],
                            removed: R ? [R.remindAt] : []
                        })))
                    }))
                }), [l, u, e, s, t, a, r, i, m]);
            return h
        };

        function te(e, t) {
            return e.withDay(t)
        }
        var se = s(857),
            ne = s(144),
            ae = s(273),
            oe = s(858),
            re = s(190),
            ie = s(282),
            ce = s(850),
            le = s(1469),
            de = s(821),
            ue = s(1470);
        const me = (e, t, s) => {
                const n = null != s ? s : new Date;
                return t ? {
                    isAtNext30Days: !0,
                    selectedDate: n,
                    startingDate: (0, v.Z)(n),
                    endDate: (0, x.Z)((0, I.Z)(n), 30)
                } : {
                    isAtNext30Days: !0,
                    selectedDate: n,
                    startingDate: (0, ne.Z)(n, (0, o.weekStartsOn)(e)),
                    endDate: (0, ae.Z)(n, (0, o.weekStartsOn)(e))
                }
            },
            he = (e, t, s) => {
                const [a, r] = n.React.useReducer((e => (t, s) => {
                    const n = new Date;
                    switch (s.type) {
                        case "today":
                            return Object.assign({}, me(e, s.isMonthlyView), {
                                focusOnOverdue: s.focusOnOverdue
                            });
                        case "next_week": {
                            const s = (0, se.Z)(t.startingDate, 1);
                            return Object.assign({}, t, {
                                focusOnOverdue: !1,
                                isAtNext30Days: (0, R.Z)(s, (0, o.weekStartsOn)(e)),
                                startingDate: (0, ne.Z)(s, (0, o.weekStartsOn)(e)),
                                endDate: (0, ae.Z)(s, (0, o.weekStartsOn)(e)),
                                selectedDate: void 0
                            })
                        }
                        case "next_month": {
                            if ((0, oe.Z)(t.startingDate, n) && !t.isAtNext30Days) return me(e, !0);
                            const s = (0, re.Z)(t.startingDate, 1);
                            return Object.assign({}, t, {
                                focusOnOverdue: !1,
                                startingDate: (0, ie.Z)(s),
                                endDate: (0, ce.Z)(s),
                                isAtNext30Days: !1,
                                selectedDate: void 0
                            })
                        }
                        case "previous_week": {
                            const s = (0, le.Z)(t.startingDate, 1);
                            return Object.assign({}, t, {
                                focusOnOverdue: !1,
                                isAtNext30Days: (0, R.Z)(s, (0, o.weekStartsOn)(e)),
                                startingDate: (0, ne.Z)(s, (0, o.weekStartsOn)(e)),
                                endDate: (0, ae.Z)(s, (0, o.weekStartsOn)(e)),
                                selectedDate: void 0
                            })
                        }
                        case "previous_month": {
                            if (t.isAtNext30Days) return Object.assign({}, t, {
                                focusOnOverdue: !1,
                                startingDate: (0, ie.Z)(t.startingDate),
                                endDate: (0, ce.Z)(t.startingDate),
                                isAtNext30Days: !1,
                                selectedDate: void 0
                            });
                            const s = (0, de.Z)(t.startingDate, 1);
                            return (0, oe.Z)(s, n) ? me(e, !0) : Object.assign({}, t, {
                                focusOnOverdue: !1,
                                startingDate: (0, ie.Z)(s),
                                endDate: (0, ce.Z)(s),
                                isAtNext30Days: !1,
                                selectedDate: void 0
                            })
                        }
                        case "select_date":
                            return s.isMonthlyView ? Object.assign({}, t, {
                                focusOnOverdue: !1,
                                isAtNext30Days: (0, ue.Z)(s.date),
                                selectedDate: s.date,
                                startingDate: (0, ie.Z)(s.date),
                                endDate: (0, ce.Z)(s.date)
                            }) : Object.assign({}, t, {
                                focusOnOverdue: !1,
                                isAtNext30Days: (0, R.Z)(s.date, (0, o.weekStartsOn)(e)),
                                selectedDate: s.date,
                                startingDate: (0, ne.Z)(s.date, (0, o.weekStartsOn)(e)),
                                endDate: (0, ae.Z)(s.date, (0, o.weekStartsOn)(e))
                            });
                        default:
                            throw new Error("Unknown action type: " + s.type)
                    }
                })(e), me(e, s, t));
                return [a, r]
            },
            pe = n.ReactUtils.lazy((() => s(1390))),
            ge = "calendar",
            fe = n.ReactUtils.createQueryParamParser("start_date"),
            be = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e,
                services: t
            }) => ({
                singleTasks: e.singleTasks,
                isTeamOfOne: e.isTeamOfOne,
                justEndedTasks: t.uiState.forTeam(e).justEndedTasks
            }))), n.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                firstWeekday: n.Rx.from(e.native.fetchFirstWeekday()),
                isMonthlyView: e.modelRoot.settings.isCalendarViewMonth.observe()
            }))), n.Hocs.withHooks((({
                isMonthlyView: e,
                firstWeekday: t,
                currentTeam: s
            }) => {
                const a = (0, p.Nk)(null, !0),
                    {
                        search: o
                    } = n.Hooks.useLocation(),
                    r = fe(o),
                    i = r ? new Date(Number(r)) : null,
                    [c, l] = he(t, i, e);
                return Object.assign({
                    state: c,
                    dispatch: l,
                    viewId: s.id + "/calendar"
                }, a)
            })), (0, l.hp)((({
                currentMember: e,
                isTeamOfOne: t,
                viewId: s
            }) => ({
                viewId: s,
                initialState: {
                    filterResponsibles: t ? void 0 : [e.id],
                    sort: {
                        by: "dueDate",
                        order: "ascending"
                    },
                    disabledOptions: ["groupBy"]
                }
            }))), n.Hocs.withObservables(["filterState", "viewId"], (({
                services: e,
                filterState: t,
                viewId: s
            }) => ({
                tasksPositionMap: t.sort ? n.Rx.of({}) : (0, c.C)(s, e.collections)
            }))), n.Hocs.withIntl, n.Hocs.withObservables(["state", "filterState", "isShowingThePast", "currentMember", "tasksPositionMap", "justEndedTasks"], (({
                state: e,
                currentTeam: t,
                filterState: s,
                intl: r,
                isShowingThePast: i,
                firstWeekday: c,
                currentMember: l,
                tasksPositionMap: u,
                justEndedTasks: m
            }) => ({
                groupedTasks: n.Rx.nowAndEveryDay().pipe(n.Rx.switchMap((() => {
                    var r;
                    const d = new Date,
                        u = i || !(0, R.Z)(e.startingDate, (0, o.weekStartsOn)(c)) ? e.startingDate : (0, w.Z)([d, e.startingDate]),
                        h = o.DateTime.onDay(u),
                        p = o.DateTime.onDay(e.endDate),
                        g = null != (r = s.filterResponsibles) && r.includes(l.id) ? n.FP.omit(["filterResponsibles"], s) : s,
                        f = t.calendarDueTasks(h, p, e.isAtNext30Days || i).pipe(n.Rx.switchMap((e => e.pipe(L(s)))), n.Rx.map((e => Z(e, (e => {
                            const {
                                endedAt: t,
                                dates: {
                                    dueDate: s
                                }
                            } = e;
                            if (t && s && m.includes(e)) return s.local;
                            const a = t || (null == s ? void 0 : s.local);
                            return a || (n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL, "Task has no due date, nor it is ended but still it has been picked for calendar " + e.id), null)
                        }))))),
                        b = t.activeRemindersBetween(h, p).pipe((e => e.pipe(function(e, t, s) {
                            return a => a.observe().pipe(n.Rx.switchMap((o => {
                                const {
                                    database: r
                                } = a.collection, i = n.FP.groupBy((e => e.task.id), o), c = Object.keys(i), l = B(e), d = (0, v.Z)(t.local), u = (0, I.Z)(s.local);
                                return r.collections.get(D.tasks).query(F.where(H.id, F.oneOf(c)), ...l).observe().pipe(n.Rx.map((e => Z(e, (e => {
                                    const t = i[e.id].map((t => {
                                        const s = (0, O.lM)(t.remindAt, e.dates.dueDate);
                                        return (0, T.Z)(s, d) || (0, y.Z)(s, u) ? null : s
                                    })).filter(Boolean);
                                    return t.length ? (0, N.Z)(t) : null
                                })))))
                            })))
                        }(g, h, p)))),
                        k = (0, a.Z)(d, {
                            start: h.local,
                            end: p.local
                        }) ? t.triggeredReminders.pipe(n.Rx.switchMap((e => e.pipe(L(g)))), n.Rx.map((e => Z(e, (e => {
                            const {
                                reviewTriggeredAt: t,
                                doesNeedReview: s
                            } = e;
                            return t && s ? (0, o.isDayBeforeDay)(t, d) ? (0, A.Z)(d, 1) : d : (n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL, "Task is not a triggered reminder but in calendar " + e.id), null)
                        }))))) : n.Rx.of({
                            tasks: [],
                            tasksDateMap: {}
                        });
                    return n.Rx.combineLatest(f, b, k)
                })), n.Rx.switchMap(z(s.sort, m, r, u, (0, R.Z)(e.startingDate, (0, o.weekStartsOn)(c))))),
                tasksWithRecurrence: t.tasksWithRecurrence.pipe(n.Rx.switchMap((e => e.pipe(function(e) {
                    return t => {
                        const s = B(e);
                        return t.extend(...s).observeWithColumns(d.yw).pipe(n.Rx.switchMap((e => n.Rx.from(n.FP.filterAsync((e => {
                            var t;
                            return null == (t = e.dates) ? void 0 : t.isCurrentRecurringInstance()
                        }), e)))), n.Rx.switchMap((e => n.Rx.combineLatestTuples(e.map((e => [e, e.dates.recurrence.observe()]))))))
                    }
                }(s)))), n.Rx.switchMap((e => {
                    const t = new Map(e);
                    return (0, d.c_)(s.sort, m, e.map((([e]) => e)), r, u).pipe(n.Rx.map((e => e.map((e => [e, t.get(e)])))))
                })))
            }))))((e => {
                var t;
                const {
                    currentTeam: s,
                    state: a,
                    dispatch: c,
                    filterState: l,
                    setFilterState: d,
                    groupedTasks: R,
                    isShowingThePast: A,
                    toggleShowThePast: I,
                    endedTasksStates: N,
                    firstWeekday: E,
                    isMonthlyView: O,
                    singleTasks: D,
                    tasksWithRecurrence: H,
                    justEndedTasks: F,
                    setEndedTasksState: Z,
                    tasksPositionMap: L,
                    viewId: B
                } = e, z = n.React.useMemo((() => ((e, t, s) => e.map((([e, n]) => {
                    const {
                        dueDate: a,
                        recurrenceOrigin: i
                    } = e.dates;
                    if (n && a && i) {
                        const c = new r.Z({
                                pattern: n.rawPattern,
                                startDay: i.day
                            }),
                            l = new Date,
                            d = (0, T.Z)(l, (0, S.Z)((0, v.Z)(l), 4)) ? l : (0, x.Z)(l, 1),
                            u = o.DateTime.onDay((0, w.Z)([t, a.local, d])),
                            m = o.DateTime.onDay(s),
                            h = c.between(u, m),
                            p = a.isAllDay ? h : h.map((e => e.withTime(a.time)));
                        return p.length ? [e, p] : null
                    }
                    return null
                })).filter(Boolean))(H, a.startingDate, a.endDate)), [H, a.startingDate, a.endDate]), W = n.Hooks.useServices(), G = n.Hooks.useIntl(), q = n.Hooks.useModalState(), {
                    currentMember: K
                } = n.Hooks.useIdentity(), {
                    isAtNext30Days: $,
                    startingDate: X
                } = a, te = $ && O ? G.f.gc : "" + G.formatDate(X, {
                    month: "long",
                    year: (0, P.Z)(X) ? void 0 : "numeric"
                }) + (O ? "" : G.g("f_", {
                    weekOfMonth: (0, _.Z)(X, (0, o.weekStartsOn)(E))
                })), se = ((e, t, s, a) => {
                    const o = (n => {
                            const o = new Date;
                            if ((0, y.Z)(o, s)) return Object.keys(e);
                            const r = (0, v.Z)(a ? t : (0, w.Z)([t, o])),
                                i = (0, k.Z)(s, r);
                            return [...null != (n = e.OVERDUE) && n.length ? [M.k.OVERDUE] : [], ...Array.from({
                                length: i + 1
                            }, ((e, t) => (0, x.Z)(r, t).getTime().toString()))]
                        })(),
                        r = (0, j.Z)((0, v.Z)(Date.now()), -1);
                    return n.FP.sortWith([n.FP.ascend((e => e === M.k.OVERDUE ? r : new Date(Number(e))))], o)
                })(R, a.startingDate, a.endDate, A), {
                    collapsedSectionsStates: ne,
                    toggleSectionCollapse: ae
                } = (0, p.SK)(), oe = (0, p.Or)(i.routeToTaskListTask), {
                    taskGroups: re,
                    sortedTasks: ie
                } = (0, g.U)({
                    sections: se,
                    listRootId: ge,
                    collapsedSectionsStates: ne,
                    getTasksForSection: e => {
                        const t = new Date(Number(e)),
                            s = z.map((([e, s]) => {
                                if (!e.dates.dueDate || (0, C.Z)(e.dates.dueDate.local, t)) return null;
                                const n = s.find((e => (0, C.Z)(e.local, t)));
                                if (!n) return null;
                                const a = e.makeGhost(n);
                                return a._raw.id += "_recurr:" + n.timestamp, a
                            })).filter(Boolean);
                        return [...R[e] || [], ...s]
                    },
                    endedTasksStates: N,
                    isShowingThePast: A,
                    justEndedTasks: F
                }), ce = n.Rx.of(ie.filter((e => !e.isEnded)).length), le = (0, b.x)(ie, te), de = (0, h.W$)(re), ue = (({
                    goToToday: e,
                    goForward: t,
                    goBack: s,
                    selectedDate: n,
                    setSelectedDate: a,
                    hasOverdue: o,
                    showWeeklyView: r
                }) => {
                    var i;
                    return () => i || (i = (0, V.jsx)(Q, {
                        goToToday: e,
                        goForward: t,
                        goBack: s,
                        hasOverdue: o,
                        selectedDate: n,
                        setSelectedDate: a,
                        showWeeklyView: r
                    }))
                })({
                    goBack: () => {
                        c(O ? {
                            type: "previous_month"
                        } : {
                            type: "previous_week"
                        })
                    },
                    goForward: () => {
                        c(O ? {
                            type: "next_month"
                        } : {
                            type: "next_week"
                        })
                    },
                    goToToday: e => {
                        c({
                            type: "today",
                            focusOnOverdue: e,
                            isMonthlyView: O
                        })
                    },
                    hasOverdue: !(null == (t = R.OVERDUE) || !t.length),
                    selectedDate: a.selectedDate || a.startingDate,
                    setSelectedDate: e => {
                        c({
                            type: "select_date",
                            date: e || new Date,
                            isMonthlyView: O
                        })
                    },
                    showWeeklyView: !O
                }), {
                    newTaskFormProps: me,
                    newTaskFormVisibility: he
                } = (0, p.G8)({
                    rootRecord: null,
                    defaultProject: D,
                    taskGroups: re,
                    defaultResponsible: K,
                    shouldCheckAccess: !0
                }), fe = n.Hooks.useModalState(), be = n.React.useRef(), ye = n.React.useCallback((e => {
                    be.current = e, fe.open()
                }), [fe]), {
                    setPositionGroup: ve
                } = me, we = n.React.useCallback((e => {
                    ve({
                        position: "top",
                        section: e
                    })
                }), [ve]), ke = ee(re, ye, we, L, !!l.sort, B), xe = n.React.useCallback((e => (invariant("string" == typeof e, "Unexpected root type"), ne.includes(ge + ":" + e))), [ne]), je = n.React.useCallback((e => {
                    invariant("string" == typeof e, "Unexpected root type"), ae(ge + ":" + e)
                }), [ae]), Te = n.React.useRef(null), Se = n.React.useCallback((e => {
                    const t = requestAnimationFrame((() => {
                        var t;
                        null == (t = Te.current) || t.scrollToHeader(e)
                    }));
                    return xe(e) && je(e), () => {
                        cancelAnimationFrame(t)
                    }
                }), [xe, je]), {
                    focusOnOverdue: Pe,
                    selectedDate: _e = a.startingDate
                } = a;
                return n.React.useEffect((() => {
                    Pe ? Se(M.k.OVERDUE) : _e && Se(U(_e))
                }), [Pe, _e]), (0, V.jsx)(h.MV, {
                    counters: de,
                    children: (0, V.jsx)(u.Z, {
                        rootRecord: s,
                        taskDetailsProps: oe,
                        title: te,
                        underNavbar: ue(),
                        leftIcon: "R",
                        color: null,
                        displayMasterPlusButton: !1,
                        onDragEnd: ke,
                        onMasterPlusPress: () => W.uiState.quickAddModal.open(),
                        newTaskFormVisibility: he,
                        masterPlusButtonStyle: "quickAdd",
                        activeTasksCounter: ce,
                        sortedTasks: ie,
                        openViewMenu: q.open,
                        menuTarget: q.target,
                        filterState: l,
                        setFilterState: d,
                        children: (0, V.jsxs)(V.Fragment, {
                            children: [(0, V.jsx)(m.Z, {
                                taskGroups: re,
                                filterState: l,
                                rootRecord: s,
                                onSetEndedTasksState: Z,
                                isDndEnabled: !0,
                                renderSectionHeader: Y({
                                    isSectionCollapsed: xe,
                                    toggleSectionCollapse: je,
                                    taskGroups: re,
                                    newTaskFormProps: me,
                                    taskDetailsProps: oe,
                                    counters: de
                                }),
                                renderSectionItemsContainer: J,
                                newTaskFormProps: me,
                                hasMasterPlus: !1,
                                withSwipeLeft: !0,
                                extraDistanceFromScreenTop: 144,
                                listHandleRef: Te
                            }), q.isOpen ? (0, V.jsx)(pe, {
                                closeMenu: q.close,
                                target: q.target,
                                saveToCSV: le,
                                isShowingThePast: A,
                                onPressShowThePast: I,
                                isShowingWeeklyView: !O,
                                onPressChangeTimeframe: () => {
                                    c({
                                        type: "today",
                                        focusOnOverdue: !1,
                                        isMonthlyView: !O
                                    }), W.modelRoot.settings.isCalendarViewMonth.set(!O)
                                }
                            }) : null, fe.isOpen && be.current ? (0, V.jsx)(f.Z, {
                                onConfirmPress: be.current,
                                onBackPress: fe.close,
                                onClose: fe.close
                            }) : null]
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(306);
        class a {
            constructor(e) {
                const {
                    pattern: t,
                    startDay: n
                } = e;
                invariant(n.isAllDay, "startDay must be all-day");
                const {
                    rrulestr: a,
                    RRuleSet: o,
                    RRule: r
                } = s(1387), i = new o, c = a("RRULE:" + t, {
                    dtstart: n.toUTC()
                });
                i.rrule(c);
                const {
                    freq: l,
                    bymonthday: d
                } = c.options;
                if (l === r.MONTHLY && d) {
                    d.filter((e => 28 < e)).forEach((e => {
                        i.rrule(new r({
                            freq: l,
                            interval: c.options.interval,
                            bymonthday: [e, -1],
                            bysetpos: [1],
                            dtstart: n.toUTC()
                        }))
                    }))
                }
                this.__unsafeRRule = i
            }
            between(e, t) {
                return invariant(e.isAllDay && t.isAllDay, "start and end must be all-day"), this.__unsafeRRule.between(e.toUTC(), t.toUTC(), !0).map(n.xf)
            }
            after(e) {
                invariant(e.isAllDay, "day must be all-day");
                const t = this.__unsafeRRule.after(e.toUTC());
                return t ? (0, n.xf)(t) : null
            }
            before(e) {
                invariant(e.isAllDay, "day must be all-day");
                const t = this.__unsafeRRule.before(e.toUTC());
                return t ? (0, n.xf)(t) : null
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => F
        });
        var n = s(0),
            a = s(65),
            o = s(19),
            r = s(14),
            i = s(39),
            c = s(17),
            l = s(29),
            d = s(35),
            u = s(74),
            m = s(678),
            h = s(68),
            p = s(12),
            g = s(75),
            f = s(90),
            b = s(89),
            y = s(70),
            v = s(44),
            w = s(1364),
            k = s(201),
            x = s(18);
        s(2), s(3);
        const j = s(761);
        var T = s(1);
        const S = () => {
            const e = n.Hooks.useIntl();
            return (0, T.jsx)("div", {
                className: j.root,
                children: (0, T.jsx)(x.default, {
                    className: j.text,
                    children: e.f.CR
                })
            })
        };
        var P = s(57);
        const _ = s(762);
        var C;

        function R(e) {
            const {
                commentsCount: t,
                isLoading: s,
                onPress: n,
                label: a
            } = e;
            return (0, T.jsx)(p.default, {
                className: _.button,
                isFullWidth: 0 !== t,
                label: a,
                onPress: n,
                right: s && 5 < t ? (0, T.jsx)(P.default, {
                    size: "small",
                    style: {
                        marginLeft: 0
                    }
                }) : void 0
            })
        }
        const A = n.Hocs.compose()((e => {
                var t;
                const {
                    commentsCount: s,
                    query: a,
                    limit: o,
                    isShowingThePast: r,
                    onLoadMore: i,
                    onSearchInEnded: c,
                    endedCommentsRequest: l
                } = e, d = n.Hooks.useIntl();
                return s < o && a && !r ? (0, T.jsx)(R, {
                    label: d.f.CQ,
                    onPress: c,
                    commentsCount: s,
                    isLoading: l.isLoading
                }) : s > o || null != (t = l.result) && t.canLoadMore ? (0, T.jsx)(R, {
                    label: d.f.CM,
                    onPress: i,
                    commentsCount: s,
                    isLoading: l.isLoading
                }) : 0 !== s || l.isLoading ? null : C || (C = (0, T.jsx)(S, {}))
            })),
            I = s(763);
        var N;
        const E = n.ReactUtils.lazy((() => s(1391))),
            O = n.ReactUtils.lazy((() => s(57))),
            M = [null],
            D = 20,
            H = e => [e.name];
        const F = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity, n.Hocs.withServices, (0, y.hp)((({
            currentTeam: e
        }) => ({
            viewId: e.id + "/search",
            initialState: {
                disabledOptions: ["name", "groupBy"]
            }
        }))), n.Hocs.withHooks((() => {
            var e, t;
            const s = null != (t = (null != (e = n.Hooks.useLocation().state) ? e : {}).searchState) ? t : null,
                a = n.React.useRef(null);
            return null !== s && (a.current = s), {
                locationState: null != s ? s : a.current
            }
        })), n.Hocs.withComponentKey((({
            locationState: e
        }) => "locationState:" + (e ? JSON.stringify(e) : ""))), n.Hocs.withHooks((({
            currentTeam: e,
            services: t,
            locationState: s,
            filterState: r
        }) => {
            const {
                query: d,
                searchInComments: u,
                showEnded: m
            } = null != s ? s : {
                query: "",
                searchInComments: !1,
                showEnded: !1
            }, h = (0, v.Nk)(null, m), {
                isShowingThePast: p
            } = h, [g, f] = n.React.useState((() => d.trim())), w = n.Hooks.useThrottledSetter((e => f(e.trim())), 150), [k, x] = n.React.useState(u ? "comments" : "tasks"), j = p ? e.allTasks : e.tasksInActiveProjects, T = n.React.useMemo((() => g && "tasks" === k ? j.pipe(n.Rx.map((e => e.extend((0, i.whereIncludesNormalized)(c.Columns.tasks.name, g), ...(0, b.Z)((0, y.LB)(r)))))) : null), [g, k, j, r]), S = n.React.useMemo((() => "comments" === k && g ? (0, y.MF)(r) ? j.pipe(n.Rx.map((e => e.extend((0, b.Z)((0, y.LB)(r))))), n.Rx.switchMap((e => n.Rx.from(e.fetchIds()))), n.Rx.switchMap((e => t.db.get(c.Tables.comments).query((0, i.whereIncludesNormalized)(c.Columns.comments.body, g), o.Q.on(c.Tables.tasks, o.Q.where(c.Columns.id, o.Q.oneOf(e)))).observe()))) : e.grantedTaskAccessesIds.pipe(n.Rx.switchMap((s => t.db.get(c.Tables.comments).query(o.Q.experimentalNestedJoin(c.Tables.tasks, c.Tables.projects), (0, i.whereIncludesNormalized)(c.Columns.comments.body, g), o.Q.on(c.Tables.tasks, [o.Q.or(o.Q.on(c.Tables.projects, (0, a.J$)(e.id)), o.Q.where(c.Columns.id, o.Q.oneOf(s))), p ? null : l.rG].filter(Boolean))).observe()))) : null), [t.db, e, g, p, k, r, j]), P = n.React.useMemo((() => T ? T.pipe(n.Rx.switchMap((e => e.extend(l.rG).observeCount()))) : n.Rx.of(0)), [T]);
            return Object.assign({}, h, {
                searchType: k,
                changeSearchType: (e, t) => {
                    x(t)
                },
                queryTextSearched: g,
                setQueryTextSearched: w,
                tasksQueryObservable: T,
                commentsQueryObservable: S,
                activeTasksCounter: P
            })
        })), n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            allTeams: e.modelRoot.allTeams
        }))), n.Hocs.withObservables(["currentTeam"], (({
            services: e,
            currentTeam: t
        }) => ({
            justEndedTasks: e.uiState.forTeam(t).justEndedTasks,
            singleTasks: t.singleTasks,
            teamMembers: t.allMembers,
            teamMemberGroups: t.allMemberGroups
        }))), n.Hocs.withObservables(["tasksQueryObservable", "commentsQueryObservable", "justEndedTasks", "filterState"], (({
            tasksQueryObservable: e,
            commentsQueryObservable: t,
            justEndedTasks: s,
            isShowingThePast: a,
            filterState: o
        }) => {
            return {
                comments: t ? t.pipe(n.Rx.map((e => (0, d.mO)(e).reverse())), n.Rx.switchMap((e => n.Rx.combineLatestTuples(e.map((e => [e, e.task.observe()])))))) : n.Rx.of([]),
                tasks: e ? (a ? e : e.pipe(n.Rx.switchMap((e => (0, l.P7)(e))))).pipe(n.Rx.switchMap((0, l.EF)(s, null != (r = o.sort) ? r : {
                    by: "projectPosition",
                    order: "ascending"
                }, !!o.sort))) : n.Rx.of([])
            };
            var r
        })), n.Hocs.withObservables(["allTeams", "comments", "teamMemberGroups", "teamMembers"], (({
            services: e,
            allTeams: t,
            comments: s,
            teamMemberGroups: a,
            teamMembers: o
        }) => ({
            searchParserContext: n.Rx.from((0, d.fk)({
                services: e,
                teams: t,
                comments: s.map((([e]) => e)),
                memberGroups: a,
                members: o
            }))
        }))), n.Hocs.withHooks((({
            queryTextSearched: e,
            currentTeam: t,
            services: s,
            isShowingThePast: a,
            searchType: o,
            setIsShowingThePast: r
        }) => {
            const [i, l] = n.React.useState(D), d = n.React.useCallback((() => {
                l((e => e + D))
            }), [l]);
            n.React.useEffect((() => {
                l(D)
            }), [e, o]);
            const [u, m, h, p, g] = n.Hooks.useLoadingState(), [f] = n.React.useState((() => new n.Rx.Subject)), b = n.React.useCallback((async () => {
                m();
                const n = s.database.get(c.Tables.comments);
                try {
                    const a = await s.api.searchEndedComments(e, t, i, D, f);
                    return (null == a ? void 0 : a.map((e => n.disposableFromDirtyRaw(e)))) || []
                } catch (e) {
                    throw p(e), e
                }
            }), [t, i, e, s.api, s.database, p, m, f]), y = n.React.useCallback((async () => {
                var e;
                const t = await b();
                h({
                    comments: ((null == (e = u.result) ? void 0 : e.comments) || []).concat(t),
                    canLoadMore: t.length >= D
                })
            }), [b, u.result, h]), v = n.React.useCallback((async () => {
                const e = await b();
                h({
                    comments: e,
                    canLoadMore: e.length >= D
                })
            }), [b, h]), w = n.React.useCallback((() => {
                a ? y() : r(!0), d()
            }), [y, d, a, r]);
            return n.React.useEffect((() => {
                a && "comments" === o && e.length ? v() : g()
            }), [a, e, o]), n.React.useEffect((() => () => {
                "loading" === u.status && f.next("Query changed")
            }), [e]), {
                endedCommentsRequest: u,
                isDownloadingComments: "loading" === u.status,
                limit: i,
                loadMore: d,
                loadMoreAndDownloadComments: w
            }
        })), n.Hocs.withObservables(["endedCommentsRequest", "filterState"], (({
            endedCommentsRequest: e,
            filterState: t,
            services: s
        }) => {
            var a, r;
            const i = null != (a = null == (r = e.result) ? void 0 : r.comments) ? a : [];
            if (!i.length) return {
                endedComments: n.Rx.of([])
            };
            const l = Array.from(new Set(i.map((e => e.task.id)))),
                d = s.database.collections.get(c.Tables.tasks).query(o.Q.where(c.Columns.id, o.Q.oneOf(l))),
                u = (0, b.Z)((0, y.LB)(t));
            return {
                endedComments: d.extend(u).observe().pipe(n.Rx.map((e => {
                    const t = new Map(e.map((e => [e.id, e])));
                    return i.reduce(((e, s) => {
                        const n = t.get(s.task.id);
                        return n && e.push([s, n]), e
                    }), [])
                })))
            }
        })), n.Hocs.withObservables(["currentTeam"], (({
            currentTeam: e
        }) => ({
            singleTasks: e.singleTasks
        }))))((e => {
            const {
                activeTasksCounter: t,
                isShowingThePast: s,
                toggleShowThePast: a,
                comments: o,
                endedComments: i,
                isDownloadingComments: c,
                searchType: l,
                changeSearchType: d,
                setQueryTextSearched: b,
                queryTextSearched: y,
                services: x,
                tasks: j,
                limit: P,
                loadMore: _,
                loadMoreAndDownloadComments: C,
                filterState: R,
                setFilterState: D,
                singleTasks: F,
                setIsShowingThePast: Z,
                endedCommentsRequest: L,
                searchParserContext: B
            } = e, z = n.Hooks.useModalState(), U = n.Hooks.useIntl(), {
                currentTeam: W
            } = n.Hooks.useIdentity(), G = n.React.useRef(null);
            n.React.useEffect((() => {
                setTimeout((() => {
                    var e;
                    null == (e = G.current) || e.focus()
                }), 0)
            }), [l]);
            const V = n.ReactUtils.unlessImeEvent((e => {
                    var t;
                    "Escape" !== e.key && "Tab" !== e.key || (null == (t = G.current) || t.blur())
                })),
                q = () => (0, T.jsxs)(T.Fragment, {
                    children: [(0, T.jsx)(k.Z, {
                        options: [{
                            id: "tasks",
                            label: U.f.CO,
                            color: "incoming",
                            icon: "P"
                        }, {
                            id: "comments",
                            label: U.f.CN,
                            color: "activity",
                            icon: "k"
                        }],
                        selectedOptionId: l,
                        selectOption: d
                    }), (0, T.jsx)("div", {
                        className: I.container,
                        children: (0, T.jsxs)("div", {
                            className: I.inputWrapper,
                            children: [(0, T.jsx)(f.Z, {
                                className: I.input,
                                placeholder: "comments" === l ? U.f.CP : U.f.CS,
                                onChange: b,
                                initialValue: y,
                                autoFocus: !0,
                                ref: G,
                                onKeyDown: V
                            }), c ? (0, T.jsx)("div", {
                                className: I.activityIndicator,
                                children: (0, T.jsx)(O, {
                                    size: "small",
                                    style: {
                                        marginLeft: 0
                                    }
                                })
                            }) : null]
                        })
                    })]
                }),
                Q = function(e, t, s) {
                    const a = n.Hooks.useFuzzySearchList({
                        list: e,
                        getText: H,
                        queryText: t,
                        mapResultItem: ({
                            item: e
                        }) => e
                    });
                    return s.sort ? e : n.FP.sortWith([n.FP.descend((e => e.isActive))])(a)
                }(j, y, R),
                {
                    taskGroups: Y,
                    sortedTasks: J
                } = (0, w.U)({
                    sections: M,
                    getTasksForSection: () => Q.slice(0, P),
                    endedTasksStates: null
                }),
                K = (0, v.Or)(r.routeToTaskListTask),
                {
                    newTaskFormProps: $
                } = (0, v.G8)({
                    rootRecord: null,
                    defaultProject: F,
                    taskGroups: Y
                }),
                X = n.React.useCallback((() => Q.length ? Q.length > P ? (0, T.jsx)(p.default, {
                    className: I.loadMoreButton,
                    label: U.f.CM,
                    onPress: _
                }) : null : N || (N = (0, T.jsx)(S, {}))), [U, P, Q.length, _]),
                ee = n.Hooks.useLocation(),
                te = n.React.useCallback((async (e, t) => {
                    const s = await t.task.fetch(),
                        n = ee.pathname.replace(r.pathTaskIdRegex, "") + "/tasks/" + s.id + "#comment=" + t.id;
                    x.router.goTo({
                        path: n
                    })
                }), [ee.pathname, x.router]),
                se = i && i.length ? n.FP.uniqWith((([e], [t]) => e.id === t.id), [...i, ...o]) : o;
            return (0, T.jsx)(u.Z, {
                rootRecord: W,
                taskDetailsProps: K,
                title: U.f.fT,
                activeTasksCounter: t,
                color: null,
                openViewMenu: z.open,
                leftIcon: "ƅ",
                menuTarget: z.target,
                sortedTasks: J,
                filterState: R,
                setFilterState: D,
                children: (0, T.jsxs)(T.Fragment, {
                    children: ["comments" === l ? (0, T.jsxs)(h.Z, {
                        keyboardShouldPersistTaps: "handled",
                        isKeyboardAware: !0,
                        children: [q(), (0, T.jsxs)("div", {
                            className: I.commentRoot,
                            children: [
                                [...se].sort((([e], [t]) => t.createdAt.getTime() - e.createdAt.getTime())).slice(0, P).map((([e, t], s) => {
                                    const a = !t.lastSeenActivityAt || e.createdAt.getTime() > t.lastActivityAt.getTime();
                                    return (0, T.jsx)(m.Z, {
                                        comment: e,
                                        isRenderedInSearch: !0,
                                        onTriggerEdit: n.FP.noop,
                                        onTriggerReply: n.FP.noop,
                                        onBodyPress: te,
                                        isBeingEdited: !1,
                                        isHighlighted: !1,
                                        isEditingDisabled: !0,
                                        isUnread: a,
                                        markAsUnread: n.FP.noop,
                                        isInitiallyRendered: 5 > s,
                                        parserContext: Object.assign({}, B, {
                                            searchQuery: n.FP.normalizeText(y)
                                        })
                                    }, e.id)
                                })), (0, T.jsx)(A, {
                                    commentsCount: se.length,
                                    limit: P,
                                    query: y,
                                    isShowingThePast: s,
                                    onLoadMore: C,
                                    onSearchInEnded: () => Z(!0),
                                    endedCommentsRequest: L
                                })
                            ]
                        })]
                    }) : (0, T.jsx)(g.Z, {
                        taskGroups: Y,
                        filterState: Object.assign({}, R, {
                            filterName: y
                        }),
                        rootRecord: W,
                        renderListHeader: q,
                        showEmptyState: !1,
                        renderListFooter: X,
                        isShowingThePast: s,
                        withSwipeLeft: !0,
                        newTaskFormProps: $
                    }), z.isOpen ? (0, T.jsx)(E, {
                        isShowingThePast: s,
                        onToggleThePast: a,
                        closeMenu: z.close,
                        target: z.target
                    }) : null]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => x
        });
        var n = s(0),
            a = s(14),
            o = s(74),
            r = s(44),
            i = s(1364),
            c = s(75),
            l = s(97),
            d = s(1);
        const u = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    tasks: t,
                    children: s,
                    isCollapsed: n,
                    toggleSectionCollapse: a,
                    needsReview: o,
                    hasActivity: r
                } = e;
                return (0, d.jsx)(l.Z, {
                    hasThreeDots: !1,
                    onCollapsePress: a,
                    isCollapsed: n,
                    hasActivity: r,
                    needsReview: o,
                    hasHairline: !t.length,
                    tasks: t,
                    viewColor: "darkgreen",
                    children: s
                })
            })),
            m = "Groups",
            h = "People",
            p = "Archived";
        var g;
        const f = n.ReactUtils.lazy((() => s(1392))),
            b = (e, t, s, n, a) => o => {
                invariant("string" == typeof o, "Expected section as a string, got: " + typeof o);
                const r = s + ":" + (null != o ? o : ""),
                    i = n.find((e => e.root === o)),
                    c = (() => {
                        switch (o) {
                            case m:
                                return a.f.rk;
                            case h:
                                return a.f.rm;
                            case p:
                                return a.f.rj;
                            default:
                                return a.f.rl
                        }
                    })();
                return o && i ? (0, d.jsx)(u, {
                    groupRoot: o,
                    collapsedSectionsStates: t,
                    setNewTaskFormPosition: () => {},
                    tasks: i.tasks,
                    isCollapsed: t.includes(r),
                    toggleSectionCollapse: () => e(r),
                    needsReview: null == i ? void 0 : i.items.some((e => e.doesNeedReview)),
                    hasActivity: null == i ? void 0 : i.items.some((e => e.isUnread)),
                    children: c
                }, "section_header-" + o) : null
            },
            y = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                singleTasks: e.singleTasks
            }))))((e => {
                var t;
                const {
                    taskGroups: s,
                    toggleSectionCollapse: a,
                    collapsedSectionsStates: o,
                    singleTasks: i
                } = e, {
                    currentTeam: l,
                    currentMember: u
                } = n.Hooks.useIdentity(), m = n.Hooks.useIntl(), {
                    newTaskFormProps: h
                } = (0, r.G8)({
                    rootRecord: null,
                    defaultProject: i,
                    taskGroups: s
                });
                return 1 >= s.length && !(null != (t = s[0]) && t.items.length) ? g || (g = (0, d.jsx)(f, {})) : (0, d.jsx)(c.Z, {
                    taskGroups: s,
                    filterState: null,
                    rootRecord: l,
                    newTaskFormProps: h,
                    hasMasterPlus: !0,
                    viewColor: "darkgreen",
                    renderSectionHeader: b(a, o, u.id, s, m),
                    isProjectVisible: !1,
                    isSectionVisible: !1,
                    withSwipeLeft: !1
                })
            })),
            v = n.ReactUtils.lazy((() => s(1393))),
            w = n.ReactUtils.lazy((() => s(1394))),
            k = s(105).wx,
            x = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withErrorBoundary({
                name: "Messages",
                onReset: ({
                    services: e,
                    currentTeam: t,
                    isLimitedAccount: s
                }) => {
                    e.router.goTo((0, a.getPathToCurrentTeamRoot)(t, s))
                }
            }), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                tasks: e.allMessageThreads.pipe(n.Rx.switchMap((e => e.observeWithColumns([n.Model.Columns.tasks.lastActivityAt, n.Model.Columns.tasks.name]))), n.Rx.map(n.FP.sortWith([n.FP.descend(n.FP.prop("lastActivityAt")), n.FP.ascend(n.FP.pipe(n.FP.prop("name"), n.FP.toLower))])))
            }))), n.Hocs.withObservables(["tasks"], (({
                tasks: e
            }) => ({
                tasksWithAccesses: n.Rx.combineLatestTuples(e.map((e => [e, e._taskAccesses.observe()])))
            }))), n.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                sawOnboarding: e.modelRoot.settings.sawMessagesOnboarding.observe()
            }))))((e => {
                const {
                    tasksWithAccesses: t,
                    tasks: s,
                    sawOnboarding: c
                } = e, {
                    currentMember: l,
                    currentTeam: u
                } = n.Hooks.useIdentity(), g = n.React.useRef(), f = n.Hooks.useIntl(), b = n.Hooks.useModalState(), x = n.Hooks.useModalState(), j = n.Hooks.useModalState({
                    isOpen: !c
                }), T = n.Hooks.useServices(), {
                    collapsedSectionsStates: S,
                    toggleSectionCollapse: P
                } = (0, r.SK)(), [_, C] = n.Hooks.useToggle(!1), R = (0, r.Or)(a.routeToTaskListTask), A = n.React.useCallback((e => e.root === p ? !!_ : null === e.root || 0 < e.items.length), [_]), {
                    taskGroups: I,
                    sortedTasks: N
                } = (0, i.U)({
                    sections: [null, m, h, p],
                    groupTasksBySection: () => (0, r.YU)((e => {
                        if (e.isEnded) return p;
                        const s = t.find((([t]) => t.id === e.id));
                        return s ? s[1].some((e => e.granteeType && "member" !== e.granteeType)) ? m : h : null
                    }), s),
                    getTasksForSection: (e, t) => t.get(e) || [],
                    justEndedTasks: [],
                    listRootId: l.id,
                    collapsedSectionsStates: S,
                    endedTasksStates: null,
                    shouldRenderSection: A
                });
                return (0, d.jsx)(o.Z, {
                    rootRecord: u,
                    taskDetailsProps: R,
                    title: f.f.Kc,
                    leftIcon: "Ķ",
                    activeTasksCounter: u.activeMessageThreads.pipe(n.Rx.switchMap((e => e.observeCount()))),
                    color: "darkgreen",
                    openViewMenu: b.open,
                    menuTarget: b.target,
                    sortedTasks: N,
                    displayMasterPlusButtonIcon: !0,
                    displayMasterPlusButton: !0,
                    masterPlusRef: g,
                    masterPlusButtonStyle: "message",
                    onMasterPlusPress: x.open,
                    children: (0, d.jsxs)(d.Fragment, {
                        children: [(0, d.jsx)(y, {
                            taskGroups: I,
                            collapsedSectionsStates: S,
                            toggleSectionCollapse: P
                        }), b.isOpen ? (0, d.jsx)(v, {
                            closeMenu: b.close,
                            target: b.target,
                            isShowingThePast: _,
                            onToggleThePast: C
                        }) : null, x.isOpen ? (0, d.jsx)(k.Thread, {
                            bundle$close: x.close,
                            target: g,
                            onClose: x.close,
                            team: u
                        }) : null, j.isOpen ? (0, d.jsx)(w, {
                            onClose: () => {
                                T.modelRoot.settings.sawMessagesOnboarding.set(!0), j.close()
                            }
                        }) : null]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => P
        });
        var n, a, o, r, i, c, l, d, u, m, h, p, g = s(0),
            f = s(14),
            b = s(162),
            y = s(1);

        function v({
            intl: e,
            showsNozbePersonalTour: t,
            showPersonalSteps: s
        }) {
            return s ? (e => [{
                testId: g.Misc.testIds.sidebar_priority,
                title: e.f.sF,
                content: e.f.sE,
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_incoming,
                title: e.f.sA,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sx, n || (n = (0, y.jsx)(b.SS, {})), e.f.sz]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_projectsGroup,
                title: e.f.sO,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sH, a || (a = (0, y.jsx)(b.SS, {})), e.g("sN", {
                        em1: (0, y.jsx)(b.Em, {
                            children: e.f.sK
                        }, "em1"),
                        em2: (0, y.jsx)(b.Em, {
                            children: e.f.sM
                        }, "em2")
                    })]
                }),
                native_placement: "scrollAboveCard"
            }, {
                testId: g.Misc.testIds.sidebar_helpButton,
                title: e.f.sw,
                content: e.g("st", {
                    em1: (0, y.jsx)(b.cK, {
                        children: e.f.su
                    }, "em1"),
                    em2: (0, y.jsx)(b.cK, {
                        children: e.f.sv
                    }, "em2")
                })
            }])(e) : t ? (e => [{
                testId: g.Misc.testIds.sidebar_priority,
                title: e.f.s1,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.g("sX", {
                        em1: (0, y.jsx)(b.cK, {
                            children: e.f.sY
                        }, "em1")
                    }), o || (o = (0, y.jsx)(b.SS, {})), e.g("sZ", {
                        em1: (0, y.jsx)(b.cK, {
                            children: e.f.s0
                        }, "em1")
                    })]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_incoming,
                title: e.f.sA,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sx, r || (r = (0, y.jsx)(b.SS, {})), e.f.sV, i || (i = (0, y.jsx)(b.SS, {})), e.f.sW]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_activity,
                title: e.f.sT,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sQ, c || (c = (0, y.jsx)(b.SS, {})), e.g("sR", {
                        em1: (0, y.jsx)(b.cK, {
                            children: e.f.sS
                        }, "em1")
                    })]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_singleTasks,
                title: e.f.s7,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.s5, l || (l = (0, y.jsx)(b.SS, {})), (0, y.jsx)(b.cK, {
                        children: e.f.rX
                    }), " ", e.f.s6]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_projectsGroup,
                title: e.f.s4,
                content: (0, y.jsx)(y.Fragment, {
                    children: e.g("s2", {
                        em1: (0, y.jsx)(b.cK, {
                            children: e.f.s3
                        }, "em1")
                    })
                }),
                native_placement: "scrollAboveCard"
            }, {
                testId: g.Misc.testIds.sidebar_helpButton,
                title: e.f.sw,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.g("st", {
                        em1: (0, y.jsx)(b.cK, {
                            children: e.f.su
                        }, "em1"),
                        em2: (0, y.jsx)(b.cK, {
                            children: e.f.sv
                        }, "em2")
                    }), d || (d = (0, y.jsx)(b.SS, {})), (0, y.jsx)(b.cK, {
                        children: e.f.rX
                    }), " ", e.f.sU]
                })
            }])(e) : (e => [{
                testId: g.Misc.testIds.sidebar_priority,
                title: e.f.sF,
                content: e.f.sE,
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_incoming,
                title: e.f.sA,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sx, u || (u = (0, y.jsx)(b.SS, {})), e.f.sy]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_activity,
                title: e.f.ss,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sq, m || (m = (0, y.jsx)(b.SS, {})), e.f.sr]
                }),
                native_placement: "scrollTop"
            }, {
                testId: g.Misc.testIds.sidebar_projectsGroup,
                title: e.f.sO,
                disableScrolling: !1,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sG, h || (h = (0, y.jsx)(b.SS, {})), e.g("sI", {
                        em1: (0, y.jsx)(b.Em, {
                            children: e.f.sJ
                        }, "em1"),
                        em2: (0, y.jsx)(b.Em, {
                            children: e.f.sL
                        }, "em2")
                    })]
                }),
                native_placement: "scrollAboveCard"
            }, {
                testId: g.Misc.testIds.sidebar_team,
                title: e.f.sD,
                disableScrolling: !1,
                content: (0, y.jsxs)(y.Fragment, {
                    children: [e.f.sB, p || (p = (0, y.jsx)(b.SS, {})), e.f.sC]
                }),
                native_placement: "scrollAboveCard"
            }, {
                testId: g.Misc.testIds.sidebar_helpButton,
                title: e.f.sw,
                content: e.g("st", {
                    em1: (0, y.jsx)(b.cK, {
                        children: e.f.su
                    }, "em1"),
                    em2: (0, y.jsx)(b.cK, {
                        children: e.f.sv
                    }, "em2")
                })
            }])(e)
        }
        var w = s(6),
            k = s(772);
        const x = g.Hocs.compose((0, w.LU)())((e => {
                const {
                    setUseCase: t
                } = e;
                return (0, y.jsx)(k.Z, {
                    setUseCase: t
                })
            })),
            j = g.ReactUtils.lazy((() => s(1399))),
            T = g.ReactUtils.lazy((() => s(223))),
            S = g.ReactUtils.lazy((() => s(1400))),
            P = g.Hocs.compose(g.Hocs.withServices, g.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                prefersPersonalUI: e.modelRoot.settings.prefersPersonalUI,
                sawTeamSetup: e.modelRoot.settings.sawTeamSetup
            }))), g.Hocs.withIdentity, g.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                isTeamOfOne: e.isTeamOfOne
            }))))((e => {
                const {
                    prefersPersonalUI: t,
                    sawTeamSetup: s,
                    isTeamOfOne: n
                } = e, a = g.Hooks.useServices(), {
                    currentMember: o,
                    currentTeam: r
                } = g.Hooks.useIdentity(), i = g.Hooks.useIntl(), c = g.Hooks.useDesktopLayout(), [l, d] = g.React.useState(n ? null : "business");
                g.React.useEffect((() => {
                    a.ab.projectPresetsBaseline.trackOnce("tourStarted"), a.uiState.isAutoTaskOpenPrevented.next(!0)
                }), [a.ab, a.uiState]);
                const u = "owner" !== o.role,
                    [m, h] = g.Hooks.useStateMachine(u || l ? "tour" : "useCase"),
                    p = () => {
                        t ? a.modelRoot.settings.sawGeneralPersonalOnboarding.set(!0) : a.modelRoot.settings.sawGeneralOnboarding.set(!0)
                    };
                return (0, y.jsx)(y.Fragment, {
                    children: m.map({
                        useCase: () => (0, y.jsx)(x, {
                            setUseCase: async e => {
                                d(e), await a.modelRoot.settings.declaredUseCase.set(e), "personal" === e ? (await a.modelRoot.settings.hasSkippedTeamSetup.set(!0), await a.modelRoot.settings.prefersPersonalUI.set(!0), h("tour")()) : (await a.modelRoot.settings.prefersPersonalUI.set(!1), await a.modelRoot.settings.hasSkippedTeamSetup.set(!1), s ? h("tour")() : h("teamName")())
                            },
                            onClose: () => {
                                a.ab.projectPresetsBaseline.trackOnce("projectsSkipped"), p()
                            }
                        }),
                        teamName: () => {
                            const e = h("inviteMembers");
                            return (0, y.jsx)(S, {
                                onClose: e,
                                onSave: e
                            })
                        },
                        inviteMembers: () => (0, y.jsx)(T, {
                            team: r,
                            onClose: async () => {
                                await a.modelRoot.settings.sawTeamSetup.set(!0), h("tour")()
                            },
                            onCancel: async () => {
                                await a.modelRoot.settings.prefersPersonalUI.set(!0)
                            },
                            startAtEmail: !0,
                            saveButtonLabel: i.f.fD,
                            saveEmptyButtonLabel: i.f.fB,
                            cancelButtonLabel: i.f.tx
                        }),
                        tour: () => (0, y.jsx)(b.ZP, {
                            native_onBefore: async () => {
                                c || (await g.FP.delay(300), a.navigation.showSidebar("main"), await g.FP.delay(100))
                            },
                            onFinish: async () => {
                                await (async () => {
                                    if (u) return !1;
                                    const e = 0 === await r.activeProjects.fetchCount() || !1;
                                    return e || a.ab.projectPresetsBaseline.trackOnce("alreadyHasProjects"), e
                                })() ? (h("projects")(), a.ab.projectPresetsBaseline.trackOnce("projectsStarted")) : (p(), a.ab.projectPresetsBaseline.trackOnce("tourCompleted"))
                            },
                            steps: v({
                                intl: i,
                                showsNozbePersonalTour: !1,
                                currentTeam: r,
                                showPersonalSteps: t
                            })
                        }),
                        projects: () => (0, y.jsx)(j, {
                            useCase: l,
                            onClose: () => {
                                a.ab.projectPresetsBaseline.trackOnce("projectsSkipped"), p()
                            },
                            onCreated: async e => {
                                a.ab.projectPresetsBaseline.trackOnce("projectsCreated"), a.uiState.isNewTaskCancelOnBlurPrevented.next(!0), a.router.goTo((0, f.smartPathToProject)(r, e), {
                                    shouldOpenNewTask: !0
                                }), await g.FP.delayedRetry([0, 50, 100, 200, 500, 750], (async () => !!a.scene.webWindow.document.querySelector('[data-testid="' + g.Misc.testIds.taskList_newTask_input + '"]'))), await g.FP.delay(0), h("tasks", e)()
                            }
                        }),
                        tasks: e => (0, y.jsx)(b.ZP, {
                            onFinish: () => {
                                var e;
                                a.ab.projectPresetsBaseline.trackOnce("tourCompleted"), null == (e = a.scene.webWindow.document.querySelector('[data-testid="' + g.Misc.testIds.taskList_newTask_input + '"]')) || e.focus(), a.uiState.isNewTaskCancelOnBlurPrevented.next(!1), p()
                            },
                            steps: [{
                                testId: g.Misc.testIds.taskList_newTask,
                                title: i.g("sk", {
                                    projectName: (0, y.jsx)(b.Em, {
                                        style: {
                                            fontWeight: "bold"
                                        },
                                        children: g.Styling.getProjectName(e, i)
                                    }, "em1")
                                }),
                                content: (0, y.jsx)(y.Fragment, {
                                    children: i.g("sj", {
                                        projectName: (0, y.jsx)(b.cK, {
                                            children: g.Styling.getProjectName(e, i)
                                        }, "strong1")
                                    })
                                })
                            }]
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n, a = s(0),
            o = s(162),
            r = s(1);

        function i({
            intl: e
        }) {
            return [{
                testId: a.Misc.testIds.sidebar_activity,
                title: e.f.ss,
                content: (0, r.jsxs)(r.Fragment, {
                    children: [e.f.sq, n || (n = (0, r.jsx)(o.SS, {})), e.f.sr]
                }),
                native_placement: "scrollTop"
            }, {
                testId: a.Misc.testIds.sidebar_helpButton,
                title: e.f.sw,
                content: e.g("st", {
                    em1: (0, r.jsx)(o.cK, {
                        children: e.f.su
                    }, "em1"),
                    em2: (0, r.jsx)(o.cK, {
                        children: e.f.sv
                    }, "em2")
                })
            }].filter(Boolean)
        }
        const c = a.Hocs.compose()((() => {
            const e = a.Hooks.useServices(),
                t = a.Hooks.useIntl(),
                s = a.Hooks.useDesktopLayout();
            return (0, r.jsx)(o.ZP, {
                native_onBefore: async () => {
                    s || (await a.FP.delay(300), e.navigation.showSidebar("main"), await a.FP.delay(100))
                },
                onFinish: async () => {
                    e.modelRoot.settings.sawGeneralOnboarding.set(!0)
                },
                steps: i({
                    intl: t
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(11),
            o = s(1550),
            r = s(18);
        s(2), s(3);
        const i = s(789);
        const c = s(23).identityElement;
        var l = s(1);
        const d = n.ReactUtils.lazy((() => s(22))),
            u = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isDisplayingSidebar: e.navigation.hasNavigatedToSidebar.pipe(n.Rx.distinctUntilChanged())
            }))))((e => {
                var t;
                const {
                    onButtonPress: s,
                    message: u,
                    bottomInset: m,
                    buttonColor: h = "incoming",
                    buttonText: p,
                    onMouseEnter: g,
                    onMouseLeave: f,
                    onHideSnackbar: b,
                    isDisplayingSidebar: y
                } = e, v = n.Hooks.useIntl(), w = n.Hooks.useLayoutBottomInset(), k = (null != (t = e.bottom) ? t : 16) + 0 + 0 + 24, [x, j] = n.React.useState(!1);
                return n.React.useEffect((() => {
                    const e = setTimeout((() => j(!0)), 100);
                    return () => {
                        clearTimeout(e)
                    }
                }), [u, s]), (0, l.jsx)(o.Z, {
                    isMounted: x,
                    timeout: ".25s",
                    children: ({
                        status: e
                    }) => (0, l.jsx)(c, {
                        isVisible: x,
                        onHideSnackbar: b,
                        children: (0, l.jsxs)("div", {
                            className: i.root + ("entering" === e || "entered" === e ? " " + i.isVisible : ""),
                            style: {
                                bottom: k,
                                marginBottom: null != m ? m : w
                            },
                            onMouseEnter: g,
                            onMouseLeave: f,
                            children: [(0, l.jsx)(r.default, {
                                className: i.text + (s ? "" : " " + i.textCentered),
                                maxLines: 2,
                                children: u
                            }), s ? (0, l.jsx)(a.Z, {
                                className: i.button,
                                style: {
                                    "--hover-button-color": n.Styling.rgba(n.Styling.factoryColor(h), .2)
                                },
                                onPress: s,
                                accessibilityLabel: null != p ? p : v.f.Jd,
                                children: (0, l.jsx)("span", {
                                    className: i.buttonText,
                                    style: {
                                        color: n.Styling.factoryColor(h)
                                    },
                                    children: null != p ? p : v.f.Jd
                                })
                            }) : null, b ? (0, l.jsx)(d, {
                                name: "b",
                                color: "textPrimaryInverse",
                                iconSize: 20,
                                accessibilityLabel: v.f.fh,
                                onPress: () => {
                                    j(!1), b()
                                }
                            }) : null]
                        })
                    })
                })
            }))
    }, , , , , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => p
        });
        var n = s(0),
            a = s(23);
        const o = {
                alt: "Alt",
                ctrl: "Ctrl",
                cmd: "Cmd",
                shift: "Shift"
            },
            r = {
                alt: "⌥",
                ctrl: "⌃",
                cmd: "⌘",
                shift: "⇧"
            },
            i = {
                ArrowDown: "↓",
                ArrowUp: "↑",
                ArrowLeft: "←",
                ArrowRight: "→",
                Enter: a.isApple ? "↵" : "Enter",
                Escape: "Esc",
                Tab: a.isApple ? "↹" : "Tab",
                Backspace: a.isApple ? "⌫" : "Backspace",
                Slash: "/",
                Digit1: "1",
                Digit2: "2",
                Digit3: "3",
                Digit4: "4",
                Digit5: "5",
                Digit6: "6",
                Digit7: "7",
                Digit8: "8",
                Digit9: "9",
                Digit0: "0",
                Period: "."
            },
            c = e => (a.isApple ? r : o)[e] || e,
            l = e => i[e] || e,
            d = (e, t) => {
                const s = [...(e || []).map(c), l(t)];
                return a.isApple ? s.join("") : s.join("+")
            };
        s(2), s(3);
        const u = s(435);
        var m = s(1);
        const h = ({
                children: e,
                isDisabled: t
            }) => (0, m.jsx)("div", {
                className: u.keyContainer,
                children: (0, m.jsx)("span", {
                    className: u.key + (t ? " " + u.keyDisabled : ""),
                    children: e
                })
            }),
            p = n.Hocs.compose()((e => {
                const {
                    item: t,
                    provider: s
                } = e, {
                    modifiers: n,
                    key: a
                } = t;
                return (0, m.jsx)(m.Fragment, {
                    children: (0, m.jsxs)("div", {
                        className: u.keysContainer,
                        children: [(0, m.jsx)(h, {
                            isDisabled: !s,
                            children: d(n, a)
                        }), (t.alternativeShortcuts || []).map(((e, t) => (0, m.jsx)(h, {
                            isDisabled: !s,
                            children: ", " + d(e.modifiers, e.key)
                        }, t)))]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        s(0);
        var n = s(40),
            a = s(11);
        s(2), s(3);
        const o = s(466);
        var r = s(1);
        const i = e => {
            const {
                color: t,
                onPress: s,
                isSelected: i
            } = e, c = [...i ? [{
                iconName: "i",
                color: t || "onBackground1",
                size: 42,
                opacity: t ? .2 : 1
            }] : [], {
                iconName: t ? "g" : "œ",
                color: t || "onBackground3",
                size: 42
            }];
            return (0, r.jsx)(a.Z, {
                className: o.touchable,
                onPress: s,
                onPressExtraParam: t,
                androidBorderless: !0,
                children: (0, r.jsx)(n.default, {
                    layers: c
                })
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            D: () => u,
            J: () => h
        });
        var n = s(19),
            a = s(4),
            o = s(8),
            r = s(14),
            i = s(23),
            c = s(315),
            l = s(16),
            d = s(245);
        async function u(e, t) {
            invariant(e.canBeCloned(), "Project cannot be cloned");
            const {
                name: s,
                description: n,
                color: a,
                isOpen: o,
                isTemplate: r,
                team: i,
                members: c,
                withEndedTasks: l,
                withAllComments: d,
                referenceDate: u
            } = t;
            return await e.callWriter((() => e.do.copy({
                name: s,
                description: n,
                color: a,
                isTemplate: r,
                isOpen: o,
                team: i,
                members: c,
                tasks: l ? "all" : "active",
                comments: d ? "all" : "pinned",
                referenceDate: u
            })))
        }
        const m = {
            name: !0,
            description: !0,
            color: !0,
            isTemplate: !1,
            timeAttributes: !0,
            tasks: "active",
            sections: !0,
            comments: "pinned"
        };
        async function h(e, t) {
            var s, u;
            invariant(await e.canBeCopied(), "Project cannot be copied");
            const h = Object.assign({}, m, t),
                p = (() => {
                    switch (h.name) {
                        case !0:
                            return e._name;
                        case !1:
                            return "";
                        default:
                            return h.name.trim()
                    }
                })(),
                g = (() => {
                    switch (h.description) {
                        case !0:
                            return e.description;
                        case !1:
                            return null;
                        default:
                            return h.description.trim()
                    }
                })(),
                f = (() => {
                    switch (h.color) {
                        case !0:
                            return e.color;
                        case !1:
                            return null;
                        default:
                            return h.color
                    }
                })(),
                b = null != (s = h.team) ? s : await e.getCurrentTeam(),
                y = await e.callWriter((async () => {
                    const t = await b.do.createProject({
                        name: p,
                        description: g,
                        color: f,
                        isOpen: !0,
                        isTemplate: h.isTemplate
                    });
                    return e.id && t.do.markAsClonedFromId(e.id), t
                })),
                v = await o.takeFirst(b.currentMember),
                w = null != (u = h.isOpen) ? u : e.permissions.isOpen;
            if (!w) {
                var k;
                const t = null != (k = h.members) ? k : await o.takeFirst(e.permissions.members),
                    s = t.includes(v) ? t : [...t, v],
                    n = await e.permissions.managerAccesses.fetch().then((e => e.map((e => e.member.id))));
                await e.callWriter((() => y.permissions.do.updateAccess({
                    isOpen: w,
                    newMembers: s.map((e => ({
                        member: e,
                        isNew: !0,
                        isInitialManager: !1,
                        isManager: e === v || n.includes(e.id)
                    }))),
                    removedMembers: [],
                    changedMembers: []
                })))
            }
            const x = h.timeAttributes && e.areTimeAttributesEnabled,
                j = "all" === h.tasks,
                T = "all" === h.comments;
            if (x && await y.canEnableTimeAttributes() && await y.callWriter((() => y.do.setAreTimeAttributesEnabled(!0))), !1 !== h.tasks) {
                const t = j ? await e.allTasksWithoutSection.fetch() : await e.activeTasksWithoutSection.fetch();
                await a.allPromises((async t => {
                    const s = await t.responsible.fetch(),
                        n = !s || await y.permissions.doesMemberHaveAccess(s);
                    await e.callWriter((() => t.do.clone({
                        selectedProject: y,
                        shouldCheckAccess: !1,
                        selectedResponsible: n ? s : v,
                        withAllComments: T,
                        withEndedTasks: j,
                        referenceDate: h.referenceDate
                    })))
                }), t)
            }
            if (!0 === h.sections) {
                const t = j ? await e.allSections.fetch() : await e.activeSections.fetch(),
                    s = await a.allPromises((async t => e.callWriter((() => t.do.clone({
                        position: t.position,
                        selectedProject: y,
                        withAllComments: T,
                        withEndedTasks: j,
                        referenceDate: h.referenceDate
                    })))), t);
                if (s.length > b.limits.projectSections) {
                    const t = (0, c.cl)(s).slice(b.limits.projectSections);
                    await a.allPromises((async t => e.callWriter((() => t.do.archive()))), t)
                }
            }
            if (e.isTemplate) {
                const [t, s] = await Promise.all([y.allTasks.fetch(), e.db.collections.get(l.w.teams).query().fetch()]), a = new Map(t.map((e => [e.extra.cloned_from_id || "", e.id]))), o = t.map((e => e.id)), c = (await e.db.collections.get(l.w.comments).query(n.Q.where(l.o.comments.taskId, n.Q.oneOf(o))).fetch()).reduce(((e, t) => {
                    const n = function({
                        comment: e,
                        team: t,
                        allTeams: s,
                        clonedTasksMap: n
                    }) {
                        const a = (0, d.W)(e._bodyText, s),
                            o = a.reduce(((e, {
                                taskId: s,
                                url: a
                            }) => {
                                const o = s ? n.get(s) : null;
                                if (!o) return e;
                                const c = (0, r.smartPathToTaskId)(t, o).path;
                                return e.replace(a, "" + i.webAppUrl + c)
                            }), e._bodyText);
                        return o
                    }({
                        comment: t,
                        clonedTasksMap: a,
                        team: b,
                        allTeams: s
                    });
                    return n !== t._bodyText && e.push(t.prepareUpdate((e => {
                        e._bodyText = n
                    }))), e
                }), []);
                0 < c.length && await e.db.batch(c)
            }
            return y
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            S: () => o
        });
        var n = s(5),
            a = s(8);

        function o(e) {
            return e.observe().pipe(a.switchMap((() => e.planInfo.isBusiness ? e.business.observe().pipe(a.switchMap((t => t ? t.activeUsers.observeCount() : (n.logError(n.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Team " + e.id + " has plan set to business, even though it has no business associated. Will use fallback value for calculating the billable members count.", "warning"), e.membersExcludingRequests.observeCount())))) : e.membersExcludingRequests.observeCount())))
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(232);
        async function a(e, t) {
            let s;
            const a = new Date;
            try {
                s = await fetch(e, t)
            } catch (e) {
                throw (0, n.S3)(e, a)
            }
            if (!s.ok) throw await (0, n.oE)(s);
            return s
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(14),
            o = s(79),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.memo, n.Hocs.withWebLazyRender((({
            isBelowTheFold: e
        }) => ({
            forceShow: !e,
            spacerHeight: 40
        }))), n.Hocs.withObservables(["tag"], (({
            tag: e
        }) => ({
            tag: e
        }))), n.Hocs.withObservables(["tag", "team", "showCounter"], (({
            tag: e,
            team: t,
            showCounter: s
        }) => ({
            activeTasksCounter: s ? e.tasksInTeam(t).activeTasks.pipe(n.Rx.map((e => e.observeCount()))) : n.Rx.of(null)
        }))))((e => {
            const {
                tag: t,
                team: s,
                hasHairline: i,
                onPress: c,
                showFavFollowIcon: l = !0,
                activeTasksCounter: d,
                onLongPress: u
            } = e, {
                isFavorite: m
            } = t.asSidebarFavoritable(s);
            return (0, r.jsx)(o.Z, {
                linkTo: (0, a.smartPathToTag)(s, t),
                title: t.name,
                onPress: c,
                hasHairline: i,
                iconColor: t.color,
                isEnded: t.isArchived,
                isFavorite: m,
                showFavFollowIcon: l,
                icon: n.Styling.defaultTagIcon(t.icon),
                counter: d,
                statusIcon: t.isPrivate ? "ŀ" : null,
                onLongPress: u
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            I: () => m
        });
        var n = s(0),
            a = s(21),
            o = s(78),
            r = s(35),
            i = s(44),
            c = s(88);
        const l = (e, t) => {
            switch (t.type) {
                case "set_name":
                    return Object.assign({}, e, {
                        name: t.payload
                    });
                case "set_responsible_member": {
                    const {
                        responsible: s,
                        shouldCheckAccess: n
                    } = t.payload;
                    return Object.assign(Object.assign({}, e, {
                        responsible: s,
                        shouldCheckAccess: n
                    }), s ? {} : {
                        dueDate: null,
                        recurrence: null
                    })
                }
                case "set_responsible_email": {
                    const {
                        email: s,
                        currentMember: n
                    } = t.payload;
                    return Object.assign({}, e, {
                        granteeEmail: s,
                        responsible: n
                    })
                }
                case "set_reminders": {
                    const {
                        added: s,
                        removed: n
                    } = t.payload;
                    return Object.assign({}, e, {
                        reminders: [...e.reminders.filter((e => !(0, o.ES)(e, n))), ...s]
                    })
                }
                case "set_tags": {
                    const {
                        added: s,
                        removed: n
                    } = t.payload;
                    return Object.assign({}, e, {
                        tags: [...e.tags.filter((e => !n.includes(e))), ...s]
                    })
                }
                case "set_project": {
                    const s = t.payload;
                    return Object.assign({}, e, {
                        project: s
                    })
                }
                case "set_team": {
                    const {
                        team: s,
                        singleTasks: a,
                        currentMember: o
                    } = t.payload;
                    return s.id === e.team.id ? e : Object.assign({}, e, {
                        project: a,
                        responsible: o,
                        hashtagsMap: n.FP.omit(["project", "tags", "projectSection", "responsible"], e.hashtagsMap),
                        team: s
                    })
                }
                case "set_due_date": {
                    const s = !e.responsible,
                        {
                            dueDate: n,
                            recurrence: a,
                            currentMember: o
                        } = t.payload;
                    return Object.assign(Object.assign({}, e, {
                        dueDate: n
                    }), a ? {
                        recurrence: a
                    } : {}, s && n ? {
                        responsible: o
                    } : {})
                }
                case "set_recurrence":
                    return Object.assign({}, e, {
                        recurrence: t.payload
                    });
                case "set_priority":
                    return Object.assign({}, e, {
                        isPriority: t.payload
                    });
                case "toggle_priority":
                    return Object.assign({}, e, {
                        isPriority: !e.isPriority
                    });
                case "set_hashtags_map":
                    return Object.assign({}, e, {
                        hashtagsMap: t.payload
                    });
                case "set_comment":
                    return Object.assign({}, e, {
                        comment: t.payload.comment,
                        attachments: t.payload.attachments
                    });
                case "reset":
                    return t.payload;
                default:
                    return e
            }
        };

        function d(e, t) {
            if (null != t && t.dueDate) return null == t ? void 0 : t.dueDate;
            if ("string" == typeof e.section) {
                const t = Number(e.section);
                if (!Number.isNaN(t)) return a.DateTime.onDay(new Date(t))
            }
            return null
        }

        function u(e, t) {
            var s, n, a, o, r, i, c, l, u, m, h, p;
            const {
                responsible: g,
                shouldCheckAccess: f,
                project: b,
                team: y,
                isPriorityActive: v,
                tags: w,
                comment: k
            } = e;
            return {
                name: null != (s = null == t ? void 0 : t.name) ? s : "",
                responsible: null != (n = null == t ? void 0 : t.responsible) ? n : g,
                shouldCheckAccess: null != (a = null == t ? void 0 : t.shouldCheckAccess) ? a : !!f,
                reminders: null != (o = null == t ? void 0 : t.reminders) ? o : [],
                dueDate: d(e, t),
                project: null != (r = null == t ? void 0 : t.project) ? r : b,
                team: null != (i = null == t ? void 0 : t.team) ? i : y,
                recurrence: null != (c = null == t ? void 0 : t.recurrence) ? c : null,
                isPriority: null != (l = null == t ? void 0 : t.isPriority) ? l : !!v,
                hashtagsMap: null != (u = null == t ? void 0 : t.hashtagsMap) ? u : {},
                granteeEmail: null == t ? void 0 : t.granteeEmail,
                comment: null != (m = null == t ? void 0 : t.comment) ? m : k,
                attachments: null != (h = null == t ? void 0 : t.attachments) ? h : [],
                tags: null != (p = null == t ? void 0 : t.tags) ? p : w || []
            }
        }
        const m = ({
            newTaskFormProps: e,
            onNewTaskFormStateChange: t,
            draft: s,
            rootRecord: o
        }) => {
            const d = n.React.useRef(),
                {
                    currentMember: m
                } = n.Hooks.useIdentity(),
                h = n.Hooks.useAttachments({
                    onDropCallback: n.FP.noop,
                    team: e.team
                }),
                {
                    attachedFiles: p,
                    clearAttachedFiles: g
                } = h;
            n.React.useEffect((() => {
                g()
            }), [o, g]);
            const f = function(e) {
                    const {
                        team: t,
                        project: s,
                        tags: a,
                        isPriorityActive: o,
                        responsible: r,
                        shouldCheckAccess: i,
                        comment: c
                    } = e, l = n.React.useMemo((() => ({
                        team: t,
                        project: s,
                        tags: a,
                        isPriorityActive: o,
                        responsible: r,
                        shouldCheckAccess: i,
                        comment: c
                    })), [t, s, o, r, i, a, c]);
                    return l
                }(e),
                b = n.React.useRef(!1),
                [y, v] = n.React.useState(!1),
                [w, k] = n.Hooks.useReducerResettable(l, u(f, s), [f]),
                x = n.React.useCallback((e => {
                    k(e), "reset" !== e.type && (b.current = !0)
                }), [k]);
            return n.React.useEffect((() => {
                const e = setTimeout((() => {
                    b.current && (b.current = !1, t(w))
                }), 300);
                return () => clearTimeout(e)
            }), [t, w]), n.React.useEffect((() => {
                var t;
                const s = null == (t = e.positionGroup) ? void 0 : t.section;
                "string" == typeof s && Number(s) && x({
                    type: "set_due_date",
                    payload: {
                        dueDate: a.DateTime.onDay(new Date(Number(s))),
                        currentMember: m
                    }
                })
            }), [e.positionGroup, m, x]), {
                onSubmit: () => {
                    var s;
                    const {
                        name: n,
                        hashtagsMap: a,
                        dueDate: o,
                        isPriority: l,
                        responsible: d,
                        shouldCheckAccess: m,
                        recurrence: h,
                        reminders: f,
                        project: b,
                        granteeEmail: y,
                        comment: v,
                        tags: k
                    } = w;
                    if (n.trim().length) {
                        var j, T, S;
                        const t = (0, i.N7)(n, a),
                            s = null != (j = t.dueDate) ? j : o;
                        e.onSubmit({
                            name: t.taskname || "",
                            project: t.project || b,
                            tags: {
                                added: t.tags || k || [],
                                removed: []
                            },
                            isPriority: l,
                            responsibleId: (null == (T = t.responsible) ? void 0 : T.id) || (null == d ? void 0 : d.id) || null,
                            shouldCheckAccess: !(null == (S = t.responsible) || !S.id) || m,
                            granteeEmail: y,
                            projectSectionId: null,
                            projectSection: t.projectSection,
                            dueDate: s,
                            recurrence: s ? t.recurrence || h : null,
                            reminders: {
                                added: t.reminders || f,
                                removed: []
                            },
                            comment: v || p.length ? (0, r.mL)({
                                body: v || e.intl.formatMessage("gY", {
                                    attachmentCount: p.length
                                }),
                                inputFiles: (0, c.up)(p).pending
                            }, e.intl) : void 0
                        }, !0), g()
                    } else e.onHide();
                    t(null), x({
                        type: "reset",
                        payload: u({
                            team: e.team,
                            project: e.project,
                            tags: e.tags,
                            comment: e.comment,
                            isPriorityActive: e.isPriorityActive,
                            responsible: e.responsible,
                            shouldCheckAccess: e.shouldCheckAccess,
                            section: null == (s = e.positionGroup) ? void 0 : s.section
                        })
                    })
                },
                inputRef: d,
                newTaskFormState: w,
                newTaskFormStateDispatch: x,
                attachmentProps: h,
                isNewTaskFocused: y,
                setIsNewTaskFocused: v
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            b: () => h
        });
        var n = s(0),
            a = s(17),
            o = s(21),
            r = s(37);

        function i(e) {
            try {
                return JSON.parse(e)
            } catch (e) {
                return null
            }
        }

        function c(e) {
            const t = Object.keys(e).reduce(((t, s) => {
                const n = e[s];
                if (!n) return t;
                if (Array.isArray(n)) {
                    const e = n.reduce(((e, t) => {
                        const s = l(t);
                        return s && e.push(s), e
                    }), []);
                    return 0 < e.length && (t[s] = e), t
                }
                const a = l(n);
                return a && (t[s] = a), t
            }), {});
            return JSON.stringify(t)
        }

        function l(e) {
            const t = function(e) {
                switch (e.type) {
                    case "project":
                    case "responsible":
                    case "tag":
                    case "section":
                        return e.value.id;
                    case "dueDate":
                        return u(e.value);
                    case "reminder":
                        return JSON.stringify(e.value);
                    case "recurrence":
                        return e.value;
                    default:
                        return null
                }
            }(e);
            return t ? {
                type: e.type,
                value: t,
                text: e.text
            } : null
        }
        async function d(e, t) {
            var s, n, o, r;
            const c = i(e);
            if (!c) return null;
            const l = null == (s = c.project) ? void 0 : s.value,
                d = null == (n = c.projectSection) ? void 0 : n.value,
                u = null == (o = c.responsible) ? void 0 : o.value,
                h = null == (r = c.tags) ? void 0 : r.map((e => e.value)),
                {
                    db: p
                } = t,
                [g, f, b, y] = await Promise.all([l ? p.get(a.Tables.projects).find(l) : Promise.resolve(void 0), u ? p.get(a.Tables.teamMembers).find(u) : Promise.resolve(void 0), d ? p.get(a.Tables.projectSections).find(d) : Promise.resolve(void 0), h && 0 < h.length ? p.get(a.Tables.tags).query(a.Q.where(a.Columns.id, a.Q.oneOf(h))).fetch() : Promise.resolve(void 0)]),
                v = {};
            var w, k, x;
            g && (v.project = {
                type: "project",
                value: g,
                text: null == (w = c.project) ? void 0 : w.text
            });
            b && (v.projectSection = {
                type: "section",
                value: b,
                text: null == (k = c.projectSection) ? void 0 : k.text
            });
            f && (v.responsible = {
                type: "responsible",
                value: f,
                text: null == (x = c.responsible) ? void 0 : x.text
            });
            if (y && 0 < y.length && (v.tags = y.map((e => {
                    var t;
                    return {
                        type: "tag",
                        value: e,
                        text: null == (t = c.tags) || null == (t = t.find((t => t.value === e.id))) ? void 0 : t.text
                    }
                }))), c.dueDate) {
                const e = m(c.dueDate.value);
                e && (v.dueDate = {
                    type: "dueDate",
                    value: e,
                    text: c.dueDate.text
                })
            }
            return c.recurrence && (v.recurrence = {
                type: "recurrence",
                value: c.recurrence.value,
                text: c.recurrence.text
            }), c.reminders && 0 < c.reminders.length && (v.reminders = c.reminders.map((e => ({
                type: "reminder",
                value: e.value,
                text: e.text
            })))), v
        }

        function u(e) {
            return JSON.stringify({
                isAllDay: e.isAllDay,
                timestamp: e.legacyDueDate.date.getTime()
            })
        }

        function m(e) {
            try {
                const t = JSON.parse(e);
                return o.DateTime.fromLegacyDueDate({
                    date: new Date(t.timestamp),
                    isAllDay: t.isAllDay
                })
            } catch (e) {
                return null
            }
        }

        function h(e) {
            return n.Hocs.compose(n.Hocs.withServices, n.Hocs.withHooks((t => {
                const {
                    services: s
                } = t, a = e(t);
                if (!a) return {
                    onNewTaskFormStateChange: n.FP.noop,
                    __newTaskDraftViewId: a
                };
                const o = n.React.useCallback((async e => {
                    const t = await s.localStorage.get(r.d.newTaskDrafts),
                        n = t ? t[a] : null;
                    if (!e) {
                        if (!n) return;
                        const e = Object.assign({}, t);
                        return delete e[a], void await s.localStorage.set(r.d.newTaskDrafts, e)
                    }
                    const o = (i = e, JSON.stringify({
                        name: i.name || void 0,
                        projectId: null == (l = i.project) ? void 0 : l.id,
                        responsibleId: null == (d = i.responsible) ? void 0 : d.id,
                        recurrence: i.recurrence || void 0,
                        dueDate: i.dueDate ? u(i.dueDate) : void 0,
                        comment: i.comment || void 0,
                        isPriority: i.isPriority || void 0,
                        granteeEmail: i.granteeEmail || void 0,
                        reminders: 0 < i.reminders.length ? i.reminders : void 0,
                        shouldCheckAccess: i.shouldCheckAccess || void 0,
                        hashtagsMap: i.hashtagsMap ? c(i.hashtagsMap) : void 0,
                        tagIds: 0 < i.tags.length ? i.tags.map((e => e.id)) : void 0,
                        teamId: i.team.id
                    }));
                    var i, l, d;
                    if (n === o) return;
                    const m = Object.assign({}, t, {
                        [a]: o
                    });
                    await s.localStorage.set(r.d.newTaskDrafts, m)
                }), [s, a]);
                return {
                    __newTaskDraftViewId: a,
                    onNewTaskFormStateChange: o
                }
            })), n.Hocs.withObservables(["__newTaskDraftViewId"], (({
                services: e,
                __newTaskDraftViewId: t
            }) => ({
                newTaskDraft: t ? n.Rx.from(e.localStorage.get(r.d.newTaskDrafts)).pipe(n.Rx.map((e => e ? e[t] : null)), n.Rx.switchMap((t => t ? n.Rx.from(async function(e, t) {
                    const s = i(e),
                        {
                            db: n
                        } = t,
                        o = null == s ? void 0 : s.projectId,
                        r = null == s ? void 0 : s.responsibleId,
                        c = null == s ? void 0 : s.teamId,
                        l = null == s ? void 0 : s.tagIds,
                        [u, h, p, g, f] = await Promise.all([o ? n.get(a.Tables.projects).find(o) : Promise.resolve(void 0), r ? n.get(a.Tables.teamMembers).find(r) : Promise.resolve(void 0), c ? n.get(a.Tables.teams).find(c) : Promise.resolve(void 0), l && 0 < l.length ? n.get(a.Tables.tags).query(a.Q.where(a.Columns.id, a.Q.oneOf(l))).fetch() : Promise.resolve(void 0), null != s && s.hashtagsMap ? d(null == s ? void 0 : s.hashtagsMap, t) : Promise.resolve(void 0)]);
                    return {
                        name: null == s ? void 0 : s.name,
                        comment: null == s ? void 0 : s.comment,
                        dueDate: m(null == s ? void 0 : s.dueDate),
                        granteeEmail: null == s ? void 0 : s.granteeEmail,
                        isPriority: null == s ? void 0 : s.isPriority,
                        recurrence: null == s ? void 0 : s.recurrence,
                        shouldCheckAccess: null == s ? void 0 : s.shouldCheckAccess,
                        reminders: null == s ? void 0 : s.reminders,
                        project: u,
                        responsible: h,
                        team: p,
                        tags: g,
                        hashtagsMap: f || {},
                        attachments: []
                    }
                }(t, e)) : n.Rx.of(null)))) : n.Rx.of(null)
            }))))
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            NewTaskContext: () => c,
            default: () => i
        });
        var n = s(0),
            a = s(927);
        s(2), s(3);
        const o = s(575);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
                const {
                    itemConfig: t,
                    beginDrag: s,
                    isDragged: i,
                    isDndEnabled: l,
                    hasTasksOrSections: d
                } = e, {
                    state: u,
                    dispatch: m,
                    onSubmit: h,
                    inputRef: p,
                    attachmentProps: g,
                    newTaskFormProps: f,
                    isNewTaskFocused: b,
                    setIsNewTaskFocused: y
                } = n.React.useContext(c), {
                    isFirst: v,
                    isLast: w
                } = t.position, k = !(v || w && !t.section.hasFooter), {
                    setPositionGroup: x
                } = f, j = n.React.useCallback((() => {
                    x((e => ({
                        position: "top" === e.position ? "bottom" : "top",
                        section: e.section
                    })))
                }), [x]), T = () => {
                    f.onHide(), y(!1)
                };
                return n.Hooks.useShortcutProviders([{
                    id: "list.new_task_close",
                    action: T
                }]), n.Hooks.useBackButton((() => (T(), !0))), (0, r.jsx)(a.Z, {
                    className: (k ? "" : o.topMargin) + (k ? " " + o.insideList : ""),
                    newTaskFormState: u,
                    newTaskFormStateDispatch: m,
                    onSubmit: h || n.FP.noop,
                    onCancel: f.onHide,
                    inputRef: p,
                    project: f.project,
                    onToggleArrow: j,
                    attachmentProps: g,
                    position: f.positionGroup.position || "top",
                    defaultResponsible: f.responsible,
                    isLastItemOnList: !d,
                    isDraggable: l,
                    dragIndex: t.index,
                    move: s,
                    isDragged: i,
                    isFocused: b,
                    setIsFocused: y
                })
            })),
            c = n.React.createContext(void 0)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => H
        });
        var n = s(0),
            a = s(297),
            o = s(352),
            r = s(17),
            i = s(90),
            c = s(22),
            l = s(60),
            d = s(13);
        const u = "onBackground3",
            m = "blue";
        s(2), s(3);
        const h = s(573);
        var p = s(40),
            g = s(11),
            f = s(18),
            b = s(71);
        const y = s(574);
        var v = s(1);
        const w = n.Hocs.compose()((e => {
                const {
                    onPress: t,
                    onPressExtraParam: s,
                    accessibilityLabel: a,
                    label: o,
                    icon: r,
                    hasBadge: i,
                    children: c,
                    color: l = u,
                    backgroundColor: d,
                    testId: h,
                    size: w
                } = e;
                invariant(c || r, "You need to provide either icon or child");
                const k = "small" === w ? 30 : 36,
                    x = "small" === w ? 20 : 24,
                    j = [...r ? [{
                        iconName: r,
                        color: l,
                        size: x
                    }] : [], ...i ? [{
                        iconName: "H",
                        color: m,
                        size: x
                    }] : []];
                return (0, v.jsx)(b.default, {
                    renderLabel: a,
                    children: (0, v.jsxs)(g.Z, {
                        className: y.iconWithHover,
                        style: {
                            backgroundColor: d ? n.Styling.factoryColor(d) : void 0,
                            height: k,
                            minWidth: k
                        },
                        __webFixBlurEventOrder: !0,
                        onPress: t,
                        testId: h,
                        onPressExtraParam: s,
                        children: [c || (r ? (0, v.jsx)(p.default, {
                            layers: j
                        }) : null), o ? (0, v.jsx)(f.default, {
                            children: o
                        }) : void 0]
                    })
                })
            })),
            k = e => {
                const {
                    openModal: t,
                    onSubmit: s,
                    hasName: a,
                    isCommentOn: o,
                    isAttachmentOn: r,
                    setShowTaskParams: i,
                    showTaskParams: c,
                    quickAddStyle: p,
                    onCommentPress: g,
                    isCommentActive: f
                } = e, b = n.Hooks.useIntl();
                return (0, v.jsx)(l.tu, {
                    style: {
                        backgroundColor: n.Styling.vars.color.surface
                    },
                    children: (0, v.jsxs)("div", {
                        className: h.root,
                        style: {
                            width: "100%"
                        },
                        children: [p ? null : (0, v.jsx)(w, {
                            onPress: e => {
                                n.ReactUtils.stopPropagation(e), n.ReactUtils.preventDefault(e), i(!c)
                            },
                            accessibilityLabel: b.f.mD,
                            children: (0, v.jsx)(d.default, {
                                color: u,
                                name: "£",
                                size: 24,
                                style: {
                                    transition: "transform var(--nozbe-animation-duration-fast)",
                                    transform: c ? " rotateZ(90deg)" : "rotateZ(0deg)"
                                }
                            })
                        }), (0, v.jsx)(w, {
                            onPress: g,
                            accessibilityLabel: b.f.tz,
                            hasBadge: o,
                            icon: "k",
                            color: f ? m : u
                        }), (0, v.jsx)(w, {
                            onPress: t,
                            onPressExtraParam: "attachments",
                            accessibilityLabel: b.f.l_,
                            hasBadge: r,
                            icon: "="
                        }), s ? (0, v.jsx)(w, {
                            backgroundColor: a ? "priority" : "transparent",
                            onPress: a ? s : void 0,
                            accessibilityLabel: b.f.CX,
                            icon: "ƈ",
                            color: a ? "white" : "onBackground1"
                        }) : null]
                    })
                })
            };
        var x = s(1297),
            j = s(1300),
            T = s(21),
            S = s(78);
        const P = n.ReactUtils.identityElement,
            _ = n.ReactUtils.lazy((() => s(67))),
            C = n.ReactUtils.lazy((() => s(56))),
            R = n.ReactUtils.lazy((() => s(106))),
            A = n.ReactUtils.lazy((() => s(13))),
            I = n.ReactUtils.lazy((() => s(18))),
            N = n.Hocs.compose(n.Hocs.withObservables(["responsible"], (({
                responsible: e
            }) => ({
                isResponsibleMe: e ? e.user.observe().pipe(n.Rx.map((e => e.isMe))) : n.Rx.of(!1)
            }))))((e => {
                const {
                    onTogglePriority: t,
                    onToggleArrow: s,
                    onToggleHashtag: a,
                    currentProject: o,
                    dueDate: r,
                    reminders: i,
                    tags: c,
                    responsible: l,
                    isPriority: d,
                    arrowState: h,
                    showProjectIcon: p,
                    hasRecurrence: g,
                    openModal: f,
                    showTeamIcon: b,
                    currentTeam: y,
                    isResponsibleMe: k
                } = e, x = n.Hooks.useIntl(), j = d ? "Ƙ" : "Ɨ", N = ((e, t) => e ? t ? "u" : "S" : "R")(!!r, g), E = d ? m : u, O = n.React.useMemo((() => null != i && i.length ? (0, S.zK)({
                    intl: x,
                    format: "short",
                    reminderDate: n.FP.sort(n.FP.ascend((e => e)), i)[0]
                }) + (1 < i.length ? " +" + (i.length - 1) : "") : ""), [i, x]);
                return (0, v.jsxs)(P, {
                    children: [h && s ? (0, v.jsx)(w, {
                        size: "small",
                        accessibilityLabel: "up" === h ? x.f.my : x.f.mz,
                        onPress: s,
                        children: (0, v.jsx)(A, {
                            color: u,
                            name: ";",
                            size: 24,
                            style: {
                                transition: "transform var(--nozbe-animation-duration-fast)",
                                transform: "up" === h ? "scale(1, 1)" : "scale(1, -1)"
                            }
                        })
                    }) : null, (0, v.jsx)(w, {
                        size: "small",
                        onPress: a,
                        onPressExtraParam: "autocomplete",
                        accessibilityLabel: x.f.mx,
                        icon: "À"
                    }), b ? (0, v.jsx)(w, {
                        size: "small",
                        accessibilityLabel: x.f.tA,
                        onPress: f,
                        onPressExtraParam: "team",
                        label: y.name,
                        children: (0, v.jsx)(R, {
                            team: y,
                            size: "tiny"
                        })
                    }) : null, p ? (0, v.jsx)(w, {
                        size: "small",
                        onPress: f,
                        onPressExtraParam: "project",
                        accessibilityLabel: x.f.lz,
                        testId: n.Misc.testIds.taskList_newTask_togglePosition,
                        color: o.color || "onBackground3",
                        icon: n.Styling.getProjectIcon(o),
                        label: n.Styling.getProjectName(o, x)
                    }) : null, (0, v.jsx)(w, {
                        size: "small",
                        onPress: f,
                        onPressExtraParam: "responsible",
                        accessibilityLabel: x.f.lx,
                        icon: "ƶ",
                        children: l ? (0, v.jsxs)(v.Fragment, {
                            children: [(0, v.jsx)(C, {
                                member: l,
                                size: "tiny"
                            }), (0, v.jsx)(_, {
                                member: l,
                                shouldRenderYou: k
                            })]
                        }) : null
                    }), (0, v.jsx)(w, {
                        size: "small",
                        onPress: f,
                        onPressExtraParam: "dueDate",
                        accessibilityLabel: x.f.mw,
                        color: r ? m : u,
                        icon: N,
                        hasBadge: !!r,
                        label: r ? (0, T.formatDateTimeRelative)({
                            dateTime: r,
                            intl: x
                        }) : void 0
                    }), (0, v.jsx)(w, {
                        size: "small",
                        onPress: f,
                        onPressExtraParam: "reminder",
                        accessibilityLabel: x.f.mC,
                        color: null != i && i.length ? m : u,
                        hasBadge: !(null == i || !i.length),
                        icon: null != i && i.length ? "Ż" : "ź",
                        label: null != i && i.length ? O : void 0
                    }), (0, v.jsx)(w, {
                        size: "small",
                        onPress: f,
                        onPressExtraParam: "tag",
                        accessibilityLabel: x.f.lC,
                        color: null != c && c.length ? m : u,
                        icon: "Ɲ",
                        children: null != c && c.length ? c.map((e => (0, v.jsxs)(n.React.Fragment, {
                            children: [(0, v.jsx)(A, {
                                name: n.Styling.defaultTagIcon(e.icon),
                                color: e.color || "onBackground3",
                                size: 24
                            }), (0, v.jsx)(I, {
                                children: e.name
                            })]
                        }, e.id))) : void 0
                    }), (0, v.jsx)(w, {
                        size: "small",
                        onPress: t,
                        accessibilityLabel: d ? x.f.mB : x.f.mA,
                        color: E,
                        icon: j
                    })]
                })
            }));
        var E = s(114);
        const {
            CommentEdit: O,
            PreviewButton: M
        } = s(253).wx, D = n.Hocs.compose(x.g_)((e => {
            const {
                dragHandleProps: t,
                onSubmit: s,
                onCancel: a,
                newTaskFormState: l,
                newTaskFormStateDispatch: d,
                showProjectIcon: u,
                showTeamIcon: m,
                attachmentProps: h,
                forceIconsDown: p,
                onToggleArrow: g,
                isPreviewModeEnabled: f,
                togglePreviewMode: b,
                setIsFocused: y
            } = e, w = n.React.useRef(), T = n.React.useRef(null), S = n.React.useRef(!1), [P, _] = (0, x.RO)(), C = p || P, [R, A] = n.Hooks.useToggle(!1), I = n.React.useCallback((() => {
                requestAnimationFrame((() => {
                    w.current && n.ReactUtils.scrollIntoView({
                        element: w.current,
                        alignment: "nearest"
                    }), T.current && T.current.focus()
                }))
            }), []), E = n.Hooks.useIntl(), {
                attachedFiles: D
            } = h, {
                name: H,
                hashtagsMap: F,
                isPriority: Z,
                dueDate: L,
                reminders: B,
                recurrence: z,
                responsible: U,
                project: W,
                team: G,
                comment: V,
                tags: q
            } = l, {
                arrowState: Q,
                preventCancelOnBlur: Y,
                openModal: J,
                closeModal: K,
                modalType: $,
                pickerTarget: X,
                setWebTarget: ee,
                hashtagsLength: te,
                setIsPickingFiles: se,
                setHasTouchedResponsible: ne,
                runOrAcknowledgeVacation: ae,
                renderVacationNotice: oe
            } = (0, x.GN)(e);
            n.React.useEffect((() => {
                e.inputRef && (e.inputRef.current = T.current)
            }));
            const re = n.React.useRef(!1),
                ie = n.React.useCallback(((e, t, s) => {
                    S.current = !0, e(t, s), I()
                }), []),
                ce = async e => {
                    var t;
                    await ae(U, (() => {
                        R && A(), ie(s, e)
                    })) || (e.stopPropagation(), null == T || null == (t = T.current) || t.blur(), ue(e, "confirmVacation"))
                }, le = n.ReactUtils.unlessImeEvent((e => {
                    "Enter" === e.key ? ce(e) : "Escape" === e.key && a()
                })), de = g ? e => {
                    ie(g, e)
                } : null, ue = (e, t) => {
                    re.current = !0, ee({
                        current: e.currentTarget
                    }), J(e, t)
                }, me = e => {
                    T.current && T.current.blur();
                    const t = (0, x.f_)(H, F);
                    d({
                        type: "set_hashtags_map",
                        payload: t
                    }), ue(e, "autocomplete")
                }, he = () => {
                    re.current = !1, A(), I()
                };
            return n.React.useEffect((() => {
                I()
            }), []), (0, v.jsxs)(v.Fragment, {
                children: [(0, v.jsxs)("div", {
                    className: j.Z.root + " " + (e.className || ""),
                    style: e.style,
                    "data-testid": n.Misc.testIds.taskList_newTask,
                    children: [(0, v.jsx)("div", {
                        className: j.Z.scrollIntoViewOffsetter,
                        ref: w
                    }), (0, v.jsxs)("div", {
                        className: j.Z.left,
                        children: [t ? (0, v.jsx)("div", Object.assign({}, t, {
                            children: (0, v.jsx)(c.default, {
                                size: 30,
                                color: "onBackground2",
                                name: "~",
                                isDisabled: !0,
                                accessibilityLabel: E.f.mv
                            })
                        })) : null, (0, v.jsx)(i.Z, {
                            className: j.Z.input,
                            ref: T,
                            placeholder: E.f.tB,
                            value: H,
                            autoFocus: !1,
                            onFocus: () => y(!0),
                            onBlur: () => {
                                S.current ? (S.current = !1, I()) : (y(!1), Y || re.current || a())
                            },
                            onChange: e => d({
                                type: "set_name",
                                payload: e
                            }),
                            onKeyDown: le,
                            onKeyPress: e => {
                                const t = H[e.target.selectionStart - 1];
                                "#" !== e.key || " " !== t && void 0 !== t || (re.current = !0, me(e));
                                const s = H[e.target.selectionStart - 2];
                                "/" !== e.key || "/" !== t || " " !== s && void 0 !== s || (d({
                                    type: "set_name",
                                    payload: H.slice(0, e.target.selectionStart - 1) + H.slice(e.target.selectionStart + 1)
                                }), re.current = !0, e.preventDefault(), A())
                            },
                            maxLength: r.MaxLengths.tasks.name + te,
                            testId: n.Misc.testIds.taskList_newTask_input
                        })]
                    }), (0, v.jsxs)("div", {
                        className: j.Z.paramContainer,
                        style: C ? {
                            width: "100%"
                        } : void 0,
                        children: [(0, v.jsx)("div", {
                            className: j.Z.bottom,
                            style: {
                                transform: "translate3d(0, " + (C ? 0 : 48) + "px, 0)",
                                opacity: C ? 1 : 0
                            },
                            children: C ? (0, v.jsx)(N, {
                                isPriority: Z,
                                arrowState: Q,
                                dueDate: L,
                                hasRecurrence: !!z,
                                reminders: B,
                                tags: q,
                                onToggleArrow: de,
                                onTogglePriority: e => {
                                    ie((() => d({
                                        type: "toggle_priority"
                                    })), e)
                                },
                                responsible: U,
                                onToggleHashtag: e => {
                                    re.current = !0, me(e)
                                },
                                showProjectIcon: !!u,
                                showTeamIcon: !!m,
                                openModal: ue,
                                currentProject: W,
                                currentTeam: G
                            }) : null
                        }), (0, v.jsx)(x.f2, {
                            children: (0, v.jsx)(k, {
                                isCommentOn: !!V,
                                isAttachmentOn: !(null == D || !D.length),
                                openModal: ue,
                                onSubmit: ce,
                                hasName: !!H,
                                setShowTaskParams: _,
                                onCommentPress: () => {
                                    re.current = !0, A()
                                },
                                isCommentActive: R,
                                quickAddStyle: p,
                                showTaskParams: C
                            })
                        })]
                    }), (0, v.jsx)("div", {
                        className: j.Z.commentContainer,
                        style: {
                            transform: "translate3d(0, " + (R ? 0 : -48) + "px, 0)",
                            opacity: R ? 1 : 0
                        },
                        children: R ? (0, v.jsxs)(v.Fragment, {
                            children: [(0, v.jsx)(o.Z, {
                                right: (0, v.jsx)(M, {
                                    bundle$close: he,
                                    isActive: f,
                                    onPress: b
                                }),
                                isActive: !0,
                                children: E.f.ty
                            }), (0, v.jsx)(O, {
                                bundle$close: he,
                                onClose: he,
                                editedComment: null,
                                replyComment: null,
                                initialDraft: V || void 0,
                                project: W,
                                onSave: (e, t) => {
                                    re.current = !1, d({
                                        type: "set_comment",
                                        payload: {
                                            comment: e,
                                            attachments: t
                                        }
                                    })
                                },
                                embededStyle: !0,
                                attachmentProps: h,
                                isPreviewModeEnabled: f,
                                togglePreviewMode: b
                            })]
                        }) : null
                    }), (0, x.rx)(Object.assign({}, e, {
                        openModal: J,
                        closeModal: () => {
                            re.current = !1, K(), I()
                        },
                        modalType: $,
                        showProjectIcon: u,
                        pickerTarget: X,
                        attachmentProps: h,
                        getSelectionStart: () => {
                            var e;
                            return null == (e = T.current) ? void 0 : e.selectionStart
                        },
                        setIsPickingFiles: se,
                        setHasTouchedResponsible: ne,
                        renderVacationNotice: oe
                    }))]
                }), h.renderDropZone()]
            })
        })), H = n.React.forwardRef(((e, t) => {
            const {
                isDraggable: s,
                dragIndex: n
            } = e;
            return s ? (0, v.jsx)(a.u, {
                draggableId: E.U3,
                index: n,
                children: s => (0, v.jsx)("div", Object.assign({
                    ref: s.innerRef
                }, s.draggableProps, {
                    children: (0, v.jsx)(D, Object.assign({
                        __forwardedRef: e.__forwardedRef || t
                    }, e, {
                        dragHandleProps: s.dragHandleProps
                    }))
                }))
            }) : (0, v.jsx)(v.Fragment, {
                children: (0, v.jsx)(D, Object.assign({
                    __forwardedRef: e.__forwardedRef || t
                }, e))
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n = s(0),
            a = s(13),
            o = s(29);
        s(2), s(3);
        const r = s(578);
        var i = s(1);
        const c = n.ReactUtils.lazy((() => s(579))),
            l = n.ReactUtils.lazy((() => s(56))),
            d = (e, t) => {
                switch (e) {
                    case o.TE.COMPLETED:
                        return t ? "Ʃ" : "ƪ";
                    case o.TE.ABANDONED:
                        return t ? "ƾ" : "ǀ";
                    default:
                        return "ƨ"
                }
            },
            u = n.Hocs.compose()((e => {
                const {
                    isSelected: t,
                    task: {
                        status: s,
                        responsible: u,
                        ghostInfo: m,
                        isThread: h
                    },
                    isJustEnded: p,
                    size: g = "normal"
                } = e, {
                    currentMember: f
                } = n.Hooks.useIdentity(), b = u.id === f.id, y = !!u.id, v = !u.id, w = n.Hooks.useIntl(), k = n.Styling.factoryAvatarSize(g), x = (b || v) && !p, j = t ? "textPrimary" : "onBackground2", T = x ? j : "white", S = !b && s !== o.TE.ACTIVE;
                return h ? (0, i.jsx)(c, {
                    task: e.task,
                    size: g,
                    sideBySideAvatarSize: "small"
                }) : m ? (0, i.jsxs)("div", {
                    className: r.root,
                    style: {
                        height: k,
                        width: k
                    },
                    children: [(0, i.jsx)(a.default, {
                        className: r.plus,
                        size: k,
                        color: j,
                        name: "ż"
                    }), (0, i.jsx)(a.default, {
                        className: r.tick,
                        size: k,
                        color: j,
                        name: "ƨ"
                    })]
                }) : y && !b && s === o.TE.ACTIVE ? (0, i.jsx)(l, {
                    member: u,
                    size: g
                }) : (0, i.jsxs)("div", {
                    className: r.root,
                    style: {
                        height: k,
                        width: k
                    },
                    children: [s === o.TE.ACTIVE && v ? (0, i.jsx)(a.default, {
                        className: r.plus,
                        size: k,
                        color: t ? "textPrimary" : "purple",
                        name: "ƫ",
                        accessibilityLabel: w.f.m2
                    }) : null, (0, i.jsx)(a.default, {
                        className: r.tick,
                        size: k,
                        color: T,
                        name: d(s, x),
                        accessibilityLabel: (() => {
                            switch (s) {
                                case o.TE.COMPLETED:
                                case o.TE.ABANDONED:
                                    return w.f.m1;
                                default:
                                    return w.f.mU
                            }
                        })()
                    }), S ? (0, i.jsx)("div", {
                        className: r.background + (y ? " " + r.backgroundDimmed : "")
                    }) : null, p ? (0, i.jsx)("div", {
                        className: r.background,
                        style: {
                            backgroundColor: n.Styling.factoryColor(e.viewColor || "purple")
                        }
                    }) : null, y && S ? (0, i.jsx)(l, {
                        className: r.doneAvatar,
                        member: u
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(56);
        s(2), s(3);
        const o = s(580);
        var r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                members: t,
                avatarStyle: s,
                size: i = "normal",
                sideBySideAvatarSize: c = i
            } = e, l = n.React.useMemo((() => n.Styling.factoryAvatarSize(c)), [c]), d = n.React.useMemo((() => 1.7 * l), [l]), u = n.React.useMemo((() => .1 * l), [l]);
            return 2 < t.length ? (0, r.jsxs)("div", {
                className: o.root,
                style: {
                    height: d,
                    width: d
                },
                children: [(0, r.jsx)("div", {
                    className: o.avatarBox,
                    style: {
                        top: u,
                        left: u
                    },
                    children: (0, r.jsx)(a.default, {
                        className: o.border,
                        member: t[0],
                        size: c,
                        avatarStyle: s
                    })
                }), (0, r.jsx)("div", {
                    className: o.avatarBox,
                    style: {
                        bottom: u,
                        right: u
                    },
                    children: (0, r.jsx)(a.default, {
                        className: o.border,
                        member: t[1],
                        size: c,
                        avatarStyle: s
                    })
                })]
            }) : (0, r.jsx)(a.default, {
                member: t[0],
                size: i,
                avatarStyle: s
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(610)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(32),
            o = s(20),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                target: t,
                closeMenu: s,
                onCopyEmailAddress: i,
                onGenerateNewEmailAddress: c,
                onDeactivateEmailToNozbe: l,
                onAddToContacts: d,
                emailAddress: u,
                deactivateLabel: m
            } = e;
            invariant(u, "Email to Nozbe is active but email address is null");
            const h = n.Hooks.useIntl(),
                [{
                    closeAnimated: p
                }, g] = (0, a.XH)();
            return (0, r.jsxs)(a.ZP, {
                onClose: s,
                target: t,
                placement: "right",
                ref: g,
                children: [(0, r.jsx)(o.Z, {
                    icon: "Ų",
                    hasArrow: !1,
                    topDescription: h.f.uf,
                    label: u
                }), (0, r.jsx)(o.Z, {
                    icon: "`",
                    hasArrow: !1,
                    label: h.f.iy,
                    onPress: n.ReactUtils.callBoth(i, p)
                }), null, (0, r.jsx)(o.Z, {
                    icon: "¦",
                    hasArrow: !1,
                    label: h.f.iA,
                    onPress: c
                }), (0, r.jsx)(o.Z, {
                    icon: "ƿ",
                    hasArrow: !1,
                    iconColor: "red",
                    label: m,
                    onPress: n.ReactUtils.callBoth(l, p)
                }), (0, r.jsx)(o.Z, {
                    icon: "Ų",
                    label: h.f.fC,
                    onPress: () => n.ReactUtils.openUrl(n.ReactUtils.helpUrl(h, "taskcommunication/email-tasks/#emailactivate"))
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n, a = s(0),
            o = s(6),
            r = s(12),
            i = s(1);
        const c = [{
                iconName: "n",
                color: "blue",
                size: 200
            }, {
                iconName: "_",
                color: "blue",
                opacity: .2,
                size: 250
            }],
            l = a.Hocs.compose((0, o.LU)())((e => {
                const {
                    header: t,
                    description: s,
                    children: l,
                    onConvertPress: d,
                    helpPageUrl: u
                } = e, m = a.Hooks.useIntl();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(o.u_.Header, {
                        helpPageUrl: u,
                        children: t
                    }), (0, i.jsxs)(o.u_.Content, {
                        children: [n || (n = (0, i.jsx)(o.u_.IconStack, {
                            stack: c
                        })), (0, i.jsx)(o.u_.Paragraph, {
                            children: s
                        }), l, (0, i.jsx)(o.u_.Buttons, {
                            children: (0, i.jsx)(r.default, {
                                label: m.f.fk,
                                variant: "opaque",
                                color: "blue",
                                onPress: d
                            })
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n, a = s(0),
            o = s(178),
            r = s(6),
            i = s(12),
            c = s(371),
            l = s(1);
        const d = a.Hocs.compose(a.Hocs.withServices, a.Hocs.withIdentity, a.Hocs.withObservables(["currentTeam"], (({
            services: e,
            currentTeam: t
        }) => ({
            integrationState: e.modelRoot.settings.observeIntegrationState(t, "dropbox_integration")
        }))))((e => {
            const {
                integrationState: t,
                onCancel: s
            } = e, d = Boolean(null == t ? void 0 : t.enabled), u = a.Hooks.useServices(), m = a.Hooks.useIntl(), {
                currentTeam: h
            } = a.Hooks.useIdentity(), p = (0, o.R)({
                team: h,
                state: t,
                connectUrl: e => u.api.integrations.getDropboxConnectUrl(h, e),
                disconnect: e => u.api.integrations.disconnectDropbox(e ? null : h)
            });
            return (0, l.jsxs)(l.Fragment, {
                children: [n || (n = (0, l.jsx)(r.u_.IconStack, {
                    stack: c.y
                })), (0, l.jsx)(r.u_.Heading, {
                    children: m.f.nF
                }), (0, l.jsx)(r.u_.Paragraph, {
                    children: m.f.hJ
                }), (0, l.jsxs)(r.u_.Buttons, {
                    children: [d ? (0, l.jsx)(i.default, {
                        label: m.f.n3,
                        color: "red",
                        isDisabled: p.request.isBusy,
                        onPress: p.disconnect
                    }) : (0, l.jsx)(i.default, {
                        label: m.f.nz,
                        variant: "opaque",
                        color: "blue",
                        isDisabled: p.request.isBusy,
                        onPress: p.connect
                    }), null]
                }), p.render()]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n, a = s(0),
            o = s(178),
            r = s(6),
            i = s(12),
            c = s(372),
            l = s(1);
        const d = a.Hocs.compose(a.Hocs.withServices, a.Hocs.withIdentity, a.Hocs.withObservables(["currentTeam"], (({
            services: e,
            currentTeam: t
        }) => ({
            integrationState: e.modelRoot.settings.observeIntegrationState(t, "gdrive_integration")
        }))))((e => {
            const {
                integrationState: t,
                onCancel: s
            } = e, d = Boolean(null == t ? void 0 : t.enabled), u = a.Hooks.useServices(), m = a.Hooks.useIntl(), {
                currentTeam: h
            } = a.Hooks.useIdentity(), p = (0, o.R)({
                team: h,
                state: t,
                connectUrl: e => u.api.integrations.getGoogleDriveConnectUrl(h, e),
                disconnect: e => u.api.integrations.disconnectGoogleDrive(e ? null : h)
            });
            return (0, l.jsxs)(l.Fragment, {
                children: [n || (n = (0, l.jsx)(r.u_.IconStack, {
                    stack: c.y
                })), (0, l.jsx)(r.u_.Heading, {
                    children: m.f.nV
                }), (0, l.jsx)(r.u_.Paragraph, {
                    children: m.f.lR
                }), (0, l.jsxs)(r.u_.Buttons, {
                    children: [d ? (0, l.jsx)(i.default, {
                        label: m.f.n3,
                        color: "red",
                        isDisabled: p.request.isBusy,
                        onPress: p.disconnect
                    }) : (0, l.jsx)(i.default, {
                        label: m.f.nz,
                        variant: "opaque",
                        color: "brown",
                        isDisabled: p.request.isBusy,
                        onPress: p.connect
                    }), null]
                }), p.render()]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n, a = s(0),
            o = s(178),
            r = s(6),
            i = s(12),
            c = s(373),
            l = s(1);
        const d = a.Hocs.compose(a.Hocs.withServices, a.Hocs.withIdentity, a.Hocs.withObservables(["currentTeam"], (({
            services: e,
            currentTeam: t
        }) => ({
            integrationState: e.modelRoot.settings.observeIntegrationState(t, "onedrive_integration")
        }))))((e => {
            const {
                integrationState: t,
                onCancel: s
            } = e, d = Boolean(null == t ? void 0 : t.enabled), u = a.Hooks.useServices(), m = a.Hooks.useIntl(), {
                currentTeam: h
            } = a.Hooks.useIdentity(), p = (0, o.R)({
                team: h,
                state: t,
                connectUrl: e => u.api.integrations.getOneDriveConnectUrl(h, e),
                disconnect: e => u.api.integrations.disconnectOneDrive(e ? null : h)
            });
            return (0, l.jsxs)(l.Fragment, {
                children: [n || (n = (0, l.jsx)(r.u_.IconStack, {
                    stack: c.$
                })), (0, l.jsx)(r.u_.Heading, {
                    children: m.f.nZ
                }), (0, l.jsx)(r.u_.Paragraph, {
                    children: m.f.uI
                }), (0, l.jsxs)(r.u_.Buttons, {
                    children: [d ? (0, l.jsx)(i.default, {
                        label: m.f.n3,
                        color: "red",
                        isDisabled: p.request.isBusy,
                        onPress: p.disconnect
                    }) : (0, l.jsx)(i.default, {
                        label: m.f.nz,
                        variant: "opaque",
                        color: "lightblue",
                        isDisabled: p.request.isBusy,
                        onPress: p.connect
                    }), null]
                }), p.render()]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            M: () => o
        });
        var n = s(0),
            a = s(14);
        async function o({
            item: e,
            currentTeam: t,
            usesShortTaskLink: s
        }) {
            const o = await n.Rx.takeFirst(t.currentMember);
            switch (e.type) {
                case "fixedView":
                    switch (e.value.type) {
                        case "activity":
                            return (0, a.pathToActivity)(t);
                        case "incoming":
                            return (0, a.pathToIncoming)(t);
                        case "priority":
                            return (0, a.pathToPriority)(t);
                        case "calendar":
                            return (0, a.pathToCalendar)(t);
                        case "my_tasks":
                            return (0, a.smartPathToMember)(t, o);
                        default:
                            throw new Error("unexpected FixedView type: " + e.value.type)
                    }
                case "project":
                    return (0, a.smartPathToProject)(t, e.value);
                case "section": {
                    const s = e.value,
                        n = await s.project.fetch();
                    return (0, a.smartPathToProjectSection)(t, n, s)
                }
                case "task": {
                    const n = e.value;
                    if (s) return (0, a.smartPathToTaskId)(t, e.value.id);
                    {
                        const e = await n.fetchCurrentProject();
                        return (0, a.smartPathToTask)(t, e, n)
                    }
                }
                case "member":
                    return (0, a.smartPathToMember)(t, e.value);
                case "tag":
                    return (0, a.smartPathToTag)(t, e.value);
                default:
                    throw new Error("Unexpected item type of item: " + e.type)
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            n0: () => o,
            sE: () => n,
            vR: () => a
        });
        s(17);

        function n(e) {
            return "member" === e.type
        }

        function a(e) {
            return "group_predefined" === e.type
        }

        function o(e) {
            return "group" === e.type
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => j
        });
        var n, a = s(0),
            o = s(25),
            r = s(32),
            i = s(6),
            c = s(20),
            l = s(868),
            d = s(104),
            u = s(132),
            m = s(81),
            h = s(60),
            p = s(123),
            g = s(43),
            f = s(14),
            b = s(1);
        const y = s(42).wx,
            v = s(158).wx,
            w = a.ReactUtils.lazy((() => s(317))),
            k = a.ReactUtils.lazy((() => s(1376))),
            x = a.Hocs.compose(a.Hocs.memo, a.Hocs.withServices, a.Hocs.withObservables(["member"], (({
                member: e
            }) => ({
                member: e,
                user: e.user,
                team: e.team,
                canHaveAliasRenamed: a.Rx.from(e.canHaveAliasRenamed()),
                canBePromoted: a.Rx.from(e.canBePromotedToAdmin()),
                canBeDemoted: a.Rx.from(e.canBeDemotedAdmin()),
                canBeArchived: a.Rx.from(e.canBeArchived()),
                groups: e.groups,
                preferredName: e.preferredName,
                closedProjects: (0, p.qJ)(e)
            }))), a.Hocs.withObservables(["team"], (({
                team: e
            }) => ({
                currentMember: e.currentMember,
                teamHasGroups: e.allMemberGroups.observeCount().pipe(a.Rx.map((e => !!e)))
            }))), a.Hocs.withObservables(["user"], (({
                user: e
            }) => ({
                canBeRenamed: a.Rx.from(e.canBeRenamed())
            }))), a.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                hasCurrentMemberAdminPowers: e.hasAdminPowers,
                manageableClosedProjects: (0, p.j9)(e)
            }))), a.Hocs.withFeatureBadges({
                placement: "member_menu"
            }))((e => {
                var t, s;
                const {
                    target: p,
                    member: x,
                    closeMenu: j,
                    canBeRenamed: T,
                    canHaveAliasRenamed: S,
                    canBePromoted: P,
                    canBeDemoted: _,
                    canBeArchived: C,
                    user: R,
                    team: A,
                    groups: I,
                    preferredName: N,
                    closedProjects: E,
                    teamHasGroups: O,
                    currentMember: M,
                    hasCurrentMemberAdminPowers: D,
                    manageableClosedProjects: H,
                    children: F,
                    level: Z,
                    __forwardedRef: L,
                    openMemberOnArchive: B,
                    featureBadges: z
                } = e, U = a.Hooks.useServices(), W = a.Hooks.useIntl(), G = async () => {
                    await x.do.promoteToAdmin(), await U.sync.synchronizeTwice()
                }, V = async () => {
                    await x.do.demoteAdmin(), await U.sync.synchronizeTwice()
                }, q = async () => {
                    B && U.router.goTo((0, f.smartPathToMember)(A, M)), x === M ? await U.account.leaveTeam(A) : await x.do.archive()
                }, Q = async (e, t) => {
                    await R.do.rename(t)
                }, Y = async (e, t) => {
                    await x.do.renameAlias(t)
                }, J = async (e, t) => {
                    await x.do.updateDescription(t)
                }, K = async () => {
                    await x.do.resendInvitation(), await U.sync.synchronize()
                }, $ = a.Hooks.useModalState(), X = a.Hooks.useModalState(), ee = async e => {
                    await x.do.updateGroups(e)
                }, [te, se] = a.Hooks.useStateMachine("menu"), ne = async () => {
                    await U.payments.invokeActionOrProposeUpgrade({
                        name: "grant-admin",
                        member: x
                    }, (() => {
                        se("confirm", {
                            onConfirmPress: G,
                            headerIcon: "Ŝ",
                            confirmMessage: W.f.qK
                        })()
                    }))
                }, ae = () => (0, b.jsx)(y.MemberGroup, {
                    team: A,
                    bundle$close: j,
                    onClose: j,
                    selectedGroups: I,
                    isDesktopModal: !1,
                    target: $.target,
                    onConfirm: ee,
                    placement: "right",
                    level: Z
                }), oe = () => {
                    const e = X.close;
                    return (0, b.jsx)(y.ProjectMultiple, {
                        bundle$close: e,
                        onClose: e,
                        onConfirm: e => {
                            const t = a.FP.arrayDifference(E, e);
                            t.added.length || t.removed.length ? se("closedProjectsConfirm", t)() : j()
                        },
                        level: Z,
                        target: X.target,
                        isDesktopModal: !1,
                        placement: "right",
                        availableProjectIds: a.FP.pluckIds(H),
                        selectedProjects: E,
                        hideNewProject: !0
                    })
                };
                return (0, b.jsx)(b.Fragment, {
                    children: te.map({
                        destroyConfirm: () => (0, b.jsx)(w, {
                            message: W.f.qJ,
                            confirmationText: A.name,
                            placeholderText: W.f.JV,
                            onConfirmPress: q,
                            onBackPress: se("menu"),
                            headerIcon: "Ʒ",
                            confirmButtonMessage: W.f.qI,
                            onClose: se("menu")
                        }),
                        confirm: ({
                            type: e = "confirm",
                            onConfirmPress: t,
                            headerIcon: s,
                            confirmMessage: n,
                            confirmButtonMessage: a
                        }) => (0, b.jsx)(o.default, {
                            type: e,
                            onConfirmPress: t,
                            onBackPress: j,
                            onClose: j,
                            headerIcon: s,
                            confirmButtonMessage: a,
                            children: n
                        }),
                        closedProjectsConfirm: e => {
                            const s = (e, t) => (0, b.jsxs)(b.Fragment, {
                                children: [(0, b.jsx)(i.u_.Heading, {
                                    children: e
                                }), (0, b.jsx)(i.u_.Section, {
                                    noGutter: !1,
                                    children: t.map((e => (0, b.jsx)(l.Z, {
                                        project: e
                                    }, e.id)))
                                })]
                            });
                            return (0, b.jsx)(o.default, {
                                type: "confirm",
                                onConfirmPress: () => A.do.updateProjectAccessesForMember(x, e),
                                onBackPress: j,
                                onClose: j,
                                hasTextContent: !1,
                                children: (0, b.jsxs)(h.tu, {
                                    children: [(0, b.jsx)(i.u_.Paragraph, {
                                        children: W.g("qR", {
                                            memberName: t || (t = (0, b.jsx)(i.u_.Emphasis, {
                                                children: N
                                            }, "memberName"))
                                        })
                                    }), e.added.length ? s(W.f.qS, e.added) : null, e.removed.length ? s(W.f.qT, e.removed) : null]
                                })
                            })
                        },
                        rename: () => (0, b.jsx)(d.default, {
                            title: W.f.qX,
                            confirmButtonLabel: W.f.fS,
                            onConfirm: Q,
                            onClose: j,
                            validators: [g.C1],
                            currentValue: R.name,
                            maxLength: a.Model.MaxLengths.users.name
                        }),
                        changeAlias: () => (0, b.jsx)(d.default, {
                            title: W.f.qB,
                            confirmButtonLabel: W.f.fS,
                            onConfirm: Y,
                            onClose: j,
                            currentValue: x.alias,
                            maxLength: a.Model.MaxLengths.teamMembers.alias
                        }),
                        changeDescription: () => (0, b.jsx)(d.default, {
                            title: W.f.qM,
                            confirmButtonLabel: W.f.fS,
                            onConfirm: J,
                            onClose: j,
                            currentValue: x.description,
                            maxLength: a.Model.MaxLengths.teamMembers.description
                        }),
                        groups: () => ae(),
                        closedProjects: () => oe(),
                        vacations: () => s || (s = (0, b.jsx)(k, {
                            member: x,
                            onClose: j
                        })),
                        menu: () => (0, b.jsxs)(r.ZP, {
                            ref: L,
                            level: Z,
                            onClose: j,
                            target: p,
                            children: [(0, b.jsxs)(b.Fragment, {
                                children: [(0, b.jsx)(v.UserCardContent, {
                                    bundle$close: a.FP.noop,
                                    member: x,
                                    isProfileView: !0
                                }), n || (n = (0, b.jsx)(r.ZP.Separator, {}))]
                            }), R.isMe ? (0, b.jsx)(c.Z, {
                                icon: "Ɖ",
                                label: W.f.db,
                                onPress: async () => {
                                    j(), U.uiState.appSettingsModal.open({
                                        pane: "user"
                                    })
                                }
                            }) : null, R.invitationEmail && x.isPending ? (0, b.jsx)(c.Z, {
                                icon: "ŉ",
                                topDescription: W.f.qP,
                                label: R.invitationEmail || ""
                            }) : null, D && x.isExpired ? (0, b.jsx)(c.Z, {
                                icon: "¥",
                                label: W.f.qV,
                                onPress: K
                            }) : null, T && !R.isMe ? (0, b.jsx)(c.Z, {
                                icon: "Ƥ",
                                topDescription: W.f.qX,
                                label: R.name,
                                hasArrow: !0,
                                onPress: se("rename")
                            }) : null, S && !R.isMe ? (0, b.jsx)(c.Z, {
                                icon: "-",
                                topDescription: x.alias ? W.f.qB : null,
                                hasArrow: !0,
                                label: x.alias || W.f.qW,
                                onPress: se("changeAlias")
                            }) : null, P ? (0, b.jsx)(c.Z, {
                                icon: "Ŝ",
                                label: W.f.qU,
                                badge: A.isFree ? m.a.Premium : void 0,
                                onPress: ne
                            }) : null, _ ? (0, b.jsx)(c.Z, {
                                icon: "Ŕ",
                                label: W.f.qL,
                                onPress: se("confirm", {
                                    onConfirmPress: V,
                                    headerIcon: "Ŕ",
                                    confirmMessage: W.f.qG
                                })
                            }) : null, C ? (0, b.jsx)(c.Z, {
                                icon: "Ʒ",
                                label: x === M ? W.f.qQ : W.f.qD,
                                iconColor: "red",
                                textColor: "red",
                                onPress: x === M ? se("destroyConfirm") : se("confirm", {
                                    type: "delete",
                                    onConfirmPress: q,
                                    headerIcon: "Ʒ",
                                    confirmMessage: W.f.qE,
                                    confirmButtonMessage: W.f.qF
                                })
                            }) : null, (0, b.jsx)(c.Z, {
                                icon: "½",
                                label: W.f.En,
                                modalWebTarget: $.target,
                                onPress: $.open,
                                hasArrow: !0,
                                isDisabled: !O,
                                bottomDescription: (0, u.v)(I, W)
                            }), R.isMe ? (0, b.jsx)(c.Z, {
                                icon: "ƹ",
                                label: W.f.qY,
                                hasArrow: !0,
                                badge: z.get("vacation_mode"),
                                onPress: se("vacations")
                            }) : null, H.length && !R.isMe ? (0, b.jsx)(c.Z, {
                                icon: "ķ",
                                label: W.f.ut,
                                modalWebTarget: X.target,
                                onPress: X.open,
                                hasArrow: !0
                            }) : null, $.isOpen ? ae() : null, X.isOpen ? oe() : null, F]
                        })
                    })
                })
            })),
            j = a.React.forwardRef(((e, t) => (0, b.jsx)(x, Object.assign({}, e, {
                __forwardedRef: t
            }))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            T: () => a
        });
        s(5), s(4), s(23), s(8);
        var n = s(14);
        const a = ({
            apiToken: e,
            invitationId: t,
            user: s,
            services: a,
            shouldOpenLogin: o = !1
        }) => setTimeout((() => {
            const r = {
                id: t,
                type: "account_upgrade",
                status: "valid",
                payload: {
                    apiToken: e,
                    email: s.myEmail
                }
            };
            o ? a.router.goTo(n.pathToLogin, {
                token: r,
                preFilledEmail: s.myEmail
            }) : a.router.goTo(n.pathToRoot, {
                accountUpgradeToken: r,
                preFilledEmail: s.myEmail
            })
        }), 0)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(77),
            o = s(81),
            r = s(483),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            team: e.currentTeam
        }))))((e => {
            const {
                project: t,
                team: s
            } = e, c = n.Hooks.useIntl(), l = (0, r.Z)(t);
            return (0, i.jsx)(a.Z, {
                label: c.f.BB,
                icon: "Ƭ",
                badge: s.isFree ? o.a.Premium : void 0,
                colorActive: "purple",
                isActive: t.areTimeAttributesEnabled,
                onChange: async () => {
                    await l()
                }
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            W: () => o
        });
        var n = s(0),
            a = s(14);
        const o = e => {
            const t = n.Hooks.useServices();
            return n.React.useCallback((async s => {
                const n = await e.do.findOrCreateThread(s),
                    o = {
                        teamId: e.id,
                        taskListName: "messages"
                    },
                    r = (0, a.getPathToTaskDetails)(o, n);
                t.router.goTo(r, {
                    openEditor: !0
                })
            }), [e, t])
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => p
        });
        var n = s(0),
            a = s(103),
            o = s(11),
            r = s(13),
            i = s(18);
        s(2), s(3);
        const c = s(767);
        var l = s(1);
        const d = n.Hocs.compose()((() => {
                const e = n.Hooks.useServices(),
                    t = n.Hooks.useIntl();
                return (0, l.jsxs)(o.Z, {
                    className: c.searchBar,
                    onPress: t => {
                        n.ReactUtils.preventDefault(t), n.ReactUtils.stopPropagation(t), e.uiState.jumpToModal.open()
                    },
                    children: [(0, l.jsx)(r.default, {
                        name: "ƅ",
                        color: "onBackground3",
                        size: 16
                    }), (0, l.jsxs)(i.default, {
                        className: c.text,
                        children: [t.f.fT, "/", t.f.pL]
                    })]
                })
            })),
            u = s(768);
        var m;
        const h = n.Misc.platform.isMacElectron ? 80 : 16,
            p = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                theme: n.Rx.wrap(n.Misc.platform.isWindowsElectron ? n.Styling.theme.asObservable() : null),
                currentPath: e.history.currentPath
            }))))((e => {
                const {
                    children: t,
                    theme: s,
                    hideButtons: o
                } = e, r = n.Hooks.useServices(), {
                    id: i
                } = r.scene, c = r.history.isLastRoute(), p = r.history.isFirstRoute();
                n.React.useEffect((() => {
                    n.Misc.platform.isWindowsElectron && s && globalThis.electron.setTitleBarOverlayTheme(s, i)
                }), [i, s]);
                const g = n.Hooks.useIntl(),
                    f = (0, l.jsxs)(l.Fragment, {
                        children: [n.Misc.platform.isWindowsElectron ? (0, l.jsx)(a.Ov, {
                            accessibilityLabel: g.f.mu,
                            icon: "Ʀ",
                            onPress: e => {
                                globalThis.electron.displayAppMenu({
                                    x: e.x,
                                    y: e.y
                                }, i)
                            }
                        }) : null, (0, l.jsx)(a.Ov, {
                            accessibilityLabel: g.f.fd,
                            icon: "7",
                            keyboardShortcutID: "go.back",
                            isDisabled: p,
                            onPress: e => {
                                n.ReactUtils.stopPropagation(e), n.ReactUtils.preventDefault(e), r.history._history.goBack()
                            }
                        }), (0, l.jsx)(a.Ov, {
                            accessibilityLabel: g.f.ll,
                            icon: "9",
                            keyboardShortcutID: "go.forward",
                            isDisabled: c,
                            onPress: e => {
                                n.ReactUtils.preventDefault(e), n.ReactUtils.stopPropagation(e), r.history._history.goForward()
                            }
                        })]
                    });
                return (0, l.jsxs)("div", {
                    className: u.electronRoot,
                    children: [(0, l.jsxs)("div", {
                        className: u.electronHeader,
                        onClick: e => {
                            2 === e.detail && globalThis.electron.toggleMaximize(i)
                        },
                        children: [(0, l.jsx)("div", {
                            className: u.controlSpace,
                            style: {
                                width: h
                            }
                        }), o ? null : (0, l.jsxs)(l.Fragment, {
                            children: [(0, l.jsx)("div", {
                                className: u.noDrag,
                                children: f
                            }), m || (m = (0, l.jsx)(d, {})), (0, l.jsx)("div", {
                                className: u.noDrag,
                                style: {
                                    height: 0,
                                    overflow: "hidden"
                                },
                                children: f
                            }), (0, l.jsx)("div", {
                                className: u.controlSpace,
                                style: {
                                    width: h
                                }
                            })]
                        })]
                    }), t]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Q: () => D,
            Z: () => H
        });
        var n = s(0),
            a = s(80),
            o = s(313),
            r = s(14);
        const i = n.Hocs.compose()((e => {
            const {
                children: t
            } = e, [s, a] = n.React.useState(!1);
            return n.React.useEffect((() => {
                n.ReactUtils.afterLaunch((() => {
                    a(!0)
                }))
            }), []), s ? t : null
        }));
        var c, l, d, u, m = s(113),
            h = s(1);
        const p = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "WhitePortals",
            render: "alert"
        }))((() => (0, h.jsxs)(h.Fragment, {
            children: [c || (c = (0, h.jsx)(m.$J, {
                name: "Tooltip"
            })), l || (l = (0, h.jsx)(m.$J, {
                name: "Modal"
            })), d || (d = (0, h.jsx)(m.$J, {
                name: "KeyboardBar"
            })), u || (u = (0, h.jsx)(m.$J, {
                name: "Onboarding"
            }))]
        })));
        var g = s(615);
        s(2), s(3);
        const f = s(769);
        var b, y, v, w, k, x, j, T, S, P, _, C = s(257);
        const R = s(770).wx,
            A = n.ReactUtils.lazy((() => s(651))),
            I = n.ReactUtils.lazy((() => s(1396))),
            N = n.ReactUtils.lazy((() => s(1397))),
            E = n.ReactUtils.lazy((() => s(1398))),
            O = n.ReactUtils.lazy((() => s(1414))),
            M = ({
                children: e
            }) => (0, h.jsx)("div", {
                className: f.overlay,
                children: (0, h.jsx)("div", {
                    className: f.messageOverlayBox,
                    children: (0, h.jsx)("span", {
                        className: f.messageOverlayText,
                        children: e
                    })
                })
            }),
            D = e => {
                const {
                    location: t
                } = e, {
                    pathname: s
                } = t, a = n.Hooks.useServices(), r = () => a.scene.webWindow.close();
                return (0, h.jsxs)(o.EZ, {
                    services: a,
                    path: s,
                    children: [(0, h.jsx)(i, {
                        children: (0, h.jsx)(R.QuickAdd, {
                            bundle$close: r,
                            onClose: r,
                            isFloating: !0
                        })
                    }), b || (b = (0, h.jsx)(p, {}))]
                })
            },
            H = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                claimPurchaseToken: e.appState.claimPurchaseToken
            }))))((e => {
                const {
                    state: t,
                    claimPurchaseToken: s,
                    location: c
                } = e, l = n.Hooks.useServices(), d = n.Hooks.useIntl(), {
                    pathname: u,
                    search: m,
                    hash: b
                } = c;
                n.React.useEffect((() => {
                    "loggedOut" === t && (u.startsWith("/teams") || u.startsWith("/promotion") || u.startsWith("/claim_purchase")) && (l.history.loginRedirectPath = u + m + b)
                }), []), (0, g.Fe)();
                switch (t) {
                    case "loggedIn":
                        return (0, h.jsxs)(o.EZ, {
                            services: l,
                            path: u,
                            children: [(0, h.jsxs)(a.Switch, {
                                children: [y || (y = (0, h.jsx)(a.Route, {
                                    path: r.routeToThirdParty,
                                    children: (0, h.jsx)(A, {})
                                })), v || (v = (0, h.jsx)(a.Route, {
                                    path: r.routeToRegisterConfirm,
                                    children: (0, h.jsx)(C.vZ, {})
                                })), w || (w = (0, h.jsx)(a.Route, {
                                    path: r.routeToEmailChangeConfirm,
                                    children: (0, h.jsx)(C.SJ, {})
                                })), (0, h.jsx)(a.Route, {
                                    path: "/",
                                    children: (0, h.jsxs)("div", {
                                        className: f.root,
                                        children: [null, s ? (0, h.jsx)(O, {
                                            token: s
                                        }) : null, k || (k = (0, h.jsx)(g.vs, {})), x || (x = (0, h.jsx)(i, {
                                            children: (0, h.jsx)(E, {})
                                        }))]
                                    })
                                })]
                            }), j || (j = (0, h.jsx)(p, {}))]
                        });
                    case "forcingRelogin":
                        return (0, h.jsx)("div", {
                            className: f.root,
                            children: (0, h.jsx)(M, {
                                children: d.f.Cz
                            })
                        });
                    case "loggingOut":
                        return (0, h.jsx)("div", {
                            className: f.root,
                            children: (0, h.jsx)(M, {
                                children: d.f.CA
                            })
                        });
                    case "withoutTeam":
                        return (0, h.jsx)("div", {
                            className: f.root,
                            children: T || (T = (0, h.jsx)(I, {}))
                        });
                    case "canceledAccount":
                        return (0, h.jsx)("div", {
                            className: f.root,
                            children: S || (S = (0, h.jsx)(N, {}))
                        });
                    case "loggedOut":
                        return (0, h.jsxs)(h.Fragment, {
                            children: [(0, h.jsxs)("div", {
                                className: f.root,
                                children: [null, P || (P = (0, h.jsx)(g.uc, {}))]
                            }), _ || (_ = (0, h.jsx)(p, {}))]
                        });
                    default:
                        throw new Error("bad state")
                }
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => g
        });
        var n = s(0),
            a = s(93),
            o = s(106);
        s(2), s(3);
        const r = s(776);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                type: t,
                children: s
            } = e;
            return (0, i.jsx)("span", {
                className: r.message + ("error" === t ? " " + r.error : "") + ("success" === t ? " " + r.success : "") + " " + (e.className || ""),
                style: e.style,
                children: s
            })
        }));
        var l = s(94),
            d = s(1546),
            u = s(774);
        const m = s(777),
            h = s(42).wx,
            p = ({
                name: e,
                color: t,
                src: s
            }) => {
                const n = (0, l.n)(s);
                return (0, i.jsx)(a.default, {
                    name: e,
                    color: t,
                    source: n,
                    size: "large",
                    isTeam: !0
                })
            },
            g = n.Hocs.compose()((e => {
                var t, s, a;
                const {
                    value: r,
                    team: l,
                    onChange: g,
                    isDisabled: f
                } = e, {
                    name: b,
                    color: y
                } = l, {
                    nativeScene: v
                } = n.Hooks.useServices(), w = n.Hooks.useIntl(), k = n.Hooks.useIsMounted(), x = n.Hooks.useModalState(), [j, T] = n.React.useState(null), [S, P] = n.Hooks.useStateMachine("idle"), _ = async (e = "files") => {
                    await v.pickFile((e => {
                        if (!k.current || !e || !e.length) return;
                        const [t] = e, s = (0, d.KZ)(t.type) ? (0, d.Kj)(t.size) ? null : "file_size_exceeded" : "invalid_file_type";
                        s ? T(s) : (g(t), T(null), P("selected")())
                    }), {
                        multiple: !1,
                        type: e,
                        mimeType: "image/*"
                    })
                };
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsxs)("div", {
                        className: m.root,
                        children: ["selected" === S.current || "removed" === S.current ? t || (t = (0, i.jsx)(p, {
                            name: b,
                            color: y,
                            src: r
                        })) : l.avatarId ? s || (s = (0, i.jsx)(o.default, {
                            team: l,
                            size: "large"
                        })) : a || (a = (0, i.jsx)(p, {
                            name: b,
                            color: y
                        })), (0, i.jsxs)("div", {
                            className: m.controls,
                            children: [(0, i.jsx)(u.Z, {
                                label: w.f.f6,
                                isDisabled: f,
                                onPress: () => {
                                    _()
                                }
                            }), (0, i.jsx)(u.Z, {
                                label: w.f.fL,
                                isDisabled: !r || f,
                                onPress: () => (g(null), T(null), void P(l.avatarId ? "removed" : "idle")())
                            })]
                        })]
                    }), j ? (0, i.jsx)(c, {
                        type: "error",
                        children: (0, d.zu)(j, w)
                    }) : null, x.isOpen ? (0, i.jsx)(h.FileType, {
                        bundle$close: x.close,
                        onClose: x.close,
                        onSelect: _
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(1),
            o = s(9);
        const r = s(208).wx,
            i = n.ReactUtils.lazy((() => s(1402))),
            c = n.ReactUtils.lazy((() => s(1403))),
            l = n.ReactUtils.lazy((() => s(1404))),
            d = e => {
                const {
                    teamCurrentMember: t,
                    team: s,
                    paymentRequirement: o,
                    onClose: d
                } = e, {
                    reason: u
                } = o, {
                    hash: m
                } = n.Hooks.useLocation(), h = n.Hooks.useServices(), p = n.React.useCallback((async () => {
                    const e = o.reason;
                    if (o.change(null), null == d || d(), s.planInfo.isBusiness && ("plan-has-been-updated" === e || "payment-info-has-been-updated" === e)) {
                        const t = await s.business.fetch();
                        invariant(t, "Unexpected missing business for team with Business plan");
                        (await t.teams.fetch()).forEach((t => {
                            const s = h.payments.requirements.get(t);
                            s.reason === e && s.change(null)
                        }))
                    }
                }), [o, d, s, h]);
                if (n.React.useEffect((() => {
                        "#payments-plan-changing" === m && o.change("plan-changing")
                    }), [m, o]), n.React.useEffect((() => {
                        if (u) {
                            const e = setTimeout(n.ReactUtils.dismissKeyboard, 200);
                            return () => clearTimeout(e)
                        }
                        return n.FP.noop
                    }), [u]), !u) return null;
                if (o.hasSyncBeenRejected) return (0, a.jsx)(i, {
                    onClose: p,
                    team: s
                });
                if (t.isOwner) return o.hasPlanBeenUpdated ? (0, a.jsx)(c, {
                    team: s,
                    onClose: p,
                    previousPlan: o.previousPlan
                }) : o.hasPaymentInfoBeenUpdated ? (0, a.jsx)(l, {
                    onClose: p
                }) : (0, a.jsx)(r.PlanManagement, {
                    bundle$close: p,
                    onClose: p,
                    team: s,
                    paymentRequirement: o
                });
                return !(o.hasPlanBeenUpdated || o.isPlanChanging || o.isPlanExtending || o.hasPaymentInfoBeenUpdated) ? (0, a.jsx)(r.NotifyMember, {
                    bundle$close: p,
                    close: p,
                    team: s,
                    paymentRequirement: o
                }) : null
            },
            u = n.Hocs.compose(n.Hocs.withErrorBoundary({
                name: "PaymentsModal",
                render: "short"
            }), n.Hocs.withServices, n.Hocs.withObservables(["team"], (({
                team: e,
                services: t
            }) => ({
                _: n.Rx.nowAndEveryMinute(),
                team: e,
                teamCurrentMember: e.currentMember,
                paymentRequirement: t.payments.requirements.get(e).observe().pipe(n.Rx.distinctUntilChanged(((e, t) => e.reason !== t.reason)))
            }))))((e => {
                const {
                    team: t
                } = e;
                return (0, o.createElement)(d, Object.assign({}, e, {
                    key: t.id
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            eh: () => a,
            hB: () => r,
            yH: () => o
        });
        var n = s(54);
        s(36), s(17);

        function a(e, t) {
            const s = n.useIntl();
            switch (e) {
                case "gcal":
                    return {
                        heading: s.f.cy, description: s.g("cz", {
                            teamName: t.name
                        }), helpPage: "advancedfeatures/gcal"
                    };
                case "mcal":
                    return {
                        heading: s.f.c_, description: s.g("da", {
                            teamName: t.name
                        }), helpPage: "advancedfeatures/outlook"
                    };
                default:
                    throw new Error('Unknown calendar integration type "' + e + '"')
            }
        }

        function o(e) {
            switch (e) {
                case "gcal":
                    return "ocean";
                case "mcal":
                    return "rufus";
                default:
                    throw new Error('Unknown calendar integration type "' + e + '"')
            }
        }

        function r(e) {
            switch (e) {
                case "gcal":
                    return [{
                        iconName: "à",
                        color: o("gcal"),
                        size: 200
                    }];
                case "mcal":
                    return [{
                        iconName: "ã",
                        color: o("mcal"),
                        size: 200
                    }];
                default:
                    throw new Error('Unknown calendar integration type "' + e + '"')
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => g
        });
        var n = s(0),
            a = s(418),
            o = s(6),
            r = s(12),
            i = s(948),
            c = s(77),
            l = s(11);
        s(2), s(3);
        const d = s(788);
        var u = s(1);
        const m = n.ReactUtils.lazy((() => s(1412))),
            h = ({
                messageType: e,
                message: t,
                shouldSendDiagnostics: s
            }) => {
                const a = n.Hooks.useIntl(),
                    r = n.Hooks.useContactSupport();
                return (0, u.jsx)(o.u_.Error, {
                    children: a.g("ht", {
                        supportEmail: (0, u.jsx)(l.Z, {
                            onPress: () => {
                                r({
                                    subject: e.label,
                                    body: t,
                                    withDiagnostics: s
                                })
                            },
                            children: (0, u.jsx)("span", {
                                className: d.email,
                                children: "support@nozbe.com"
                            })
                        })
                    })
                })
            },
            p = ({
                onClose: e
            }) => {
                const t = n.Hooks.useIntl();
                return (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsx)(o.u_.IconStack, {
                        stack: [{
                            iconName: "í",
                            color: "pedro",
                            opacity: .3,
                            size: 150
                        }, {
                            iconName: "î",
                            color: "pedro",
                            opacity: .2,
                            size: 150
                        }, {
                            iconName: "ï",
                            color: "pedro",
                            opacity: .6,
                            size: 150
                        }, {
                            iconName: "ð",
                            color: "pedro",
                            opacity: 1,
                            size: 150
                        }]
                    }), (0, u.jsx)(o.u_.Paragraph, {
                        emphasis: !0,
                        centered: !0,
                        children: t.f.hy
                    }), (0, u.jsx)(o.u_.Paragraph, {
                        children: t.f.hx
                    }), (0, u.jsx)(o.u_.Buttons, {
                        children: (0, u.jsx)(r.default, {
                            label: t.f.fh,
                            onPress: e
                        })
                    })]
                })
            },
            g = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                localizationSettings: e.localization.settings
            }))), n.Hocs.withIdentity, n.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                user: e.user
            }))), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                owner: e.owner,
                membersCount: e.membersExcludingRequests.observeCount()
            }))))((e => {
                var t, l, g;
                const {
                    title: f,
                    description: b,
                    hideMessageTypePicker: y,
                    initialType: v,
                    user: w,
                    owner: k,
                    membersCount: x,
                    onClose: j,
                    onSubmit: T,
                    localizationSettings: S
                } = e, P = n.Hooks.useIntl(), _ = n.Hooks.useServices(), {
                    currentMember: C,
                    currentTeam: R
                } = n.Hooks.useIdentity(), A = n.Hooks.useAsyncState(), I = n.Hooks.useModalState(), [N, E] = n.React.useState(""), O = n.React.useMemo((() => [{
                    type: "issue",
                    label: P.f.hE
                }, {
                    type: "account",
                    label: P.f.hA
                }, {
                    type: "billing",
                    label: P.f.hB
                }, {
                    type: "feature",
                    label: P.f.hC
                }, {
                    type: "feedback",
                    label: P.f.hD
                }, {
                    type: "other",
                    label: P.f.hF
                }]), [P]), M = O.find((e => e.type === v)), [D, H] = n.React.useState(M);
                invariant(!y || D, "Initial message type must be defined when type picker is hidden");
                const [F, Z] = n.Hooks.useToggle(!0), L = "issue" === (null == D ? void 0 : D.type) && F, B = async () => (async () => {
                    const e = await s(107).tl();
                    return await e.runDiagnostics({
                        isFull: !1,
                        setLog: n.FP.noop,
                        services: _,
                        currentMember: C
                    })
                })().then((e => "\n\nBasic diagnostics (" + e.issueCount + " issues found):\n\n" + e.log)).catch((async e => "\n\nDiagnostics error: " + e.toString())), z = n.Hooks.useAsyncFetcher(A, (async () => {
                    if (!D) return;
                    const e = await (async e => {
                            const t = await e.modelRoot.settings.npsRatingSetting.fetch();
                            if (!t) return "Not rated";
                            const s = new Date(2023, 2, 21);
                            return t.ratedAt < s.getTime() ? 2 * t.rating + " (adjusted)" : "" + t.rating
                        })(_),
                        t = await (0, a.z)({
                            currentTeam: R,
                            user: w,
                            ownerId: k.user.id,
                            membersCount: x,
                            npsRating: e
                        }, "contact form"),
                        s = L ? await B() : "",
                        n = S.locale;
                    await _.api.account.sendContactForm(w.myEmail, D.label, "" + N + t + s, w.id, n), T && T()
                }));
                return (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsx)(o.u_.Header, {
                        children: f
                    }), (0, u.jsx)(o.u_.Content, {
                        children: A.map.status({
                            success: () => t || (t = (0, u.jsx)(p, {
                                onClose: j
                            })),
                            _: () => (0, u.jsxs)(u.Fragment, {
                                children: ["string" == typeof b ? l || (l = (0, u.jsx)(o.u_.Paragraph, {
                                    children: b
                                })) : b, y ? null : (0, u.jsx)(o.u_.Buttons, {
                                    direction: "column",
                                    children: (0, u.jsx)(r.default, {
                                        label: (null == D ? void 0 : D.label) || P.f.hz,
                                        iconPosition: "right",
                                        modalWebTarget: I.target,
                                        onPress: I.open,
                                        iconName: "Ɣ"
                                    })
                                }), D ? (0, u.jsxs)(u.Fragment, {
                                    children: [(0, u.jsx)(o.u_.Section, {
                                        children: (0, u.jsx)(i.Z, {
                                            className: d.textArea,
                                            autoFocus: !0,
                                            value: N,
                                            onChange: E,
                                            placeholder: P.f.hv,
                                            activeBorderColor: "pedro"
                                        })
                                    }), A.isError ? g || (g = (0, u.jsx)(h, {
                                        message: N,
                                        messageType: D,
                                        shouldSendDiagnostics: L
                                    })) : null, (0, u.jsxs)(o.u_.Buttons, {
                                        direction: "column",
                                        children: ["issue" === D.type ? (0, u.jsx)(c.Z, {
                                            isActive: F,
                                            colorActive: "pedro",
                                            label: P.f.hw,
                                            onChange: Z
                                        }) : null, (0, u.jsx)(r.default, {
                                            label: P.f.fW,
                                            iconName: "ƈ",
                                            variant: "opaque",
                                            iconPosition: "right",
                                            isDisabled: A.isBusy || !N,
                                            color: "pedro",
                                            onPress: () => z()
                                        })]
                                    })]
                                }) : null, I.isOpen ? (0, u.jsx)(m, {
                                    onClose: I.close,
                                    items: O,
                                    target: I.target,
                                    onSelect: H,
                                    level: 90
                                }) : null]
                            })
                        })
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0);
        s(2), s(3);
        const a = s(787);
        var o = s(1);
        const r = e => {
            const {
                value: t,
                onChange: s,
                isDisabled: r,
                placeholder: i,
                activeBorderColor: c,
                autoFocus: l
            } = e;
            return (0, o.jsx)("textarea", {
                className: a.input,
                style: {
                    "--border-color": n.Styling.factoryColor(null != c ? c : "purple")
                },
                value: t,
                onChange: e => s(e.target.value),
                placeholder: i,
                maxLength: 1e3,
                autoFocus: l
            })
        }
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        globalThis.opener && globalThis.electron ? s(1045) : s(1046)
    }, () => {
        const {
            opener: e
        } = globalThis;
        if (!(e && globalThis.electron && (globalThis.name.startsWith("_nozbe_child_window_") || globalThis.name.startsWith("_nozbe_quickadd_window")) && e.__unsafeBootChild)) throw globalThis.alert("Invalid window opener"), new Error("Invalid window opener");
        e.__unsafeBootChild(globalThis)
    }, (e, t, s) => {
        const n = new Date;
        s(1047);
        const a = () => s(1050).Z(n);
        !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) ? (() => {
            let e;
            return new Promise((t => {
                const s = () => globalThis.indexedDB.databases().finally(t);
                e = setInterval(s, 100), s()
            })).finally((() => clearInterval(e)))
        })().then(a) : a()
    }, (e, t, s) => {
        "use strict";
        s.r(t);
        var n = s(377);
        try {
            (0, n.fT)((0, n.VT)("sentry.nozbe.tv", "2", "9102b38ab6914b33bffef738f1ff0204")), (0, n.bO)((() => ({
                release: s(1049).Z
            }))), (0, n.ip)(), (0, n.$4)(), (0, n.bI)()
        } catch (e) {
            console.error(e), globalThis.alert("microsentry init error")
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        const n = /^((.*) \((.*)\)$|(.*)$)/,
            a = /^((.*)@(.*)|(.*))$/,
            o = /^(.*):(\d+):(\d+)$/;

        function r(e) {
            const t = e.stack.split("\n"),
                s = t[1] && t[1].startsWith("    at ");
            return s && t.shift(), {
                frames: t.filter(Boolean).map((e => {
                    const t = s ? e.slice(7).match(n) : e.match(a),
                        [, , r = "", i, c] = t,
                        l = c || i,
                        d = l.match(o) || [],
                        [, u = l, m = 0, h = 0] = d;
                    return {
                        function: r,
                        filename: u,
                        lineno: Number(m),
                        colno: Number(h)
                    }
                })).slice(e.framesToPop || 0).reverse()
            }
        }
    }, (e, t, s) => {
        "use strict";
        var n;
        s.d(t, {
            Z: () => a
        });
        const a = (null == (n = globalThis.document.body) ? void 0 : n.dataset.appVersion) || ""
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => m
        });
        var n = s(1474),
            a = s(793),
            o = s(95),
            r = (s(1509), s(1511)),
            i = s(16),
            c = s(1434);
        const l = (0, c.pr)({
            migrations: [{
                toVersion: 126,
                steps: [(0, c.RK)({
                    table: i.w.teamMembers,
                    columns: [{
                        name: i.o.teamMembers.vacations,
                        type: "string",
                        isOptional: !0
                    }]
                }), (0, c.RK)({
                    table: i.w.businessMembers,
                    columns: [{
                        name: i.o.businessMembers.vacations,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 125,
                steps: [(0, c.RK)({
                    table: i.w.teamMembers,
                    columns: [{
                        name: i.o.teamMembers.contactInfo,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 124,
                steps: [(0, c.RK)({
                    table: i.w.taskAccesses,
                    columns: [{
                        name: i.o.taskAccesses.granteeType,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 123,
                steps: [(0, c.RK)({
                    table: i.w.tasks,
                    columns: [{
                        name: i.o.tasks.extra,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 122,
                steps: [(0, c.RK)({
                    table: i.w.tasks,
                    columns: [{
                        name: i.o.tasks.type,
                        type: "string",
                        isOptional: !0,
                        isIndexed: !0
                    }]
                })]
            }, {
                toVersion: 121,
                steps: []
            }, {
                toVersion: 120,
                steps: [(0, c.RK)({
                    table: i.w.tasks,
                    columns: [{
                        name: i.o.tasks.recurrenceOriginAt,
                        type: "number",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 119,
                steps: [(0, c.W_)({
                    name: i.w.taskPositions,
                    columns: [{
                        name: i.o.taskPositions.taskId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.taskPositions.listId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.taskPositions.position,
                        type: "number"
                    }]
                }), (0, c.W_)({
                    name: i.w.projectPositions,
                    columns: [{
                        name: i.o.projectPositions.listId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.projectPositions.projectId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.projectPositions.position,
                        type: "number"
                    }]
                })]
            }, {
                toVersion: 118,
                steps: [(0, c.RK)({
                    table: i.w.taskEvents,
                    columns: [{
                        name: i.o.taskEvents.integration,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 117,
                steps: [(0, c.RK)({
                    table: i.w.groupAssignments,
                    columns: [{
                        name: i.o.groupAssignments.sidebarPosition,
                        type: "number",
                        isOptional: !0,
                        isIndexed: !0
                    }]
                })]
            }, {
                toVersion: 116,
                steps: [(0, c.W_)({
                    name: i.w.businesses,
                    columns: [{
                        name: i.o.businesses.name,
                        type: "string"
                    }, {
                        name: i.o.businesses.color,
                        type: "string"
                    }, {
                        name: i.o.businesses.limits,
                        type: "string"
                    }, {
                        name: i.o.businesses.planInfo,
                        type: "string",
                        isOptional: !0
                    }, {
                        name: i.o.businesses.paymentInfo,
                        type: "string",
                        isOptional: !0
                    }]
                }), (0, c.W_)({
                    name: i.w.businessMembers,
                    columns: [{
                        name: i.o.businessMembers.businessId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.businessMembers.userId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.businessMembers.role,
                        type: "string"
                    }]
                }), (0, c.RK)({
                    table: i.w.teams,
                    columns: [{
                        name: i.o.teams.businessId,
                        type: "string",
                        isOptional: !0,
                        isIndexed: !0
                    }]
                })]
            }, {
                toVersion: 115,
                steps: [(0, c.RK)({
                    table: i.w.projectGroups,
                    columns: [{
                        name: i.o.projectGroups.sidebarPosition,
                        type: "number",
                        isOptional: !0,
                        isIndexed: !0
                    }]
                })]
            }, {
                toVersion: 114,
                steps: [(0, c.RK)({
                    table: i.w.tasks,
                    columns: [{
                        name: i.o.tasks.timeNeeded,
                        type: "number"
                    }, {
                        name: i.o.tasks.timeSpent,
                        type: "number"
                    }]
                }), (0, c.RK)({
                    table: i.w.attachmentVersions,
                    columns: [{
                        name: i.o.attachmentVersions.integrationType,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 113,
                steps: [(0, c.RK)({
                    table: i.w.comments,
                    columns: [{
                        name: i.o.comments.isTeam,
                        type: "boolean"
                    }]
                }), (0, c.RK)({
                    table: i.w.attachmentVersions,
                    columns: [{
                        name: i.o.attachmentVersions.extra,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 112,
                steps: [(0, c.RK)({
                    table: i.w.taskAccesses,
                    columns: [{
                        name: i.o.taskAccesses.granteeEmail,
                        type: "string",
                        isOptional: !0
                    }]
                }), (0, c.RK)({
                    table: i.w.users,
                    columns: [{
                        name: i.o.users.isLimited,
                        type: "boolean"
                    }]
                })]
            }, {
                toVersion: 111,
                steps: []
            }, {
                toVersion: 110,
                steps: [(0, c.RK)({
                    table: i.w.projects,
                    columns: [{
                        name: i.o.projects.isTemplate,
                        type: "boolean"
                    }]
                })]
            }, {
                toVersion: 109,
                steps: [(0, c.RK)({
                    table: i.w.projects,
                    columns: [{
                        name: i.o.projects.teamColor,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 108,
                steps: [(0, c.RK)({
                    table: i.w.teams,
                    columns: [{
                        name: i.o.teams.paymentInfo,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 107,
                steps: [(0, c.RK)({
                    table: i.w.tags,
                    columns: [{
                        name: i.o.tags.archivedAt,
                        type: "number",
                        isOptional: !0,
                        isIndexed: !0
                    }, {
                        name: i.o.tags.teamColor,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 106,
                steps: []
            }, {
                toVersion: 105,
                steps: [(0, c.RK)({
                    table: i.w.tags,
                    columns: [{
                        name: i.o.tags.preferences,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 104,
                steps: [(0, c.RK)({
                    table: i.w.teams,
                    columns: [{
                        name: i.o.teams.sidebarPosition,
                        type: "number"
                    }]
                })]
            }, {
                toVersion: 103,
                steps: [(0, c.RK)({
                    table: i.w.memberGroups,
                    columns: [{
                        name: i.o.memberGroups.isAdminGroup,
                        type: "boolean",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 102,
                steps: [(0, c.W_)({
                    name: i.w.taskAccesses,
                    columns: [{
                        name: i.o.taskAccesses.taskId,
                        type: "string"
                    }, {
                        name: i.o.taskAccesses.granteeId,
                        type: "string"
                    }, {
                        name: i.o.taskAccesses.granterId,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 101,
                steps: [(0, c.RK)({
                    table: i.w.projects,
                    columns: [{
                        name: i.o.projects.sharedTeamId,
                        type: "string",
                        isOptional: !0,
                        isIndexed: !0
                    }]
                }), (0, c.RK)({
                    table: i.w.teams,
                    columns: [{
                        name: i.o.teams.isShared,
                        type: "boolean",
                        isIndexed: !0
                    }]
                })]
            }, {
                toVersion: 100,
                steps: [(0, c.W_)({
                    name: i.w.groupAssignments,
                    columns: [{
                        name: i.o.groupAssignments.groupId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.groupAssignments.objectId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.groupAssignments.groupType,
                        type: "string"
                    }]
                }), (0, c.W_)({
                    name: i.w.projectGroups,
                    columns: [{
                        name: i.o.projectGroups.teamId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.projectGroups.name,
                        type: "string"
                    }, {
                        name: i.o.projectGroups.isPrivate,
                        type: "boolean"
                    }]
                }), (0, c.W_)({
                    name: i.w.memberGroups,
                    columns: [{
                        name: i.o.memberGroups.teamId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.memberGroups.name,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 99,
                steps: [(0, c.RK)({
                    table: i.w.tasks,
                    columns: [{
                        name: i.o.tasks.commentsCached,
                        type: "number",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 98,
                steps: []
            }, {
                toVersion: 97,
                steps: [(0, c.RK)({
                    table: i.w.teams,
                    columns: [{
                        name: i.o.teams.planInfo,
                        type: "string",
                        isOptional: !0
                    }, {
                        name: i.o.teams.limits,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 96,
                steps: [(0, c.W_)({
                    name: i.w.attachments,
                    columns: [{
                        name: i.o.attachments.parentId,
                        type: "string",
                        isIndexed: !0
                    }]
                }), (0, c.W_)({
                    name: i.w.attachmentVersions,
                    columns: [{
                        name: i.o.attachmentVersions.name,
                        type: "string"
                    }, {
                        name: i.o.attachmentVersions.size,
                        type: "number"
                    }, {
                        name: i.o.attachmentVersions.status,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.attachmentVersions.mimeType,
                        type: "string"
                    }, {
                        name: i.o.attachmentVersions.attachmentId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.attachmentVersions.authorId,
                        type: "string"
                    }, {
                        name: i.o.attachmentVersions.createdAt,
                        type: "number"
                    }]
                })]
            }, {
                toVersion: 95,
                steps: [(0, c.RK)({
                    table: i.w.comments,
                    columns: [{
                        name: i.o.comments.isPinned,
                        type: "boolean"
                    }, {
                        name: i.o.comments.extra,
                        type: "string"
                    }]
                }), (0, c.RK)({
                    table: i.w.projects,
                    columns: [{
                        name: i.o.projects.extra,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 94,
                steps: []
            }, {
                toVersion: 93,
                steps: []
            }, {
                toVersion: 92,
                steps: [(0, c.RK)({
                    table: i.w.taskRecurrences,
                    columns: [{
                        name: i.o.taskRecurrences.projectId,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 91,
                steps: [(0, c.RK)({
                    table: i.w.users,
                    columns: [{
                        name: i.o.users.invitationEmail,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 90,
                steps: [(0, c.W_)({
                    name: i.w.settings,
                    columns: [{
                        name: i.o.settings.teamId,
                        type: "string",
                        isIndexed: !0,
                        isOptional: !0
                    }, {
                        name: i.o.settings.name,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.settings.value,
                        type: "string"
                    }]
                })]
            }, {
                toVersion: 89,
                steps: [(0, c.W_)({
                    name: i.w.taskRecurrences,
                    columns: [{
                        name: i.o.taskRecurrences.currentTaskId,
                        type: "string"
                    }, {
                        name: i.o.taskRecurrences.pattern,
                        type: "string"
                    }]
                }), (0, c.RK)({
                    table: i.w.tasks,
                    columns: [{
                        name: i.o.tasks.missedRepeats,
                        type: "number"
                    }, {
                        name: i.o.tasks.recurrenceId,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 88,
                steps: [(0, c.W_)({
                    name: i.w.reminders,
                    columns: [{
                        name: i.o.reminders.taskId,
                        type: "string",
                        isIndexed: !0
                    }, {
                        name: i.o.reminders.remindAt,
                        type: "number",
                        isIndexed: !0
                    }, {
                        name: i.o.reminders.isRelative,
                        type: "boolean",
                        isIndexed: !0
                    }, {
                        name: i.o.reminders.isAllDay,
                        type: "boolean"
                    }]
                })]
            }, {
                toVersion: 87,
                steps: [(0, c.RK)({
                    table: i.w.projects,
                    columns: [{
                        name: i.o.projects.preferences,
                        type: "string",
                        isOptional: !0
                    }]
                })]
            }, {
                toVersion: 86,
                steps: []
            }, {
                toVersion: 85,
                steps: []
            }]
        });

        function d(e, t) {
            switch (e) {
                case "comments":
                    return function(e) {
                        const t = new Array(e.length);
                        let s;
                        for (let n = 0, a = e.length; n < a; n++) s = e[n], t[n] = [s.$loki, s.id, s._status, s._changed, s.author_id, s.body, s.created_at, s.edited_at, s.extra, s.is_deleted, s.is_pinned, s.reactions, s.task_id, s.is_team];
                        return ["v", 1, t]
                    }(t);
                case "task_events":
                    return function(e) {
                        const t = new Array(e.length);
                        let s;
                        for (let n = 0, a = e.length; n < a; n++) s = e[n], t[n] = [s.$loki, s.id, s._status, s._changed, s.author_id, s.created_at, s.change, s.task_id, s.integration];
                        return ["v", 1, t]
                    }(t);
                case "tasks":
                    return function(e) {
                        const t = new Array(e.length);
                        let s;
                        for (let n = 0, a = e.length; n < a; n++) s = e[n], t[n] = [s.$loki, s.id, s._status, s._changed, s.author_id, s.created_at, s.comments_cached, s.due_at, s.ended_at, s.is_abandoned, s.is_all_day, s.is_followed, s.last_activity_at, s.last_reviewed_at, s.last_seen_activity_at, s.missed_repeats, s.name, null, s.priority_position, s.project_id, s.project_position, s.project_section_id, s.recurrence_id, s.responsible_id, s.review_reason, s.review_triggered_at, s.time_needed, s.time_spent, s.recurrence_origin_at, s.type, s.extra];
                        return ["v", 1, t]
                    }(t);
                default:
                    return t
            }
        }

        function u(e, t) {
            if (!Array.isArray(t)) throw new Error("Unsupported chunk layout");
            if ("v" === t[0]) {
                if (1 !== t[1]) throw new Error("Unsupported chunk layout version");
                {
                    const s = t[2];
                    switch (e) {
                        case "comments":
                            return function(e) {
                                const t = new Array(e.length);
                                let s, n;
                                for (let a = 0, o = e.length; a < o; a++) s = e[a], n = {
                                    $loki: s[0],
                                    id: s[1],
                                    _status: s[2],
                                    _changed: s[3],
                                    author_id: s[4],
                                    body: s[5],
                                    created_at: s[6],
                                    edited_at: s[7],
                                    extra: s[8],
                                    is_deleted: s[9],
                                    is_pinned: s[10],
                                    reactions: s[11],
                                    task_id: s[12],
                                    is_team: s[13]
                                }, t[a] = n;
                                return t
                            }(s);
                        case "task_events":
                            return function(e) {
                                const t = new Array(e.length);
                                let s, n;
                                for (let a = 0, o = e.length; a < o; a++) s = e[a], n = {
                                    $loki: s[0],
                                    id: s[1],
                                    _status: s[2],
                                    _changed: s[3],
                                    author_id: s[4],
                                    created_at: s[5],
                                    change: s[6],
                                    task_id: s[7],
                                    integration: s[8]
                                }, t[a] = n;
                                return t
                            }(s);
                        case "tasks":
                            return function(e) {
                                const t = new Array(e.length);
                                let s, n;
                                for (let a = 0, o = e.length; a < o; a++) s = e[a], n = {
                                    $loki: s[0],
                                    id: s[1],
                                    _status: s[2],
                                    _changed: s[3],
                                    author_id: s[4],
                                    created_at: s[5],
                                    comments_cached: s[6],
                                    due_at: s[7],
                                    ended_at: s[8],
                                    is_abandoned: s[9],
                                    is_all_day: s[10],
                                    is_followed: s[11],
                                    last_activity_at: s[12],
                                    last_reviewed_at: s[13],
                                    last_seen_activity_at: s[14],
                                    missed_repeats: s[15],
                                    name: s[16],
                                    priority_position: s[18],
                                    project_id: s[19],
                                    project_position: s[20],
                                    project_section_id: s[21],
                                    recurrence_id: s[22],
                                    responsible_id: s[23],
                                    review_reason: s[24],
                                    review_triggered_at: s[25],
                                    time_needed: s[26],
                                    time_spent: s[27],
                                    recurrence_origin_at: s[28],
                                    type: s[29],
                                    extra: s[30]
                                }, t[a] = n;
                                return t
                            }(s);
                        default:
                            throw new Error("Unsupported table for layout version 1")
                    }
                }
            }
            return t
        }

        function m(e) {
            (0, o.Z)("initialization").install();
            let t = !1,
                a = !1,
                c = null;
            const m = () => {
                    if (!c) {
                        const t = s(1512).Z;
                        c = t(e, p)
                    }
                },
                h = () => {
                    if (m(), !c) throw new Error("AppServices not initialized");
                    return c
                },
                p = new n.Z({
                    dbName: "nozbe",
                    schema: r.j,
                    migrations: l,
                    useWebWorker: !1,
                    useIncrementalIndexedDB: !0,
                    onSetUpError: e => {
                        (0, s(1559).Z)(e, globalThis.electron ? h().localization.formatMessage("Db") : h().localization.formatMessage("Da"), h().localization.formatMessage("gS"), h().localization.formatMessage("cU"))
                    },
                    _onFatalError: e => {
                        (0, s(1559).Z)(e, globalThis.electron ? h().localization.formatMessage("C_") : h().localization.formatMessage("C$"), h().localization.formatMessage("gS"), h().localization.formatMessage("cU"))
                    },
                    onQuotaExceededError: () => {
                        if (!t) {
                            t = !0;
                            const e = h(),
                                n = s(181).Z;
                            void 0 !== globalThis.fluid ? n(e.localization.formatMessage("De")) : n(e.localization.formatMessage("Dd"))
                        }
                    },
                    extraLokiOptions: {
                        autosaveInterval: 1e3
                    },
                    extraIncrementalIDBOptions: {
                        serializeChunk: d,
                        deserializeChunk: u,
                        lazyCollections: [i.w.taskEvents, i.w.attachments, i.w.attachmentVersions, i.w.taskRecurrences, i.w.projectEvents],
                        onFetchStart: () => {
                            s(1420).Z().then((() => {
                                m()
                            }))
                        },
                        onversionchange: () => {
                            const e = h();
                            (0, o.Z)("safe literal").log("App logged out in a different tab - forcing log out"), e.appState.isLoggedIn.getValue() && globalThis.location.reload()
                        },
                        onDidOverwrite: () => {
                            const e = h();
                            if (!a && !e.sync.lastSyncSuccessful) {
                                a = !0;
                                (0, s(181).Z)(e.localization.formatMessage("Dc"))
                            }
                        }
                    }
                })
        }
        globalThis.__loki_incremental_idb_debug = !1, (0, a.setExperimentalAllowsFatalError)()
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            BV: () => a,
            ZP: () => c,
            uJ: () => i
        });
        const n = "((?:((?:https?|ftp):)?\\/\\/|(?:www\\.))(?:(\\S+(?::\\S*)?)@)*?((?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?)))(?::(\\d{2,5}))?((?:[/?#]\\S*)?)(?:[^.,;\\s]|\\b))",
            a = new RegExp(n, "gi"),
            o = new RegExp("^" + n + "$", "i"),
            r = (e, t) => t.split(e).slice(1).join(""),
            i = e => {
                const t = o.exec(e);
                if (!t) throw new Error("Invalid URL");
                const [, s, n, a, i, c, l] = t, d = c ? ":" + c : "", u = n ? n + "//" : "www.", {
                    pathname: m,
                    search: h,
                    hash: p
                } = (e => {
                    const t = e || "";
                    return {
                        pathname: t.split("?")[0].split("#")[0] || void 0,
                        search: r("?", t).split("#")[0] || void 0,
                        hash: r("#", t) || void 0
                    }
                })(l), {
                    username: g,
                    password: f
                } = (e => {
                    const t = e || "",
                        s = t.indexOf(":");
                    return {
                        username: -1 !== s ? t.substring(0, s) : void 0,
                        password: -1 !== s ? t.substring(s + 1) : void 0
                    }
                })(a);
                return {
                    href: s,
                    origin: "" + u + i + d,
                    protocol: n,
                    username: g,
                    password: f,
                    host: "" + i + d,
                    hostname: i,
                    port: c,
                    pathname: m,
                    search: h,
                    hash: p
                }
            },
            c = e => o.test(e)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(95),
            a = s(173),
            o = s(803);

        function r(e, t, s = "error") {
            const r = (0, o.Z)(t);
            r.framesToPop += 1, (0, n.Z)(e).error(r), (0, a.uT)(r, s)
        }
    }, , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            C0: () => m,
            be: () => u,
            ri: () => d
        });
        var n = s(4),
            a = s(19),
            o = s(263),
            r = s(796),
            i = s(803),
            c = (s(5), s(346)),
            l = s(17);
        (0, o.useCustomDiagnosticErrorFunction)(i.Z), (0, r.experimentalDisableObserveCountThrottling)();
        const d = e => {
                const t = new a.Database({
                        adapter: e,
                        modelClasses: (0, n.values)(l.Models)
                    }),
                    s = new c.ZP(t);
                return s.performance.markBooted(), s._tcslm = "7c83dc6a8082efdbf675937ff01840ce", delete s._tcslm, s
            },
            u = e => {
                globalThis.noz_dt = () => {
                    (e => {
                        globalThis.app = e, globalThis.app.Q = a.Q
                    })(e), (() => {
                        globalThis.nozbe = {};
                        const e = s(0);
                        Object.keys(e).forEach((t => {
                            globalThis.nozbe[t] = e[t]
                        }))
                    })()
                }
            },
            m = () => {}
    }, , , , , (e, t, s) => {
        "use strict";
        var n, a;
        s.d(t, {
            Z: () => o
        });
        const o = Object.freeze({
            isWeb: !0,
            isNative: !1,
            isiOS: !1,
            isAndroid: !1,
            isMacElectron: "mac" === (null == (n = globalThis.electron) ? void 0 : n.platform),
            isWindowsElectron: "mac" !== (null == (a = globalThis.electron) ? void 0 : a.platform)
        })
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r,
            t: () => o
        });
        var n = s(8);
        const a = new n.BehaviorSubject("active");

        function o(e) {
            a.next("active"), e.addEventListener("focus", (() => {
                a.next("active")
            })), e.addEventListener("blur", (() => {
                a.next("inactive")
            }))
        }
        const r = a.pipe(n.debounceTime(250), n.distinctUntilChanged())
    }, , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n, a = s(24),
            o = (s(5), s(33)),
            r = s(4),
            i = s(8),
            c = s(16);
        const l = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let d = (l(n = class {
            get database() {
                return this.root.database
            }
            get db() {
                return this.root.database
            }
            constructor(e) {
                this.root = e
            }
            async transferProjects(e) {
                await this.db.write((t => r.allPromises((async e => {
                    const s = await e.getCurrentTeam(),
                        n = {
                            newMembers: [{
                                member: await i.takeFirst(s.owner),
                                isManager: !0,
                                isNew: !0,
                                isInitialManager: !1
                            }],
                            changedMembers: [],
                            removedMembers: [],
                            isOpen: !1
                        };
                    await t.callWriter((() => e.permissions.do.updateAccess(n)))
                }), e)), "transferProjects")
            }
            async createPersonalTag(e) {
                const {
                    name: t,
                    color: s,
                    icon: n
                } = e;
                return this.db.collections.get(c.w.tags).create((e => {
                    e.name = t, e.userColor = s, e.icon = n
                }))
            }
            async createTeam(e, t, s) {
                const n = await i.takeFirst(this.root.currentUser);
                invariant(n, "Attempted to create team for a non-exisiting user"), s && invariant(await s.canCreateTeam(), "Attempted to add new team to a space without required permissions");
                const a = await this.root.teams.fetch(),
                    o = r.getLastPosition(a, (e => e.sidebarPosition)),
                    l = this.db.collections.get(c.w.teams).prepareCreate((n => {
                        n.name = e, n.color = t, n.sidebarPosition = o, n._setRaw(c.o.teams.planInfo, null), n.business.set(s)
                    }));
                return await this.db.batch(l), l
            }
            async leaveTeam(e) {
                const t = await i.takeFirst(e.currentMember);
                await t.do.archive()
            }
            async removeTeam(e) {
                const t = await i.takeFirst(e.currentMember);
                invariant(t.isOwner, "Expected current user to be the owner of the team being removed");
                const s = await e.members.fetch();
                await this.db.write((e => Promise.all(s.map((async t => {
                    await e.callWriter((() => t.do.archive()))
                })))), "removeTeam")
            }
            async joinTeamAsBusinessAdmin(e, t) {
                invariant(t.hasAdminPowers, "Expected member to have admin powers");
                const s = await t.user.fetch(),
                    n = (await s.teamMemberships.fetch()).find((t => t.team.id === e));
                if (n) return n;
                return await this.database.collections.get(c.w.teamMembers).create((t => {
                    t.team.id = e, t.user.set(s), t.role = "member", t.status = "active"
                }))
            }
        }, "createPersonalTag", [o.writer]), l(n, "createTeam", [o.writer]), l(n, "joinTeamAsBusinessAdmin", [o.writer]), n)
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = -1 !== globalThis.navigator.appVersion.indexOf("Mac")
    }, , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(13),
            o = s(11),
            r = s(18),
            i = s(453);
        s(2), s(3);
        const c = s(456);
        var l = s(1);
        const d = e => {
            const {
                isActive: t,
                onPress: s,
                onPressExtraParam: d,
                label: u,
                icon: m,
                color: h,
                isDisabled: p,
                badge: g,
                __webFixBlurEventOrder: f = !0
            } = e;
            return (0, l.jsxs)(l.Fragment, {
                children: [g ? (0, l.jsx)(i.k, {
                    badge: g
                }) : null, (0, l.jsxs)(o.Z, {
                    className: c.touchable,
                    onPress: t ? n.FP.noop : e => {
                        s(e, d)
                    },
                    isDisabled: p,
                    androidNoRipple: !0,
                    __webFixBlurEventOrder: f,
                    children: [m ? (0, l.jsx)(a.default, {
                        name: m,
                        color: t ? h : "textSecondary",
                        size: 25
                    }) : null, (0, l.jsx)(r.default, {
                        className: c.text + (t ? " " + c.semiBold : ""),
                        style: {
                            color: n.Styling.factoryColor(t ? h : "textSecondary")
                        },
                        adjustsFontSizeToFit: !1,
                        children: u
                    })]
                })]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(13),
            o = s(11),
            r = s(18),
            i = s(453);
        s(2), s(3);
        const c = s(457);
        var l = s(1);
        const d = e => {
            const {
                isActive: t,
                onPress: s,
                onPressExtraParam: d,
                label: u,
                subLabel: m,
                icon: h,
                customIconComponent: p,
                color: g,
                isDisabled: f,
                badge: b,
                __webFixBlurEventOrder: y = !0
            } = e;
            invariant(!(h && p), 'You can only pass "icon" or "customIconComponent" passing both will not work');
            const v = t ? g : "textSecondary";
            return (0, l.jsxs)(o.Z, {
                className: c.touchable,
                onPress: t ? n.FP.noop : e => {
                    s(e, d)
                },
                isDisabled: f,
                androidNoRipple: !0,
                __webFixBlurEventOrder: y,
                children: [(0, l.jsxs)("div", {
                    className: c.textContainer,
                    children: [(0, l.jsx)(r.default, {
                        className: c.text + (t ? " " + c.semiBold : ""),
                        style: {
                            color: n.Styling.factoryColor(v)
                        },
                        adjustsFontSizeToFit: !1,
                        children: u
                    }), (0, l.jsx)(r.default, {
                        className: c.subLabel,
                        style: {
                            color: n.Styling.factoryColor(v)
                        },
                        adjustsFontSizeToFit: !1,
                        children: m
                    })]
                }), (0, l.jsx)("div", {
                    className: c.icon,
                    children: h ? (0, l.jsx)(a.default, {
                        name: h,
                        color: v,
                        size: 28
                    }) : p
                }), b ? (0, l.jsx)(i.k, {
                    badge: b
                }) : null]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n, a = s(24),
            o = s(33);
        s(8);
        const r = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let i = (r(n = class {
            get asModel() {
                return this.business
            }
            get database() {
                return this.business.database
            }
            constructor(e) {
                this.business = e
            }
            async rename(e) {
                invariant(await this.business.canBeRenamed(), "Can't rename business"), this.business.update((t => {
                    t.name = e
                }))
            }
            async setColor(e) {
                (await this.business._me)._ensureHasAdminPowers(), await this.business.update((t => {
                    t.color = e
                }))
            }
            async changeAdminAccesses(e) {
                (await this.business._me)._ensureHasAdminPowers();
                const t = e.added.filter((e => !e.hasAdminPowers)),
                    s = e.removed.filter((e => e.hasAdminPowers));
                invariant(!s.some((e => e.isOwner)), "Cannot revoke admin privileges from a business owner"), invariant([...t, ...s].every((e => e.business.id === this.business.id)), "Cannot modify admin privileges for a member from a different business"), await this.database.batch(...t.map((e => e.prepareUpdate((e => {
                    e.role = "admin"
                })))), ...s.map((e => e.prepareUpdate((e => {
                    e.role = "member"
                })))))
            }
        }, "rename", [o.writer]), r(n, "setColor", [o.writer]), r(n, "changeAdminAccesses", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n, a = s(24),
            o = s(33);
        s(8);
        const r = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let i = (r(n = class {
            get asModel() {
                return this.businessMember
            }
            get database() {
                return this.businessMember.database
            }
            constructor(e) {
                this.businessMember = e
            }
            async promoteToAdmin() {
                const {
                    businessMember: e
                } = this;
                invariant(await e.canBePromotedToAdmin(), "Can't promote to admin"), await e.update((() => {
                    e.role = "admin"
                }))
            }
            async demoteAdmin() {
                const {
                    businessMember: e
                } = this;
                invariant(await e.canBeDemotedAdmin(), "Can't demote admin"), await e.update((() => {
                    e.role = "member"
                }))
            }
        }, "promoteToAdmin", [o.writer]), r(n, "demoteAdmin", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            KB: () => r,
            dK: () => i,
            gm: () => d,
            lG: () => c,
            nT: () => l
        });
        s(5);
        var n = s(243),
            a = s(244),
            o = s(473);

        function r(e) {
            switch (e._integrationType) {
                case n.m.Evernote: {
                    const t = u(e);
                    return {
                        integration: n.m.Evernote,
                        sourceId: t.note_id,
                        name: e.name,
                        size: e.size,
                        mimeType: e.mimeType,
                        metadata: t
                    }
                }
                case n.m.Dropbox: {
                    const t = u(e);
                    return {
                        integration: n.m.Dropbox,
                        sourceId: t.file_id,
                        name: e.name,
                        size: e.size,
                        mimeType: e.mimeType,
                        metadata: t
                    }
                }
                case n.m.GoogleDrive: {
                    const t = u(e);
                    return {
                        integration: n.m.GoogleDrive,
                        sourceId: t.file_id,
                        name: e.name,
                        size: e.size,
                        mimeType: e.mimeType,
                        metadata: t
                    }
                }
                case n.m.OneDrive: {
                    const t = u(e);
                    return {
                        integration: n.m.OneDrive,
                        sourceId: t.item_id,
                        name: e.name,
                        size: e.size,
                        mimeType: e.mimeType,
                        metadata: t
                    }
                }
                default:
                    return null
            }
        }

        function i(e) {
            return {
                integration: n.m.Evernote,
                sourceId: e.note_id,
                name: e.name,
                size: 0,
                mimeType: "text/html",
                metadata: {
                    note_id: e.note_id,
                    link: e.link,
                    app_link: e.in_app_link
                }
            }
        }

        function c(e) {
            return invariant(e.is_file, "Expected a Dropbox file, got directory instead"), {
                integration: n.m.Dropbox,
                sourceId: e.id,
                name: e.name,
                size: m(e.size),
                mimeType: (0, o.l)(e.name),
                metadata: {
                    file_id: e.id,
                    path_lower: e.path_lower,
                    link: null,
                    is_thumbnail_available: !1
                }
            }
        }

        function l(e) {
            return invariant(e.is_file, "Expected a Google Drive file, got directory instead"), {
                integration: n.m.GoogleDrive,
                sourceId: e.id,
                name: e.name,
                size: 0,
                mimeType: e.mime_type,
                metadata: {
                    file_id: e.id,
                    thumbnail_link: e.thumbnail_link,
                    webview_link: e.webview_link
                }
            }
        }

        function d(e) {
            const {
                id: t,
                name: s,
                size: a,
                is_file: o,
                mime_type: r
            } = e;
            return invariant(o && r, "Expected a OneDrive file, got directory instead"), {
                integration: n.m.OneDrive,
                sourceId: t,
                name: s,
                size: m(a),
                mimeType: r,
                metadata: {
                    item_id: t,
                    link: null,
                    is_thumbnail_available: !1
                }
            }
        }

        function u(e) {
            return e.extra[a.k.integrationMetadata]
        }

        function m(e) {
            return Number.isInteger(e) && 0 < e ? e : 0
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(244);
        class a {
            get asModel() {
                return this.version
            }
            get database() {
                return this.version.database
            }
            constructor(e) {
                this.version = e
            }
            _markAsExternal(e) {
                const {
                    version: t
                } = this;
                t._integrationType = e.integration, t.extra = Object.assign({}, t.extra, {
                    [n.k.integrationMetadata]: e.metadata
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => j
        });
        s(5);
        var n = s(4);
        const a = /^(\d+\.|-) /;

        function o(e, t, s) {
            return "numbered-list" === t ? function(e, t) {
                var s;
                const [o] = t.slice(-1);
                if ("numbered-list" === (null == o ? void 0 : o.type)) {
                    const {
                        data: e = {},
                        nodes: t = []
                    } = o;
                    if (e.start || t.length) return {
                        start: e.start ? e.start + t.length : t.length + 1
                    }
                }
                const r = null == (s = e.match(a)) ? void 0 : s[1];
                if (r) {
                    const e = n.int(r);
                    if (1 < e) return {
                        start: e
                    }
                }
                return {}
            }(e, s) : {}
        }
        var r = s(245),
            i = s(221),
            c = s(35);
        const l = /^((?:(?:(?!@[^\s])).)*)(^|\s)@([^\s]+)/,
            d = new RegExp("group:([^\\s]+)"),
            u = new RegExp("^(" + c.Nx.join("|") + ")\\b");

        function m(e, t, s, n) {
            if (!t.length) return null;
            const a = l.exec(e);
            if (!a) return null;
            const [, o, r, i] = a, m = o + r, h = m.length + 1;
            if (null != n && n < h) return null;
            const p = e.substring(h).toLowerCase(),
                g = ({
                    memberId: t = null,
                    groupMentionId: s = null,
                    preferredName: n = null
                } = {}) => {
                    const a = n || i;
                    return {
                        value: a,
                        precedingText: m,
                        restOfText: e.substring(h + a.length),
                        memberId: t,
                        groupMentionId: s
                    }
                },
                f = [...t].sort((({
                    preferredName: e
                }, {
                    preferredName: t
                }) => t.length - e.length)).find((({
                    preferredName: e
                }) => p.startsWith(e.toLowerCase())));
            if (f) {
                const {
                    member: e,
                    preferredName: t
                } = f;
                return g({
                    memberId: e.id,
                    preferredName: t
                })
            }
            const b = [...s].sort((({
                name: e
            }, {
                name: t
            }) => t.length - e.length)).find((({
                name: e
            }) => p.startsWith(e.toLowerCase())));
            if (b) return g({
                groupMentionId: b.id,
                preferredName: b.name
            });
            const y = function(e) {
                const t = e.match(d);
                if (t) {
                    return t[1]
                }
                const s = e.match(u);
                if (s) {
                    const e = s[1];
                    if ((0, c.sU)(e)) return e
                }
                return null
            }(p);
            return y ? g({
                groupMentionId: y
            }) : g()
        }
        var h = s(475);
        const p = "​‌​",
            g = ["**", "__", "*", "_", "`", "~~", "==", p],
            f = {
                "**": "bold",
                __: "bold",
                "*": "italic",
                _: "italic",
                "`": "code",
                "~~": "strikethrough",
                "==": "highlight",
                [p]: "highlightSearch"
            },
            b = /\W/;

        function y(e, t = []) {
            if (!e.length) return [""];
            const s = [];
            let n = e;
            for (; n.length;) {
                const [e, a, o] = v(n, t);
                if (!e) {
                    s.push(n);
                    break
                }
                const r = n.slice(0, a),
                    i = n.slice(a + e.length, o),
                    c = n.slice(o + e.length);
                if (!i.length) {
                    s.push(n.slice(0, o + e.length)), n = c;
                    continue
                }
                r.length && s.push(r);
                const l = f[e];
                if ("code" !== l) {
                    y(i, [...t, l]).forEach((e => {
                        if ("string" == typeof e) s.push([
                            [l], e
                        ]);
                        else {
                            const [t, n] = e;
                            s.push([t.includes("code") ? ["code"] : [l].concat(t), n])
                        }
                    }))
                } else s.push([
                    [l], i
                ]);
                n = c
            }
            return s
        }

        function v(e, t) {
            let s = -1,
                n = -1,
                a = null;
            return g.forEach((o => {
                const r = e.indexOf(o);
                if (-1 < r) {
                    const i = e.indexOf(o, r + o.length),
                        c = e.charAt(r - 1);
                    (!c || o === p || b.test(c)) && !t.includes(f[o]) && "\\" !== c && -1 < i && (-1 === s || r < s) && (s = r, n = i, a = o)
                }
            })), [a, s, n]
        }

        function w(e, t = []) {
            return {
                object: "text",
                leaves: [{
                    object: "leaf",
                    text: e,
                    marks: t
                }]
            }
        }

        function k(e, t = []) {
            return y(e).map((e => {
                if ("string" == typeof e) return w(e);
                const [s, n] = e;
                return w(n, [...t, ...s.map((e => ({
                    object: "mark",
                    type: e,
                    data: {}
                })))])
            }))
        }
        const x = /^> ?/;
        class j {
            constructor(e, t) {
                this._hasParsed = !1, this._parsedNodes = [], this._parsedRichContent = [], this._text = e, this._context = t
            }
            getResult() {
                this._hasParsed || (this._parse(), this._hasParsed = !0);
                const e = this._parsedRichContent.length ? this._parsedRichContent : void 0;
                return {
                    nodes: this._parsedNodes,
                    richContent: e
                }
            }
            _parse() {
                this._ensureCanParse();
                const e = [],
                    t = function(e, t) {
                        const {
                            searchQuery: s
                        } = t || {};
                        if (!s) return e;
                        const a = n.normalizeText(e).indexOf(s),
                            o = a + s.length;
                        if (-1 === a) return e;
                        const r = e.slice(0, a),
                            i = e.slice(a, o),
                            c = e.slice(o);
                        return "" + r + p + i + p + c
                    }(this._text, this._context);
                (0, h.Z)(t).forEach((([t, s], n) => {
                    const a = s.join("\n"),
                        r = o(a, t, e),
                        i = this._parseBlock(a, t, n);
                    e.push({
                        type: t,
                        object: "block",
                        data: r,
                        nodes: i
                    })
                })), this._parsedNodes = e
            }
            _parseBlock(e, t, s) {
                switch (this._ensureCanParse(), t) {
                    case "paragraph":
                        return this._parseParagraphNodes(e);
                    case "checklist":
                        return this._parseChecklistNodes(e, s);
                    case "blockquote":
                        return this._parseBlockquoteNodes(e);
                    case "bullet-list":
                    case "numbered-list":
                        return this._parseListNodes(e);
                    case "code-block":
                        return function(e) {
                            return [w(n.splitLines(e).slice(1, -1).join("\n"))]
                        }(e);
                    case "heading-one":
                        return function(e) {
                            return [w(e.slice(1).trim())]
                        }(e);
                    case "heading-two":
                        return function(e) {
                            return [w(e.slice(2).trim())]
                        }(e);
                    case "horizontal-rule":
                        return [];
                    default:
                        throw new Error("Unexpected block type " + t)
                }
            }
            _parseParagraphNodes(e) {
                this._ensureCanParse();
                const t = n.splitLines(e).map((e => this._parseInlineNodes(e))),
                    s = [];
                return t.forEach(((e, n) => {
                    s.push(...e), n < t.length - 1 && s.push(w("\r\n"))
                })), s
            }
            _parseInlineNodes(e) {
                this._ensureCanParse();
                const {
                    membersWithNames: t = [],
                    internalLinkModelMap: s = new Map,
                    teams: n = [],
                    memberGroups: a = []
                } = this._context || {}, o = (0, i.Vz)(e), c = m(e, t, a, null == o ? void 0 : o.precedingText.length);
                if (c) return this._parseMentionMatch(c);
                if (!o) return k(e);
                const l = k(o.precedingText),
                    d = this._parseInlineNodes(o.restOfText),
                    u = i.Ni.test(e) ? null : (0, r.n)(n, o.url);
                if (u) {
                    const {
                        url: e
                    } = o, {
                        hash: t
                    } = u, n = s.get(u.taskId || u.projectId || u.sectionId || u.tagId || u.memberId || "");
                    return [...l, {
                        object: "inline",
                        type: "internal-link",
                        data: {
                            url: e,
                            model: n,
                            hash: t
                        },
                        nodes: [w(e)]
                    }, ...d]
                }
                const {
                    url: h,
                    label: p,
                    richContent: g
                } = o;
                return g && this._parsedRichContent.push(g), [...l, {
                    object: "inline",
                    type: "link",
                    data: {
                        url: h,
                        richContent: g
                    },
                    nodes: [w(p)]
                }, ...d]
            }
            _parseChecklistNodes(e, t) {
                return this._ensureCanParse(), e.split("\n").map(((e, s) => {
                    var n;
                    const a = e.startsWith("(+)") || e.startsWith("- [x]"),
                        o = e.slice(e.startsWith("(") ? 4 : 6);
                    return {
                        object: "block",
                        type: "checklist-item",
                        data: {
                            isCompleted: a,
                            id: null != (n = this._context) && n.rootBlockTypeForNestedNodes ? null : t + "-" + s
                        },
                        nodes: this._parseInlineNodes(o)
                    }
                }))
            }
            _parseBlockquoteNodes(e) {
                var t;
                this._ensureCanParse();
                const s = function(e) {
                        return n.splitLines(e).map((e => e.trim().replace(x, ""))).join("\n")
                    }(e),
                    a = (null == (t = this._context) ? void 0 : t.rootBlockTypeForNestedNodes) || "blockquote",
                    {
                        nodes: o
                    } = new j(s, Object.assign({
                        rootBlockTypeForNestedNodes: a
                    }, this._context)).getResult();
                return o
            }
            _parseListNodes(e) {
                this._ensureCanParse();
                return e.trim().split(/\n/).map((e => ({
                    object: "block",
                    type: "list-item",
                    data: {},
                    nodes: this._parseInlineNodes(e.replace(a, ""))
                })))
            }
            _parseMentionMatch(e) {
                this._ensureCanParse();
                const {
                    precedingText: t,
                    restOfText: s,
                    memberId: n,
                    value: a,
                    groupMentionId: o
                } = e;
                if (!n && !o) {
                    const e = t + "@" + a,
                        n = this._parseInlineNodes(s),
                        [o, ...r] = n;
                    if (o && "text" === o.object) {
                        const [t] = o.leaves;
                        return [...k(e + t.text, t.marks), ...r]
                    }
                    return [...k(e), ...n]
                }
                return [...k(t), {
                    object: "inline",
                    type: "mention",
                    data: {
                        memberId: n,
                        groupMentionId: o
                    },
                    nodes: [w(a)]
                }, ...this._parseInlineNodes(s)]
            }
            _ensureCanParse() {
                invariant(!this._hasParsed, "Cannot parse the comment text twice")
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            A: () => r
        });
        s(5);
        var n = s(4);
        const a = {
            youtube: /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube(-nocookie)?\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/|shorts\/)?)(?<videoId>[\w\-]+)(\S+)?$/,
            vimeo: /^(http|https)?:\/\/(www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|)(?<videoId>\d+)(?:|\/\?)/
        };
        const o = [e => {
                const t = function(e) {
                    for (const [s, o] of n.toPairs(a)) {
                        var t;
                        const n = o.exec(e);
                        if (null != n && null != (t = n.groups) && t.videoId) return {
                            service: s,
                            videoUrl: e,
                            videoId: n.groups.videoId
                        }
                    }
                    return null
                }(e);
                return t ? {
                    object: "rich-content",
                    type: "video",
                    data: t
                } : null
            }],
            r = e => {
                for (const t of o) {
                    const s = t(e);
                    if (s) return s
                }
                return null
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            k: () => r,
            u: () => i
        });
        var n = s(4),
            a = s(83),
            o = s(476);
        const r = {
            invitation: "project_invitation",
            areTimeAttributesEnabled: "are_time_attributes_enabled",
            clonedFromId: "cloned_from_id"
        };

        function i(e) {
            const t = {};
            if (n.isObject(e)) {
                const s = function(e) {
                    if (n.isObject(e)) {
                        const {
                            status: t,
                            email: s,
                            invited_by: n
                        } = e;
                        if (c(t) && l(s) && d(n)) return {
                            status: t,
                            email: s,
                            invited_by: n
                        }
                    }
                    return null
                }(e[r.invitation]);
                s && (t[r.invitation] = s), e[r.areTimeAttributesEnabled] && (t[r.areTimeAttributesEnabled] = !!e[r.areTimeAttributesEnabled]);
                const a = e[r.clonedFromId];
                n.isString(a) && Boolean(a) && (t[r.clonedFromId] = a)
            }
            return t
        }
        const c = e => Object.values(o.m).includes(e),
            l = e => n.isString(e) && a.Ej.test(e),
            d = e => n.isString(e) && Boolean(e)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => T
        });
        var n, a, o, r, i, c, l, d, u, m, h, p, g, f = s(69),
            b = s(24),
            y = s(19),
            v = s(33),
            w = s(16),
            k = s(110);
        const x = (e, t, s, n = null) => (0, b.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            j = w.o.taskEvents;
        let T = (n = (0, v.json)(j.change, k.b), a = (0, v.field)(j.integration), o = (0, v.immutableRelation)(w.w.tasks, j.taskId), r = (0, v.experimentalFailsafe)(), i = (0, v.immutableRelation)(w.w.teamMembers, j.authorId), c = (0, v.date)(j.createdAt), (g = class extends y.Model {
            constructor(...e) {
                super(...e), (0, f.Z)(this, "change", d, this), (0, f.Z)(this, "integration", u, this), (0, f.Z)(this, "task", m, this), (0, f.Z)(this, "author", h, this), (0, f.Z)(this, "createdAt", p, this)
            }
            get isIncomplete() {
                return "" === this._getRaw(j.change)
            }
            get type() {
                return (0, k.x6)(this.change)
            }
        }).table = w.w.taskEvents, g.associations = (0, y.associations)([w.w.tasks, {
            type: "belongs_to",
            key: j.taskId
        }], [w.w.teamMembers, {
            type: "belongs_to",
            key: j.authorId
        }]), d = x(l = g, "change", [v.nochange, n]), u = x(l, "integration", [v.nochange, a]), m = x(l, "task", [o]), h = x(l, "author", [r, i]), p = x(l, "createdAt", [v.nochange, c]), l)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n, a = s(24),
            o = (s(5), s(33)),
            r = (s(8), s(35));
        const i = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let c = (i(n = class {
            get asModel() {
                return this.comment
            }
            get database() {
                return this.comment.database
            }
            constructor(e) {
                this.comment = e
            }
            async updateBody(e, t = !0) {
                const {
                    comment: s
                } = this;
                this._ensureNotDeleted(), this._ensureNotIncomplete(), await s.update((() => {
                    s.body = e, t && (s.editedAt = new Date)
                })), await s.removeDraft()
            }
            async togglePin() {
                const {
                    comment: e
                } = this;
                this._ensureNotDeleted(), await e.update((() => {
                    e.isPinned = !e.isPinned
                }))
            }
            async toggleReaction(e) {
                const {
                    comment: t
                } = this;
                this._ensureNotDeleted(), this._ensureNotIncomplete();
                const s = await t.task.fetch(),
                    n = (0, r.P1)(t.reactions, e, await s._me);
                await t.update((() => {
                    t.reactions = n
                }))
            }
            async deleteComment() {
                const {
                    comment: e
                } = this;
                this._ensureNotDeleted(), this._ensureNotIncomplete(), e.isPinned && await e.callWriter((() => this.togglePin())), await e.update((() => {
                    e._deletedCommentBody = e._bodyJSON || e._bodyText, e.isDeleted = !0, e._bodyText = "", e.editedAt = new Date
                }))
            }
            async restore() {
                const {
                    comment: e
                } = this;
                this._ensureNotIncomplete();
                const t = e._deletedCommentBody;
                t && await e.update((() => {
                    e.isDeleted = !1, e.body = t, e.editedAt = new Date, e._deletedCommentBody = null
                }))
            }
            async markAsClonedFromId(e) {
                this._ensureNotDeleted(), await this.comment.update((t => {
                    t.extra = Object.assign({}, t.extra, {
                        [r.ku.clonedFromId]: e
                    })
                }))
            }
            async markAsClonedFrom(e) {
                await e.callWriter((() => this.markAsClonedFromId(e.id)))
            }
            async markAsTeam() {
                await this._ensureCanBeMarkedAsTeam();
                const {
                    comment: e
                } = this, t = await e.task.fetch(), s = await t._me;
                await this.database.batch(e.prepareUpdate((e => {
                    e.isTeam = !0, e.isPinned = !0
                })), t.prepareUpdate((e => {
                    e.do._bumpLastActivity()
                })), t.do._prepareEvent({
                    team_comment: {
                        from: null,
                        to: e.id
                    }
                }, s))
            }
            _ensureNotDeleted() {
                const {
                    comment: e
                } = this;
                invariant(!e.isDeleted, "Operation not allowed on a deleted comment")
            }
            _ensureNotIncomplete() {
                const {
                    comment: e
                } = this;
                invariant(!e.isIncomplete, "Operation not allowed on an incomplete comment")
            }
            async _ensureCanBeMarkedAsTeam() {
                const {
                    comment: e
                } = this;
                invariant(await e.canBeMarkedAsTeam(), "Comment cannot be marked as team-editable")
            }
        }, "updateBody", [o.writer]), i(n, "togglePin", [o.writer]), i(n, "toggleReaction", [o.writer]), i(n, "deleteComment", [o.writer]), i(n, "restore", [o.writer]), i(n, "markAsClonedFromId", [o.writer]), i(n, "markAsClonedFrom", [o.writer]), i(n, "markAsTeam", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            G: () => r,
            u: () => a
        });
        var n = s(4);
        const a = {
                shouldHidePurpose: "hide_purpose",
                shouldProposeUnfollow: "propose_unfollow",
                shouldUseTeamColor: "use_team_color"
            },
            o = n.is(Boolean);

        function r(e, t) {
            const s = {};
            if (n.isObject(e)) {
                const t = e[a.shouldHidePurpose],
                    n = e[a.shouldProposeUnfollow];
                s[a.shouldHidePurpose] = !!o(t) && t, s[a.shouldProposeUnfollow] = !o(n) || n
            }
            const r = e ? e[a.shouldUseTeamColor] : void 0;
            return s[a.shouldUseTeamColor] = o(r) ? r : !!t.teamColor && !t.userColor, s
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n, a = s(24),
            o = s(4),
            r = s(5),
            i = (s(8), s(19)),
            c = s(33),
            l = s(16),
            d = s(29);
        let u = (m = n = class {
            get asModel() {
                return this.project
            }
            get database() {
                return this.project.database
            }
            get permissions() {
                return this.project.permissions
            }
            constructor(e) {
                this.project = e
            }
            async updateAccess(e) {
                const {
                    permissions: t,
                    project: s
                } = this, {
                    newMembers: n,
                    removedMembers: a,
                    changedMembers: r,
                    isOpen: i
                } = e, c = await this._isBecomingOnlyManager(e);
                if (await this._ensureCanUpdateAccess(c), invariant(!t.isOpen || !i, "Can't change access for open project"), s.isShared) {
                    invariant(!i, "Can't change access for shared project");
                    const e = await o.filterAsync((({
                        member: e
                    }) => e.isSharedTeamMember), [...n, ...a, ...r]);
                    invariant(!e.length, "Cannot modify access for shared members")
                }
                const l = !t.isOpen && i;
                a.length && await this._removeAccessesFor(a.map(o.prop("member")), l), await this._ensureMembersDontHaveAccess(n, l);
                const d = await s._me,
                    u = await t.accesses.fetch(),
                    m = c || t.isOpen && !i,
                    h = [...this._prepareGrantAccessesBatch(n, m, d), ...this._prepareUpdateAccessesBatch({
                        changedMembers: r,
                        allowToBecomeManager: m,
                        currentMember: d,
                        currentProjectAccesses: u
                    }), this._prepareProjectTypeChangeBatch(i)];
                await s.batch(...h)
            }
            async _removeAccessesFor(e, t) {
                const {
                    permissions: s,
                    project: n
                } = this, a = await n._me;
                o.forEach((e => {
                    invariant(t || e !== a, "Can't remove access for member " + e.id)
                }), e);
                const r = o.pluckIds(e),
                    c = s.accesses.extend(i.Q.where(l.o.projectAccesses.memberId, i.Q.oneOf(r)));
                await c.markAllAsDeleted(), t || await (0, d.yN)(n.activeTasks.extend(i.Q.where(l.o.tasks.responsibleId, i.Q.oneOf(r))))
            }
            async _ensureMembersDontHaveAccess(e, t) {
                const {
                    permissions: s
                } = this;
                await Promise.all(e.map((async ({
                    member: e
                }) => {
                    await s.doesMemberHaveAccess(e, !1) && (r.logError(r.PROD_CONSOLE_REASON.SAFE_LITERAL, "Attempt to grant project access to member that already has access"), await this._removeAccessesFor([e], t))
                })))
            }
            _prepareGrantAccessesBatch(e, t, s) {
                return e.map((({
                    member: e,
                    isManager: n
                }) => (e._ensureNotArchived(), e === s && invariant(t || !n, "Can't make yourself a manager"), this._prepareGrantAccess(e, n))))
            }
            _prepareUpdateAccessesBatch({
                changedMembers: e,
                allowToBecomeManager: t,
                currentMember: s,
                currentProjectAccesses: n
            }) {
                return e.map((({
                    member: e,
                    isManager: a
                }) => {
                    invariant(s !== e || t, "Can't change project access for yourself");
                    const o = n.find((t => t.member.id === e.id));
                    return invariant(o, "Expected project access"), o.prepareUpdate((e => {
                        e.isManager = a
                    }))
                }))
            }
            _prepareProjectTypeChangeBatch(e) {
                const {
                    permissions: t,
                    project: s
                } = this;
                return s.prepareUpdate((() => {
                    t.isOpen = e
                }))
            }
            _prepareGrantAccess(e, t) {
                const {
                    project: s
                } = this;
                return s.collections.get(l.w.projectAccesses).prepareCreate((n => {
                    n.project.set(s), n.member.set(e), n.isManager = t
                }))
            }
            async _ensureCanUpdateAccess(e) {
                const {
                    permissions: t,
                    project: s
                } = this;
                await s._ensureTeamProject(), s._ensureNotSingleTasks(), s._ensureNotEnded(), e ? invariant(await t.isEligibleForManagerClaim(), "You can't become manager of this project") : await t._ensureCanManage()
            }
            async _isBecomingOnlyManager({
                newMembers: e,
                removedMembers: t,
                changedMembers: s,
                isOpen: n
            }) {
                const {
                    permissions: a,
                    project: o
                } = this, r = await o._me;
                return !e.length && !t.length && a.isOpen === n && 1 === s.length && s[0].member === r && !0 === s[0].isManager
            }
        }, h = "updateAccess", p = [c.writer], (0, a.Z)(m.prototype, h, p, Object.getOwnPropertyDescriptor(m.prototype, h), m.prototype), n);
        var m, h, p
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n, a = s(24),
            o = s(33),
            r = s(4),
            i = (s(5), s(8), s(39));
        const c = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let l = (c(n = class {
            get asModel() {
                return this.section
            }
            get database() {
                return this.section.database
            }
            constructor(e) {
                this.section = e
            }
            async getProjectPositionForForm(e, t) {
                const {
                    section: s
                } = this;
                return (0, i.getNewPositionForForm)({
                    position: e,
                    list: t,
                    getTopPosition: () => s.getTopPosition(),
                    getBottomPosition: () => s.getBottomPosition(),
                    selector: e => e.projectPosition,
                    updater: (e, t) => {
                        e.projectPosition = t
                    }
                })
            }
            async updatePosition(e) {
                const {
                    section: t
                } = this;
                t.position !== e && await t.update((() => {
                    t.position = e
                }))
            }
            async rename(e) {
                const {
                    section: t
                } = this;
                await t._ensureActiveProject(), await t.update((() => {
                    t.name = e
                }))
            }
            async addTask(e) {
                const {
                    section: t
                } = this;
                invariant(t.isActive, "Not allowed to add tasks to archived sections");
                const s = e.projectPosition || await t.getTopPosition(),
                    n = await t.project.fetch();
                return t.callWriter((() => n.do.addTask(Object.assign({}, e, {
                    projectSectionId: t.id,
                    projectPosition: s
                }))))
            }
            async clone({
                name: e,
                selectedProject: t,
                withAllComments: s,
                withEndedTasks: n,
                position: a,
                referenceDate: o
            }) {
                invariant(this.section.canBeCloned(), "Cannot clone this project section");
                const i = t || await this.section.project.fetch(),
                    c = await (async () => i.id === this.section.project.id || i.permissions.isOpen ? [] : i.permissions.accesses.fetch())(),
                    l = await this.section.callWriter((() => i.do.createSection({
                        name: e || this.section.name,
                        position: a,
                        archivedAt: this.section.archivedAt
                    }))),
                    d = await l._me,
                    u = n ? await this.section.allTasks.fetch() : await this.section.activeTasks.fetch();
                return await r.allPromises((async e => {
                    const t = i.permissions.isOpen || c.some((t => t.member.id === e.responsible.id));
                    await this.section.callWriter((() => e.do.clone({
                        selectedProject: i,
                        section: l,
                        withAllComments: s,
                        withEndedTasks: n,
                        selectedResponsible: t ? void 0 : d,
                        shouldCheckAccess: !1,
                        referenceDate: o
                    })))
                }), u), l
            }
            async archive() {
                const {
                    section: e
                } = this;
                await e._ensureActiveProject();
                const t = await e.activeTasks.fetch();
                await this._moveTasksToNullSection(t), await e.update((() => {
                    e.archivedAt = new Date
                }))
            }
            async restore() {
                const {
                    section: e
                } = this;
                await e._ensureActiveProject(), await e.update((() => {
                    e.archivedAt = null
                }))
            }
            async convertToProject() {
                const {
                    section: e
                } = this;
                invariant(await e.canBeConvertedToProject(), "Cannot convert section to project");
                const t = await e.project.fetch(),
                    s = await e.callWriter((() => t.do.copy({
                        name: e.name,
                        tasks: !1,
                        sections: !1
                    })));
                return await r.allPromises((t => e.callWriter((() => t.do.moveToProject(s)))), await e.activeTasks.fetch()), await e.callWriter((() => e.do.archive())), s
            }
            async _moveTasksToNullSection(e) {
                const {
                    section: t
                } = this;
                await t.batch(...e.map((e => e.prepareUpdate((() => {
                    e.projectSection.id = null
                })))))
            }
        }, "updatePosition", [o.writer]), c(n, "rename", [o.writer]), c(n, "addTask", [o.writer]), c(n, "clone", [o.writer]), c(n, "archive", [o.writer]), c(n, "restore", [o.writer]), c(n, "convertToProject", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            c: () => a,
            m: () => o
        });
        var n = s(4);
        const a = ["avatarColor1", "avatarColor2", "avatarColor3", "avatarColor4", "avatarColor5", "avatarColor6", "avatarColor7", "avatarColor8", "avatarColor9", "avatarColor10", "avatarColor11", "avatarColor12"];

        function o() {
            const e = n.randomElement(a);
            return invariant(e, "unexpected null as color in randomAvatarColor"), e
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n, a = s(24),
            o = (s(5), s(33));
        const r = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let i = (r(n = class {
            get asModel() {
                return this.tag
            }
            get database() {
                return this.tag.database
            }
            constructor(e) {
                this.tag = e
            }
            async rename(e) {
                const {
                    tag: t
                } = this;
                t._ensureActive(), await t.update((() => {
                    t.name = e
                }))
            }
            async updateColor(e) {
                const {
                    tag: t
                } = this;
                t._ensureActive(), await t.update((() => {
                    t.isShared ? t.teamColor = e : t.userColor = e
                }))
            }
            async updateIcon(e) {
                const {
                    tag: t
                } = this;
                t._ensureActive(), await t.update((() => {
                    t.icon = e
                }))
            }
            async archive() {
                const {
                    tag: e
                } = this;
                e._ensureActive(), await e.update((() => {
                    e.archivedAt = new Date
                }))
            }
            async restore() {
                const {
                    tag: e
                } = this;
                e._ensureArchived(), await e.update((() => {
                    e.archivedAt = null
                }))
            }
        }, "rename", [o.writer]), r(n, "updateColor", [o.writer]), r(n, "updateIcon", [o.writer]), r(n, "archive", [o.writer]), r(n, "restore", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n, a = s(24),
            o = s(33),
            r = s(19),
            i = s(194),
            c = s(280),
            l = (s(4), s(5), s(21)),
            d = s(16),
            u = s(110),
            m = s(78);
        const h = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let p = (h(n = class {
            get asModel() {
                return this.task
            }
            get database() {
                return this.task.database
            }
            get taskDates() {
                return this.task.dates
            }
            constructor(e) {
                this.task = e
            }
            async updateDueDate(e, t) {
                const {
                    task: s,
                    taskDates: n
                } = this, a = n.dueDate, o = n.recurrenceOrigin;
                if (!(0, l.dateTimeEquals)(e, a)) {
                    await s._ensureActiveProject();
                    const r = await s._me,
                        d = !s.responsible.id && e,
                        m = await s.dates.isDueDateRelative(),
                        [h, p] = n._recurrenceOriginAt ? (0, l.dateTimeEquals)(e, t) ? [!0, null] : [!(0, l.dateTimeEquals)(t, o), t] : [!(0, l.dateTimeEquals)(t, e), t];
                    await s.batch(s.prepareUpdate((() => {
                        n.dueDate = e, e && (d || s.responsible.id === r.id) && (m || !(0, i.Z)(e.local) && !(0, c.Z)(e.local) || s.unsafeSetReviewReason("due_date")), e || this._removeDueDate(), d && s.responsible.set(r), h && (n.recurrenceOrigin = p)
                    })), s.do._prepareEvent({
                        due_date: {
                            from: (0, u.PD)(null == a ? void 0 : a.legacyDueDate),
                            to: (0, u.PD)(null == e ? void 0 : e.legacyDueDate)
                        }
                    }, r), d && s.do._prepareEvent({
                        responsible: {
                            from: null,
                            to: r.id
                        }
                    }, r))
                }
            }
            _removeDueDate() {
                const {
                    taskDates: e
                } = this;
                e.dueDate = null, this._removeRecurrence()
            }
            async updateRecurrence(e) {
                const {
                    task: t,
                    taskDates: s
                } = this;
                await t._ensureActiveProject(), e && invariant(s.dueDate, "Recurrence can only be set on a task with a due date"), s.isRecurring && invariant(await s.canUpdateRecurrence(), "Cannot update recurrence for task");
                const n = await s.recurrence.fetch().catch((() => null)),
                    a = (null == n ? void 0 : n.rawPattern) || null;
                if (a === e) return;
                const [o] = await s.db.collections.get(d.w.taskRecurrences).query(r.Q.where(d.o.taskRecurrences.currentTaskId, t.id)).fetch(), i = n || o, c = e && !i ? s.db.collections.get(d.w.taskRecurrences).prepareCreate((s => {
                    invariant(e, "New recurrence pattern cannot be null"), s.rawPattern = e, s.currentTask.set(t), s.project.id = t._project.id
                })) : null, l = c || n || o, u = await t._me;
                await t.batch(c, t.prepareUpdate((() => {
                    e ? l && s.recurrence.set(l) : this._removeRecurrence()
                })), i && i.prepareUpdate((() => {
                    e && (i.rawPattern = e), i.project.id = t._project.id
                })), t.do._prepareEvent({
                    recurrence: {
                        from: a,
                        to: e
                    }
                }, u))
            }
            _removeRecurrence() {
                const {
                    taskDates: e
                } = this;
                e.recurrence.set(null), e.missedRepeats = 0
            }
            async updateDueDateAndRecurrence(e, t, s) {
                const {
                    task: n,
                    taskDates: a
                } = this;
                a.dueDate && !e ? (await n.callWriter((() => this.updateRecurrence(null))), await n.callWriter((() => this.updateDueDate(null)))) : e && (await n.callWriter((() => this.updateDueDate(e, s))), await n.callWriter((() => this.updateRecurrence(t))))
            }
            async updateReminders({
                added: e,
                removed: t
            }) {
                const {
                    task: s,
                    taskDates: n
                } = this;
                if (e.length || t.length) {
                    await s._ensureActiveProject();
                    const a = await n.reminders.fetch(),
                        o = a.map((e => e.remindAt)),
                        r = e.filter((e => !(0, m.ES)(e, o))),
                        i = a.filter((e => (0, m.ES)(e.remindAt, t)));
                    await s.batch(...r.map((e => n.db.collections.get(d.w.reminders).prepareCreate((t => {
                        t.task.set(s), t.remindAt = e
                    })))), ...i.map((e => e.prepareMarkAsDeleted())))
                }
            }
            async _assignRecurrence(e) {
                const {
                    task: t
                } = this;
                await t.update((() => {
                    t.dates.recurrence.set(e)
                }))
            }
        }, "updateDueDate", [o.writer]), h(n, "updateRecurrence", [o.writer]), h(n, "updateDueDateAndRecurrence", [o.writer]), h(n, "updateReminders", [o.writer]), h(n, "_assignRecurrence", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n, a = s(24),
            o = s(4),
            r = (s(5), s(8), s(33)),
            i = s(16),
            c = s(88);
        const l = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype),
            d = i.o.tasks;
        let u = (l(n = class {
            get asModel() {
                return this.task
            }
            get database() {
                return this.task.database
            }
            get timeline() {
                return this.task.timeline
            }
            constructor(e) {
                this.task = e
            }
            async addComment(e) {
                const [t] = await this.addComments([e]);
                return t
            }
            async addComments(e) {
                if (invariant(!this.task.isThread || this.task.isActive, "Cannot add comments/messages to an inactive thread"), !e.length) return [];
                const {
                    task: t,
                    timeline: s
                } = this, n = await t._me, a = [], r = [], c = [];
                e.forEach((({
                    body: s,
                    inputFiles: o = []
                }, l) => {
                    const d = t.collections.get(i.w.comments).prepareCreate((a => {
                            if (a.task.id = t.id, a.author.set(n), a.body = s, a._createdAt -= e.length - l, "object" == typeof s && s.document) {
                                var o;
                                const e = null == (o = s.document.data) ? void 0 : o.importMetadata;
                                a.isDeleted = !(null == e || !e.isDeleted), a.isPinned = !(null == e || !e.isPinned)
                            }
                        })),
                        [u, m] = this._prepareCreateAttachments(n, d, o);
                    a.push(d), r.push(...u), c.push(...m)
                }));
                const l = o.last(a);
                return await t.batch(...a, ...r, ...c, t.prepareUpdate((() => {
                    t.do._bumpLastActivity(null == l ? void 0 : l.createdAt), t.isFollowed = !0
                }))), await s.removeNewCommentDraft(), a
            }
            async updateComment(e, t, s = []) {
                const {
                    task: n
                } = this, a = await n._me;
                await this.task.callWriter((() => e.do.updateBody(t)));
                const o = [],
                    {
                        newAttachmentVersions: r,
                        removedAttachmentVersions: i,
                        removedAttachments: l
                    } = await (0, c.wD)(e, s);
                o.push(...i.map((e => e.prepareMarkAsDeleted()))), o.push(...l.map((e => e.prepareMarkAsDeleted())));
                const [d, u] = this._prepareCreateAttachments(a, e, r);
                o.push(...d, ...u), e.isTeam && o.push(n.do._prepareEvent({
                    team_comment: {
                        from: e.id,
                        to: e.id
                    }
                }, a), n.prepareUpdate((e => {
                    e.do._bumpLastActivity()
                }))), await this.task.batch(...o)
            }
            _prepareCreateAttachments(e, t, s) {
                const {
                    task: n
                } = this;
                return o.unzip(s.map((s => {
                    const {
                        name: a,
                        size: o
                    } = s, r = n.collections.get(i.w.attachments).prepareCreate((e => {
                        e.parent.set(t)
                    })), c = n.collections.get(i.w.attachmentVersions).prepareCreate((t => {
                        if (t.author.set(e), t.attachment.set(r), t.name = a, t.size = o, t.status = "uploading", "local" === s.content.source) {
                            const {
                                file: e
                            } = s.content;
                            t.mimeType = e.type, t.file = e
                        } else if ("external" === s.content.source) {
                            const {
                                file: e
                            } = s.content;
                            t.mimeType = e.mimeType, t.do._markAsExternal(e)
                        }
                    }));
                    return [r, c]
                })))
            }
            async updateIncompleteTimeline(e) {
                const {
                    task: t
                } = this, s = await t.timeline.events.fetch(), n = await t.timeline.comments.fetch();
                await t.batch(...e.comments.map((e => {
                    const s = n.find((t => t.id === e.id));
                    return s ? s.isIncomplete ? s.prepareUpdate((() => {
                        s._dangerouslySetRawWithoutMarkingColumnChange(i.o.comments.body, e.body), s._dangerouslySetRawWithoutMarkingColumnChange(i.o.comments.reactions, e.reactions || null)
                    })) : null : t.db.get(i.w.comments).prepareCreateFromDirtyRaw(Object.assign({}, e, {
                        _status: "synced",
                        _changed: ""
                    }))
                })), ...e.task_events.map((e => {
                    const n = s.find((t => t.id === e.id));
                    return n ? n.isIncomplete ? n.prepareUpdate((() => {
                        n._dangerouslySetRawWithoutMarkingColumnChange(i.o.taskEvents.change, e.change)
                    })) : null : t.db.get(i.w.taskEvents).prepareCreateFromDirtyRaw(Object.assign({}, e, {
                        _status: "synced",
                        _changed: ""
                    }))
                })), t.prepareUpdate((() => {
                    t._dangerouslySetRawWithoutMarkingColumnChange(d.commentsCached, null)
                })))
            }
        }, "addComments", [r.writer]), l(n, "updateComment", [r.writer]), l(n, "updateIncompleteTimeline", [r.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => v
        });
        var n, a = s(24),
            o = s(4),
            r = (s(5), s(8)),
            i = s(21),
            c = s(192),
            l = s(41),
            d = s(1452),
            u = s(19),
            m = s(33),
            h = s(16),
            p = s(110),
            g = s(35),
            f = s(29),
            b = s(478);
        const y = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let v = (y(n = class {
            get asModel() {
                return this.task
            }
            get database() {
                return this.task.database
            }
            constructor(e) {
                this.task = e
            }
            async assignResponsible(e, t) {
                const {
                    task: s
                } = this;
                await s._ensureActiveProject(), invariant(!(null != e && e.isArchived), "Must not assign archived members to tasks"), invariant(!s.isThread, "threads shouldn't have resposible");
                const n = s.responsible.id,
                    a = (null == e ? void 0 : e.id) || null;
                if (n === a) return;
                const o = await s._me,
                    i = !e,
                    c = s.dates.dueDate,
                    l = t ? await r.takeFirst(s.taskAccess) : null,
                    d = [s.prepareUpdate((() => {
                        s.responsible.set(e), i && s._unassignResponsible(), i || this._markAsReviewed(), e === o && (s.isFollowed = !0)
                    })), this._prepareEvent({
                        responsible: {
                            from: n,
                            to: a || null
                        }
                    }, o)];
                var u;
                (l && d.push(l._prepareRevoke()), t && e) && d.push(s.do._prepareAccess({
                    member: e
                }, o), this._prepareEvent({
                    access: {
                        from: null == l || null == (u = l.grantee) ? void 0 : u.id,
                        to: e.id
                    }
                }, o));
                i && c && d.push(this._prepareEvent({
                    due_date: {
                        from: (0, p.PD)(c.legacyDueDate),
                        to: null
                    }
                }, o)), await s.batch(...d)
            }
            async shareWithEmail(e) {
                var t;
                const {
                    task: s
                } = this, n = await s._me, a = s.responsible.id, o = await r.takeFirst(s.taskAccess), i = [s.prepareUpdate((() => {
                    a !== n.id && s.responsible.set(n), this._markAsReviewed(), s.isFollowed = !0
                }))];
                a !== n.id && i.push(this._prepareEvent({
                    responsible: {
                        from: a,
                        to: n.id
                    }
                }, n)), o && i.push(o._prepareRevoke()), i.push(s.do._prepareAccess({
                    email: e
                }, n), this._prepareEvent({
                    access: {
                        from: null == o || null == (t = o.grantee) ? void 0 : t.id,
                        to: e
                    }
                }, n)), await s.batch(...i)
            }
            async updateTags({
                added: e,
                removed: t
            }) {
                const {
                    task: s
                } = this;
                await s._ensureActiveProject(), invariant(!s.isThread, "threads shouldn't have tags"), invariant(e.every((e => e.isActive)), "Task can be only assigned active tags");
                const n = await s.tagAssignments.extend(u.Q.where(h.o.tagAssignments.tagId, u.Q.oneOf(o.pluckIds(t)))).fetch(),
                    a = e.filter((e => !e.isPrivate)),
                    r = t.filter((e => !e.isPrivate)),
                    i = await s._me;
                await s.batch(...e.map((e => s.collections.get(h.w.tagAssignments).prepareCreate((t => {
                    t.task.id = s.id, t.tag.set(e)
                })))), ...n.map((e => e.prepareMarkAsDeleted())), 0 < a.length || 0 < r.length ? this._prepareEvent({
                    tag: {
                        added: o.pluckIds(a),
                        removed: o.pluckIds(r)
                    }
                }, i) : void 0)
            }
            async moveToProject(e) {
                const {
                    task: t
                } = this;
                invariant(!t.isGranted, "Cannot change project for granted task"), invariant(!t.isThread, "Cannot move `thread` type tasks");
                const s = t._project.id;
                if (e.id !== s) {
                    await t._ensureCanMoveToProject(e);
                    const n = await t._me,
                        a = await e.getTopPosition(),
                        o = t.responsible.id && !await this._doesResponsibleHaveAccessToTask(e),
                        r = await t.dates.recurrence.fetch().catch((() => null)),
                        c = await (async () => {
                            const s = t.dates.dueDate;
                            if (!s) return null;
                            const n = await t.dates.isDueDateRelative();
                            return n && !e.isTemplate ? (0, i.toAbsoluteDateTime)(t.dates.dueDate) : !n && e.isTemplate ? (0, i.toRelativeDateTime)(s) : t.dates.dueDate
                        })();
                    await t.batch(t.prepareUpdate((() => {
                        t._project.set(e), t.projectPosition = a, t.projectSection.set(null), this._bumpLastActivity(), t.dates.dueDate = c, o && t._unassignResponsible()
                    })), r && r.prepareUpdate((() => {
                        r.project.set(e)
                    })), this._prepareEvent({
                        project: {
                            from: s,
                            to: e.id
                        }
                    }, n))
                }
            }
            async moveToSection(e, {
                position: t
            } = {}) {
                const {
                    task: s
                } = this;
                invariant(!s.isGranted, "Cannot change section for a granted task"), await s._ensureActiveProject(), e && invariant(e.project.id === s._project.id, "Can not move " + s.id + " to section " + e.id + " because it doesn't belong to project " + s._project.id);
                const n = s.projectSection.id,
                    a = (null == e ? void 0 : e.id) || null;
                if (a !== n) {
                    const o = await s._me,
                        r = t || (e ? await e.getTopPosition() : await s._projectTopPosition());
                    await s.batch(s.prepareUpdate((() => {
                        s.projectSection.set(e), s.projectPosition = r
                    })), this._prepareEvent({
                        section: {
                            from: n,
                            to: a || null
                        }
                    }, o))
                }
            }
            async updateTimeNeeded(e) {
                const {
                    task: t
                } = this;
                await t._ensureCanUpdateTimeAttributes();
                const s = (0, f.C9)(t._timeNeeded),
                    n = (0, f.C9)(e),
                    a = await t._me;
                await t.batch(t.prepareUpdate((() => {
                    t._timeNeeded = n
                })), s !== n ? t.do._prepareEvent({
                    time_needed: {
                        from: s,
                        to: n
                    }
                }, a) : null)
            }
            async updateTimeSpent(e) {
                const {
                    task: t
                } = this;
                await t._ensureCanUpdateTimeAttributes();
                const s = (0, f.C9)(t._timeSpent),
                    n = (0, f.C9)(e),
                    a = await t._me;
                await t.batch(t.prepareUpdate((() => {
                    t._timeSpent = n
                })), s !== n ? t.do._prepareEvent({
                    time_spent: {
                        from: s,
                        to: n
                    }
                }, a) : null)
            }
            async complete() {
                const {
                    task: e
                } = this;
                if (invariant(!e.isThread, "threads shouldn't be completed"), !e.isCompleted) {
                    const t = await e._me;
                    await e.batch(e.prepareUpdate((() => {
                        this._markAsEnded({
                            abandoned: !1
                        })
                    })), this._prepareEvent({
                        completed: !0
                    }, t))
                }
            }
            async abandon() {
                const {
                    task: e
                } = this;
                if (invariant(!e.isThread, "threads shouldn't be abandoned"), !e.isAbandoned) {
                    const t = await e._me;
                    await e.batch(e.prepareUpdate((() => {
                        this._markAsEnded({
                            abandoned: !0
                        }), this._markAsReviewed()
                    })), this._prepareEvent({
                        abandoned: !0
                    }, t))
                }
            }
            _markAsEnded({
                abandoned: e
            }) {
                const {
                    task: t
                } = this, s = new Date;
                t.endedAt = s, t._isEndedByAbandonment = e, this._bumpLastActivity(s)
            }
            async restore() {
                const {
                    task: e
                } = this;
                if (!e.isEnded) return !1;
                if (invariant(!e.isThread, "threads shouldn't be restored"), invariant(!e.isGranted, "Cannot restore granted task"), await e._ensureActiveProject(), !await e.canRestoreDueToHistoryLimits()) return !1;
                const t = await e._me,
                    s = e.endedAt && (0, c.Z)(e.endedAt, (0, l.Z)(new Date)),
                    n = e.responsible.id && e.responsible.id !== t.id && (!await this._doesResponsibleHaveAccessToTask() || s),
                    a = await e._isSectionArchived(),
                    o = a ? await e._projectTopPosition() : 0,
                    r = e.dates.isRecurring && !await e.dates.isCurrentRecurringInstance();
                return await e.batch(e.prepareUpdate((() => {
                    e.endedAt = null, e._isEndedByAbandonment = !1, this._bumpLastActivity(), n && e._unassignResponsible(), r && e.dates.do._removeRecurrence(), a && (e.projectSection.set(null), e.projectPosition = o)
                })), this._prepareEvent({
                    restored: !0
                }, t)), !0
            }
            async markAsRead() {
                const {
                    task: e
                } = this;
                e.isUnread && await e.update((() => {
                    this._markAsRead()
                }))
            }
            _markAsRead() {
                const {
                    task: e
                } = this;
                e.isUnread && (e.lastSeenActivityAt = e.lastActivityAt)
            }
            async _findDateToMarkAsUnread(e = null) {
                const {
                    task: t
                } = this, s = await t._me, n = await t.timeline.comments.fetch(), a = await t.timeline.events.fetch(), r = (0, g.mO)(n.concat(a)), i = o.findIndex((t => e ? e === t : t.table === h.w.comments && t.author.id !== s.id), r.reverse()), c = -1 !== i ? r[i + 1] : null;
                return null == c ? void 0 : c.createdAt
            }
            async markCommentAsUnread(e) {
                const {
                    task: t
                } = this, s = await this._findDateToMarkAsUnread(e);
                await t.callWriter((() => this.markAsUnread(s)))
            }
            async markAsUnread(e = null) {
                const {
                    task: t
                } = this, s = null !== e && (0, d.Z)(t.lastSeenActivityAt || 0, e || 0) ? await this._findDateToMarkAsUnread() : e;
                await t.update((() => {
                    t.lastSeenActivityAt = s
                }))
            }
            _bumpLastActivity(e = new Date) {
                const {
                    task: t
                } = this;
                t.lastActivityAt = e, t.lastSeenActivityAt = e
            }
            async markAsReviewed() {
                const {
                    task: e
                } = this;
                e.doesNeedReview && await e.update((() => {
                    this._markAsReviewed()
                }))
            }
            async restoreReview() {
                const {
                    task: e
                } = this;
                e.doesNeedReview || await e.update((() => {
                    this._restoreReviewReason()
                }))
            }
            _savePreviousReview() {
                const {
                    task: e
                } = this;
                e.previousLastReviewedAt = e.lastReviewedAt, e.previousReviewReason = e._reviewReason
            }
            clearPreviousReview() {
                const {
                    task: e
                } = this;
                e.previousLastReviewedAt = null, e.previousReviewReason = null
            }
            _markAsReviewed() {
                const {
                    task: e
                } = this;
                e.doesNeedReview && (this._savePreviousReview(), e.lastReviewedAt = e.reviewTriggeredAt, e._reviewReason = null)
            }
            _restoreReviewReason() {
                const {
                    task: e
                } = this;
                invariant(e.previousReviewReason, "Cannot bring back reviewReson that does not exist"), e._reviewReason = e.previousReviewReason, e.previousReviewReason = null, e.lastReviewedAt = e.previousLastReviewedAt, e.previousLastReviewedAt = null
            }
            async updateProjectPosition(e) {
                const {
                    task: t
                } = this;
                await t.update((() => {
                    t.projectPosition = e
                }))
            }
            async updatePriorityPosition(e) {
                const {
                    task: t
                } = this;
                await t.update((() => {
                    t.priorityPosition = e
                }))
            }
            createTaskPosition(e, t) {
                const {
                    task: s
                } = this;
                return s.collections.get(h.w.taskPositions).prepareCreate((n => {
                    n.task.set(s), n.position = t, n.listId = e
                }))
            }
            async setFollow(e) {
                const {
                    task: t
                } = this;
                await t.update((() => {
                    t.isFollowed = e
                }))
            }
            async rename(e) {
                const {
                    task: t
                } = this;
                if (e !== t.name) {
                    await t._ensureActiveProject();
                    const s = t.name,
                        n = await t._me;
                    await t.batch(t.prepareUpdate((() => {
                        t.name = e
                    })), this._prepareEvent({
                        name: {
                            from: s,
                            to: e
                        }
                    }, n))
                }
            }
            async revokeAccess() {
                const {
                    task: e
                } = this, t = await r.takeFirst(e.taskAccess);
                if (!t) return;
                const s = await e._me,
                    n = e.responsible.id === t.grantee.id,
                    a = e.isGranted ? await t.granter.fetch() : s,
                    o = n ? [e.prepareUpdate((() => {
                        e.responsible.set(a)
                    })), this._prepareEvent({
                        responsible: {
                            from: t.grantee.id,
                            to: a.id
                        }
                    }, s)] : [];
                await e.batch(...o, t._prepareRevoke(), this._prepareEvent({
                    access: {
                        from: t.grantee.id,
                        to: null
                    }
                }, s))
            }
            async markAsPriority() {
                const {
                    task: e
                } = this;
                await e._ensureActiveProject();
                const t = await e.fetchCurrentProject(),
                    s = await t.getCurrentTeam(),
                    n = await s.do.getTopPriorityPosition();
                await e.update((() => {
                    e.priorityPosition = n, e.isFollowed = !0
                }))
            }
            async removePriority() {
                const {
                    task: e
                } = this;
                await e._ensureActiveProject(), await e.update((() => {
                    e.priorityPosition = null
                }))
            }
            togglePriority() {
                return this.task.isPriority ? this.removePriority() : this.markAsPriority()
            }
            async _doesResponsibleHaveAccessToTask(e) {
                var t;
                const {
                    task: s
                } = this, n = s.responsible.id;
                if (s.isGranted || !n) return !1;
                const a = await r.takeFirst(s.taskAccess);
                if (n === (null == a || null == (t = a.grantee) ? void 0 : t.id)) return !0;
                const o = e || await s._project.fetch(),
                    i = await s.collections.get(h.w.teamMembers).find(n);
                return o.permissions.doesMemberHaveAccess(i)
            }
            _prepareAccess(e, t) {
                const {
                    task: s
                } = this;
                return s.collections.get(h.w.taskAccesses).prepareCreate((n => {
                    n.task.id = s.id, n.granter.set(t), e.team ? (n.granteeType = "team", n._granteeTeam.set(e.team)) : e.group ? (n.granteeType = "member_group", n._granteeGroup.set(e.group)) : e.member ? (n.granteeType = "member", n._grantee.set(e.member)) : n.granteeEmail = e.email
                }))
            }
            _prepareEvent(e, t, {
                when: s = new Date
            } = {}) {
                const {
                    task: n
                } = this;
                return n.collections.get(h.w.taskEvents).prepareCreate((a => {
                    a.task.id = n.id, a.author.set(t), a.createdAt = s, a.change = e
                }))
            }
            async clone({
                name: e,
                annotation: t,
                withAllComments: s,
                withEndedTasks: n,
                selectedProject: a,
                selectedResponsible: c,
                section: l,
                shouldCheckAccess: d,
                selectedDueDate: m,
                selectedRecurrence: p,
                referenceDate: f
            }) {
                var b;
                invariant(n || await this.task.canBeCloned(), "Cannot clone the task");
                const {
                    task: y
                } = this, {
                    responsible: v,
                    projectPosition: w,
                    projectSection: k,
                    isPriority: x,
                    priorityPosition: j,
                    dates: {
                        dueDate: T
                    },
                    isGranted: S
                } = y, P = await y.fetchCurrentProject(), _ = a || P, C = void 0 !== p ? p : null == (b = await y.dates.recurrence.fetch()) ? void 0 : b.rawPattern, R = await y.dates.reminders.fetch(), A = await y.tags.fetch(), I = s ? y.timeline.comments : y.timeline.pinnedComments, N = (0, g.mO)(await I.fetch()).filter((e => !e.isDeleted)), E = await y.dates.isDueDateRelative(), O = m || (T ? E && !_.isTemplate ? (0, i.toAbsoluteDateTime)(T, f) : !E && _.isTemplate ? (0, i.toRelativeDateTime)(T) : T : null), M = await (null == v ? void 0 : v.fetch()), [D] = M ? await y.collections.get(h.w.teamMembers).query(u.Q.experimentalJoinTables([h.w.users]), u.Q.and(u.Q.where(h.o.teamMembers.teamId, _.team.id), u.Q.on(h.w.users, u.Q.where(h.o.id, M.user.id)))).fetch() : [null], [H] = await y.collections.get(h.w.teamMembers).query(u.Q.experimentalJoinTables([h.w.users]), u.Q.and(u.Q.where(h.o.teamMembers.teamId, _.team.id), u.Q.on(h.w.users, u.Q.where(h.o.users.isMe, !0)))).fetch(), F = void 0 !== c ? c : D, Z = (null == F ? void 0 : F.id) || (O ? H.id : null), L = void 0 !== l ? l : k, B = await y.callWriter((async () => await _.do.addTask({
                    name: e || y.name,
                    projectPosition: w,
                    projectSectionId: (null == L ? void 0 : L.id) || null,
                    isPriority: x,
                    priorityPosition: null != j ? j : null,
                    responsibleId: Z,
                    dueDate: O,
                    skipDueDateSanitization: !0,
                    recurrence: O && C || null,
                    reminders: {
                        added: R.map((e => e.remindAt)),
                        removed: []
                    },
                    shouldCheckAccess: d || S,
                    endedAt: y.endedAt
                })));
                if (await B.callWriter((() => B.do.markAsClonedFromId(y.id))), _.areTimeAttributesEnabled) {
                    const e = await r.takeFirst(y.timeAttributes);
                    e && (await y.callWriter((() => B.do.updateTimeNeeded(e.timeNeeded))), await y.callWriter((() => B.do.updateTimeSpent(e.timeSpent))))
                }
                if (A.length) {
                    const e = _.team.id === P.team.id ? A : A.filter((e => e.isPrivate));
                    await y.callWriter((() => B.do.updateTags({
                        added: e,
                        removed: []
                    })))
                }
                if (t) {
                    const e = await y.callWriter((() => B.timeline.do.addComment((0, g.zJ)({
                        body: t
                    }))));
                    await e.update((() => {
                        e._createdAt -= N.length
                    }))
                }
                const z = await y.callWriter((() => B.timeline.do.addComments(N.map((e => (0, g.zJ)({
                    body: (0, g.SR)(e),
                    inputFiles: []
                }))))));
                return await o.allPromises((async ([e, t]) => {
                    t.isTeam && await y.callWriter((() => e.do.markAsTeam())), t.isPinned && !e.isPinned && await y.callWriter((() => e.do.togglePin())), await y.callWriter((() => e.do.markAsClonedFrom(t)))
                }), o.zip(z, N)), B
            }
            convertToProject(e) {
                return s(1244).Z(this.task, e)
            }
            async markAsClonedFromId(e) {
                await this.task.update((t => {
                    t.extra = Object.assign({}, t.extra, {
                        [b.k.clonedFromId]: e
                    })
                }))
            }
        }, "assignResponsible", [m.writer]), y(n, "shareWithEmail", [m.writer]), y(n, "updateTags", [m.writer]), y(n, "moveToProject", [m.writer]), y(n, "moveToSection", [m.writer]), y(n, "updateTimeNeeded", [m.writer]), y(n, "updateTimeSpent", [m.writer]), y(n, "complete", [m.writer]), y(n, "abandon", [m.writer]), y(n, "restore", [m.writer]), y(n, "markAsRead", [m.writer]), y(n, "markCommentAsUnread", [m.writer]), y(n, "markAsUnread", [m.writer]), y(n, "markAsReviewed", [m.writer]), y(n, "restoreReview", [m.writer]), y(n, "updateProjectPosition", [m.writer]), y(n, "updatePriorityPosition", [m.writer]), y(n, "setFollow", [m.writer]), y(n, "rename", [m.writer]), y(n, "revokeAccess", [m.writer]), y(n, "markAsPriority", [m.writer]), y(n, "removePriority", [m.writer]), y(n, "clone", [m.writer]), y(n, "convertToProject", [m.writer]), y(n, "markAsClonedFromId", [m.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(4),
            a = s(8),
            o = s(35);
        async function r(e, t) {
            invariant(await e.canBeConvertedToProject(), "Cannot convert task to project");
            const {
                annotations: s
            } = t, r = await e.fetchCurrentProject(), i = await e.callWriter((() => r.do.copy({
                name: e.name,
                description: s.projectDescription,
                tasks: !1,
                sections: !1,
                isOpen: r.permissions.isOpen ? void 0 : t.usesPersonalUI
            }))), [c, l, d] = await async function(e, t) {
                const s = [],
                    a = [],
                    r = [],
                    i = t.onlyPinnedComments ? e.timeline.pinnedComments : e.timeline.activeComments,
                    c = (0, o.mO)(await i.fetch());
                return await n.allPromises((async e => {
                    0 < await e.attachments.fetchCount() && r.push(e);
                    const {
                        body: {
                            document: n
                        }
                    } = e, i = [];
                    n.nodes.forEach((e => {
                        var n;
                        "checklist" === e.type ? null == (n = e.nodes) || n.forEach((e => {
                            var n;
                            if ("checklist-item" === e.type && null != (n = e.data) && n.id) {
                                var a, r;
                                const n = (0, o.uD)(e),
                                    i = null != (a = null == t.formatTaskName ? void 0 : t.formatTaskName(n)) ? a : n;
                                s.push({
                                    name: i,
                                    isCompleted: !(null == (r = e.data) || !r.isCompleted)
                                })
                            }
                        })) : i.push(e)
                    }));
                    const c = (0, o.Ji)(i),
                        l = (0, o.Ds)(c);
                    l && a.push(l)
                }), c), [s, a, r]
            }(e, t), u = await a.takeFirst(i.permissions.isPrivate) ? await i._me : null, m = new Date, h = await Promise.all(c.map((({
                name: t,
                isCompleted: s
            }, n) => e.callWriter((() => i.do.addTask({
                name: t,
                responsibleId: null == u ? void 0 : u.id,
                projectPosition: n,
                endedAt: s ? m : null
            }))))));
            if (l.length || d.length) {
                const t = await e.callWriter((() => i.do.createSection({
                    name: s.projectResources,
                    position: h.length
                })));
                if (l.length) {
                    const n = await e.callWriter((() => i.do.addTask({
                        name: s.taskNotes,
                        projectSectionId: t.id
                    })));
                    await e.callWriter((() => n.timeline.do.addComments(l.map((e => (0, o.zJ)({
                        body: e
                    }))))))
                }
                if (d.length) {
                    const a = await e.callWriter((() => i.do.addTask({
                        name: s.taskFiles,
                        projectSectionId: t.id
                    })));
                    await n.allPromises((async t => {
                        const n = await t.attachments.fetchCount(),
                            r = await e.callWriter((() => a.timeline.do.addComment((0, o.zJ)({
                                body: s.commentFile(n)
                            }))));
                        await e.callWriter((() => r.do.markAsClonedFrom(t)))
                    }), d)
                }
            }
            return await e.callWriter((() => e.timeline.do.addComment((0, o.zJ)({
                body: s.taskAbandoned(i)
            })))), await e.callWriter((() => e.do.abandon())), i
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            p: () => d
        });
        s(5), s(4);
        var n = s(8),
            a = (s(21), s(39)),
            o = s(41),
            r = s(102),
            i = s(19),
            c = s(16),
            l = s(29);

        function d(e, t, s, a) {
            return invariant(t.isAllDay && s.isAllDay, "getRemindersBetween: start and end must be all-day dates"), e.tasksInActiveProjectsWithoutTemplates.pipe(n.map((e => e.extend(i.Q.or(...u(t, s), ...m(a ? null : t, s))))))
        }
        const u = (e, t) => [i.Q.where(c.o.tasks.endedAt, i.Q.between((0, o.Z)(e.local).getTime(), (0, r.Z)(t.local).getTime()))],
            m = (e, t) => [i.Q.and([l.rG, (0, a.queryBetweenDays)({
                start: e,
                end: t,
                isAllDayColumn: c.o.tasks.isAllDay,
                timestampColumn: c.o.tasks.dueAt
            })])]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            _: () => u
        });
        s(5), s(8);
        var n = s(39),
            a = s(19),
            o = s(16),
            r = (s(21), s(65));
        const i = (e, t) => [a.Q.and(a.Q.where(o.o.reminders.isRelative, !1), (0, n.queryBetweenDays)({
                start: e,
                end: t,
                isAllDayColumn: o.o.reminders.isAllDay,
                timestampColumn: o.o.reminders.remindAt
            }))],
            c = (e, t) => {
                const [s, a] = n.allDayUTCFixupOffsets;
                return [e.timestamp + s, t.timestamp + a + 864e5]
            },
            l = (e, t) => {
                const [s, n] = c(e, t);
                return [a.Q.and(a.Q.where(o.o.reminders.isRelative, !0), a.Q.on(o.w.tasks, [a.Q.where(o.o.tasks.dueAt, a.Q.notEq(null)), a.Q.where(o.o.tasks.endedAt, null)]))]
            },
            d = (e, t) => {
                {
                    const [s, n] = c(e, t);
                    return [a.Q.unsafeLokiTransform(((e, t) => e.filter((e => {
                        if (e.is_relative) {
                            const a = t.getCollection(o.w.tasks).by("id", e.task_id);
                            return a && a.due_at && a.due_at + e.remind_at >= s && a.due_at + e.remind_at <= n
                        }
                        return !0
                    }))))]
                }
            };

        function u(e, t, s) {
            return invariant(t.isAllDay && s.isAllDay, "getRemindersBetween: start and end must be all-day dates"), e.collections.get(o.w.reminders).query(a.Q.experimentalJoinTables([o.w.tasks]), a.Q.experimentalNestedJoin(o.w.tasks, o.w.projects), a.Q.or(...i(t, s), ...l(t, s)), a.Q.on(o.w.tasks, a.Q.on(o.w.projects, [r.Y3, (0, r.J$)(e.id)])), ...d(t, s))
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n, a = s(24),
            o = (s(5), s(33)),
            r = s(8),
            i = s(39),
            c = s(4),
            l = s(16),
            d = s(108),
            u = s(29),
            m = s(1239);
        const h = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let p = (h(n = class {
            get asModel() {
                return this.team
            }
            get database() {
                return this.team.database
            }
            constructor(e) {
                this.team = e
            }
            async createProject(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared();
                const {
                    name: s,
                    description: n,
                    color: a,
                    isOpen: o,
                    isTemplate: i = !1,
                    members: c = []
                } = e;
                i ? invariant(await t.canCreateProjectTemplate(), "Project template limit has been reached") : invariant(await t._canCreateProjects(o), "Projects limit has been reached"), t.isPersonal && invariant(!o, "Setting project as open for everyone isn't allowed in Personal Team"), t.isPersonal && invariant(!c.length, "Adding members to private project isn't allowed"), o && invariant(!c.length, "Open project can't have invited members");
                const u = await r.takeFirst(t.currentMember),
                    m = (0, d.zP)(await t.followedNotFavoriteProjects.fetch(), t),
                    h = t.collections.get(l.w.projects).prepareCreate((e => {
                        e.team.id = t.id, e._name = s, e.author.set(u), e.teamColor = a, e.description = n, e.permissions.isOpen = o, e.lastEventAt = e.createdAt, e.lastSeenEventAt = e.createdAt, e.sidebarPosition = m, e.isTemplate = i
                    })),
                    p = o || c.includes(u) ? [] : [h.permissions.do._prepareGrantAccess(u, !0)],
                    g = [h, h.do._prepareEvent("created", u, {
                        when: h.createdAt
                    }), ...p, ...o ? [] : c.map((e => h.permissions.do._prepareGrantAccess(e, !1)))];
                return await t.batch(...g), h
            }
            async createMemberGroup(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared();
                const s = await r.takeFirst(t.currentMember),
                    n = await r.takeFirst(s.hasAdminPowers);
                invariant(n, "Only admins can create member groups");
                const {
                    name: a,
                    members: o = []
                } = e, i = t.collections.get(l.w.memberGroups).prepareCreate((e => {
                    e.team.set(t), e.name = a
                }));
                return await t.batch(i), o.length && await t.callWriter((async () => i.do.updateMembers({
                    added: o,
                    removed: []
                }))), i
            }
            async createProjectGroup(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared();
                const {
                    name: s,
                    isPrivate: n,
                    projects: a = []
                } = e, o = await r.takeFirst(t.currentMember), i = await r.takeFirst(o.hasAdminPowers);
                invariant(i || n, "Only admins can create open project groups");
                const c = t.collections.get(l.w.projectGroups).prepareCreate((e => {
                    e.team.set(t), e.name = s, e.isPrivate = n
                }));
                return await t.batch(c), a.length && await t.callWriter((() => c.do.updateProjects({
                    added: a,
                    removed: []
                }))), c
            }
            async createSharedTag(e) {
                const {
                    team: t
                } = this;
                invariant(await t.canCreateSharedTag(), "Shared tags limit has been reached");
                const {
                    name: s,
                    color: n,
                    icon: a
                } = e, o = await this.database.collections.get(l.w.tags).create((e => {
                    e.team.set(t), e.name = s, e.teamColor = n, e.icon = a
                }));
                return await o.callWriter((() => o.openOnSidebar(t))), o
            }
            async findOrCreateThread(e) {
                const t = await (async () => e.member ? this.team.findThreadForMember(e.member) : e.team ? this.team.findThreadForTeam(e.team) : e.group ? this.team.findThreadForGroup(e.group) : null)();
                if (t) return t;
                const s = await r.takeFirst(this.team.currentMember),
                    n = this.database.collections.get(l.w.tasks).prepareCreate((e => {
                        e.type = "thread", e.author.set(s), e.lastActivityAt = e.createdAt, e.lastSeenActivityAt = e.createdAt, e.isFollowed = !0
                    }));
                return n.batch(n, n.do._prepareAccess(e, s), n.do._prepareAccess({
                    member: s
                }, s)), n
            }
            async inviteMember({
                email: e,
                description: t
            }) {
                const {
                    team: s
                } = this;
                invariant(!s.isShared && !s.isPersonal && await r.takeFirst(s.currentMember.pipe(r.switchMap((e => e.hasAdminPowers)))), "You can't manage this team"), invariant(await s.canInviteMembers(1), "Team members limit reached");
                const n = this.database.collections.get(l.w.users).prepareCreate((t => {
                        t.name = e, t.invitationEmail = e, t.color = (0, m.m)(), t.isPlaceholder = !0
                    })),
                    a = this._prepareMemberForUser(n, {
                        description: null != t ? t : ""
                    });
                return await s.batch(n, a), await a.callWriter((() => a.openOnSidebar())), a
            }
            async addMembersFromBusiness(e) {
                const {
                    team: t
                } = this;
                invariant(await t.canInviteBusinessMembers(), "Only business and team admins can add business members to a team");
                const s = await t.business.fetch();
                invariant(s, "Cannot add business members to a team that is not a part of a business"), invariant(e.every((e => e.business.id === s.id)), "All members added to a team must belong to the same business");
                const n = await Promise.all(e.flatMap((async e => {
                    const s = await e.user.fetch();
                    if ((await s.teamMemberships.fetch()).some((e => e.team.id === t.id))) return [];
                    if (!s.isPlaceholder) return [this._prepareMemberForUser(s)];
                    const n = this.database.collections.get(l.w.users).prepareCreate((e => {
                        e.name = s.name, e.invitationEmail = s.invitationEmail, e.color = s.color, e.isPlaceholder = !0
                    }));
                    return [n, this._prepareMemberForUser(n)]
                })));
                await this.database.batch(...n)
            }
            async getTopPriorityPosition() {
                const {
                    team: e
                } = this;
                e._ensureNotShared();
                const t = await r.takeFirst(e.activePriorityTasks.pipe(r.switchMap((e => e.observe()))));
                return (0, u.Gn)(t)
            }
            async getBottomPriorityPosition() {
                const {
                    team: e
                } = this;
                e._ensureNotShared();
                const t = await r.takeFirst(e.activePriorityTasks.pipe(r.switchMap((e => e.observe()))));
                return (0, u.$S)(t)
            }
            async getPriorityPositionForForm(e, t) {
                const {
                    team: s
                } = this;
                return s._ensureNotShared(), (0, i.getNewPositionForForm)({
                    position: e,
                    list: t,
                    getTopPosition: () => this.getTopPriorityPosition(),
                    getBottomPosition: () => this.getBottomPriorityPosition(),
                    selector: e => e.priorityPosition,
                    updater: (e, t) => {
                        e.priorityPosition = t
                    }
                })
            }
            async markTasksAsReviewed(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared(), await t.batch(...e.map((e => e.prepareUpdate((() => {
                    e.do._markAsReviewed()
                })))))
            }
            async markTasksAsNotReviewed(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared(), await t.batch(...e.map((e => e.prepareUpdate((() => {
                    e.do.restoreReview()
                })))))
            }
            async clearTasksPreviousReviews(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared(), e.forEach((e => {
                    e.do.clearPreviousReview()
                }))
            }
            async markTasksAsPriority(e) {
                const {
                    team: t
                } = this;
                if (t._ensureNotShared(), 0 === e.length) return;
                const s = await this.getTopPriorityPosition() - e.length - 1;
                await t.batch(...e.map(((e, t) => e.prepareUpdate((() => {
                    e.priorityPosition = s + t, e.isFollowed = !0
                })))))
            }
            async updateSidebarPosition(e) {
                const {
                    team: t
                } = this;
                t._ensureNotShared(), t.sidebarPosition !== e && await t.update((() => {
                    t.sidebarPosition = e
                }))
            }
            async rename(e) {
                const {
                    team: t
                } = this;
                invariant(await t.canBeRenamed(), "Can't rename team"), await t.update((() => {
                    t.name = e
                }))
            }
            async updateProjectAccessesForMember(e, {
                added: t,
                removed: s
            }) {
                const {
                    team: n
                } = this, a = await r.takeFirst(n.currentMember);
                async function o(t, s) {
                    await c.allPromises((async s => (invariant(!s.permissions.isOpen, "Expected closed project when updating project accesses for member " + e.id), invariant(s.team.id === n.id || s.sharedTeam.id === n.id, "Accesses can be updated only for projects belonging to the current team"), invariant(s.team.id === e.team.id || s.sharedTeam.id === e.team.id, "Accesses can be updated only for members belonging to the current team"), n.callWriter((() => s.permissions.do.updateAccess(Object.assign({
                        isOpen: !1,
                        newMembers: [],
                        changedMembers: [],
                        removedMembers: []
                    }, t)))))), s)
                }
                invariant(a !== e, "Can't update project accesses in bulk for current member"), await o({
                    newMembers: [{
                        member: e,
                        isNew: !0,
                        isManager: !1,
                        isInitialManager: !1
                    }]
                }, t), await o({
                    removedMembers: [{
                        member: e,
                        isNew: !1,
                        isManager: !1,
                        isInitialManager: !1
                    }]
                }, s)
            }
            _prepareMemberForUser(e, t) {
                return this.database.collections.get(l.w.teamMembers).prepareCreate((s => {
                    s.team.set(this.team), s.user.set(e), s.status = e.isPlaceholder ? "pending" : "active", s.role = (null == t ? void 0 : t.role) || "member", s.description = (null == t ? void 0 : t.description) || null
                }))
            }
        }, "createProject", [o.writer]), h(n, "createMemberGroup", [o.writer]), h(n, "createProjectGroup", [o.writer]), h(n, "createSharedTag", [o.writer]), h(n, "findOrCreateThread", [o.writer]), h(n, "inviteMember", [o.writer]), h(n, "addMembersFromBusiness", [o.writer]), h(n, "markTasksAsReviewed", [o.writer]), h(n, "markTasksAsNotReviewed", [o.writer]), h(n, "clearTasksPreviousReviews", [o.writer]), h(n, "markTasksAsPriority", [o.writer]), h(n, "updateSidebarPosition", [o.writer]), h(n, "rename", [o.writer]), h(n, "updateProjectAccessesForMember", [o.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => u
        });
        var n, a = s(24),
            o = s(19),
            r = s(4),
            i = (s(5), s(8), s(33)),
            c = s(16),
            l = s(29);
        const d = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let u = (d(n = class {
            get asModel() {
                return this.member
            }
            get database() {
                return this.member.database
            }
            constructor(e) {
                this.member = e
            }
            async renameAlias(e) {
                const {
                    member: t
                } = this;
                invariant(await t.canHaveAliasRenamed(), "Can't rename alias"), await t.update((() => {
                    t.alias = e || null
                }))
            }
            async updateDescription(e) {
                const {
                    member: t
                } = this;
                invariant(await t.canHaveDescriptionUpdated(), "Can't update description"), await t.update((() => {
                    t.description = e || null
                }))
            }
            async promoteToAdmin() {
                const {
                    member: e
                } = this;
                invariant(await e.canBePromotedToAdmin(), "Can't promote to admin"), invariant(await e.canBePromotedToAdminDueToLimits(), "Admins limit reached"), await e.update((() => {
                    e.role = "admin"
                }))
            }
            async demoteAdmin() {
                const {
                    member: e
                } = this;
                invariant(await e.canBeDemotedAdmin(), "Can't demote admin"), await e.update((() => {
                    e.role = "member"
                }))
            }
            async archive() {
                const {
                    member: e
                } = this;
                invariant(await e.canBeArchived(), "Can't archive member"), await e.update((() => {
                    e.status = "archived"
                })), await e.projectAccesses.markAllAsDeleted(), await (0, l.yN)(e.activeTasksResponsibleFor)
            }
            async acceptJoinRequest() {
                const {
                    member: e
                } = this;
                invariant(await e.canBeAccepted(), "Can't accept member"), await e.update((() => {
                    e.status = "active"
                }))
            }
            async updateGroups({
                added: e,
                removed: t
            }) {
                const {
                    member: s
                } = this, n = await s.groupAssignments.extend(o.Q.where(c.o.groupAssignments.groupId, o.Q.oneOf(r.pluckIds(t)))).fetch();
                await s.batch(...r.map((e => s.collections.get(c.w.groupAssignments).prepareCreate((t => {
                    t._memberGroup.set(e), t._teamMember.set(s), t.groupType = "member"
                }))), e), ...r.map((e => e.prepareMarkAsDeleted()), n))
            }
            async resendInvitation() {
                const {
                    member: e
                } = this;
                invariant(e.isExpired, "Can't resend invitation if not expired"), await e.update((() => {
                    e.status = "pending"
                }))
            }
        }, "renameAlias", [i.writer]), d(n, "updateDescription", [i.writer]), d(n, "promoteToAdmin", [i.writer]), d(n, "demoteAdmin", [i.writer]), d(n, "archive", [i.writer]), d(n, "acceptJoinRequest", [i.writer]), d(n, "updateGroups", [i.writer]), d(n, "resendInvitation", [i.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => m
        });
        var n, a = s(24),
            o = (s(5), s(19)),
            r = s(33),
            i = s(4),
            c = s(8),
            l = s(16),
            d = s(65);
        const u = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let m = (u(n = class {
            get asModel() {
                return this.user
            }
            get database() {
                return this.user.database
            }
            constructor(e) {
                this.user = e
            }
            async rename(e) {
                const {
                    user: t
                } = this;
                invariant(await t.canBeRenamed(), "Can't rename user"), await t.update((() => {
                    t.name = e
                }))
            }
            async updateTimeZone(e) {
                const {
                    user: t
                } = this;
                invariant(t.isMe, "Can't update time zone of a different user"), e !== t.timeZone && await t.update((() => {
                    t.timeZone = e
                }))
            }
            observeTranferableProjects() {
                const {
                    user: e
                } = this;
                return invariant(e.isMe, "Cannot access transferable projects of another user"), e.teamMemberships.observe().pipe(c.map(i.pipe(i.filter((e => !e.isOwner)), i.pluckIds)), c.switchMap((t => t.length ? e.collections.get(l.w.projects).query(o.Q.where(l.o.projects.isSingleTasks, !1), o.Q.on(l.w.projectAccesses, l.o.projectAccesses.memberId, o.Q.oneOf(t))).extend(d.Y3).observe() : c.of([]))), c.switchMap((e => {
                    const t = i.pipe(i.zip(e), i.filter((([, e]) => e)), i.map((([e]) => e)));
                    return c.combineLatest(i.map((e => e.permissions.isPrivate), e)).pipe(c.map(t))
                })), c.switchMap((e => c.from(i.filterAsync((e => e.permissions.canBeManaged()), e)))))
            }
        }, "rename", [r.writer]), u(n, "updateTimeZone", [r.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n, a = s(24),
            o = (s(5), s(4)),
            r = s(33),
            i = s(19),
            c = s(16);
        const l = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let d = (l(n = class {
            get asModel() {
                return this.group
            }
            get database() {
                return this.group.database
            }
            constructor(e) {
                this.group = e
            }
            async updateMembers({
                added: e,
                removed: t
            }) {
                const {
                    group: s
                } = this, n = await o.filterAsync((e => e.isSharedTeamMember), [...e, ...t]);
                invariant(!n.length, "Shared members cannot be part of the group");
                const a = await s.assignments.extend(i.Q.where(c.o.groupAssignments.objectId, i.Q.oneOf(o.pluckIds(t)))).fetch();
                await s.batch(...e.map((e => s.collections.get(c.w.groupAssignments).prepareCreate((t => {
                    t._memberGroup.set(s), t._teamMember.set(e), t.groupType = "member"
                })))), ...a.map((e => e.prepareMarkAsDeleted())))
            }
            async rename(e) {
                const {
                    group: t
                } = this;
                await t.update((() => {
                    t.name = e
                }))
            }
            async delete() {
                const {
                    group: e
                } = this, t = await e.assignments.fetch();
                await e.batch(e.prepareMarkAsDeleted(), ...t.map((e => e.prepareMarkAsDeleted())))
            }
        }, "updateMembers", [r.writer]), l(n, "rename", [r.writer]), l(n, "delete", [r.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n, a = s(24),
            o = (s(5), s(4)),
            r = s(19),
            i = s(33),
            c = s(16);
        const l = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let d = (l(n = class {
            get asModel() {
                return this.group
            }
            get database() {
                return this.group.database
            }
            constructor(e) {
                this.group = e
            }
            async updateProjects({
                added: e,
                removed: t
            }) {
                const {
                    group: s
                } = this, n = await s.assignments.extend(r.Q.where(c.o.groupAssignments.objectId, r.Q.oneOf(o.pluckIds(t)))).fetch();
                await s.batch(...e.map((e => s.collections.get(c.w.groupAssignments).prepareCreate((t => {
                    t._projectGroup.set(s), t._project.set(e), t.groupType = "project"
                })))), ...n.map((e => e.prepareMarkAsDeleted())))
            }
            async rename(e) {
                const {
                    group: t
                } = this;
                await t.update((() => {
                    t.name = e
                }))
            }
            async updateSidebarPosition(e) {
                const {
                    group: t
                } = this;
                await t.update((() => {
                    t.sidebarPosition = e
                }))
            }
            async openOnSidebar() {
                const {
                    group: e
                } = this, t = await e.team.fetch(), s = await t.projectGroupsOnSidebar.fetch(), n = o.getLastPosition(s, (e => e.sidebarPosition));
                await e.update((() => {
                    e.sidebarPosition = n
                }))
            }
            async toggleOnSidebar() {
                const {
                    group: e
                } = this;
                await e.callWriter((() => null !== e.sidebarPosition ? this.updateSidebarPosition(null) : this.openOnSidebar()))
            }
            async delete() {
                const {
                    group: e
                } = this, t = await e.assignments.fetch();
                await e.batch(e.prepareMarkAsDeleted(), ...t.map((e => e.prepareMarkAsDeleted())))
            }
        }, "updateProjects", [i.writer]), l(n, "rename", [i.writer]), l(n, "updateSidebarPosition", [i.writer]), l(n, "openOnSidebar", [i.writer]), l(n, "toggleOnSidebar", [i.writer]), l(n, "delete", [i.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        s(17);
        var n = s(16);
        async function a(e) {
            var t;
            const {
                team: s
            } = e;
            invariant(s.isShared, "Only a shared team may be used for matching the current team");
            const a = await async function(e) {
                const {
                    team: t,
                    projectId: s,
                    taskId: a
                } = e, {
                    collections: o
                } = t;
                if (!s) {
                    invariant(a, "Task ID must be used to match the team if no project is given");
                    return (await o.get(n.w.tasks).find(a)).fetchCurrentProject()
                }
                return o.get(n.w.projects).find(s)
            }(e);
            return invariant(a.isShared, "The given project is not shared, so it cannot be used to match the current team"), invariant(a.team.id === s.id || (null == (t = a.sharedTeam) ? void 0 : t.id) === s.id, "The given team does not participate in the project in any way"), a.getCurrentTeam()
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(9),
            a = (s(54), s(17), s(36), s(5)),
            o = (s(4), s(23)),
            r = (s(8), s(154)),
            i = s(61),
            c = s(173);
        s(2), s(3);
        const l = s(481);
        var d = s(1);
        const u = o.lazy((() => s(1254)));
        class m extends n.Component {
            constructor(...e) {
                super(...e), this.state = {
                    hasError: !1,
                    error: null
                }, this.reloadApp = () => {
                    globalThis.location.reload()
                }, this.resetError = () => {
                    this.setState({
                        hasError: !1
                    }), this.props.onReset()
                }, this.confirmRelog = async () => {
                    const {
                        intl: e
                    } = this.props;
                    await (0, o.devConfirm)(e.f.cV) && await this.props.services.app.forceRelogin()
                }
            }
            componentDidCatch(e, t) {
                const {
                    render: s,
                    intl: n,
                    name: r,
                    onReset: i
                } = this.props;
                this.setState({
                    hasError: !0,
                    error: e
                }), a.PROD_CONSOLE("name ought to be safe").error("Something crashed in: " + r, {
                    error: e,
                    info: t
                }), (0, c.zt)(e, t), "alert" === s && o.devAlert(n.g("kL", {
                    name: r
                })).then((() => {
                    this.reloadApp()
                })), "screen" !== s && i()
            }
            render() {
                const {
                    name: e,
                    render: t,
                    children: s
                } = this.props;
                return this.state.hasError ? "screen" === t ? (0, d.jsx)(u, {
                    name: e,
                    error: this.state.error,
                    reset: this.resetError,
                    reload: this.reloadApp,
                    relog: this.confirmRelog
                }) : "short" === t ? (0, d.jsx)("span", {
                    className: l.text,
                    children: (0, d.jsx)(i.Z, {
                        id: "kQ",
                        values: {
                            name: e
                        }
                    })
                }) : "function" == typeof t ? t() : null : s
            }
        }
        const h = (0, r.compose)(r.withIntl, r.withServices, r.withIdentity)(m)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n = s(0),
            a = s(12),
            o = s(40),
            r = s(482),
            i = s(68);
        s(2), s(3);
        const c = s(507);
        var l, d = s(1);
        const u = [{
                iconName: "Ĥ",
                color: "incoming",
                size: 270
            }, {
                iconName: "ĥ",
                color: "incoming",
                opacity: .6,
                size: 270
            }, {
                iconName: "Ħ",
                color: "incoming",
                opacity: .3,
                size: 270
            }],
            m = n.Hocs.compose()((e => {
                const {
                    name: t,
                    error: s,
                    reset: m,
                    reload: h,
                    relog: p
                } = e, g = n.Hooks.useIntl(), f = n.Hooks.useContactSupport();
                return (0, d.jsxs)("div", {
                    className: c.root,
                    children: [(0, d.jsx)(r.Z, {
                        title: g.f.kR
                    }), (0, d.jsx)(i.Z, {
                        contentContainerStyle: {
                            height: "100%",
                            minHeight: "100%",
                            alignItems: "center"
                        },
                        reachesTopOfScreen: !1,
                        topBarInset: 0,
                        isAbsoluteFilled: !1,
                        children: (0, d.jsxs)("div", {
                            className: c.content,
                            children: [l || (l = (0, d.jsx)(o.default, {
                                layers: u
                            })), (0, d.jsx)("span", {
                                className: c.header,
                                children: g.f.kO
                            }), (0, d.jsx)("span", {
                                className: c.text,
                                children: g.f.kM
                            }), (0, d.jsx)("span", {
                                className: c.text,
                                children: g.f.kN
                            }), (0, d.jsxs)("div", {
                                className: c.buttonContainer,
                                children: [(0, d.jsx)(a.default, {
                                    onPress: () => {
                                        f({
                                            subject: g.f.kO,
                                            body: g.f.CD,
                                            withDiagnostics: !0,
                                            extraDiagnosticText: "Crash in " + t + ". Error: " + ((null == s ? void 0 : s.name) || "Unknown Error") + ", " + ((null == s ? void 0 : s.message) || "?") + "\n\nStack trace: " + (s ? s.stack.slice(0, 512) : "Unknown")
                                        })
                                    },
                                    label: g.f.dO,
                                    iconName: "Ã",
                                    marginTop: "big",
                                    color: "darkgreen"
                                }), (0, d.jsx)(a.default, {
                                    onPress: m,
                                    label: g.f.fd,
                                    iconName: "ż",
                                    marginTop: "huge",
                                    color: "orange"
                                }), (0, d.jsx)(a.default, {
                                    onPress: h,
                                    label: g.f.kP,
                                    iconName: "ż",
                                    marginTop: "medium",
                                    color: "red"
                                }), (0, d.jsx)(a.default, {
                                    onPress: p,
                                    label: g.f.kS,
                                    iconName: "ł",
                                    marginTop: "medium",
                                    color: "blue"
                                })]
                            })]
                        })
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => X
        });
        var n = s(0),
            a = s(1256),
            o = s(866),
            r = s(867),
            i = s(492),
            c = s(70);
        s(2), s(3);
        const l = s(496);
        var d = s(1);
        const u = n.Hocs.compose()((e => {
            const {
                state: t
            } = e;
            return (0, c.MF)(t) ? (0, d.jsx)("div", {
                className: l.root,
                children: (0, d.jsx)(i.default, {
                    className: l.bar,
                    filterState: t
                })
            }) : null
        }));
        var m = s(6),
            h = s(18),
            p = s(71);

        function g(e) {
            const t = n.Styling.factoryColor(e);
            return {
                colorActive: n.Styling.rgba(t, .1),
                colorCompleted: t
            }
        }

        function f(e) {
            return 100 * n.FP.clamp(e, 0, 1)
        }

        function b(e, t) {
            if (0 === e) return "0%";
            return 1 <= Math.round(e) ? (t ? "+" : "") + e.toFixed() + "%" : "< 1%"
        }
        const y = s(497),
            v = {
                small: 8,
                regular: 16
            },
            w = {
                small: 4,
                regular: 6
            },
            k = n.Hocs.compose()((e => {
                const {
                    colorPrimary: t,
                    colorSecondary: s,
                    size: a = "regular",
                    showMarker: o,
                    barPercentagesLength: r,
                    formatProgress: i = b,
                    __forwardedRef: c
                } = e, l = f(e.progress), u = null != r ? r : l, m = u ? Math.max(u, 1) + "%" : 0, p = v[a], g = w[a], k = o ? 37 : 0, x = s ? n.Styling.rgba(n.Styling.factoryColor("backgroundPrimary"), .2) : "transparent";
                return (0, d.jsx)("div", {
                    className: y.root + " " + (e.className || ""),
                    style: Object.assign({
                        paddingTop: k
                    }, e.style),
                    ref: c,
                    children: (0, d.jsxs)("div", {
                        className: y.outerBar,
                        style: {
                            height: p,
                            backgroundColor: s,
                            borderRadius: g,
                            borderColor: x
                        },
                        children: [(0, d.jsx)("div", {
                            className: y.innerBar,
                            style: Object.assign({
                                width: m,
                                backgroundColor: t,
                                borderRadius: g - 1
                            }, o ? {
                                borderTopRightRadius: 0,
                                borderBottomRightRadius: 0
                            } : {})
                        }), o ? (0, d.jsx)("div", {
                            className: y.progressMarker,
                            children: (0, d.jsx)("div", {
                                className: y.progressLabel,
                                children: (0, d.jsx)(h.default, {
                                    className: y.progressText,
                                    children: i(l)
                                })
                            })
                        }) : null]
                    })
                })
            })),
            x = n.React.forwardRef(((e, t) => (0, d.jsx)(k, Object.assign({}, e, {
                __forwardedRef: t
            })))),
            j = s(498),
            T = n.Hocs.compose()((e => {
                const {
                    data: t,
                    color: s,
                    formatLabel: a = (e => String(e)),
                    formatProgress: o
                } = e, r = n.Hooks.useIntl(), {
                    colorActive: i,
                    colorCompleted: c
                } = g(s);
                return (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsx)(m.u_.Heading, {
                        className: j.heading,
                        children: r.f.Fd
                    }), (0, d.jsxs)(m.u_.Section, {
                        children: [(0, d.jsx)(x, {
                            progress: t.progress,
                            colorPrimary: c,
                            colorSecondary: i,
                            showMarker: !0,
                            formatProgress: o
                        }), (0, d.jsxs)("div", {
                            className: j.legend,
                            children: [(0, d.jsxs)("div", {
                                className: j.legendItem,
                                children: [(0, d.jsx)(p.default, {
                                    renderLabel: r.f.E5,
                                    children: (0, d.jsxs)("div", {
                                        className: j.legendLabel,
                                        children: [(0, d.jsx)("div", {
                                            className: j.legendDot,
                                            style: {
                                                backgroundColor: c
                                            }
                                        }), (0, d.jsx)(h.default, {
                                            className: j.legendLabelText,
                                            children: r.f.E4
                                        })]
                                    })
                                }), (0, d.jsx)(h.default, {
                                    className: j.legendValue,
                                    children: a(t.completed)
                                })]
                            }), (0, d.jsxs)("div", {
                                className: j.legendItem,
                                children: [(0, d.jsxs)("div", {
                                    className: j.legendLabel,
                                    children: [(0, d.jsx)("div", {
                                        className: j.legendDot,
                                        style: {
                                            backgroundColor: i
                                        }
                                    }), (0, d.jsx)(h.default, {
                                        className: j.legendLabelText,
                                        children: r.f.E3
                                    })]
                                }), (0, d.jsx)(h.default, {
                                    className: j.legendValue,
                                    children: a(t.active)
                                })]
                            })]
                        })]
                    })]
                })
            }));
        var S = s(273),
            P = s(880),
            _ = s(206),
            C = s(21);
        const R = s(499),
            A = {
                year: "numeric",
                month: "short",
                day: "numeric"
            },
            I = e => {
                const {
                    period: t,
                    type: s,
                    firstWeekday: a
                } = e, o = n.Hooks.useIntl();
                switch (s) {
                    case "daily":
                        return (0, d.jsx)("span", {
                            className: R.text + " " + R.secondaryText,
                            children: o.formatDate(t, A)
                        });
                    case "weekly": {
                        const e = (0, S.Z)(t, (0, C.weekStartsOn)(a)),
                            s = o.formatDate(e, A),
                            n = o.formatDate(t, A);
                        return (0, d.jsxs)(d.Fragment, {
                            children: [(0, d.jsxs)("span", {
                                className: R.text + " " + R.secondaryText,
                                children: [s, " -"]
                            }), (0, d.jsxs)("span", {
                                className: R.text + " " + R.secondaryText,
                                children: [n, " "]
                            })]
                        })
                    }
                    case "monthly":
                        return (0, d.jsx)("span", {
                            className: R.text + " " + R.secondaryText,
                            children: o.formatDate(t, Object.assign({}, A, {
                                day: void 0
                            }))
                        });
                    default:
                        return ""
                }
            },
            N = e => {
                const {
                    periodType: t,
                    entry: [s, {
                        active: a,
                        completed: o
                    }],
                    firstWeekday: r,
                    rootRef: i,
                    colorActive: c,
                    colorCompleted: l,
                    activeLabel: u,
                    completedLabel: m,
                    activeValueLabel: h,
                    completedValueLabel: g,
                    progressLabel: f,
                    activeBarLength: b,
                    completedBarLength: y
                } = e, {
                    isInViewport: v,
                    targetRef: w
                } = n.Hooks.useShownInViewport({
                    root: i.current
                });
                return (0, d.jsx)("div", {
                    className: R.entry,
                    ref: w,
                    children: v ? (0, d.jsxs)(d.Fragment, {
                        children: [(0, d.jsx)("div", {
                            className: R.period,
                            children: (0, d.jsx)(I, {
                                period: s,
                                type: t,
                                firstWeekday: r
                            })
                        }), (0, d.jsxs)("div", {
                            className: R.column + " " + R.labels,
                            children: [(0, d.jsx)("div", {
                                className: R.row + " " + R.label,
                                children: (0, d.jsx)(p.default, {
                                    renderLabel: m,
                                    children: (0, d.jsx)("span", {
                                        className: R.text + " " + R.labelText,
                                        children: g
                                    })
                                })
                            }), (0, d.jsx)("div", {
                                className: R.row + " " + R.label,
                                children: (0, d.jsx)(p.default, {
                                    renderLabel: u,
                                    children: (0, d.jsx)("span", {
                                        className: R.text + " " + R.labelText,
                                        children: h
                                    })
                                })
                            })]
                        }), (0, d.jsxs)("div", {
                            className: R.column + " " + R.progressBars,
                            children: [(0, d.jsx)("div", {
                                className: R.row,
                                children: (0, d.jsx)(p.default, {
                                    renderLabel: m,
                                    children: (0, d.jsx)(x, {
                                        progress: o.progress,
                                        colorPrimary: l,
                                        size: "small",
                                        barPercentagesLength: y
                                    })
                                })
                            }), (0, d.jsx)("div", {
                                className: R.row,
                                children: (0, d.jsx)(p.default, {
                                    renderLabel: u,
                                    children: (0, d.jsx)(x, {
                                        progress: a.progress,
                                        colorPrimary: c,
                                        size: "small",
                                        barPercentagesLength: b
                                    })
                                })
                            })]
                        }), (0, d.jsx)("div", {
                            className: R.progress,
                            children: (0, d.jsx)(p.default, {
                                renderLabel: m,
                                children: (0, d.jsx)("span", {
                                    className: R.text + " " + R.secondaryText,
                                    children: f
                                })
                            })
                        })]
                    }) : null
                }, s)
            },
            E = n.Hocs.compose()((e => {
                const {
                    data: t,
                    color: s,
                    firstWeekday: a,
                    formatActiveLabel: o,
                    formatCompletedLabel: r,
                    formatValueLabel: i = (e => String(e)),
                    formatProgressLabel: c = (e => b(e, !0))
                } = e, l = n.Hooks.useIntl(), [u, h] = n.React.useState("daily"), p = t.pace[u], y = t.overall.active + t.overall.completed, v = n.React.useRef(), {
                    colorActive: w,
                    colorCompleted: k
                } = g(s), x = n.React.useMemo((() => [{
                    root: null,
                    items: p
                }]), [p]), j = n.React.useMemo((() => p.reduce(((e, [, t]) => Math.max(e, t.active.value, t.completed.value)), 0)), [p]), T = (e, t) => 0 < t ? f(e / t) : void 0;
                return (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsx)(m.u_.Heading, {
                        children: l.f.E6
                    }), (0, d.jsx)(m.u_.Switch, {
                        options: [{
                            id: "daily",
                            label: l.f.E7
                        }, {
                            id: "weekly",
                            label: l.f.Fc
                        }, {
                            id: "monthly",
                            label: l.f.Fa
                        }],
                        selectedOptionId: u,
                        selectOption: (e, t) => h(t),
                        buttonStyle: "small",
                        activeColor: s
                    }), p.length ? (0, d.jsx)(m.u_.Section, {
                        className: R.listSection,
                        ref: v,
                        children: (0, d.jsx)(_.Z, {
                            children: (0, d.jsx)(P.Z, {
                                groups: x,
                                rowRenderer: ({
                                    item: e
                                }) => {
                                    const [t, s] = e, {
                                        completed: n,
                                        active: l
                                    } = s, m = i(n.value), h = i(l.value), p = i(y), g = c(f(n.progress)), b = r(m, p, g), x = o(h), S = T(l.value, j), P = T(n.value, j);
                                    return (0, d.jsx)(N, {
                                        periodType: u,
                                        entry: e,
                                        firstWeekday: a,
                                        rootRef: v,
                                        colorActive: w,
                                        colorCompleted: k,
                                        activeLabel: x,
                                        completedLabel: b,
                                        activeValueLabel: h,
                                        completedValueLabel: m,
                                        progressLabel: g,
                                        activeBarLength: S,
                                        completedBarLength: P
                                    }, t)
                                },
                                getLayoutTypeForItem: e => e.type,
                                getLengthForType: () => 52,
                                topBarInset: 0,
                                estimatedAboveTheFoldItems: 10
                            }, u)
                        })
                    }) : (0, d.jsx)(m.u_.Paragraph, {
                        centered: !0,
                        children: l.f.Fb
                    })]
                })
            }));
        var O = s(41),
            M = s(144),
            D = s(282);
        class H {
            constructor() {
                this.active = 0, this.completed = 0
            }
            get sum() {
                return this.active + this.completed
            }
            get progress() {
                return 0 === this.sum ? 0 : this.completed / this.sum
            }
            add(e, t = 1) {
                e.isActive ? this.active += t : this.completed += t
            }
        }
        class F {
            constructor(e) {
                this.dailyRecords = new Map, this.weeklyRecords = new Map, this.monthlyRecords = new Map, this._firstWeekday = e
            }
            add({
                group: e,
                task: t,
                date: s,
                value: n = 1
            }) {
                this._findRecordsForDate(s).forEach((s => {
                    const a = s[e];
                    a.value += n, a.tasks.push(t)
                }))
            }
            _findRecordsForDate(e) {
                return [
                    [this.dailyRecords, "daily"],
                    [this.weeklyRecords, "weekly"],
                    [this.monthlyRecords, "monthly"]
                ].map((([t, s]) => {
                    const n = function(e, t, s) {
                        switch (t) {
                            case "daily":
                                return (0, O.Z)(e).getTime();
                            case "weekly":
                                return (0, M.Z)(e, (0, C.weekStartsOn)(s)).getTime();
                            case "monthly":
                                return (0, D.Z)(e).getTime();
                            default:
                                throw new Error('Unknown pace period "' + t + '"')
                        }
                    }(e, s, this._firstWeekday);
                    return function(e, t) {
                        const s = e.get(t);
                        if (s) return s;
                        const n = {
                            active: {
                                value: 0,
                                tasks: []
                            },
                            completed: {
                                value: 0,
                                tasks: []
                            }
                        };
                        return e.set(t, n), n
                    }(t, n)
                }))
            }
        }

        function Z(e, t) {
            return {
                overall: {
                    active: e.active,
                    completed: e.completed,
                    progress: e.progress
                },
                pace: {
                    daily: L(t.dailyRecords, e),
                    weekly: L(t.weeklyRecords, e),
                    monthly: L(t.monthlyRecords, e)
                }
            }
        }

        function L(e, t) {
            return [...e].map((([e, {
                active: s,
                completed: n
            }]) => [e, {
                active: Object.assign({}, s, {
                    progress: s.value / t.sum
                }),
                completed: Object.assign({}, n, {
                    progress: n.value / t.sum
                })
            }])).sort((([e], [t]) => t - e))
        }
        var B = s(35);

        function z(e) {
            return n.Rx.combineLatestObject({
                task: e.observe(),
                timeline: e.timeline.events.observe().pipe(n.Rx.map((e => (0, B.mO)(e).reverse())))
            })
        }

        function U({
            event: e,
            root: t,
            task: s,
            member: a
        }) {
            var o, r, i, c, l;
            return t instanceof n.Model.Models.Project ? t.isSingleTasks && s.isGranted ? "access" === e.type && (null == (o = e.change.access) ? void 0 : o.to) === a.id : "project" === e.type && (null == (r = e.change.project) ? void 0 : r.to) === t.id : t instanceof n.Model.Models.ProjectSection ? "section" === e.type && (null == (i = e.change.section) ? void 0 : i.to) === t.id : t instanceof n.Model.Models.TeamMember ? "responsible" === e.type && (null == (c = e.change.responsible) ? void 0 : c.to) === t.id : t instanceof n.Model.Models.Tag && ("tag" === e.type && !(null == (l = e.change.tag) || !l.added.includes(t.id)))
        }

        function W({
            root: e,
            tasks: t,
            firstWeekday: s,
            currentMember: a
        }) {
            return n.Rx.combineLatest(t.map((e => z(e)))).pipe(n.Rx.map((t => {
                const n = new H,
                    o = new F(s);
                return t.forEach((({
                    task: t,
                    timeline: s
                }) => {
                    var r, i;
                    n.add(t);
                    const c = null != (r = null == (i = s.find((s => U({
                        event: s,
                        root: e,
                        task: t,
                        member: a
                    })))) ? void 0 : i.createdAt) ? r : t.createdAt;
                    o.add({
                        group: "active",
                        task: t,
                        date: c
                    });
                    const {
                        endedAt: l
                    } = t;
                    l && o.add({
                        group: "completed",
                        task: t,
                        date: l
                    })
                })), Z(n, o)
            })))
        }
        const G = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["root", "tasks", "firstWeekday", "currentMember"], (({
            root: e,
            tasks: t,
            firstWeekday: s,
            currentMember: n
        }) => ({
            data: W({
                root: e,
                tasks: t,
                firstWeekday: s,
                currentMember: n
            })
        }))))((e => {
            const {
                data: t,
                color: s,
                filterState: a,
                firstWeekday: o
            } = e, r = n.Hooks.useIntl();
            return (0, d.jsxs)(d.Fragment, {
                children: [a ? (0, d.jsx)(u, {
                    state: a
                }) : null, (0, d.jsx)(T, {
                    color: s,
                    data: t.overall
                }), (0, d.jsx)(E, {
                    color: s,
                    data: t,
                    firstWeekday: o,
                    formatCompletedLabel: (e, t, s) => r.g("E2", {
                        value: e,
                        total: t,
                        progress: s
                    }),
                    formatActiveLabel: e => r.g("E1", {
                        value: e
                    })
                })]
            })
        }));

        function V({
            root: e,
            tasks: t,
            attribute: s,
            firstWeekday: a,
            currentMember: o
        }) {
            return n.Rx.combineLatest(t.map((e => z(e)))).pipe(n.Rx.map((t => {
                const n = new H,
                    r = new F(a);

                function i(e, t) {
                    const [s, a] = t;
                    0 !== s && (n.add(e, s), r.add({
                        group: e.isActive ? "active" : "completed",
                        task: e,
                        date: a,
                        value: s
                    }))
                }
                return t.forEach((({
                    task: t,
                    timeline: n
                }) => {
                    if ("timeNeeded" === s) {
                        const s = n.find((s => "time_needed" === s.type || U({
                            event: s,
                            root: e,
                            task: t,
                            member: o
                        })));
                        i(t, function(e, t) {
                            var s;
                            const n = null != (s = e._timeNeeded) ? s : 0,
                                a = (null == t ? void 0 : t.createdAt) || (e.isActive ? e.createdAt : e.endedAt);
                            return invariant(a, "Could not determine date for task's time needed pace"), [n, a]
                        }(t, s))
                    } else {
                        n.filter((e => "time_spent" === e.type)).forEach((e => {
                            i(t, function(e, t) {
                                var s, n;
                                const a = t.change.time_spent;
                                invariant(a, "Expected time spent event for generating task pace");
                                return [(null != (s = a.to) ? s : 0) - (null != (n = a.from) ? n : 0), t.createdAt]
                            }(0, e))
                        }))
                    }
                })), Z(n, r)
            })))
        }
        const q = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["root", "tasks", "attribute", "firstWeekday", "currentMember"], (({
                root: e,
                tasks: t,
                attribute: s,
                firstWeekday: n,
                currentMember: a
            }) => ({
                data: V({
                    root: e,
                    tasks: t,
                    attribute: s,
                    firstWeekday: n,
                    currentMember: a
                })
            }))))((e => {
                const {
                    data: t,
                    attribute: s,
                    color: a,
                    firstWeekday: o,
                    filterState: r
                } = e, i = n.Hooks.useIntl(), c = {
                    timeNeeded: {
                        active: e => i.g("E8", {
                            value: e
                        }),
                        completed: (e, t, s) => i.g("E9", {
                            value: e,
                            progress: s
                        })
                    },
                    timeSpent: {
                        active: e => i.g("E$", {
                            value: e
                        }),
                        completed: (e, t, s) => i.g("E_", {
                            value: e,
                            total: t,
                            progress: s
                        })
                    }
                }, l = e => (0, C.formatTimeAttribute)(e, i, {
                    format: "short"
                });
                return (0, d.jsxs)(d.Fragment, {
                    children: [r ? (0, d.jsx)(u, {
                        state: r
                    }) : null, (0, d.jsx)(T, {
                        color: a,
                        data: t.overall,
                        formatLabel: l
                    }), (0, d.jsx)(E, {
                        color: a,
                        data: t,
                        firstWeekday: o,
                        formatActiveLabel: c[s].active,
                        formatCompletedLabel: c[s].completed,
                        formatValueLabel: l
                    })]
                })
            })),
            Q = "avatarColor4",
            Y = "blue",
            J = "ocean",
            K = {
                contentStatic: !0,
                contentSize: "fullscreen"
            };

        function $(e, t, s) {
            return e instanceof n.Model.Models.Project ? e.observe().pipe(n.Rx.switchMap((async e => ({
                name: n.Styling.getProjectName(e, t),
                project: e,
                areTimeAttributesEnabled: e.areTimeAttributesEnabled,
                canEnableTimeAttributes: await e.canEnableTimeAttributes()
            })))) : e instanceof n.Model.Models.ProjectSection ? e.observe().pipe(n.Rx.switchMap((e => e.project.observe())), n.Rx.switchMap((async t => ({
                name: e.name,
                project: t,
                areTimeAttributesEnabled: t.areTimeAttributesEnabled,
                canEnableTimeAttributes: await t.canEnableTimeAttributes()
            })))) : e instanceof n.Model.Models.TeamMember ? e.observe().pipe(n.Rx.switchMap((e => n.Rx.combineLatestObject({
                name: e.preferredName,
                team: e.team.observe()
            }))), n.Rx.map((({
                name: e,
                team: t
            }) => ({
                name: e,
                project: void 0,
                areTimeAttributesEnabled: t.canEnableTimeAttributes,
                canEnableTimeAttributes: !1
            })))) : e instanceof n.Model.Models.Tag ? e.observe().pipe(n.Rx.switchMap((e => e.team.observe())), n.Rx.map((t => {
                var n;
                return {
                    name: e.name,
                    project: void 0,
                    areTimeAttributesEnabled: null != (n = null == t ? void 0 : t.canEnableTimeAttributes) ? n : s,
                    canEnableTimeAttributes: !1
                }
            }))) : n.Rx.of({
                name: e,
                project: void 0,
                areTimeAttributesEnabled: !1,
                canEnableTimeAttributes: !1
            })
        }
        const X = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIntl, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            firstWeekday: n.Rx.from(e.native.fetchFirstWeekday()),
            canAccessPremiumFeatures: e.modelRoot.activeTeams.pipe(n.Rx.map((e => e.some((e => !e.isFree || e.isTrial)))))
        }))), n.Hocs.withObservables(["root", "intl", "canAccessPremiumFeatures"], (({
            root: e,
            intl: t,
            canAccessPremiumFeatures: s
        }) => ({
            rootProps: $(e, t, s)
        }))), n.Hocs.withObservables(["rootProps"], (({
            rootProps: {
                project: e
            }
        }) => {
            var t;
            return {
                canUpsellTimeAttributes: null != (t = null == e ? void 0 : e.currentTeam.pipe(n.Rx.map((e => e.isFree)))) ? t : n.Rx.of(!1)
            }
        })))((e => {
            const {
                root: t,
                rootProps: {
                    name: s,
                    project: i,
                    areTimeAttributesEnabled: c,
                    canEnableTimeAttributes: l
                },
                tasks: u,
                filterState: m,
                onClose: h,
                firstWeekday: p,
                canUpsellTimeAttributes: g
            } = e, f = n.Hooks.useIntl(), b = c ? void 0 : "content", y = [{
                id: "general",
                list: (e, t) => (0, d.jsx)(r.Z, {
                    label: f.f.E0,
                    icon: "ƙ",
                    isActive: t,
                    activeColor: Q,
                    onPress: e
                }),
                pane: () => (0, d.jsx)(G, {
                    root: t,
                    tasks: u,
                    color: Q,
                    filterState: m,
                    firstWeekday: p
                }),
                containsScroll: !0
            }, ...c || l || g ? [{
                id: "timeNeeded",
                list: (e, t) => (0, d.jsx)(r.Z, {
                    label: f.f.uE,
                    icon: "Ƭ",
                    isActive: t,
                    activeColor: Y,
                    onPress: e
                }),
                pane: () => c ? (0, d.jsx)(q, {
                    root: t,
                    tasks: u,
                    attribute: "timeNeeded",
                    color: Y,
                    firstWeekday: p,
                    filterState: m
                }) : (invariant(i, "Expected project for enabling/upselling time attributes"), (0, d.jsx)(a.Z, {
                    project: i,
                    color: Y
                })),
                contentSize: b,
                containsScroll: !0
            }, {
                id: "timeSpent",
                list: (e, t) => (0, d.jsx)(r.Z, {
                    label: f.f.uF,
                    icon: "Ư",
                    isActive: t,
                    activeColor: J,
                    onPress: e
                }),
                pane: () => c ? (0, d.jsx)(q, {
                    root: t,
                    tasks: u,
                    attribute: "timeSpent",
                    color: J,
                    firstWeekday: p,
                    filterState: m
                }) : (invariant(i, "Expected project for enabling/upselling time attributes"), (0, d.jsx)(a.Z, {
                    project: i,
                    color: J
                })),
                contentSize: b,
                containsScroll: !0
            }] : []];
            return (0, d.jsx)(o.Z, {
                header: f.g("Fe", {
                    parent: s
                }),
                items: y,
                helpPageUrl: n.ReactUtils.helpUrl(f, "taskmanagement/projects/#projects_stats"),
                contentOptions: K,
                _skipPaneWrapper: !1,
                onClose: h
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(483),
            i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                project: t,
                color: s = "orange",
                onClose: c
            } = e, l = n.Hooks.useIntl(), d = n.Styling.getProjectName(t, l), u = (0, r.Z)(t);
            return (0, i.jsxs)(i.Fragment, {
                children: [(0, i.jsx)(a.u_.IconStack, {
                    stack: [{
                        iconName: "ƭ",
                        color: s,
                        size: 150
                    }]
                }), (0, i.jsx)(a.u_.Heading, {
                    children: l.f.uD
                }), (0, i.jsx)(a.u_.Paragraph, {
                    children: l.g("Jo", {
                        projectName: (0, i.jsx)(a.u_.Emphasis, {
                            children: d
                        }, "projectName")
                    })
                }), (0, i.jsxs)(a.u_.Buttons, {
                    direction: "column",
                    children: [(0, i.jsx)(o.default, {
                        label: l.f.fv,
                        variant: "opaque",
                        color: s,
                        onPress: async e => {
                            null == c || c(e), await u()
                        }
                    }), c ? (0, i.jsx)(o.default, {
                        label: l.f.fe,
                        onPress: c
                    }) : null]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            e: () => i
        });
        var n = s(0),
            a = s(18),
            o = s(353),
            r = s(1);
        const i = e => {
            const {
                isEnded: t,
                children: s,
                hoverText: i
            } = e, c = e.color ? n.Styling.factoryColor(e.color) : void 0;
            return (0, r.jsx)(a.default, {
                className: o.Z.text + (t ? " " + o.Z.textCrossed : ""),
                style: {
                    color: c
                },
                allowFontScaling: !1,
                hoverText: i,
                children: s
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(22),
            o = s(1);
        const r = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            isSidebarCollapsed: e.layout.isSidebarCollapsed,
            isSidebarFloating: e.layout.isSidebarFloating
        }))))((e => {
            const {
                color: t,
                isSidebarCollapsed: s,
                isSidebarFloating: r
            } = e, i = n.Hooks.useIntl(), c = n.Hooks.useServices();
            return (0, o.jsx)(a.default, {
                name: "Ə",
                color: t,
                iconSize: 24,
                hitSlop: {
                    left: 10,
                    top: 10,
                    right: 10,
                    bottom: 10
                },
                accessibilityLabel: s ? i.f.mO : i.f.mN,
                onPress: () => c.layout.toggleSidebar(!r)
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => h
        });
        var n = s(5),
            a = s(8),
            o = s(4),
            r = s(19),
            i = s(16),
            c = s(511);
        class l {
            constructor() {
                this.status = new a.BehaviorSubject({
                    state: "pending"
                })
            }
            get currentStatus() {
                return this.status.getValue()
            }
            async start(e, t, s) {
                invariant("pending" === this.currentStatus.state, "Upload already started"), await (0, c.Z)(e, {
                    method: "POST",
                    headers: t,
                    body: s,
                    onUploadProgress: e => {
                        this.status.next({
                            state: "uploading",
                            progress: e
                        })
                    }
                })
            }
            reset() {
                this.status.next({
                    state: "pending"
                })
            }
        }
        const d = i.o.attachmentVersions,
            u = e => (e.preventDefault(), e.returnValue = "", ""),
            m = e => e.id;
        class h {
            constructor({
                sync: e,
                database: t,
                getApi: s,
                getCurrentUser: n
            }) {
                this._queue = new a.Subject, this._queueSubscription = null, this._jobs = new Map, this._sync = e, this._database = t, this._getApi = s, this._getCurrentUser = n
            }
            getJob(e) {
                return this._jobs.get(e)
            }
            run() {
                this._queueSubscription || (this._queueSubscription = this._queue.pipe(a.concatAll()).subscribe(o.noop))
            }
            abort() {
                this._queueSubscription && (this._queueSubscription.unsubscribe(), this._queueSubscription = null)
            }
            async clearAbortedUploads() {
                if (!this._isAborted) return;
                const e = await this._getCurrentUser();
                if (!e) return;
                const t = await e.allTeamMemberships.fetch(),
                    s = o.pluckIds(t);
                if (!s.length) return;
                const a = await this._database.collections.get(i.w.attachmentVersions).query(r.Q.where(d.status, "uploading"), r.Q.where(d.integrationType, null), r.Q.where(d.authorId, r.Q.oneOf(s))).fetch();
                a.length && ((0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.NO_PRIVATE).log("[Uploader] Clearing aborted downloads (" + a.length + ")"), await this._database.write((async () => {
                    const e = a.map((e => e.prepareUpdate((e => {
                        e.status = "error"
                    }))));
                    await this._database.batch(...e)
                }), "clearAbortedDownloads"))
            }
            get _isAborted() {
                return null === this._queueSubscription
            }
            async _setStatus(e, t) {
                this._isAborted || await this._database.write((async () => {
                    await t.update((() => {
                        t.status = e
                    }))
                }))
            }
            async _uploadFileImpl(e, t = 1) {
                const s = this._jobs.get(e);
                invariant(s, "Missing UploadJob for " + m(e));
                try {
                    {
                        const {
                            url: t,
                            headers: n,
                            body: a
                        } = await this._getApi().attachments.attachmentUploadInfo([e]);
                        await s.start(t, n, a)
                    }(0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.SAFE_ID).log("[Uploader] Done uploading", m(e))
                } catch (a) {
                    2 > t ? ((0, n.PROD_CONSOLE)("Api/Native error").warn("[Uploader] Error while uploading file. Retrying...", m(e), a), s.reset(), await this._uploadFileImpl(e, t + 1)) : ((0, n.PROD_CONSOLE)("Api/Native error").error("[Uploader] Unable to upload files", a), await this._setStatus("error", e), (0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.SAFE_ID).log("[Uploader] Error", m(e)))
                }
            }
            async _uploadFile(e) {
                globalThis.addEventListener("beforeunload", u), (0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.SAFE_ID).log("[Uploader] Uploading", m(e));
                try {
                    await this._uploadFileImpl(e)
                } finally {
                    globalThis.removeEventListener("beforeunload", u)
                }
                this._syncUntilUploaded([e]), this._jobs.delete(e)
            }
            async _findNewAttachments(e) {
                const t = o.pluckIds([...this._jobs.keys()]);
                return this._database.get(i.w.attachmentVersions).query(r.Q.and(r.Q.where(d.authorId, e.id), r.Q.where(d.status, "uploading"), r.Q.where(i.o.id, r.Q.notIn(t)), r.Q.where(d.integrationType, null))).fetch()
            }
            _push(e) {
                invariant(!this._isAborted, "Attempted to push a new attachment to the queue but the uploader is not running");
                const t = a.defer((() => a.from(this._uploadFile(e).catch((t => {
                    const s = m(e);
                    n.logError(n.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "[Uploader] fatal error when uploading " + s + ": " + t)
                })))));
                this._queue.next(t)
            }
            async _performUpload(e) {
                const t = await this._findNewAttachments(e);
                (0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.SAFE_ID).log("[Uploader] New pending uploads:", t.map(m)), t.forEach((e => {
                    this._jobs.has(e) || this._jobs.set(e, new l)
                }));
                try {
                    await this._sync.synchronize()
                } catch (e) {
                    return void t.forEach((async e => {
                        await this._setStatus("error", e), this._jobs.delete(e)
                    }))
                }
                t.forEach((e => {
                    this._push(e)
                }))
            }
            async _syncUntilUploaded(e) {
                await o.delayedRetry([1e3, 3e3, 5e3, 1e4, 3e4], (async () => (await this._sync.synchronize(), e.every((e => "uploaded" === e.status))))) || (0, n.PROD_CONSOLE)(n.PROD_CONSOLE_REASON.SAFE_ID).warn("[Uploader] Did not succeed to get thumbnail for some attachments:", e.map(m))
            }
            performUpload(e) {
                this._performUpload(e)
            }
        }
    }, , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(5),
            a = (s(4), s(23), s(8), s(37)),
            o = s(14);
        class r {
            get sync() {
                return this.app.sync
            }
            get api() {
                return this.app.api
            }
            constructor(e) {
                this.app = e
            }
            _requestOAuthParameters({
                invitationId: e,
                isInviteCode: t
            }) {
                const {
                    locale: s
                } = this.app.localization.currentSettings;
                return {
                    api: this.api,
                    locale: s,
                    invitationId: e,
                    isInviteCode: t,
                    disableOnboarding: !0
                }
            }
            requestSignInWithApple(e) {
                return this.app.native.requestSignInWithApple(this._requestOAuthParameters(e))
            }
            requestGoogleSignIn(e) {
                return this.app.native.requestGoogleSignIn(this._requestOAuthParameters(e))
            }
            signInWithThirdParty({
                code: e,
                idToken: t,
                name: s,
                teamName: n,
                inviteCode: a,
                provider: o,
                marketingConsent: r
            }) {
                return this._logInSync({
                    authenticator: async () => this.api.account.authenticateWithThirdParty({
                        provider: o,
                        code: e,
                        idToken: t,
                        name: s,
                        teamName: n,
                        inviteCode: a,
                        marketingConsent: r
                    })
                })
            }
            basicSignIn({
                email: e,
                password: t,
                otp: s,
                serverUrl: n,
                userId: a,
                onBeforeFirstSync: o,
                apiToken: r
            }) {
                return this._logInSync({
                    authenticator: async () => (invariant(!n, "Attempted to change serverUrl in prod build"), a && invariant(!1, "Attempted to log in using a custom userId in prod build"), this.api.account.basicAuthenticate({
                        email: e,
                        password: t,
                        otp: s,
                        userId: a,
                        apiToken: r
                    })),
                    onBeforeFirstSync: o
                })
            }
            async signInAsGuest(e) {
                const {
                    authorization: t
                } = e;
                return await this.app.keychain.apiToken === t ? {
                    needsOTP: !1
                } : this._logInSync({
                    authenticator: async () => (this.app.keychain.apiToken = t, {
                        needsOTP: !1
                    })
                })
            }
            async _logInSync({
                authenticator: e,
                skipAppStateChange: t = !0,
                onBeforeFirstSync: s,
                skipRemovingCaches: o
            }) {
                try {
                    n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] Logging in with sync..."), invariant(!this.app.appState.isLoggedIn.getValue(), "Cannot log in when already logged in"), await this.app._forceLogOut({
                        shouldPushHistory: !1,
                        reason: "clear data before logging in",
                        skipRemovingCaches: o
                    });
                    const {
                        needsOTP: r,
                        isServiceMode: i
                    } = await e();
                    if (!r) {
                        i ? this.app.localStorage.set(a.d.serviceMode, !0) : this.app.localStorage.remove(a.d.serviceMode), s && await s();
                        const e = Date.now();
                        await this.app.localStorage.set(a.d.hasUnfinishedLogin, !0), await this.sync.synchronize(), await this.app.localStorage.remove(a.d.hasUnfinishedLogin), this.app.performance.loginTime = Date.now() - e;
                        const n = await this.app.restoreUserSession({
                            skipAppStateChange: t,
                            skipNotificationsRegister: !globalThis.electron
                        });
                        if (this.app.localStorage.set(a.d.diagnosticLoggedInAt, Date.now()), !n) throw new Error("[Sync] Log-in sync failed — no user found");
                        this.app.ab.triggerEntryLoggedIn()
                    }
                    return {
                        needsOTP: r,
                        isServiceMode: i
                    }
                } catch (e) {
                    throw await this.app._forceLogOut({
                        shouldPushHistory: !1,
                        reason: "login failure"
                    }), e
                }
            }
            async signUp(e, t) {
                return n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] Signing Up..."), this._performSignup((async () => {
                    invariant(!t.serverUrl, "Attempted to change serverUrl in prod build");
                    const {
                        locale: s
                    } = this.app.localization.currentSettings;
                    return this.api.account.signUp(Object.assign({}, e, {
                        locale: s
                    }))
                }), t.skipRemovingCaches)
            }
            async confirmEmail({
                confirmId: e,
                inviteCode: t,
                serverUrl: s
            }) {
                return n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] Confirming Email..."), this._logInSync({
                    authenticator: async () => (invariant(!s, "Attempted to change serverUrl in prod build"), this.api.account.confirmEmail({
                        confirmId: e,
                        inviteCode: t
                    }))
                })
            }
            async changePasswordWithResetAndLogin({
                newPassword: e,
                tokenId: t
            }) {
                const s = await this.api.account.changePasswordWithReset({
                    newPassword: e,
                    tokenId: t
                });
                return "boolean" == typeof s ? s : (this._logInSync({
                    authenticator: async () => ({
                        needsConfirmation: !1
                    })
                }), !0)
            }
            async confirmEmailChange({
                confirmId: e,
                intl: t
            }) {
                try {
                    this.sync.setAutoSyncEnabled(!1), await this.api.account.confirmEmailChange({
                        confirmId: e
                    }), await this.app._forceLogOut({
                        reason: "after email change",
                        shouldPushHistory: !0,
                        pathToPush: {
                            path: o.pathToLogin.path,
                            state: {
                                message: t.f.iQ
                            }
                        }
                    })
                } catch (e) {
                    throw this.sync.setAutoSyncEnabled(!0), e
                }
            }
            async cancelAccount(e, t) {
                invariant(e.isMe, "Cannot cancel other user's account"), this.sync.setAutoSyncEnabled(!1);
                try {
                    await this.app._isSyncing() && await this.app._waitForSync(), await this.api.account.cancelAccount(e, t)
                } catch (e) {
                    throw this.sync.setAutoSyncEnabled(!0), e
                }
                await this.app._forceLogOut({
                    shouldPushHistory: !0,
                    reason: "user canceled account"
                }), this.app.appState.hasCanceledAccount.next(!0)
            }
            async leaveTeam(e) {
                await this._performActionWithRelogin((async () => {
                    await this.app.modelRoot.do.leaveTeam(e)
                }))
            }
            async removeTeam(e) {
                await this._performActionWithRelogin((async () => {
                    await this.app.modelRoot.do.removeTeam(e)
                }))
            }
            async joinTeamAsBusinessAdmin(e, t) {
                await this._performActionWithRelogin((async () => {
                    await this.app.modelRoot.do.joinTeamAsBusinessAdmin(e, t)
                }))
            }
            async authThirdParty({
                email: e,
                password: t,
                otp: s,
                serverUrl: a,
                integrationToken: o,
                thirdPartyName: r
            }) {
                try {
                    return invariant(!a, "Attempted to change serverUrl in prod build"), await this.api.account.authThirdParty({
                        email: e,
                        password: t,
                        otp: s,
                        integrationToken: o,
                        thirdPartyName: r
                    })
                } catch (e) {
                    throw n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.API_ERROR).log(e), e
                }
            }
            pickTeamForThirdParty({
                teamId: e,
                patchToken: t,
                thirdPartyName: s,
                authenticationToken: n
            }) {
                return this.api.account.pickTeamForThirdParty({
                    teamId: e,
                    patchToken: t,
                    thirdPartyName: s,
                    authenticationToken: n
                })
            }
            async retrieveLoginProvider(e) {
                const t = await this.api.account.checkLoginProvider(e);
                return invariant("google" === t || "apple" === t, 'Expected login provider to be either "google" or "apple", got "' + t + '" instead'), t
            }
            async _performSignup(e, t = !1) {
                try {
                    invariant(!this.app.appState.isLoggedIn.getValue(), "Cannot sign up when already logged in"), await this.app._forceLogOut({
                        shouldPushHistory: !1,
                        reason: "clear data before signup",
                        skipRemovingCaches: t
                    });
                    const s = await e();
                    if (202 === s.status) {
                        const e = await s.json();
                        return {
                            status: "confirmation_required",
                            avatarUploadToken: e.avatar_upload_token,
                            teamAvatarUploadToken: e.team_avatar_upload_token
                        }
                    }
                    return await this._logInSync({
                        authenticator: async () => {
                            const e = await s.json();
                            return this.app.keychain.apiToken = e, {
                                needsOTP: !1
                            }
                        },
                        skipRemovingCaches: t
                    }), {
                        status: "ok"
                    }
                } catch (e) {
                    var s;
                    n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.API_ERROR).error(e);
                    return {
                        status: "error",
                        errorCode: null == (s = e.originalResponse) ? void 0 : s.status
                    }
                }
            }
            async _performActionWithRelogin(e) {
                this.app.appState.isForcingRelogin.next(!0);
                try {
                    await e()
                } catch (e) {
                    throw this.app.appState.isForcingRelogin.next(!1), e
                }
                try {
                    await this.sync.synchronize(), await this.app.forceRelogin()
                } catch (e) {}
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => F
        });
        var n = s(52),
            a = s(69),
            o = s(24),
            r = s(4),
            i = (s(8), s(5)),
            c = s(39),
            l = (s(17), s(37), s(23)),
            d = s(1511),
            u = s(922),
            m = s(511);
        var h = s(514);
        const p = ["Content-Type"];
        var g, f, b, y, v, w, k, x, j, T, S, P, _, C, R, A, I, N, E, O, M;
        const D = (e, t, s, n = null) => (0, o.Z)(e.prototype, t, s, {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: n
            }),
            H = d.j.version;
        let F = (g = i.lazy, f = i.lazy, b = i.lazy, y = i.lazy, v = i.lazy, w = i.lazy, k = i.lazy, x = i.lazy, j = i.lazy, T = i.lazy, P = D(S = class {
            constructor({
                keychain: e,
                localStorage: t,
                native: s,
                getPerfStatHeaders: n,
                launchId: o
            }) {
                (0, a.Z)(this, "attachments", P, this), (0, a.Z)(this, "account", _, this), (0, a.Z)(this, "affiliate", C, this), (0, a.Z)(this, "business", R, this), (0, a.Z)(this, "payments", A, this), (0, a.Z)(this, "invoices", I, this), (0, a.Z)(this, "share", N, this), (0, a.Z)(this, "sync", E, this), (0, a.Z)(this, "integrations", O, this), (0, a.Z)(this, "telemetry", M, this), this._pendingRequestCount = 0, this._keychain = e, this._localStorage = t, this._native = s, this._launchId = o, this._getPerfStatHeaders = n
            }
            async _fetch(e = [], t = {}, s = {}) {
                this._pendingRequestCount += 1;
                try {
                    return await (0, u.Z)(await this._url(e, s), Object.assign({
                        headers: await this._headers()
                    }, t))
                } finally {
                    this._pendingRequestCount -= 1
                }
            }
            async _fetchXHR(e = [], t = {}, s = {}) {
                this._pendingRequestCount += 1;
                try {
                    return await (0, m.Z)(await this._url(e, s), Object.assign({
                        headers: await this._headers()
                    }, t))
                } finally {
                    this._pendingRequestCount -= 1
                }
            }
            async _fetchJSON(e = [], t = {}, s = {}) {
                return (await this._fetch(e, t, s)).json()
            }
            async _url(e = [], t = {}) {
                const s = await this.getServerUrl(),
                    n = function(e = [], t = {}) {
                        invariant(Array.isArray(e), "pathSegments is not an Array!"), invariant((0, r.isObject)(t), "searchParams is not a Object!");
                        const s = e.map(encodeURIComponent).join("/"),
                            n = (0, r.toPairs)(t).map((([e, t]) => encodeURIComponent(e) + "=" + encodeURIComponent(t))).join("&");
                        return (s ? "/" + s : "") + (n ? "?" + n : "")
                    }(e, t);
                return "" + s + n
            }
            async getServerUrl() {
                return "https://api4.nozbe.com/v1"
            }
            async setServerUrl() {
                throw new Error("serverUrl is immutable in prod builds")
            }
            async isAuthenticated() {
                return !!await this._keychain.apiToken
            }
            async _headers({
                hello: e,
                apiToken: t
            } = {}) {
                const s = t || await this._keychain.apiToken,
                    [n] = await this._native.fetchPreferredLocales(),
                    a = {
                        "Content-Type": "application/json",
                        "API-Version": "" + H,
                        "X-Launch-ID": this._launchId,
                        "X-Device-OS": await (0, l.getDeviceOS)() + " " + await (0, l.getDeviceOSVersion)(),
                        "X-Device-Model": "" + await (0, l.getDeviceModel)(),
                        "X-App-Version": "" + i.appVersion
                    };
                return s && (a.Authorization = s, a["X-Authorization"] = s), e && (a["X-Hello"] = await this._getTrackingId()), a
            }
            async _getTrackingId() {
                if (null != this._trackingId) return this._trackingId;
                const e = await (0, h.vq)() || "";
                return this._trackingId = e, e
            }
            async validateToken({
                tokenType: e,
                tokenId: t,
                serverUrl: s
            }) {
                s && await this.setServerUrl(s), await this._fetch(["token_status", e, t])
            }
            async notifyTeamOwner(e, t, s) {
                const n = Object.assign({
                    notification_type: t,
                    team_id: e
                }, s ? {
                    reason: s
                } : {});
                await this._fetch(["notify"], {
                    method: "POST",
                    body: JSON.stringify(n)
                })
            }
            async getNewsFeed(e) {
                const t = (0, c.localeToBlogLanguage)(e),
                    s = await fetch("https://nozbe.com/" + ("en" !== t ? t + "/" : "") + "tags/nozbeteams/feed.json");
                return (await s.json()).items
            }
            async searchEndedComments(e, t, s, n, a) {
                const o = new AbortController,
                    r = a.subscribe((e => {
                        o.abort(e)
                    }));
                try {
                    const a = await this._fetch(["search"], {
                            signal: o.signal
                        }, {
                            search_ended_tasks: e,
                            team_id: t.id,
                            limit: "" + n,
                            page: "" + (Math.ceil(s / n) - 1)
                        }),
                        r = await a.json() || {};
                    return Object.values(r.comments || {})
                } catch (e) {
                    return []
                } finally {
                    r.unsubscribe()
                }
            }
            async getVapidPublicKey() {
                try {
                    return await this._fetchJSON(["webpush_subs"])
                } catch (e) {
                    return null
                }
            }
            async windowsNotificationFeed() {
                const e = await this._headers(),
                    t = (0, n.Z)(e, p);
                return {
                    url: await this.getServerUrl() + "/stream/users/",
                    headers: t
                }
            }
            async getWebSocketUrl() {
                const e = await this._fetchJSON(["ws_token"]);
                invariant("string" == typeof e, "Bad ws_token");
                const t = await this.getServerUrl(),
                    s = new RegExp("^https:\\/\\/([\\w\\.-]+)(?::\\d{1,4})?\\/v1$"),
                    n = t.match(s);
                invariant(n, "Bad serverUrl format, can't extract host for WS");
                const [, a] = n;
                return "wss://" + a + ":" + ("api4.nozbe.com" === a ? "8098" : "8097") + "/v1/ws/" + e
            }
            async moveProjects(e, t) {
                var s;
                return {
                    movedProjectIds: null != (s = (await this._fetchJSON(["projects", "move"], {
                        method: "POST",
                        body: JSON.stringify({
                            team_id: e,
                            project_ids: t
                        })
                    })).project_ids) ? s : []
                }
            }
            async moveTasks(e, t) {
                const s = await this._fetchJSON(["tasks", "move"], {
                    method: "POST",
                    body: JSON.stringify({
                        project_id: e,
                        task_ids: t
                    })
                });
                return invariant(Array.isArray(s.task_ids), "Unexpected server response"), {
                    movedTaskIds: s.task_ids
                }
            }
        }, "attachments", [g], (function() {
            return (() => new(0, s(1268).Z)(this))()
        })), _ = D(S, "account", [f], (function() {
            return (() => new(0, s(1534).Z)(this))()
        })), C = D(S, "affiliate", [b], (function() {
            return (() => new(0, s(1269).Z)(this))()
        })), R = D(S, "business", [y], (function() {
            return (() => new(0, s(1270).Z)(this))()
        })), A = D(S, "payments", [v], (function() {
            return (() => new(0, s(1271).Z)(this))()
        })), I = D(S, "invoices", [w], (function() {
            return (() => new(0, s(1272).Z)(this))()
        })), N = D(S, "share", [k], (function() {
            return (() => new(0, s(1273).Z)(this))()
        })), E = D(S, "sync", [x], (function() {
            return (() => new(0, s(1274).Z)(this))()
        })), O = D(S, "integrations", [j], (function() {
            return (() => new(0, s(1535).Z)(this))()
        })), M = D(S, "telemetry", [T], (function() {
            return (() => new(0, s(1275).Z)(this))()
        })), S)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(4),
            a = s(8);
        s(5), s(17);
        class o {
            constructor(e) {
                this._api = e
            }
            async _blobTransferHeaders() {
                return n.omit(["Content-Type"], await this._api._headers())
            }
            async attachmentUploadInfo(e) {
                const t = new FormData;
                return e.forEach((({
                    id: e,
                    file: s,
                    status: n
                }) => {
                    invariant("uploading" === n, "Cannot upload file with status " + n), invariant(s, "Cannot upload file because source object is unavailable"), t.append(e, s)
                })), {
                    url: await this._api._url(["files"]),
                    headers: await this._blobTransferHeaders(),
                    body: t
                }
            }
            async uploadAvatar(e, t) {
                const s = new FormData;
                s.append("avatar", e);
                const n = await this._api._fetch(["files", "avatars", "/"], {
                        method: "POST",
                        headers: await this._blobTransferHeaders(),
                        body: s
                    }, {
                        team_id: t ? t.id : ""
                    }),
                    [a] = await n.json();
                return a
            }
            async uploadAvatarWithToken(e, t) {
                const s = new FormData;
                return s.append("avatar", e), this._api._fetch(["files", "avatars", t], {
                    method: "POST",
                    headers: await this._blobTransferHeaders(),
                    body: s
                })
            }
            async deleteAvatar(e, t) {
                await this._api._fetch(["files", "avatars", e], {
                    method: "DELETE"
                }, {
                    team_id: t ? t.id : ""
                })
            }
            async avatarSource(e, t, s) {
                return {
                    uri: await this._api._url(["files", "avatars", e], {
                        width: String(t),
                        team_id: s || ""
                    }),
                    headers: await this._blobTransferHeaders()
                }
            }
            async nativeUploadAttachments(e) {
                const t = e.filter((({
                    file: e
                }) => e)).map((({
                    id: e,
                    file: t
                }) => ({
                    id: e,
                    file: t
                })));
                return this._api._native.uploadAttachments({
                    files: t,
                    serverUrl: await this._api.getServerUrl(),
                    headers: await this._blobTransferHeaders()
                })
            }
            async nativeDownloadAttachment(e) {
                return this._api._native.downloadAttachment({
                    attachmentVersion: e,
                    url: await this._api._url(["files", e.id]),
                    requestHeaders: await this._blobTransferHeaders()
                })
            }
            downloadAttachmentAsBlob(e) {
                const t = new a.BehaviorSubject(0);
                return [(async () => (await this._api._fetchXHR(["files", e.id], {
                    method: "GET",
                    headers: await this._blobTransferHeaders(),
                    onDownloadProgress: e => {
                        t.next(e || 0)
                    }
                })).blob())(), t]
            }
            async thumbnailSource(e, t) {
                return {
                    uri: await this._api._url(["files", e.id], {
                        width: String(t)
                    }),
                    headers: await this._blobTransferHeaders()
                }
            }
            async getExternalVideoMetadata(e, t, s) {
                const n = "vimeo" === e ? {
                        url: s
                    } : void 0,
                    a = await this._api._fetchJSON(["video_thumbnail", e, t], {}, n);
                if (!a) return null;
                const {
                    title: o = "",
                    preview_url: r,
                    thumbnails: i = []
                } = a;
                return {
                    title: o,
                    previewUrl: r,
                    thumbnails: i
                }
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(4), s(8), s(5), s(17);
        class n {
            constructor(e) {
                this._api = e
            }
            async getInfo() {
                const e = await this._api._fetch(["affiliate_info"]),
                    t = await e.json();
                return t ? {
                    affiliateCode: t.affiliate_code,
                    creditsAvailable: t.credits_available,
                    creditsPending: t.credits_pending,
                    creditsTotal: t.credits_available + t.credits_pending,
                    creditsTotalWithUsed: t.credits_total,
                    currency: t.currency,
                    testimonial: t.testimonial,
                    referrerCode: t.referrer_code,
                    canEditReferrer: t.can_edit_referrer
                } : null
            }
            async updateAffiliateCode(e) {
                return this._api._fetch(["affiliate_info"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        affiliate_code: e
                    })
                })
            }
            async updateReferrerCode(e) {
                return this._api._fetch(["affiliate_info"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        referrer_code: e
                    })
                })
            }
            async getTestimonial() {
                const e = await this.getInfo();
                return (null == e ? void 0 : e.testimonial) || ""
            }
            async updateTestimonial(e) {
                await this._api._fetch(["affiliate_info"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        testimonial: e
                    })
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(17);
        class n {
            constructor(e) {
                this._api = e
            }
            async getAllTeams(e) {
                const t = await this._api._fetchJSON(["businesses", e.id, "teams"]);
                return invariant(Array.isArray(t.teams), "Malformed response of business teams"), t.teams
            }
            async modifyBusinessTeams(e, t) {
                await this._api._fetch(["businesses", e.id, "teams"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        teams_added: t.added,
                        teams_removed: t.removed
                    })
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(4), s(8), s(5), s(17);
        class n {
            constructor(e) {
                this._api = e
            }
            async fetchPlansJSON(e, t, s = !1) {
                return this._api._fetchJSON(["teams", e, s ? "renewals" : "plans"], {}, {
                    reason: t
                })
            }
            async verifyReceipt({
                provider: e,
                team: t,
                base64Receipt: s,
                productId: n
            }) {
                await this._api._fetch(["verify_receipt"], {
                    method: "POST",
                    body: JSON.stringify({
                        provider: e,
                        team_id: null == t ? void 0 : t.id,
                        receipt_data: s,
                        product_id: n
                    })
                })
            }
            async getReceipts() {
                const e = await this._api._headers();
                return this._api._native.inAppPurchases.getReceipts(await this._api._url(["receipts"]), e)
            }
            async claimPurchase({
                team: e,
                token: t
            }) {
                await this._api._fetch(["teams", e.id, "claim_purchase", t], {
                    method: "PATCH"
                })
            }
            async getUpdatePaymentUrl({
                team: e
            }) {
                return (await this._api._fetchJSON(["teams", e.id, "payment"])).payment_info_url
            }
            async paylessPlanChange(e, t, s, n) {
                await this._api._fetch(["teams", e, "plan"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        plan_type: t,
                        is_recurring: s,
                        credits: n
                    })
                })
            }
            async importNozbePersonalSubscription(e) {
                return this._api._fetch(["np_import", e.id, "subscription"], {
                    method: "POST"
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(4), s(8), s(5), s(17);
        var n = s(322);

        function a(e, t) {
            return [e.table, e.id, ...t]
        }
        class o {
            constructor(e) {
                this._api = e
            }
            async getInvoicedOrders(e) {
                return this._api._fetchJSON(a(e, ["orders"]))
            }
            async getInvoiceDetails(e) {
                var t, s, n;
                const o = await this._api._fetchJSON(a(e, ["invoice_details"]));
                return {
                    email: null != (t = o.invoice_email) ? t : null,
                    taxId: null != (s = o.tax_id) ? s : null,
                    currency: null != (n = o.currency) ? n : ""
                }
            }
            async setInvoiceDetails(e, t) {
                await this._api._fetch(a(e, ["invoice_details"]), {
                    method: "POST",
                    body: JSON.stringify({
                        invoice_email: t.email,
                        tax_id: null !== t.taxId ? (0, n.IC)(t.taxId) : null
                    })
                })
            }
            async generateProformaInvoice(e, t, s) {
                return {
                    url: (await this._api._fetchJSON(["teams", e, "proforma"], {
                        method: "POST",
                        body: JSON.stringify({
                            plan_type: t,
                            tax_id: (0, n.IC)(s)
                        })
                    })).invoice_url
                }
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(4), s(8), s(5), s(17);
        class n {
            constructor(e) {
                this._api = e
            }
            async inviteTeamToProject(e, t) {
                await this._api._fetch(["projects", e.id, "invite"], {
                    method: "POST",
                    body: JSON.stringify({
                        email: t
                    })
                })
            }
            async cancelTeamInvitationToProject(e) {
                await this._api._fetch(["projects", e.id, "invite"], {
                    method: "DELETE"
                })
            }
            async fetchProjectInvitation(e) {
                const {
                    project_name: t,
                    project_color: s,
                    team_name: n,
                    team_id: a,
                    inviter_name: o,
                    inviter_email: r,
                    inviter_avatar_url: i,
                    email: c
                } = await this._api._fetchJSON(["projects", "invite", e]);
                return {
                    projectName: t,
                    projectColor: s,
                    teamName: n,
                    teamId: a,
                    inviterName: o,
                    inviterEmail: r,
                    inviterAvatarUrl: i,
                    email: c
                }
            }
            async acceptProjectInvitation(e, t = []) {
                const {
                    project_id: s
                } = await this._api._fetchJSON(["projects", "invite", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        accept: !0,
                        members_ids: t
                    })
                });
                return {
                    projectId: s
                }
            }
            async rejectProjectInvitation(e) {
                await this._api._fetch(["projects", "invite", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        accept: !1,
                        members_ids: []
                    })
                })
            }
            async getTaskInvitation(e) {
                const t = await this._api._fetch(["tasks", "invite", e]),
                    {
                        inviter_name: s,
                        inviter_email: n,
                        inviter_avatar_url: a,
                        task_name: o,
                        team_name: r,
                        task_id: i,
                        authorization: c,
                        can_accept_as_guest: l
                    } = await t.json();
                if (s && o && r && n) return {
                    status: "pending",
                    inviterName: s,
                    taskName: o,
                    teamName: r,
                    inviterEmail: n,
                    inviterAvatarUrl: a,
                    canAcceptAsGuest: Boolean(l)
                };
                if (i) return c ? {
                    status: "accepted",
                    taskId: i,
                    acceptedByGuest: !0,
                    authorization: c
                } : {
                    status: "accepted",
                    taskId: i,
                    acceptedByGuest: !1
                };
                throw new Error("Malformed task invitation response")
            }
            async acceptTaskInvitation({
                token: e,
                teamId: t,
                locale: s
            }) {
                const n = await this._api._fetch(["tasks", "invite", e], {
                        method: "PATCH",
                        body: JSON.stringify({
                            accept: !0,
                            team_id: t,
                            locale: s
                        })
                    }),
                    {
                        task_id: a,
                        authorization: o
                    } = await n.json();
                return invariant(a, "Missing task_id after accepting the invitation"), {
                    taskId: a,
                    authorization: o
                }
            }
            async rejectTaskInvitation({
                token: e
            }) {
                await this._api._fetch(["tasks", "invite", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        accept: !1
                    })
                })
            }
            async acceptAccountMerge({
                token: e,
                teamId: t
            }) {
                await this._api._fetch(["accounts", "merge", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        accept: !0,
                        team_id: t
                    })
                })
            }
            async rejectAccountMerge({
                token: e
            }) {
                await this._api._fetch(["accounts", "merge", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        accept: !1
                    })
                })
            }
            async getGTMInvitationLink(e) {
                var t, s;
                const n = await this._api._fetch(["tasks", e, "invite"]),
                    a = await n.json();
                return {
                    invitationId: null != (t = null == a ? void 0 : a.invitation_id) ? t : "",
                    invitationUrl: null != (s = null == a ? void 0 : a.invitation_url) ? s : ""
                }
            }
            async createGTMInvitationLink(e) {
                var t, s;
                const n = await this._api._fetch(["tasks", e, "invite"], {
                        method: "POST"
                    }),
                    a = await n.json();
                return {
                    invitationId: null != (t = null == a ? void 0 : a.invitation_id) ? t : "",
                    invitationUrl: null != (s = null == a ? void 0 : a.invitation_url) ? s : ""
                }
            }
            async removeGTMInvitationLink(e) {
                await this._api._fetch(["tasks", e, "invite"], {
                    method: "DELETE"
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(4), s(8), s(5), s(17);
        class n {
            constructor(e) {
                this._api = e
            }
            async pullSync(e) {
                return this._api._fetchJSON(["sync"], {
                    headers: await this._pullSyncHeaders()
                }, this._pullSyncSearchParams(e))
            }
            async turboLogin(e, t) {
                return this._api._native.turboLogin({
                    headers: await this._pullSyncHeaders(),
                    searchParams: this._pullSyncSearchParams(t),
                    serverUrl: await this._api.getServerUrl(),
                    syncId: e
                })
            }
            async _pullSyncHeaders() {
                return Object.assign({}, await this._api._headers(), this._api._getPerfStatHeaders())
            }
            _pullSyncSearchParams({
                lastPulledAt: e,
                migration: t
            }) {
                return {
                    last_pulled_at: String(e || 0),
                    migration: JSON.stringify(t),
                    selectiveSync2: "true"
                }
            }
            async pushSync({
                lastPulledAt: e,
                changes: t
            }) {
                const s = await this._api._fetch(["sync"], {
                    method: "POST",
                    body: JSON.stringify(t)
                }, {
                    last_pulled_at: String(e)
                });
                return await s.json() || {}
            }
            async getTaskTimeline(e) {
                const t = await this._api._fetchJSON(["task_timeline", e]);
                return invariant(Array.isArray(t.comments) && Array.isArray(t.task_events), "Invalid /task_timeline response"), t
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(4), s(8);
        var n = s(5);
        s(17);
        const a = e => e();
        class o {
            constructor(e) {
                this._api = e
            }
            trackSignupProcess(e) {
                a((async () => {
                    this._sendEvent('signup step "' + e + '"', {
                        headers: await this._api._headers({
                            hello: !0
                        })
                    }, {
                        step: e
                    })
                }))
            }
            trackInstallSource() {
                a((async () => {
                    const e = await this._api._native.getAdsToken();
                    e && this._sendEvent("installSource", {
                        body: JSON.stringify({
                            source: e
                        })
                    }, {
                        stat: "install_source"
                    })
                }))
            }
            abEvent(e, t, s) {
                a((async () => {
                    this._sendEvent("AB event " + e + "::" + s, {
                        headers: await this._api._headers()
                    }, {
                        event: "ab_" + e + "_" + s + "_" + t
                    })
                }))
            }
            trackCancelAccount(e) {
                a((async () => {
                    this._sendEvent("cancelAccount", {
                        headers: await this._api._headers()
                    }, {
                        cancel_reason: JSON.stringify(e)
                    })
                }))
            }
            answerSurvey(e) {
                a((async () => {
                    this._sendEvent("answerSurvey", {
                        headers: await this._api._headers()
                    }, {
                        survey: JSON.stringify(e)
                    })
                }))
            }
            trackBanner(e) {
                a((async () => {
                    this._sendEvent("carousel_banner", {
                        headers: await this._api._headers()
                    }, {
                        banner_name: e
                    })
                }))
            }
            async _sendEvent(e, t, s = {}) {
                try {
                    await this._api._fetch(["nav"], Object.assign({
                        method: "POST"
                    }, t), s)
                } catch (t) {
                    this._error(e, t)
                }
            }
            _error(e, t) {
                n.logError(n.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, "Didn't track " + e + ": " + t.message)
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => x
        });
        var n = s(69),
            a = s(24),
            o = s(5),
            r = s(8),
            i = s(4),
            c = s(1454),
            l = s(23),
            d = s(37),
            u = s(17);
        var m, h, p, g, f, b, y, v = s(16);

        function w(e, t, s, n) {
            if (e === v.w.tasks) {
                const e = "number" == typeof s.comments_cached && "number" == typeof t.comments_cached;
                n.comments_cached = e ? s.comments_cached : t.comments_cached
            }
            return n
        }
        const k = (e, t, s, n = null) => (0, a.Z)(e.prototype, t, s, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: n
        });
        let x = (m = o.lazy, h = o.lazy, p = o.lazy, f = k(g = class {
            get lastSyncSuccessful() {
                return this._lastSyncSuccessful
            }
            constructor({
                getApi: e,
                database: t,
                formatMessage: s,
                pushSyncSignal: a,
                onBeforeSync: o,
                onAfterSync: i,
                forceLogOut: l,
                onPaymentRequired: d,
                displayMessages: u
            }) {
                this.logger = new c.Z, this._manualTriggers = new r.Subject, (0, n.Z)(this, "_automaticTriggers", f, this), this._autoSyncEnabled = new r.BehaviorSubject(!1), (0, n.Z)(this, "_triggers", b, this), (0, n.Z)(this, "queue", y, this), this.isSyncing = new r.BehaviorSubject(!1), this._lastSyncSuccessful = !0, this._getApi = e, this._database = t, this._formatMessage = s, this._pushSyncSignal = a, this._onBeforeSync = o, this._onAfterSync = i, this._forceLogOut = l, this._onPaymentRequired = d, this._displayMessages = u, this._queueSubscription = this.queue.subscribe()
            }
            setAutoSyncEnabled(e) {
                this._autoSyncEnabled.next(e)
            }
            async synchronize() {
                const e = this.queue.pipe(r.first()),
                    t = r.takeLast(e.pipe(r.dematerialize()));
                return this._manualTriggers.next(), t
            }
            async synchronizeTwice() {
                return [await this.synchronize(), await this.synchronize()]
            }
            async _performSync() {
                try {
                    this.isSyncing.next(!0), o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Sync] Started");
                    const e = await this._synchronizeImpl().catch((e => (o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.SAFE_LITERAL).warn("[Sync] Failed, but will try second time"), o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.API_ERROR).warn(e), this._synchronizeImpl())));
                    return o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Sync] Completed"), this._lastSyncSuccessful = !0, this.isSyncing.next(!1), this._onAfterSync(e), e
                } catch (e) {
                    throw o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.SAFE_LITERAL).error("[Sync] Failed"), o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.API_ERROR).error(e), this._lastSyncSuccessful = !1, e.forceRelogin || e.forceLogOut ? this._forceLogOut(e.forceRelogin) : "number" == typeof e.expectedApiVersion && e.expectedApiVersion !== this._database.schema.version ? await (0, l.devAlert)(this._formatMessage("Dg")) : e.isNetworkErrorLikely || (o.PROD_CONSOLE(o.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR).log("Sync error stack trace: ", e.stack), o.logError("diagnostic error", "Sync error: " + e)), e.userMessages && await this._displayMessages(e.userMessages), this.isSyncing.next(!1), e
                }
            }
            async _synchronizeImpl() {
                const {
                    synchronize: e
                } = s(166);
                if (!await this._getApi().isAuthenticated()) return "no_new_data";
                await this._onBeforeSync();
                const t = 0 === await this._database.collections.get(u.Tables.users).query().fetchCount();
                let n = "no_new_data";
                const a = t && !1;
                return await e({
                    database: this._database,
                    sendCreatedAsUpdated: !0,
                    log: this.logger.newLog(),
                    migrationsEnabledAtVersion: 97,
                    conflictResolver: w,
                    _unsafeBatchPerCollection: t && !1,
                    unsafeTurbo: a,
                    pullChanges: async e => {
                        var t, s;
                        if (a) {
                            const t = Math.floor(1e9 * Math.random());
                            return await this._getApi().sync.turboLogin(t, e), n = "new_data", {
                                syncJsonId: t
                            }
                        }
                        const o = await this._getApi().sync.pullSync(e),
                            {
                                changes: r,
                                timestamp: c
                            } = o,
                            l = (e => (0, i.piped)(e, (0, i.map)((({
                                created: e,
                                updated: t,
                                deleted: s
                            }) => e.length + t.length + s.length)), i.values, (e => (0, i.anyTrue)(...e))))(r);
                        n = l ? "new_data" : "no_new_data";
                        if (l && ((null == (t = r[u.Tables.teams]) ? void 0 : t.created.some((e => null != e.plan_info))) || (null == (s = r[u.Tables.teams]) ? void 0 : s.updated.some((e => null != e.plan_info))))) {
                            const {
                                localStorage: e
                            } = this._database;
                            await e.get(d.d.lastPromptedForReviewAt) || await e.set(d.d.lastPromptedForReviewAt, (new Date).getTime())
                        }
                        return {
                            changes: r,
                            timestamp: c
                        }
                    },
                    onDidPullChanges: async ({
                        messages: e
                    }) => {
                        e && await this._displayMessages(e)
                    },
                    pushChanges: async e => {
                        const t = await this._getApi().sync.pushSync(e),
                            {
                                rejected_record_ids: s,
                                payment_error_team_ids: n
                            } = t;
                        return n && this._onPaymentRequired(n), {
                            experimentalRejectedIds: s
                        }
                    }
                }), n
            }
            async experimental_replacementSync() {
                const {
                    synchronize: e
                } = s(166);
                await e({
                    database: this._database,
                    sendCreatedAsUpdated: !0,
                    log: this.logger.newLog(),
                    migrationsEnabledAtVersion: 97,
                    conflictResolver: w,
                    pullChanges: async e => {
                        const t = await this._getApi().sync.pullSync({
                                schemaVersion: e.schemaVersion,
                                migration: null,
                                lastPulledAt: 0
                            }),
                            {
                                changes: s,
                                timestamp: n
                            } = t;
                        return {
                            changes: s,
                            timestamp: n,
                            experimentalStrategy: "replacement"
                        }
                    },
                    onDidPullChanges: async ({
                        messages: e
                    }) => {
                        e && await this._displayMessages(e)
                    },
                    pushChanges: async e => {
                        const t = await this._getApi().sync.pushSync(e),
                            {
                                rejected_record_ids: s,
                                payment_error_team_ids: n
                            } = t;
                        return n && this._onPaymentRequired(n), {
                            experimentalRejectedIds: s
                        }
                    }
                })
            }
        }, "_automaticTriggers", [m], (function() {
            return r.merge(l.appState.pipe(r.switchMap((e => "active" === e ? r.interval(3e5) : r.interval(72e4)))), l.appBecameActive.pipe(r.skip(1), r.throttleTime(2e4)), this._database.withChangesForTables((0, i.values)(u.Tables)).pipe(r.skip(1), r.filter((e => !e.every((e => "synced" === e.record.syncStatus)))), r.debounceTime(300)), this._pushSyncSignal.pipe(r.throttleTime(2e3, void 0, {
                leading: !0,
                trailing: !0
            })), l.onOnline)
        })), b = k(g, "_triggers", [h], (function() {
            return r.merge(this._manualTriggers, this._autoSyncEnabled.pipe(r.switchMap((e => e ? this._automaticTriggers : r.never()))))
        })), y = k(g, "queue", [p], (function() {
            return this._triggers.pipe(r.exhaustMap((() => r.from(this._performSync()).pipe(r.materialize()))), r.share())
        })), g)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(5),
            a = s(8),
            o = s(4),
            r = s(23),
            i = s(95);
        s(0);
        const c = JSON.stringify({
            type: "ping"
        });
        class l {
            constructor(e) {
                this._receivedMessageCount = 0, this._connectRetry = new o.Retry({
                    max: 12e4,
                    add: 1e3
                }), this._url = e, this._enabled = !0, this._connect()
            }
            disconnect() {
                this._enabled = !1, this._socket.close(), n.PROD_CONSOLE(i.p.SAFE_LITERAL).log("[WebSocket] Disconnected")
            }
            send(e) {
                1 === this._socket.readyState ? this._socket.send(e) : n.PROD_CONSOLE(i.p.SAFE_LITERAL).log("[WebSocket] Message not sent (socket not ready)")
            }
            sendJSON(e) {
                this.send(JSON.stringify(e))
            }
            _connect() {
                if (!this._enabled) return;
                console.log("[WebSocket] Connecting...");
                const e = new WebSocket(this._url, n.platform.isWindowsElectron ? "WindowsElectron" : void 0);
                let t;
                this._socket = e, e.onopen = () => {
                    n.PROD_CONSOLE(i.p.SAFE_LITERAL).log("[WebSocket] Connected"), t = setInterval((() => {
                        this._keepAlive(e)
                    }), 3e4), this._connectRetry.reset()
                }, e.onmessage = e => {
                    this._receivedMessageCount += 1, this.onmessage(e)
                }, e.onerror = e => {
                    n.PROD_CONSOLE(i.p.API_ERROR).error("[WebSocket] Error", e)
                }, e.onclose = async () => {
                    clearInterval(t), this._enabled && (n.PROD_CONSOLE(i.p.SAFE_LITERAL).log("[WebSocket] Will reconnect..."), await this._connectRetry.wait(), this._connect())
                }
            }
            async _keepAlive(e) {
                const t = this._receivedMessageCount;
                e.send(c), await o.delay(15e3);
                this._receivedMessageCount > t || (n.PROD_CONSOLE(i.p.SAFE_LITERAL).log("[WebSocket] Disconnected silently, reconnecting..."), e.close())
            }
        }
        class d {
            constructor({
                getApi: e
            }) {
                this._socket = null, this.syncSignals = new a.Subject, this._getApi = e
            }
            async initialize() {
                invariant(!this._socket, "Unexpected socket"), await this._getApi().isAuthenticated() && (this._connectAbort = new AbortController, this._connect(this._connectAbort.signal))
            }
            invalidate() {
                var e, t;
                null == (e = this._connectAbort) || e.abort(), null == (t = this._socket) || t.disconnect(), this._socket = null
            }
            async _connect(e) {
                const t = new o.Retry({
                    max: 12e4,
                    add: 1e3
                });
                for (;;) try {
                    const e = await this._getApi().getWebSocketUrl();
                    return this._socket = new l(e), void(this._socket.onmessage = e => {
                        this._onMessage(e.data)
                    })
                } catch (s) {
                    if (n.PROD_CONSOLE(i.p.API_ERROR).error("[WebSocket] Error", s), await t.wait(), e.aborted) return
                }
            }
            _onMessage(e) {
                const t = function(e) {
                    const t = JSON.parse(e);
                    return invariant(t.type, "Unexpected WS message format"), t
                }(e);
                switch (t.type) {
                    case "pong":
                        return void console.log("[WebSocket] Pong");
                    case "sync":
                        return console.log("[WebSocket] Push-sync"), void this.syncSignals.next();
                    case "notification":
                        globalThis.electron && "Windows" === r.getDeviceOS() && globalThis.electron.postNotification(t.data);
                        break;
                    default:
                        console.log("[WebSocket] Unknown message", t)
                }
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => f
        });
        var n = s(8),
            a = (s(17), s(5));
        class o {
            constructor({
                team: e,
                onTeamDelete: t,
                synchronize: s
            }) {
                this.isChangingBlocked = !1, this.team = e, this._requirement = new n.BehaviorSubject({
                    reason: null
                }), this._planInfo = {
                    current: e.planInfo,
                    previous: null
                }, this._paymentInfo = {
                    current: e.paymentInfo,
                    previous: null
                }, this._teamSubscription = this._observeTeamChanges(s).subscribe({
                    complete: () => t()
                })
            }
            get reason() {
                return this._requirement.getValue().reason
            }
            get previousPlan() {
                return this._planInfo.previous
            }
            get withPromotion() {
                return !!this._requirement.getValue().withPromotion
            }
            get shouldDisplayBusinessOffer() {
                return !!this._requirement.getValue().shouldDisplayBusinessOffer
            }
            get invitedMembersCount() {
                var e;
                return null != (e = this._requirement.getValue().invitedMembersCount) ? e : 1
            }
            get hasPlanExpired() {
                return "plan-has-expired" === this.reason
            }
            get hasPlanBeenUpdated() {
                return "plan-has-been-updated" === this.reason
            }
            get hasPaymentInfoBeenUpdated() {
                return "payment-info-has-been-updated" === this.reason
            }
            get isPlanChanging() {
                return "plan-changing" === this.reason || "plan-changing-banner" === this.reason
            }
            get isPlanExtending() {
                return "plan-extending" === this.reason || "plan-extending-banner" === this.reason
            }
            get isInvitingToTeam() {
                return "invite-to-team" === this.reason
            }
            get hasSyncBeenRejected() {
                return "sync-rejection" === this.reason
            }
            observe() {
                return this._requirement.asObservable().pipe(n.mapTo(this))
            }
            change(e, t) {
                var s;
                this.isChangingBlocked || this._requirement.next({
                    reason: e,
                    withPromotion: null != (s = null == t ? void 0 : t.withPromotion) && s,
                    shouldDisplayBusinessOffer: null == t ? void 0 : t.shouldDisplayBusinessOffer,
                    invitedMembersCount: null == t ? void 0 : t.invitedMembersCount
                })
            }
            _observeTeamChanges(e) {
                return n.from(e()).pipe(n.retryWhen((e => e.pipe(n.delay(1e4)))), n.tap((() => {
                    this._updatePlanExpirationTimer(this.team.planInfo.expiresAt)
                })), n.switchMap((() => this.team.observe().pipe(n.concatMap((() => n.from(this._onTeamChange())))))))
            }
            async _onTeamChange() {
                const {
                    current: e
                } = this._planInfo, {
                    current: t
                } = this._paymentInfo, {
                    planInfo: s,
                    paymentInfo: n
                } = this.team;
                if (this.team.isExpired) this.change("plan-has-expired"), this._updatePlanExpirationTimer(null);
                else if (function(e, t) {
                        const s = 1e3 < Math.abs(t.expiresAt.getTime() - e.expiresAt.getTime()),
                            n = t.type !== e.type,
                            a = t.isRecurring !== e.isRecurring;
                        return s || n || a
                    }(e, s)) {
                    this._planInfo = {
                        current: s,
                        previous: e
                    }, this._updatePlanExpirationTimer(s.expiresAt);
                    await this._shouldSkipRequirementChange(e, s) || this.change("plan-has-been-updated")
                } else n && function(e, t) {
                    var s, n;
                    if (!t || !e) return t !== e;
                    if (t.type !== e.type) return !0;
                    if ("card" !== t.type) return t.extra !== e.extra;
                    if (!t.cardExpirationDate || !e.cardExpirationDate) return !1;
                    const a = 0 < Math.abs(t.cardExpirationDate.getTime() - (null != (s = null == (n = e.cardExpirationDate) ? void 0 : n.getTime()) ? s : 0)),
                        o = t.cardType !== e.cardType,
                        r = t.cardLastDigits !== e.cardLastDigits;
                    return a || o || r
                }(t, n) && (this._paymentInfo = {
                    current: n,
                    previous: t
                }, this.reason || this.change("payment-info-has-been-updated"))
            }
            _updatePlanExpirationTimer(e) {
                if (this._planExpirationTimer && clearTimeout(this._planExpirationTimer), !e) return;
                const t = Date.now(),
                    s = e ? e.getTime() - t : null;
                if (s && 0 < s) {
                    const t = 2147483647,
                        n = s > t;
                    this._planExpirationTimer = setTimeout((() => {
                        n ? this._updatePlanExpirationTimer(e) : (this.team.isExpired && this.change("plan-has-expired"), this._planExpirationTimer = null)
                    }), n ? t : s)
                }
            }
            async _shouldSkipRequirementChange(e, t) {
                var s;
                if (!t.isBusiness || e.isBusiness) return !1;
                const n = await this.team.business.fetch();
                return 1 < (null != (s = await (null == n ? void 0 : n.teams.fetchCount())) ? s : 1)
            }
        }
        class r {
            constructor(e) {
                this._items = new Map, this._synchronize = e
            }
            get(e) {
                const t = this._items.get(e);
                if (t) return t;
                const s = new o({
                    team: e,
                    onTeamDelete: () => this.delete(e),
                    synchronize: this._synchronize
                });
                return this._items.set(e, s), s
            }
            set(e, t, s) {
                this.get(e).change(t, s)
            }
            delete(e) {
                var t;
                null == (t = this._items.get(e)) || t._teamSubscription.unsubscribe(), this._items.delete(e)
            }
            clear() {
                this._items.forEach((e => e._teamSubscription.unsubscribe())), this._items.clear()
            }
        }
        var i = s(1455),
            c = s(4);
        const l = a.isElectron ? ["1mo", "2mo", "3mo", "4mo", "5mo", "6mo", "7mo", "8mo", "9mo", "10mo", "12mo", "15mo", "20mo", "25mo", "30mo", "40mo", "50mo", "60mo", "75mo", "100mo"].map((e => "com.nozbe4mac.iap.premium." + e)) : ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "12", "15", "20", "25", "30", "40", "50", "60", "75", "100", "trial.5", "trial.7", "trial.10", "trial.15", "trial.20", "trial.30", "trial.50", "trial.75a", "trial.100"].map((e => "com.nozbe4.premium." + e)),
            d = e => l.find((t => t.includes("trial." + e))),
            u = ({
                productId: e,
                localizedPrice: t,
                price: s
            }) => {
                const n = (e => parseInt(e.split(".").pop(), 10))(e),
                    a = !e.endsWith("y"),
                    o = a ? s : s / 12;
                return {
                    id: e,
                    maxTeamMembers: n,
                    isMonthly: a,
                    nativeLocalizedPrice: t,
                    priceMonthly: o,
                    priceYearly: a ? 12 * s : s,
                    priceDaily: NaN,
                    priceUser: (null != o ? o : 0) / n,
                    webUrlOrNativeId: e,
                    trialWebUrlOrNativeId: d(n),
                    expiresAt: new Date(0)
                }
            },
            m = (0, c.sortBy)((0, c.prop)("maxTeamMembers"));
        const h = async ({
            native: e,
            api: t,
            team: s,
            reason: n,
            isRenewal: o,
            isPromo: r
        }) => {
            const {
                planInfo: d
            } = s;
            if (!d.shouldUseIAP || r) return (0, i.Z)({
                native: e,
                api: t,
                team: s,
                reason: n,
                isRenewal: o
            });
            const h = await async function(e) {
                let t, s;
                if (await c.delayedRetry([0, 500, 3e3], (async () => {
                        try {
                            return t = await e(), !0
                        } catch (e) {
                            return a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.API_ERROR).warn("IAP error (might retry): " + e.message), s = e, !1
                        }
                    }))) return t;
                throw s
            }((() => e.inAppPurchases.getProductInfo(l)));
            invariant(h && h.products && 0 < h.products.length, "Invalid payments product list");
            const {
                products: p,
                currency: g
            } = h, f = p.filter((({
                productId: e
            }) => (invariant("string" == typeof e, "Invalid IAP productId"), !e.includes("trial") && !e.endsWith("y")))).map(u), b = f.some((e => e.trialWebUrlOrNativeId));
            return {
                currency: g,
                version: 0,
                plansMonthly: m(f),
                plansYearly: [],
                isTrialAvailable: b
            }
        }, p = (e, t = 1e4) => new Promise(((s, n) => {
            setTimeout(n, t, new Error(e))
        })), g = async e => e.currentTeam ? e.currentTeam : e.member ? e.member.team.fetch() : e.project.getCurrentTeam();
        class f {
            constructor({
                database: e,
                native: t,
                getApi: s,
                synchronize: n
            }) {
                this._database = e, this._native = t, this._getApi = s, this._synchronize = n, this.requirements = new r(n)
            }
            async canInvokeAction(e) {
                switch (e.name) {
                    case "create-projects":
                        return e.currentTeam.canCreateOpenProjects(e.projectsCount);
                    case "create-project-template":
                        return e.currentTeam.canCreateProjectTemplate();
                    case "invite-to-project":
                        return e.currentTeam.canInviteToProject();
                    case "create-any-tag":
                        return e.currentTeam.canCreateAnyTag();
                    case "create-team-tag":
                        return e.currentTeam.canCreateSharedTag();
                    case "create-private-tag":
                        return e.currentTeam.canCreatePrivateTag();
                    case "invite-to-team":
                        return e.currentTeam.canInviteMembers(e.membersCount);
                    case "grant-admin":
                        return e.member.canBePromotedToAdminDueToLimits();
                    case "create-section":
                        return e.project.canCreateSection();
                    case "enable-time-attributes":
                        return e.project.canEnableTimeAttributes();
                    case "create-member-group":
                        return e.currentTeam.canCreateMemberGroup();
                    case "create-project-group":
                        return e.currentTeam.canCreateProjectGroup();
                    case "3rd-party-import":
                        return !e.currentTeam.isFree
                }
                return !1
            }
            proposeUpgrade(e, t, s) {
                this.requirements.set(e, t, s)
            }
            remindExpired(e) {
                return !!e.isExpired && (this.requirements.set(e, "plan-has-expired"), !0)
            }
            async invokeActionOrProposeUpgrade(e, t) {
                const s = await g(e);
                if (s.isExpired) return this.requirements.set(s, "plan-has-expired"), !1;
                if (!await this.canInvokeAction(e) && !await this.seamlessUpgrade(e)) {
                    const t = "invite-to-team" === e.name ? {
                        invitedMembersCount: e.membersCount
                    } : {};
                    return this.proposeUpgrade(s, e.name, t), !1
                }
                return await t(), !0
            }
            async seamlessUpgrade(e) {
                const t = await g(e),
                    {
                        name: s
                    } = e;
                if (!await this.canSeamlessUpgrade(t, s)) return !1;
                try {
                    const a = await this.getPricing(t, s),
                        o = (() => {
                            const {
                                isMonthly: e,
                                isBusiness: s
                            } = t.planInfo;
                            return s ? e ? a.businessPlansMonthly : a.businessPlansYearly : e ? a.plansMonthly : a.plansYearly
                        })();
                    invariant(o, "Missing plans for seamless upgrade");
                    const r = await n.takeFirst(t.billableMembersCount),
                        i = "invite-to-team" === e.name ? e.membersCount : 0,
                        c = o.find((e => e.maxTeamMembers >= r + i));
                    return !!c && (await this.paylessPlanChange({
                        planType: c.id,
                        teamId: t.id,
                        isRecurring: t.planInfo.isRecurring
                    }), await this._synchronize(), !0)
                } catch (e) {
                    return !1
                }
            }
            async canSeamlessUpgrade(e, t) {
                if ("invite-to-team" === t) {
                    if (e.isFreeOrTrial || e.planInfo.isProvidedByIAP) return !1;
                    const t = await n.takeFirst(e.currentMember);
                    return await n.takeFirst(t.hasAdminPowers)
                }
                return !1
            }
            async getPricing(e, t, s = !1, n = !1) {
                const o = p("Pricing fetch timeout"),
                    r = (a.isMAS ? h : i.Z)({
                        api: this._getApi(),
                        native: this._native,
                        team: e,
                        reason: t,
                        isRenewal: s,
                        isPromo: n
                    });
                return Promise.race([r, o])
            }
            async paylessPlanChange({
                teamId: e,
                planType: t,
                isRecurring: s,
                credits: n
            }) {
                await Promise.race([this._getApi().payments.paylessPlanChange(e, t, s, n), p("Payless plan change timeout")])
            }
            async startTrial(e) {
                await this._getApi().payments.paylessPlanChange(e, "trial", !1)
            }
            async buyInAppPurchase({
                productId: e,
                userId: t,
                team: s
            }) {
                try {
                    a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_ID).log("[IAP] Purchasing " + e);
                    const n = await (async () => {})(),
                        o = await this._native.inAppPurchases.purchase(e, t, n);
                    a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[IAP] IAP purchase successful"), this._verifyReceiptAndFinish(o, s)
                } catch (e) {
                    throw a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.NATIVE_ERROR).error("[IAP] Unsuccessful purchase", e), e
                }
            }
            async _completeInAppPurchaseAtLaunch(e) {
                try {
                    const {
                        transactionId: t
                    } = e;
                    a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_ID).log("[IAP] completeInAppPurchaseAtLaunch: " + t), await this._verifyReceiptAndFinish(e, null)
                } catch (e) {
                    a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.NATIVE_ERROR).error("[IAP] Could not complete IAP at launch", e)
                }
            }
            async _verifyReceiptAndFinish(e, t) {
                await this._getApi().payments.verifyReceipt({
                    provider: "apple",
                    team: t,
                    base64Receipt: e.receipt,
                    productId: e.productId
                }), a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[IAP] Backend verification successful"), await this._native.inAppPurchases.finishTransaction(e.transactionId, e.receipt), a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[IAP] Transation finished"), await this._synchronize()
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(14),
            a = s(5),
            o = s(4),
            r = s(17);
        class i {
            constructor(e) {
                this._app = e
            }
            _getScene() {
                const [e] = [...this._app.scenes];
                if (!e) return null;
                const [, t] = e;
                return t
            }
            _onScene(e, t) {
                const s = this._app.scenes.get(e);
                s && t(s)
            }
            async _getFromId(e, t) {
                const s = (() => {
                    switch (t) {
                        case "single_tasks":
                        case "project":
                            return r.Tables.projects;
                        case "messages":
                        case "task":
                            return r.Tables.tasks;
                        case "tag":
                            return r.Tables.tags;
                        default:
                            throw Error("[Bridge] Unknown page type: " + t)
                    }
                })();
                try {
                    return await this._app.collections.get(s).find(e)
                } catch (t) {
                    await this._app.sync.synchronize();
                    return await this._app.collections.get(s).find(e).catch((() => null))
                }
            }
            async createPath(e, t, s) {
                if (!t) return null;
                const o = await this._getFromId(t, s);
                if (!o) return a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_ID).error("Could not find record: " + e.id + "/" + t + "(" + s + ")"), null;
                switch (s) {
                    case "project":
                        return (0, n.smartPathToProject)(e, o);
                    case "task": {
                        const t = await o.fetchCurrentProject();
                        return (0, n.smartPathToTask)(e, t, o.id)
                    }
                    case "messages":
                        return (0, n.smartPathToThread)(e, o.id);
                    case "tag":
                        return (0, n.smartPathToTag)(e, o);
                    default:
                        throw Error("[Bridge] Unknown page type: " + s)
                }
            }
            async _handleNotification(e) {
                const {
                    action: t,
                    workspace_id: s,
                    task_id: n
                } = e;
                this._app._addDebugLog("[NOTIFICATION] action: " + (null != t ? t : "null") + " team_id: " + s), this.openPage({
                    action: t,
                    team_id: s,
                    page_id: n,
                    page_type: n ? "task" : "incoming"
                })
            }
            async openPage(e) {
                await o.delayedRetry([0, 50, 100, 200, 500, 750, 1e3, 2e3], (async () => !!this._getScene() && (this._openPage(e), !0)))
            }
            async _openPage(e) {
                const t = this._getScene();
                if (this._app._addDebugLog("[NOTIFICATION] has scene: " + (t ? "yes" : "no")), !t) return void a.PROD_CONSOLE(a.PROD_CONSOLE_REASON.SAFE_LITERAL).error("Could not open page, scene is not ready");
                if (e.raw_path) return void t.router.goTo({
                    path: e.raw_path,
                    hash: e.action
                });
                const {
                    page_id: s,
                    page_type: o,
                    team_id: i,
                    action: c
                } = e, l = await this._app.collections.get(r.Tables.teams).find(i), d = c ? "#" + c : null;
                switch (this._app._addDebugLog("[NOTIFICATION] has team: " + (l ? "yes" : "no") + ", actionHash: " + (null != d ? d : "null")), o) {
                    case "priority":
                        return void t.router.goTo(Object.assign({}, (0, n.pathToPriority)(l), {
                            hash: d
                        }), void 0, !!d);
                    case "incoming":
                        return void t.router.goTo(Object.assign({}, (0, n.pathToIncoming)(l), {
                            hash: d
                        }), void 0, !!d);
                    case "activity":
                        return void t.router.goTo(Object.assign({}, (0, n.pathToActivity)(l), {
                            hash: d
                        }), void 0, !!d);
                    case "single_tasks":
                        return void t.router.goTo(Object.assign({}, (0, n.pathToSingleTasks)(l), {
                            hash: d
                        }), void 0, !!d);
                    case "messages":
                    case "project":
                    case "tag":
                    case "task": {
                        const e = await this.createPath(l, s, o);
                        return void(e && t.router.goTo(Object.assign({}, e, {
                            hash: d
                        }), void 0, !!d))
                    }
                    default:
                        throw Error("unexpected page_type " + o)
                }
            }
        }
        class c extends i {
            call(e, t) {
                const s = this[e];
                s && s.bind(this)(...t)
            }
            synchronize() {
                this._app.sync.synchronize()
            }
            handleNotification(e) {
                this._handleNotification(e)
            }
            keyCommandInvoked(e, t) {
                this._onScene(e, (e => {
                    e.shortcuts.invoke(t)
                }))
            }
            setIsUpdateAvaliable() {
                this._app.appState.isUpdateAvaliable.next(!0)
            }
            async completeInAppPurchase(e) {
                this._app.payments._completeInAppPurchaseAtLaunch(e)
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(8),
            a = s(5);

        function o() {
            ! function() {
                let e = 0;
                const t = new n.BehaviorSubject(null),
                    s = n.of(null).pipe(n.switchMap((() => t.pipe(n.tap((() => {
                        e += 1
                    })))))).subscribe();
                setTimeout((() => {
                    t.next(null), invariant(2 === e, "Rx self-test is broken"), s.unsubscribe(), setTimeout((() => {
                        t.next(null), invariant(2 === e, "Rx is terribly broken"), 2 === e && (0, a.PROD_CONSOLE)(a.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[selftest] Rx ok")
                    }), 0)
                }), 0)
            }()
        }
    }, (e, t, s) => {
        "use strict";
        async function n(e) {
            s(516), s(570), e.localization.formatMessage("F_", {
                taskCount: 0
            })
        }
        s.d(t, {
            Z: () => n
        })
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => fe
        });
        var n = s(0),
            a = s(354),
            o = s(207),
            r = s(37),
            i = s(355),
            c = s(86),
            l = s(167),
            d = s(81),
            u = s(103),
            m = s(199),
            h = s(126),
            p = s(330),
            g = s(530),
            f = s(14),
            b = s(79),
            y = s(132),
            v = s(91),
            w = s(1);
        const k = n.Hocs.compose(n.Hocs.withWebLazyRender((({
            isBelowTheFold: e
        }) => ({
            forceShow: !e,
            spacerHeight: 40
        }))))((e => {
            const {
                project: t,
                isPrivate: s,
                team: a,
                counter: o,
                hasDescription: r,
                hasHairline: i,
                onPress: c,
                groups: l,
                showFavFollowIcon: d = !0,
                highlightRanges: u,
                onLongPress: m
            } = e, h = n.Hooks.useIntl(), p = r ? ((e, t, s) => e.endedAt ? s.g("Ee", {
                date: s.formatDate(e.endedAt)
            }) : (0, y.S)(t))(t, l, h) : null, {
                isShared: g,
                hasPendingInvitation: k,
                isFavorite: x,
                isFollowed: j
            } = t, T = g || k ? "Ĺ" : s ? "ŀ" : null, S = n.Styling.getProjectName(t, h), P = n.React.useMemo((() => (0, f.smartPathToProject)(a, t)), [a, t]);
            return (0, w.jsx)(b.Z, {
                linkTo: P,
                title: S,
                formattedTitle: u ? (0, w.jsx)(v.Z, {
                    text: S,
                    ranges: u
                }) : S,
                onPress: c,
                isEnded: t.isEnded,
                icon: n.Styling.getProjectIcon(t),
                isFavorite: x,
                isFollowed: j,
                showFavFollowIcon: d,
                iconColor: n.Styling.getProjectIconColor(t),
                counter: o,
                description: p,
                hasHairline: i,
                statusIcon: T,
                statusIconColor: k && !g ? "onBackground2" : void 0,
                hasUnreadDot: !t.lastSeenEventAt,
                onLongPress: m
            })
        }));
        var x = s(332),
            j = s(139);
        const T = n.Hocs.compose(n.Hocs.withWebLazyRender((({
            isBelowTheFold: e
        }) => ({
            forceShow: !e,
            spacerHeight: 40
        }))))((e => {
            const {
                tag: t,
                team: s,
                hasHairline: a,
                onPress: o,
                showFavFollowIcon: r = !0,
                counter: i,
                onLongPress: c
            } = e, {
                isFavorite: l
            } = t.asSidebarFavoritable(s), d = n.React.useMemo((() => (0, f.smartPathToTag)(s, t)), [s, t]);
            return (0, w.jsx)(b.Z, {
                linkTo: d,
                title: t.name,
                onPress: o,
                hasHairline: a,
                iconColor: t.color,
                isEnded: t.isArchived,
                isFavorite: l,
                showFavFollowIcon: r,
                icon: n.Styling.defaultTagIcon(t.icon),
                counter: i,
                statusIcon: t.isPrivate ? "ŀ" : null,
                onLongPress: c
            })
        }));
        var S = s(62),
            P = s(96),
            _ = s(50);
        const C = "other",
            R = "list_header",
            A = n.ReactUtils.lazy((() => s(1287))),
            I = n.Hocs.compose()((e => {
                const {
                    itemConfig: t,
                    newProjectBadge: s,
                    projectGroupsSetting: a,
                    isCollapsed: o,
                    onToggleSection: r,
                    isShowingThePast: i,
                    onToggleShowingThePast: c,
                    switchSidebarContent: l,
                    onLongPress: d,
                    onAddNewProjectPress: m,
                    testId: h,
                    sectionIndex: p
                } = e, {
                    section: g
                } = t, {
                    root: f
                } = g, b = n.Hooks.useIntl(), y = n.Hooks.useModalState(), v = ((e, t, s) => {
                    const a = e.root;
                    var o;
                    if (a instanceof n.Model.Models.ProjectGroup) return {
                        title: a.name,
                        sort: (null == (o = t[a.id]) ? void 0 : o.sort) || {
                            by: n.Model.SidebarGroupsSortBy.Name,
                            order: "ascending"
                        },
                        hasPlusIcon: !0
                    };
                    switch (a.id) {
                        case n.Model.SidebarBuiltinGroups.ProjectsActive:
                            return {
                                title: s.f.EF, sort: a.sort, hasPlusIcon: !0
                            };
                        case n.Model.SidebarBuiltinGroups.ProjectsFollowed:
                            return {
                                title: s.f.EE, sort: a.sort, hasPlusIcon: !0
                            };
                        case n.Model.SidebarBuiltinGroups.Favorites:
                            return {
                                title: s.f.D2, sort: a.sort, hasPlusIcon: !1
                            };
                        case C:
                            return {
                                title: s.f.D6, sort: null, hasPlusIcon: !1
                            };
                        default:
                            return null
                    }
                })(g, a, b);
                if (!v) return null;
                const {
                    title: k,
                    sort: x,
                    hasPlusIcon: j
                } = v;
                return (0, w.jsxs)(w.Fragment, {
                    children: [(0, w.jsx)(P.Z, {
                        id: t.item.id,
                        type: "SECTION",
                        position: p,
                        useCustomDragHandle: !0,
                        children: ({
                            dragHandleProps: e
                        }) => (0, w.jsx)(u.pF, {
                            title: k,
                            toggleSection: r,
                            isCollapsed: o,
                            onPlusIconPress: j ? () => m(g) : void 0,
                            plusTestId: j ? n.Misc.testIds.sidebar_addProject : void 0,
                            plusIconBadge: j ? s : void 0,
                            plusA11yLabel: j ? b.f.Eb : void 0,
                            rootTestId: h,
                            targetRef: y.target,
                            onThreeDotPress: g.root.id !== C ? y.open : void 0,
                            onLongPress: d,
                            groupDragHandle: e
                        })
                    }), y.isOpen && x ? (0, w.jsx)(A, {
                        root: f,
                        closeMenu: y.close,
                        target: y.target,
                        isShowingThePast: i,
                        onToggleShowingThePast: c,
                        sort: x,
                        switchSidebarContent: l,
                        onAddNewProject: j ? () => {
                            y.close(), m(g)
                        } : void 0
                    }) : null]
                })
            }));
        var N = s(160),
            E = s(130),
            O = s(82),
            M = s(11),
            D = s(18),
            H = s(13),
            F = s(551);
        const Z = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withObservables(["linkTo"], (({
            services: e,
            linkTo: t
        }) => ({
            isActive: t ? e.history.matchesPath(t) : n.Rx.of(!1)
        }))))((e => {
            const {
                linkTo: t,
                onPress: s,
                title: a,
                icon: o,
                color: r,
                count: i,
                testId: c,
                isActive: l
            } = e;
            invariant((t || s) && !(t && s), "Box must have either linkTo or onPress, but not both at the same time");
            const d = n.Hooks.useDense(),
                u = n.Styling.factoryColor(r),
                m = n.React.useContext(E.l),
                h = m ? (0, N.Z)(u).brighten(15).toRgbString() : u,
                p = (0, w.jsxs)(M.Z, {
                    className: F.Z.container + (d ? " " + F.Z.containerDense : "") + " " + (e.className || ""),
                    style: Object.assign({
                        backgroundColor: n.Styling.rgba(u, m ? .3 : .08),
                        borderColor: l ? n.Styling.rgba(u, .7) : undefined,
                        "--hover-border-color": n.Styling.rgba(u, .2)
                    }, e.style),
                    webComponent: "div",
                    testId: c,
                    onPress: s,
                    children: [(0, w.jsx)(D.default, {
                        className: F.Z.title,
                        style: {
                            color: h
                        },
                        adjustsFontSizeToFit: !0,
                        children: a
                    }), (0, w.jsxs)("div", {
                        className: F.Z.bottomRow,
                        children: [(0, w.jsx)("span", {
                            className: F.Z.count,
                            style: {
                                color: h
                            },
                            children: i
                        }), (0, w.jsx)(H.default, {
                            name: o,
                            size: 22,
                            color: r
                        })]
                    })]
                });
            return (0, w.jsx)("div", {
                className: F.Z.root,
                children: (0, w.jsx)((({
                    children: e
                }) => t ? (0, w.jsx)(O.Z, {
                    to: t,
                    force: !0,
                    children: e
                }) : e), {
                    children: p
                })
            })
        }));
        var L = s(553);
        const B = n.ReactUtils.lazy((() => s(559))),
            z = n.ReactUtils.lazy((() => s(562))),
            U = n.Hocs.compose()((e => {
                const {
                    banners: t,
                    onBrokenBanner: s,
                    promoBanner: n
                } = e;
                return (0, w.jsxs)(B, {
                    children: [n ? (0, w.jsx)(z, {
                        promoSetting: n
                    }, "internal_promo_banner") : null, t.map((e => (0, w.jsx)(L.Z, {
                        banner: e,
                        onContentMissing: () => s(e)
                    }, e.name)))]
                })
            }));
        var W = s(360);
        const G = (e, t) => {
                const {
                    item: s,
                    index: n
                } = e;
                switch (s.type) {
                    case "PROJECT":
                        return Object.assign({}, e, {
                            item: s,
                            type: "PROJECT_ITEM",
                            layout: {
                                length: 48,
                                offset: t + 48,
                                index: n
                            }
                        });
                    case "MEMBER":
                        return Object.assign({}, e, {
                            item: s,
                            type: "MEMBER_ITEM",
                            layout: {
                                length: 48,
                                offset: t + 48,
                                index: n
                            }
                        });
                    case "TAG":
                        return Object.assign({}, e, {
                            item: s,
                            type: "TAG_ITEM",
                            layout: {
                                length: 48,
                                offset: t + 48,
                                index: n
                            }
                        });
                    case "FIXED":
                        return Object.assign({}, e, {
                            item: s,
                            type: "FIXED_ITEM",
                            layout: {
                                length: 48,
                                offset: t + 48,
                                index: n
                            }
                        });
                    case "BOXES":
                        return Object.assign({}, e, {
                            item: s,
                            type: "BOX_ITEM",
                            layout: {
                                length: 150,
                                offset: t + 150,
                                index: n
                            }
                        });
                    case "BANNERS":
                        return Object.assign({}, e, {
                            item: s,
                            type: "BANNER_ITEM",
                            layout: {
                                length: 165,
                                offset: t + 165,
                                index: n
                            }
                        });
                    case "PENDING":
                        return Object.assign({}, e, {
                            item: s,
                            type: "PENDING_ITEM",
                            layout: {
                                length: 48,
                                offset: t + 48,
                                index: n
                            }
                        });
                    default:
                        return s.type
                }
            },
            V = ({
                team: e,
                switchSidebarContent: t,
                shouldRenderPersonalUI: s,
                projectGroupsSetting: a,
                toggleCollapsedGroup: o,
                toggleGroupShowingThePast: r,
                sections: i,
                currentMember: c,
                onTrialExplainerPress: l,
                onAccountMergesPickerOpen: d,
                onProjectInvitationsPickerOpen: u,
                onTaskInvitationsPickerOpen: m,
                onAddNewProjectPress: h,
                onBrokenBanner: p,
                showsCounters: g,
                newProjectBadge: y
            }) => {
                const v = n.Hooks.useIntl();
                return n.React.useCallback(((j, S) => {
                    var _, C;
                    const R = (null == (_ = j.section.sort) ? void 0 : _.by) === n.Model.SidebarGroupsSortBy.Custom,
                        A = () => {
                            switch (j.type) {
                                case "PROJECT_ITEM":
                                    return (0, w.jsx)(k, {
                                        project: j.item.project,
                                        groups: j.item.groups,
                                        team: j.item.team,
                                        isPrivate: j.item.isPrivate,
                                        isBelowTheFold: !j.position.isAboveTheFold,
                                        showFavFollowIcon: !1,
                                        counter: j.item.counter,
                                        onLongPress: void 0
                                    });
                                case "MEMBER_ITEM":
                                    return (0, w.jsx)(x.default, {
                                        member: j.item.member,
                                        shouldRenderYou: j.item === c,
                                        isBelowTheFold: !j.position.isAboveTheFold,
                                        showFavFollowIcon: !1,
                                        showCounter: g,
                                        onLongPress: void 0
                                    });
                                case "TAG_ITEM":
                                    return (0, w.jsx)(T, {
                                        tag: j.item.tag,
                                        team: e,
                                        isBelowTheFold: !j.position.isAboveTheFold,
                                        showFavFollowIcon: !1,
                                        onLongPress: void 0,
                                        counter: j.item.counter
                                    });
                                case "FIXED_ITEM":
                                    return (({
                                        itemConfig: e,
                                        switchSidebarContent: t,
                                        shouldRenderPersonalUI: s,
                                        intl: a,
                                        currentTeam: o,
                                        onTrialExplainerPress: r
                                    }) => {
                                        switch (e.item.id) {
                                            case "TAGS":
                                                return (0, w.jsx)(b.Z, {
                                                    title: a.f.uz,
                                                    icon: "Ɲ",
                                                    onPress: t,
                                                    onPressExtraParam: "tags"
                                                });
                                            case "TEAM":
                                                return (0, w.jsx)(b.Z, {
                                                    title: s ? a.f.ED : a.f.EH,
                                                    testId: n.Misc.testIds.sidebar_team,
                                                    icon: "ơ",
                                                    onPress: t,
                                                    onPressExtraParam: "team"
                                                });
                                            case "PROJECTS_GROUPS":
                                                return (0, w.jsx)(b.Z, {
                                                    title: a.f.D7,
                                                    icon: "°",
                                                    onPress: t,
                                                    onPressExtraParam: "projectsGroups"
                                                });
                                            case "PROJECTS_TEMPLATES":
                                                return (0, w.jsx)(b.Z, {
                                                    title: a.f.D$,
                                                    icon: "ƣ",
                                                    onPress: t,
                                                    onPressExtraParam: "projectsTemplates"
                                                });
                                            case "ACTIVE_PROJECTS":
                                                return (0, w.jsx)(b.Z, {
                                                    title: a.f.EF,
                                                    icon: "ş",
                                                    onPress: t,
                                                    onPressExtraParam: "projects"
                                                });
                                            case "TRIAL_EXPLAINER":
                                                return (0, w.jsx)(b.Z, {
                                                    onPress: r,
                                                    title: a.f.EI,
                                                    icon: "·",
                                                    iconColor: "purple",
                                                    textColor: "purple"
                                                });
                                            case "ACTIVITY":
                                                return (0, w.jsx)(b.Z, {
                                                    linkTo: (0, f.pathToActivity)(o),
                                                    title: a.f.y,
                                                    icon: "±",
                                                    iconColor: "activity",
                                                    testId: n.Misc.testIds.sidebar_activity,
                                                    counter: e.item.count
                                                });
                                            case "CALENDAR":
                                                return (0, w.jsx)(b.Z, {
                                                    linkTo: (0, f.pathToCalendar)(o),
                                                    title: a.f.Ed,
                                                    icon: "R"
                                                });
                                            case "MESSAGES": {
                                                const t = 0 < e.item.unreadThreadsCount;
                                                return (0, w.jsx)(b.Z, {
                                                    linkTo: (0, f.pathToMessages)(o),
                                                    title: a.f.Kc,
                                                    iconColor: t ? "darkgreen" : void 0,
                                                    textColor: t ? "darkgreen" : void 0,
                                                    icon: "Ķ",
                                                    counter: e.item.unreadThreadsCount
                                                })
                                            }
                                            case "DEV_TOOLS":
                                                return (0, w.jsx)(b.Z, {
                                                    linkTo: (0, f.pathToDevTools)(o),
                                                    title: "DEV tools",
                                                    icon: "Ƽ",
                                                    isEnabledOnProduction: !1
                                                });
                                            case "SINGLE_TASKS":
                                                return (0, w.jsx)(b.Z, {
                                                    linkTo: (0, f.pathToSingleTasks)(o),
                                                    title: a.f.EO,
                                                    icon: "ƒ",
                                                    iconColor: "singleTasks",
                                                    counter: e.item.count,
                                                    testId: n.Misc.testIds.sidebar_singleTasks
                                                });
                                            default:
                                                return e.item.id
                                        }
                                    })({
                                        itemConfig: j,
                                        switchSidebarContent: t,
                                        shouldRenderPersonalUI: s,
                                        intl: v,
                                        currentTeam: e,
                                        onTrialExplainerPress: l
                                    });
                                case "BOX_ITEM":
                                    return function({
                                        intl: e,
                                        team: t,
                                        shouldRenderPersonalUI: s,
                                        itemConfig: a
                                    }) {
                                        const {
                                            item: o
                                        } = a;
                                        return (0, w.jsxs)("div", {
                                            className: W.Z.boxes,
                                            children: [(0, w.jsx)(Z, {
                                                title: e.f.zV,
                                                linkTo: (0, f.pathToPriority)(t),
                                                icon: "Ƙ",
                                                color: "priority",
                                                testId: n.Misc.testIds.sidebar_priority,
                                                count: o.priorityCount
                                            }), (0, w.jsx)(Z, {
                                                linkTo: (0, f.pathToIncoming)(t),
                                                title: e.f.ny,
                                                icon: "Ĵ",
                                                color: "incoming",
                                                testId: n.Misc.testIds.sidebar_incoming,
                                                count: o.incomingCount
                                            }), s ? null : (0, w.jsxs)(w.Fragment, {
                                                children: [t.isPersonal ? null : (0, w.jsx)(Z, {
                                                    linkTo: (0, f.pathToActivity)(t),
                                                    title: e.f.y,
                                                    icon: "±",
                                                    color: "activity",
                                                    testId: n.Misc.testIds.sidebar_activity,
                                                    count: o.activityCount
                                                }), (0, w.jsx)(Z, {
                                                    linkTo: (0, f.pathToSingleTasks)(t),
                                                    title: e.f.EG,
                                                    icon: "ƒ",
                                                    color: "singleTasks",
                                                    testId: n.Misc.testIds.sidebar_singleTasks,
                                                    count: o.singleTasksCount
                                                })]
                                            })]
                                        })
                                    }({
                                        intl: v,
                                        team: e,
                                        shouldRenderPersonalUI: s,
                                        itemConfig: j
                                    });
                                case "BANNER_ITEM":
                                    return (0, w.jsx)(U, {
                                        banners: j.item.banners,
                                        promoBanner: j.item.promoBanner,
                                        onBrokenBanner: p
                                    });
                                case "PENDING_ITEM":
                                    return C || (C = (0, w.jsx)(q, {
                                        itemConfig: j,
                                        switchSidebarContent: t,
                                        onAccountMergesPickerOpen: d,
                                        onProjectInvitationsPickerOpen: u,
                                        onTaskInvitationsPickerOpen: m
                                    }));
                                case "SECTION_HEADER": {
                                    if ("onboarding_spacer" === j.section.type) return (0, w.jsx)("div", {
                                        className: W.Z.onboardingSpacer
                                    });
                                    const {
                                        isCollapsed: e
                                    } = j.section, s = i.findIndex((e => e === j.section)), c = "projects_active" === j.section.type ? n.Misc.testIds.sidebar_projectsGroup : void 0;
                                    return (0, w.jsx)(I, {
                                        itemConfig: j,
                                        sectionIndex: s,
                                        projectGroupsSetting: a,
                                        isCollapsed: e,
                                        newProjectBadge: y,
                                        onToggleSection: () => o(j.item.id),
                                        isShowingThePast: j.section.isShowingThePast,
                                        onToggleShowingThePast: () => r(j.item.id),
                                        switchSidebarContent: t,
                                        onAddNewProjectPress: h,
                                        testId: c,
                                        onLongPress: void 0
                                    })
                                }
                                case "SECTION_FOOTER":
                                    return null;
                                default:
                                    return j
                            }
                        };
                    if ((j.section.root.id === n.Model.SidebarBuiltinGroups.Favorites || j.section.root.id === n.Model.SidebarBuiltinGroups.ProjectsFollowed || j.section.root.id === n.Model.SidebarBuiltinGroups.ProjectsActive || j.section.root instanceof n.Model.Models.ProjectGroup) && "SECTION_HEADER" !== j.type && "SECTION_FOOTER" !== j.type) {
                        const e = j.section.root.id + "-" + j.item.id;
                        return (0, w.jsx)(P.Z, {
                            id: e,
                            position: j.position.indexInSection,
                            isDisabled: !R,
                            children: () => A()
                        })
                    }
                    return A()
                }), [v, c, e, t, s, a, o, r, i, l, d, u, m, h, y])
            };

        function q(e) {
            const {
                itemConfig: t,
                switchSidebarContent: s,
                onProjectInvitationsPickerOpen: a,
                onTaskInvitationsPickerOpen: o,
                onAccountMergesPickerOpen: r
            } = e, i = n.Hooks.useIntl(), c = n.Hooks.useServices(), {
                item: l
            } = t;
            switch (l.id) {
                case "JOIN_REQUESTS":
                    return (0, w.jsx)(j.Z, {
                        onPress: s,
                        onPressExtraParam: "team",
                        title: i.f.D5,
                        count: l.count
                    });
                case "PROJECT_INVITATIONS":
                    return (0, w.jsx)(j.Z, {
                        title: i.f.Eg,
                        count: l.invitations.length,
                        onPress: () => {
                            if (1 < l.invitations.length) a();
                            else {
                                const e = l.invitations[0];
                                c.appState.startAcceptingProjectInvitation(e.invitation_id)
                            }
                        }
                    });
                case "TASK_INVITATIONS":
                    return (0, w.jsx)(j.Z, {
                        title: i.f.Ew,
                        count: l.invitations.length,
                        onPress: () => {
                            if (1 < l.invitations.length) o();
                            else {
                                const e = l.invitations[0];
                                c.appState.startAcceptingTaskInvitation(e.invitation_id)
                            }
                        }
                    });
                case "ACCOUNT_MERGES":
                    return (0, w.jsx)(j.Z, {
                        title: i.f.Dh,
                        count: l.merges.length,
                        onPress: () => {
                            if (1 < l.merges.length) r();
                            else {
                                const e = l.merges[0];
                                c.appState.startAcceptingAccountMerge(e)
                            }
                        }
                    });
                default:
                    return l.id
            }
        }
        const Q = (e, t) => {
                const {
                    root: {
                        id: s
                    }
                } = e;
                return (0, w.jsx)(S.Z, {
                    id: "" + _.M.droppable + s,
                    children: t
                }, "droppable-" + s)
            },
            Y = ({
                children: e
            }) => (0, w.jsx)(S.Z, {
                id: "sidebarGroups",
                type: "SECTION",
                children: e
            });
        var J = s(39);
        const K = (e, t, s, a, o) => {
            const r = n.Hooks.useServices(),
                i = n.React.useCallback((async i => {
                    const {
                        source: c,
                        destination: l
                    } = i;
                    l && c && ("SECTION" === i.type ? await async function({
                        destination: e,
                        draggableId: t,
                        services: s,
                        groups: a,
                        currentTeam: o
                    }) {
                        const r = a.find((e => e.id === t));
                        invariant(r, "Unexpected missing draggedGroup");
                        const i = Array.from((0, J.calculateReorders)(r, a, e.index, p.c)),
                            c = [],
                            l = [];
                        i.forEach((([e, t]) => {
                            e instanceof n.Model.Models.ProjectGroup ? c.push([e, t]) : l.push([e, t])
                        }));
                        const d = c.map((([e, t]) => e.prepareUpdate((e => {
                                e.sidebarPosition = t
                            })))),
                            u = Object.fromEntries(l.map((([e, t]) => [e.id, t]))),
                            {
                                database: m,
                                modelRoot: {
                                    settings: h
                                }
                            } = s;
                        await m.write((() => m.batch(d))), await h.reorderSidebarBuiltinGroups(u, o)
                    }({
                        destination: l,
                        services: r,
                        currentTeam: o,
                        groups: a,
                        draggableId: i.draggableId
                    }): await async function({
                        destination: e,
                        source: t,
                        sections: s,
                        currentTeam: n,
                        services: a,
                        projectGroupAssignmentMap: o,
                        projectsPositionMap: r
                    }) {
                        if (e.droppableId !== t.droppableId) return;
                        const i = s.find((e => e.root.id === t.droppableId)),
                            c = s.find((t => t.root.id === e.droppableId));
                        if (!c || !i) return;
                        const l = $({
                            currentTeam: n,
                            droppedSection: c,
                            sourceSection: i,
                            fromIndex: t.index,
                            toIndex: e.index,
                            projectsPositionMap: r,
                            projectGroupAssignmentMap: o
                        });
                        l && await a.db.write((async () => {
                            await a.db.batch(l)
                        }))
                    }({
                        destination: l,
                        source: c,
                        sections: e,
                        currentTeam: o,
                        services: r,
                        projectGroupAssignmentMap: s,
                        projectsPositionMap: t
                    }))
                }), [e, r, o, t, s, a]);
            return i
        };
        const $ = ({
                sourceSection: e,
                droppedSection: t,
                fromIndex: s,
                toIndex: n,
                currentTeam: a,
                projectsPositionMap: o,
                projectGroupAssignmentMap: r
            }) => {
                switch (t.type) {
                    case "favorites":
                        return invariant("favorites" === e.type, "Source section must have the same type as desttination"), X({
                            currentTeam: a,
                            sourceSection: e,
                            droppedSection: t,
                            fromIndex: s,
                            toIndex: n
                        });
                    case "projects_followed":
                        return invariant("projects_followed" === e.type, "Source section must have the same type as desttination"), ee({
                            currentTeam: a,
                            sourceSection: e,
                            droppedSection: t,
                            fromIndex: s,
                            toIndex: n
                        });
                    case "projects_active":
                        return invariant("projects_active" === e.type, "Source section must have the same type as desttination"), te({
                            currentTeam: a,
                            sourceSection: e,
                            droppedSection: t,
                            fromIndex: s,
                            toIndex: n,
                            projectsPositionMap: o
                        });
                    case "projects_group":
                        return invariant("projects_group" === e.type, "Source section must have the same type as desttination"), se({
                            sourceSection: e,
                            droppedSection: t,
                            fromIndex: s,
                            toIndex: n,
                            projectGroupAssignmentMap: r
                        });
                    case "fixed":
                    case "list_header":
                    case "onboarding_spacer":
                        return null;
                    default:
                        return t.type
                }
            },
            X = ({
                sourceSection: e,
                droppedSection: t,
                fromIndex: s,
                toIndex: n,
                currentTeam: a
            }) => {
                const o = e.items[s],
                    r = Array.from((0, J.calculateReorders)(o, t.items, n, (e => {
                        var t;
                        return null != (t = ne(e).asSidebarFavoritable(a).sidebarPosition) ? t : 0
                    }))).map((([e, t]) => {
                        const s = ne(e),
                            n = s.asSidebarFavoritable(a);
                        return s.prepareUpdate((() => {
                            n.sidebarPosition = t
                        }))
                    }));
                return r
            },
            ee = ({
                sourceSection: e,
                droppedSection: t,
                fromIndex: s,
                toIndex: n,
                currentTeam: a
            }) => {
                const o = e.items[s];
                return Array.from((0, J.calculateReorders)(o, t.items, n, (e => e.project.asSidebarFavoritable(a).sidebarPosition))).reduce(((e, [t, s]) => {
                    const {
                        project: n
                    } = t, o = n.asSidebarFavoritable(a);
                    return e.push(n.prepareUpdate((() => {
                        o.sidebarPosition = s
                    }))), e
                }), [])
            },
            te = ({
                sourceSection: e,
                droppedSection: t,
                fromIndex: s,
                toIndex: n,
                currentTeam: a,
                projectsPositionMap: r
            }) => {
                const i = e.items[s];
                return (0, o.A)({
                    draggedItem: i.project,
                    items: t.items.map((e => e.project)),
                    destinationIdx: n,
                    viewId: a.id + "/active_projects",
                    projectsPositionMap: r
                })
            },
            se = ({
                sourceSection: e,
                droppedSection: t,
                toIndex: s,
                fromIndex: n,
                projectGroupAssignmentMap: a
            }) => {
                const o = e.items[n];
                return Array.from((0, J.calculateReorders)(o, t.items, s, (t => {
                    var s, n;
                    return null != (s = null == (n = a[e.root.id][t.id]) ? void 0 : n.sidebarPosition) ? s : 0
                }))).map((([t, s]) => a[e.root.id][t.id].prepareUpdate((e => {
                    e.sidebarPosition = s
                }))))
            };

        function ne(e) {
            switch (e.type) {
                case "PROJECT":
                    return e.project;
                case "MEMBER":
                    return e.member;
                case "TAG":
                    return e.tag;
                default:
                    return e.type
            }
        }
        var ae = s(19);

        function oe(e) {
            var t;
            const {
                groups: s,
                groupedItems: a,
                shouldRenderActiveProjectsSection: o,
                collapsedGroupsState: r,
                groupsShowingThePastState: i,
                projectGroupsSetting: c,
                isNativeOnboardingShown: l
            } = e, d = [], u = function(e) {
                const {
                    joinRequestMembersCount: t,
                    projectInvitations: s,
                    activityCount: n,
                    priorityCount: a,
                    incomingCount: o,
                    singleTasksCount: r,
                    banners: i,
                    promoBanner: c,
                    taskInvitations: l,
                    accountMerges: d,
                    shouldRenderTrialExplainer: u,
                    shouldRenderPersonalUI: m,
                    shouldShowMessages: h,
                    unreadThreadsCount: p
                } = e, g = [{
                    id: "SIDEBAR_BOX",
                    activityCount: n,
                    incomingCount: o,
                    singleTasksCount: r,
                    priorityCount: a,
                    type: "BOXES"
                }];
                (i.length || c) && g.push({
                    id: "BANNERS",
                    banners: i,
                    promoBanner: c,
                    type: "BANNERS"
                });
                0 < t && g.push({
                    id: "JOIN_REQUESTS",
                    count: t,
                    type: "PENDING"
                });
                0 < s.length && g.push({
                    id: "PROJECT_INVITATIONS",
                    invitations: s,
                    type: "PENDING"
                });
                0 < l.length && g.push({
                    id: "TASK_INVITATIONS",
                    invitations: l,
                    type: "PENDING"
                });
                0 < d.length && g.push({
                    id: "ACCOUNT_MERGES",
                    merges: d,
                    type: "PENDING"
                });
                u && g.push({
                    id: "TRIAL_EXPLAINER",
                    type: "FIXED"
                });
                m && 0 < n && g.push({
                    id: "ACTIVITY",
                    type: "FIXED",
                    count: n
                });
                g.push({
                    id: "CALENDAR",
                    type: "FIXED"
                }), m && g.push({
                    id: "SINGLE_TASKS",
                    type: "FIXED",
                    count: r
                });
                h && g.push({
                    id: "MESSAGES",
                    type: "FIXED",
                    unreadThreadsCount: p
                });
                return {
                    root: {
                        id: R
                    },
                    items: g,
                    hasFooter: !1,
                    isCollapsed: !1,
                    isShowingThePast: !1,
                    sort: null,
                    type: "list_header"
                }
            }(e);
            d.push(u), s.forEach((e => {
                if (e instanceof n.Model.Models.ProjectGroup) return d.push(function(e, t, s, n, a) {
                    var o, r, i;
                    const c = t.get(e) || [];
                    return {
                        root: e,
                        items: c,
                        hasFooter: !1,
                        isCollapsed: null != (o = s[e.id]) && o,
                        isShowingThePast: null != (r = n[e.id]) && r,
                        sort: null == (i = a[e.id]) ? void 0 : i.sort,
                        type: "projects_group"
                    }
                }(e, a, r, i, c)), null;
                switch (e.id) {
                    case "favorites":
                        return d.push(function(e, t, s, n) {
                            var a, o, r;
                            const i = null != (a = t.get(e)) ? a : [];
                            return {
                                root: e,
                                items: i,
                                hasFooter: !1,
                                isCollapsed: null != (o = s[e.id]) && o,
                                isShowingThePast: null != (r = n[e.id]) && r,
                                sort: e.sort,
                                type: "favorites"
                            }
                        }(e, a, r, i)), null;
                    case "projects_followed":
                    case "projects_active":
                        return d.push(function(e, t, s, n, a) {
                            var o, r, i;
                            const c = null != (o = t.get(e)) ? o : [],
                                l = {
                                    root: e,
                                    items: c,
                                    hasFooter: !1,
                                    isCollapsed: null != (r = s[e.id]) && r,
                                    isShowingThePast: null != (i = n[e.id]) && i,
                                    sort: e.sort
                                };
                            if ("projects_active" === a) return Object.assign({}, l, {
                                type: "projects_active"
                            });
                            return Object.assign({}, l, {
                                type: "projects_followed"
                            })
                        }(e, a, r, i, e.id)), null;
                    default:
                        return e.id
                }
            }));
            const m = {
                root: {
                    id: C
                },
                items: [...o ? [] : [{
                    id: "ACTIVE_PROJECTS",
                    type: "FIXED"
                }], {
                    id: "TAGS",
                    type: "FIXED"
                }, {
                    id: "TEAM",
                    type: "FIXED"
                }, {
                    id: "PROJECTS_GROUPS",
                    type: "FIXED"
                }, {
                    id: "PROJECTS_TEMPLATES",
                    type: "FIXED"
                }],
                hasFooter: !1,
                isCollapsed: null != (t = r[C]) && t,
                isShowingThePast: !1,
                sort: null,
                type: "fixed"
            };
            return d.push(m), l && d.push({
                root: {
                    id: "onboarding_spacer"
                },
                items: [],
                hasFooter: !1,
                isCollapsed: !1,
                isShowingThePast: !1,
                sort: null,
                type: "onboarding_spacer"
            }), d
        }

        function re(e) {
            return function({
                groups: e,
                groupsShowingThePastState: t,
                projectGroupsSetting: s,
                currentTeam: a,
                intl: o,
                services: r
            }) {
                return n.Rx.combineLatest(e.map((e => {
                    var i;
                    return e instanceof n.Model.Models.ProjectGroup ? (0, h.Dk)({
                        group: e,
                        query: t[e.id] ? e.allProjects : e.activeProjects,
                        sort: (null == (i = s[e.id]) ? void 0 : i.sort) || {
                            by: n.Model.SidebarGroupsSortBy.Name,
                            order: "ascending"
                        },
                        intl: o
                    }) : e.id === n.Model.SidebarBuiltinGroups.ProjectsActive ? (0, h.Pw)({
                        team: a,
                        sort: e.sort || {
                            by: n.Model.SidebarGroupsSortBy.Name,
                            order: "ascending"
                        },
                        intl: o,
                        services: r
                    }) : e.id === n.Model.SidebarBuiltinGroups.Favorites ? (0, h.v5)({
                        team: a,
                        sort: e.sort || {
                            by: n.Model.SidebarGroupsSortBy.Custom
                        },
                        intl: o
                    }) : e.id === n.Model.SidebarBuiltinGroups.ProjectsFollowed ? (0, h.E5)({
                        query: a.followedNotFavoriteProjects,
                        sort: e.sort || {
                            by: n.Model.SidebarGroupsSortBy.Custom
                        },
                        intl: o
                    }) : n.Rx.of([])
                })))
            }(e).pipe(n.Rx.switchMap((t => function(e, {
                services: t,
                showsCounters: s,
                currentTeam: a
            }) {
                const o = new Set;
                e.forEach((e => {
                    e.forEach((e => {
                        e instanceof n.Model.Models.Project && (e.isSingleTasks || e.permissions.isOpen || o.add(e.id))
                    }))
                }));
                const r = Array.from(o),
                    i = t.collections.get(n.Model.Tables.projectAccesses).query(ae.Q.where(n.Model.Columns.projectAccesses.projectId, ae.Q.oneOf(r))),
                    c = s ? e.reduce(((e, t) => (t.forEach((t => {
                        t instanceof n.Model.Models.Project ? e[t.id] = t.activeTasks.observeCount() : t instanceof n.Model.Models.Tag && (e[t.id] = t.tasksInTeam(a).activeTasks.pipe(n.Rx.switchMap((e => e.observeCount()))))
                    })), e)), {}) : null;
                return n.Rx.combineLatestObject({
                    projectAccessesMap: i.observe().pipe(n.Rx.map((e => {
                        const t = new Map;
                        return e.forEach((e => {
                            var s;
                            const n = null != (s = t.get(e.project.id)) ? s : [];
                            t.set(e.project.id, n.concat(e))
                        })), t
                    }))),
                    itemCountersMap: c ? n.Rx.combineLatestObject(c) : n.Rx.of(void 0)
                })
            }(t, e).pipe(n.Rx.map((s => function(e, t, s) {
                const {
                    projectAccessesMap: a,
                    itemCountersMap: o
                } = t;
                return e.map((e => e.map((e => {
                    if (e instanceof n.Model.Models.Project) {
                        return {
                            id: e.id,
                            project: e,
                            type: "PROJECT",
                            team: s,
                            isPrivate: ie(e, a),
                            groups: [],
                            counter: o ? o[e.id] : void 0
                        }
                    }
                    if (e instanceof n.Model.Models.Tag) {
                        return {
                            id: e.id,
                            tag: e,
                            type: "TAG",
                            counter: o ? o[e.id] : void 0
                        }
                    }
                    return {
                        id: e.id,
                        member: e,
                        type: "MEMBER"
                    }
                }))))
            }(t, s, e.currentTeam))), n.Rx.map((t => {
                return s = e.groups, n = t, new Map(s.map(((e, t) => [e, n[t]])));
                var s, n
            }))))))
        }

        function ie(e, t) {
            if (e.isSingleTasks) return !0;
            if (e.permissions.isOpen) return !1;
            const s = t.get(e.id);
            return !s || 2 > s.length
        }
        const ce = s(107).wx,
            le = n.ReactUtils.lazy((() => s(565))),
            de = n.ReactUtils.lazy((() => s(566))),
            ue = n.ReactUtils.lazy((() => s(567))),
            me = () => 0,
            he = () => 56,
            pe = r.d.sidebarGroupCollapsed,
            ge = {},
            fe = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withPersonalUI, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                projectInvitations: e.modelRoot.settings.projectInvitations.observeAll(),
                accountMerges: e.modelRoot.settings.accountMerge.observeAll(),
                taskInvitations: e.modelRoot.settings.taskInvitations.observeAll(),
                showsCounters: e.modelRoot.settings.isSidebarShowingCounters.observe()
            }))), n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t,
                intl: s
            }) => ({
                builtinGroups: e.modelRoot.settings.sidebarBuiltinGroups.forTeam(t),
                projectGroups: t.projectGroupsOnSidebar.pipe((0, a.n4)(s)),
                projectGroupsSetting: e.modelRoot.settings.sidebarProjectGroups.forTeam(t),
                promoBannerSettings: e.modelRoot.settings.observePromoBannerSetting(t),
                priorityCount: t.activePriorityTasksCounter,
                activityCount: t.activityTasksCounter,
                incomingCount: t.incomingTasksCounter,
                singleTasksCount: t.singleAndGrantedTasksCounter,
                activeProjectsCount: t.activeProjects.observeCount(),
                unreadThreadsCount: t.unreadThreadsCounter
            }))), n.Hocs.withObservables(["currentTeam", "shouldRenderPersonalUI"], (({
                currentTeam: e,
                shouldRenderPersonalUI: t
            }) => ({
                shouldShowMessages: t ? n.Rx.of(!1) : e.activeMembers.observeCount().pipe(n.Rx.map((e => 1 < e)))
            }))), n.Hocs.withHooks((({
                builtinGroups: e
            }) => {
                const t = e[n.Model.SidebarBuiltinGroups.ProjectsActive];
                return {
                    shouldRenderActiveProjectsSection: "number" == typeof(null == t ? void 0 : t.position)
                }
            })), n.Hocs.withObservables(["shouldRenderActiveProjectsSection", "currentTeam"], (({
                shouldRenderActiveProjectsSection: e,
                services: t,
                currentTeam: s
            }) => ({
                projectsPositionMap: e ? (0, o.n)(s.id + "/active_projects", t.collections) : n.Rx.of(ge)
            }))), n.Hocs.withHooks((({
                builtinGroups: e,
                projectGroups: t
            }) => {
                const s = n.React.useMemo((() => Object.entries(e).map((([e, t]) => "number" == typeof t.position ? Object.assign({}, t, {
                        id: e
                    }) : null)).filter(Boolean)), [e]),
                    a = n.React.useMemo((() => [...t, ...s].sort(((e, t) => (0, p.c)(e) - (0, p.c)(t)))), [t, s]),
                    o = n.Hooks.useFastLocalStorage(),
                    r = o.get(pe),
                    [i, c] = n.React.useState(r || {}),
                    l = n.React.useCallback((e => {
                        const t = Object.assign({}, i, {
                            [e]: !i[e]
                        });
                        c(t), o.set(pe, t)
                    }), [o, i]),
                    [d, u] = n.React.useState({}),
                    m = n.React.useCallback((e => {
                        u((t => Object.assign({}, t, {
                            [e]: !t[e]
                        })))
                    }), []);
                return {
                    groups: a,
                    collapsedGroupsState: i,
                    toggleCollapsedGroup: l,
                    groupsShowingThePastState: d,
                    toggleGroupShowingThePast: m
                }
            })), n.Hocs.withObservables(["groups", "currentTeam", "projectGroupsSetting", "groupsShowingThePastState", "showsCounters"], (({
                groups: e,
                currentTeam: t,
                intl: s,
                services: n,
                projectGroupsSetting: a,
                groupsShowingThePastState: o,
                showsCounters: r
            }) => ({
                groupedItems: re({
                    groups: e,
                    currentTeam: t,
                    groupsShowingThePastState: o,
                    projectGroupsSetting: a,
                    intl: s,
                    services: n,
                    showsCounters: r
                })
            }))), n.Hocs.withObservables(["projectGroups"], (({
                projectGroups: e
            }) => ({
                projectsGroupAssignmentMap: (0, h.Ks)(e)
            }))), n.Hocs.withFeatureBadges({
                placement: "sidebar_menu_button"
            }), n.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                localizationSettings: e.localization.settings,
                creditsGranted: e.modelRoot.settings.observeCreditsGrantedSetting(),
                isUpdateAvaliable: e.appState.isUpdateAvaliable,
                isNativeOnboardingShown: e.uiState.isNativeOnboardingShown
            }))), n.Hocs.withObservables(["services", "localizationSettings"], (({
                services: e,
                localizationSettings: t
            }) => ({
                newsActivity: e.modelRoot.settings.observeNewsActivitySettings(t.locale)
            }))), n.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                hasCurrentMemberAdminPowers: e.hasAdminPowers
            }))), n.Hocs.withObservables(["hasCurrentMemberAdminPowers", "currentTeam"], (({
                hasCurrentMemberAdminPowers: e,
                currentTeam: t
            }) => ({
                joinRequestMembersCount: e ? t.membersRequestingJoin.observeCount() : n.Rx.of(0)
            }))), n.Hocs.withHooks((e => {
                const {
                    services: t,
                    intl: s,
                    currentMember: a,
                    currentTeam: o,
                    hasCurrentMemberAdminPowers: r,
                    shouldRenderPersonalUI: i,
                    promoBannerSettings: c
                } = e, l = (0, m.Ny)(o), d = (0, m.bg)(o), u = Boolean((null == c ? void 0 : c.is_visible) && c.image_url), h = null == c ? void 0 : c.action, [p, g] = n.Hooks.useStateResettable([], [s.locale]);
                return {
                    newProjectModal: l,
                    newMemberModal: d,
                    showPromoBanner: u,
                    brokenBanners: p,
                    hideBrokenBanner: n.React.useCallback((e => {
                        g((t => {
                            const {
                                name: s
                            } = e;
                            return t.includes(s) ? t : t.concat(s)
                        }))
                    }), [g]),
                    bannerContext: n.React.useMemo((() => ({
                        services: t,
                        intl: s,
                        currentMember: a,
                        currentTeam: o,
                        prefersPersonalUI: i,
                        hasCurrentMemberAdminPowers: r,
                        isShowingSomeOtherPromo: u && ("buy_premium" === h || "buy_business" === h),
                        onOpenNewProjectModal: l.open,
                        onOpenNewMemberModal: d.open
                    })), [a, o, r, s, d.open, l.open, t, i, u, h])
                }
            })), n.Hocs.withObservables(["bannerContext", "brokenBanners"], (({
                bannerContext: e,
                brokenBanners: t
            }) => ({
                banners: (0, g.$)(e, {
                    omitBannersByName: t
                })
            }))))((e => {
                const {
                    groups: t,
                    groupedItems: s,
                    switchSidebarContent: a,
                    shouldRenderPersonalUI: o,
                    shouldRenderActiveProjectsSection: r,
                    projectsPositionMap: m,
                    projectGroupsSetting: h,
                    collapsedGroupsState: p,
                    toggleCollapsedGroup: g,
                    groupsShowingThePastState: f,
                    toggleGroupShowingThePast: b,
                    promoBannerSettings: y,
                    featureBadges: v,
                    creditsGranted: k,
                    newsActivity: x,
                    isUpdateAvaliable: j,
                    projectsGroupAssignmentMap: T,
                    shouldShowMessages: S,
                    joinRequestMembersCount: P,
                    projectInvitations: _,
                    taskInvitations: C,
                    accountMerges: R,
                    currentTeam: A,
                    currentMember: I,
                    hasCurrentMemberAdminPowers: N,
                    services: E,
                    intl: O,
                    activityCount: M,
                    incomingCount: D,
                    priorityCount: H,
                    singleTasksCount: F,
                    activeProjectsCount: Z,
                    banners: L,
                    showPromoBanner: B,
                    unreadThreadsCount: z,
                    newProjectModal: U,
                    newMemberModal: q,
                    hideBrokenBanner: J,
                    isNativeOnboardingShown: $,
                    showsCounters: X,
                    isShowingTeamSwitch: ee
                } = e, te = n.Hooks.useDesktopLayout(), se = n.Hooks.useModalState(), ne = n.Hooks.useModalState(), ae = n.Hooks.useModalState(), re = n.Hooks.useModalState(), ie = n.Hooks.useModalState(), pe = n.React.useMemo((() => B ? y : null), [B, y]), ge = n.React.useMemo((() => I.isOwner && A.isTrial), [I.isOwner, A.isTrial]), fe = n.React.useMemo((() => oe({
                    groups: t,
                    groupedItems: s,
                    collapsedGroupsState: p,
                    groupsShowingThePastState: f,
                    shouldRenderActiveProjectsSection: r,
                    projectGroupsSetting: h,
                    joinRequestMembersCount: P,
                    projectInvitations: _,
                    taskInvitations: C,
                    accountMerges: R,
                    activityCount: M,
                    priorityCount: H,
                    incomingCount: D,
                    singleTasksCount: F,
                    banners: L,
                    promoBanner: pe,
                    shouldRenderTrialExplainer: ge,
                    shouldRenderPersonalUI: o,
                    shouldShowMessages: S,
                    unreadThreadsCount: z,
                    isNativeOnboardingShown: $
                })), [t, s, r, p, f, h, P, _, M, H, D, F, L, pe, C, R, ge, o, S, z, $]), {
                    open: be
                } = U, ye = n.React.useCallback((e => {
                    be({
                        initialProjectGroups: e.root instanceof n.Model.Models.ProjectGroup ? [e.root] : void 0
                    })
                }), [be]), ve = (() => {
                    if (A.isFree) {
                        const e = Z >= A.limits.openProjects;
                        if (N && e) return d.a.Premium
                    }
                })(), we = V({
                    team: A,
                    switchSidebarContent: a,
                    shouldRenderPersonalUI: o,
                    projectGroupsSetting: h,
                    toggleCollapsedGroup: g,
                    toggleGroupShowingThePast: b,
                    sections: fe,
                    currentMember: I,
                    onTrialExplainerPress: ne.open,
                    onAccountMergesPickerOpen: ie.open,
                    onProjectInvitationsPickerOpen: ae.open,
                    onTaskInvitationsPickerOpen: re.open,
                    newProjectBadge: ve,
                    onAddNewProjectPress: ye,
                    onBrokenBanner: J,
                    showsCounters: X
                }), {
                    lastCreditsGrantedAt: ke = 0,
                    lastCreditsSeenAt: xe = 0
                } = k || {}, {
                    lastNewsAt: je,
                    lastSeenNewsAt: Te
                } = x, Se = (() => {
                    if (!se.isOpen) return ke > xe || j ? d.a.Incoming : je > Te ? d.a.Activity : v.placementBadge
                })(), Pe = K(fe, m, T, t, A), _e = te ? 16 : 104;
                return (0, w.jsxs)(u.fC, {
                    children: [(0, w.jsxs)(u.h4, {
                        menuTarget: se.target,
                        children: [(0, w.jsx)(u.z, {
                            className: W.Z.headerText,
                            children: A.name
                        }), (0, w.jsxs)(u.z6, {
                            children: [n.Misc.isElectron ? null : (0, w.jsx)(u.Ov, {
                                icon: "ƅ",
                                accessibilityLabel: O.f.pL,
                                keyboardShortcutID: "global.jumpTo",
                                testId: n.Misc.testIds.sidebar_search,
                                onPress: () => E.uiState.jumpToModal.open()
                            }), (0, w.jsx)(u.Ov, {
                                className: W.Z.menuButton + (se.isOpen ? " " + W.Z.menuButtonActive : ""),
                                icon: "Ɖ",
                                accessibilityLabel: O.f.db,
                                onPress: se.open,
                                badge: Se,
                                testId: n.Misc.testIds.sidebar_settings
                            })]
                        })]
                    }), (0, w.jsx)(c.Z, {
                        onDragEnd: Pe,
                        children: (0, w.jsx)(i.Z, {
                            sections: fe,
                            createItemConfig: G,
                            renderItem: we,
                            estimatedItemSize: 40,
                            getSectionFooterLength: me,
                            getSectionHeaderLength: he,
                            rootRecord: A,
                            renderSectionItemsContainer: Q,
                            extraData: void 0,
                            bottomBarInset: _e,
                            reachesBottomOfScreen: !0,
                            ContentWrapperWeb: Y
                        })
                    }), te ? null : (0, w.jsx)(u.MT, {
                        children: (0, w.jsx)(l.Z, {
                            className: W.Z.quickAddPlusButton,
                            onPress: () => E.uiState.quickAddModal.open(),
                            color: "singleTasks",
                            icon: "ū",
                            accessibilityLabel: O.f.mF
                        })
                    }), se.isOpen ? (0, w.jsx)(ce.AppMenu, {
                        bundle$close: se.close,
                        closeMenu: se.close,
                        target: se.target,
                        isPromo: !!pe
                    }) : null, U.render(), q.render(), ie.isOpen ? (0, w.jsx)(ue, {
                        onClose: ie.close,
                        accountMerges: R
                    }) : null, ae.isOpen ? (0, w.jsx)(de, {
                        onClose: ae.close,
                        invitations: _
                    }) : null, re.isOpen ? (0, w.jsx)(le, {
                        onClose: re.close,
                        invitations: C
                    }) : null]
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => f
        });
        var n = s(0),
            a = s(11),
            o = s(12),
            r = s(213),
            i = s(6),
            c = s(125),
            l = s(252);
        s(2), s(3);
        const d = s(526);
        var u, m = s(1);
        const h = "https://",
            p = "nozbe.app/j/",
            g = [{
                iconName: "Ķ",
                color: "purple",
                size: 200
            }],
            f = n.Hocs.compose(n.Hocs.withObservables(["taskAccess"], (({
                taskAccess: e
            }) => ({
                granteeName: e ? e._grantee.observe().pipe(n.Rx.switchMap((t => (null == t ? void 0 : t.preferredName) || n.Rx.of(e.granteeEmail)))) : n.Rx.of("")
            }))))((e => {
                const {
                    item: t,
                    taskAccess: s,
                    granteeName: f
                } = e, b = t.table === n.Model.Tables.teams, y = n.Hooks.useIsMounted(), v = n.Hooks.useServices(), w = n.Hooks.useIntl(), [k, x, j, T] = n.Hooks.useLoadingState(), [S, P] = n.React.useState(!1), _ = k.result, C = () => {
                    N(!_), P(!1)
                }, R = e => (invariant(e, "Cannot get URL that is null"), b ? "" + h + p + e : e), A = async e => {
                    const t = R(e);
                    await n.ReactUtils.copyToClipboard(t, w.formatMessage), P(!0)
                }, {
                    name: I
                } = t;
                n.Hooks.useAsyncEffect((async e => {
                    try {
                        if (!(b || null != s && s.isGTMLinkActive)) return void(e.isPending() && j(null));
                        x();
                        const n = b ? await v.api.account.getInviteCode(t.id) : await v.api.share.getGTMInvitationLink(t.id),
                            a = b ? n.invitationId : n.invitationUrl;
                        e.isPending() && j(a)
                    } catch (t) {
                        if (e.isPending()) {
                            if (!b) {
                                var n;
                                const e = null == (n = t.originalResponse) ? void 0 : n.status;
                                404 !== e && 409 !== e || j(null)
                            }
                            T(t)
                        }
                    }
                }), [t]);
                const N = async e => {
                    const s = t.id;
                    y.current && x();
                    try {
                        if (e) {
                            const e = b ? await v.api.account.createInviteCode(s) : await v.api.share.createGTMInvitationLink(s);
                            if (e.invitationId && y.current) {
                                const t = b ? e.invitationId : e.invitationUrl;
                                j(t), A(t)
                            }
                        } else b ? await v.api.account.deleteInviteCode(s) : await v.api.share.removeGTMInvitationLink(s), y.current && j(null);
                        b || await v.sync.synchronize()
                    } catch (e) {
                        T(e)
                    }
                }, E = b ? _ ? w.f.JI : w.f.JK : _ ? w.f.HV : w.f.HX, O = b ? w.f.JN : w.f.HY, M = S ? w.f.JL : w.f.fm;
                return (0, m.jsxs)(l.W2, {
                    children: [u || (u = (0, m.jsx)(l.$I, {
                        layers: g
                    })), b ? (0, m.jsx)(l.Dx, {
                        children: w.f.JC
                    }) : null, (0, m.jsx)("div", {
                        className: d.linkContainer,
                        children: (0, m.jsx)(l.dk, {
                            children: b ? w.f.JB : w.f.zj
                        })
                    }), k.isError ? (0, m.jsx)(i.u_.Error, {
                        children: w.f.a3
                    }) : null, k.isError || b || !s || s.isGTMLinkActive || !f ? null : (0, m.jsx)(i.u_.Success, {
                        children: w.g("HW", {
                            granteeName: f
                        })
                    }), (0, m.jsxs)(r.Z, {
                        direction: "column",
                        spacing: 8,
                        children: [(0, m.jsx)("div", {
                            className: d.generateLinkContainer + (_ ? " " + d.notClickableContainer : ""),
                            children: (0, m.jsx)(o.default, {
                                label: E,
                                iconName: _ ? "]" : void 0,
                                color: "purple",
                                iconPosition: "right",
                                variant: _ ? "standard" : "opaque",
                                onPress: _ ? void 0 : C,
                                isDisabled: !_ && k.isLoading || !!s && !s.isGTMLinkActive
                            })
                        }), (0, m.jsxs)("div", {
                            className: d.linkContainer,
                            children: [(0, m.jsxs)("div", {
                                className: d.linkBackground,
                                children: [(0, m.jsx)("span", {
                                    className: d.text,
                                    children: _ ? (0, m.jsxs)(m.Fragment, {
                                        children: [b ? (0, m.jsx)("span", {
                                            className: d.link,
                                            children: p
                                        }) : null, (D = _, invariant(D, "Cannot format link that is null"), "string" == typeof D && D.startsWith(h) ? D.slice(8) : D)]
                                    }) : O
                                }), (0, m.jsx)(a.Z, {
                                    className: d.linkCopyButton + (_ ? "" : " " + d.copyDisabled),
                                    onPress: () => {
                                        A(_)
                                    },
                                    isDisabled: !_,
                                    children: (0, m.jsx)("span", {
                                        className: d.textInCopy + (_ ? "" : " " + d.textDisabled),
                                        children: M
                                    })
                                })]
                            }), (0, m.jsx)(l.hj, {
                                onPress: () => {
                                    const e = R(_);
                                    n.ReactUtils.openEmailUrl({
                                        subject: b ? w.g("JQ", {
                                            itemName: I
                                        }) : w.f.IL,
                                        body: b ? w.g("JF", {
                                            teamName: I,
                                            link: e,
                                            teamCode: _
                                        }) : w.g("HU", {
                                            taskName: I,
                                            link: e
                                        })
                                    })
                                },
                                disabledStyle: !_,
                                isDisabled: !_,
                                children: (0, m.jsx)(l.Fk, {
                                    isDisabled: !_,
                                    children: w.f.JP
                                })
                            })]
                        }), null]
                    }), b ? (0, m.jsx)(c.Z, {
                        hint: w.f.l5,
                        helpPageUrl: n.ReactUtils.helpUrl(w, "management/team/#team_invite")
                    }) : null, (0, m.jsx)(o.default, {
                        label: w.f.JJ,
                        isDisabled: !_ || k.isLoading,
                        marginTop: "small",
                        onPress: C
                    })]
                });
                var D
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n = s(0),
            a = s(1536),
            o = s(198),
            r = (s(6), s(252));
        s(2), s(3);
        const i = s(529);
        var c, l = s(1);
        n.ReactUtils.lazy((() => s(12)));
        const d = n.ReactUtils.lazy((() => s(53))),
            u = [{
                iconName: "æ",
                color: "purple",
                size: 200
            }, {
                iconName: "ç",
                color: "purple",
                opacity: .3,
                size: 200
            }],
            m = n.Hocs.compose()((e => {
                const {
                    setEmails: t,
                    emails: s,
                    onConfirm: m,
                    onClose: h,
                    onCancel: p,
                    validation: g,
                    cancelButtonLabel: f,
                    saveButtonLabel: b,
                    saveEmptyButtonLabel: y,
                    allowMultipleEmails: v
                } = e, w = (n.Hooks.useServices(), n.Hooks.useIntl()), k = s[0].trim().length, x = s[s.length - 1].trim().length, j = !(k && g.isAnyValid && x), T = v ? w.f.JD : w.f.zl;
                return (0, l.jsxs)(l.Fragment, {
                    children: [c || (c = (0, l.jsx)(r.$I, {
                        layers: u
                    })), v && (0, l.jsx)(r.W2, {
                        children: (0, l.jsx)(r.Dx, {
                            children: w.f.JG
                        })
                    }), (0, l.jsx)(r.W2, {
                        children: (0, l.jsx)(r.dk, {
                            children: T
                        })
                    }), (0, l.jsx)(r.W2, {
                        children: v ? (0, l.jsx)(a.Z, {
                            validation: g,
                            placeholder: w.f.uf,
                            onChange: t,
                            values: s,
                            autoFocus: !0,
                            withBorderOnNative: !0,
                            type: "email",
                            autoComplete: "email"
                        }) : (0, l.jsx)(o.Z, {
                            type: "email",
                            autoComplete: "email",
                            placeholder: w.f.uf,
                            onChange: e => t([e]),
                            value: s.length ? s[0] : "",
                            autoFocus: !0
                        })
                    }), v && (0, l.jsx)(r.W2, {
                        children: (0, l.jsx)(r.hj, {
                            onPress: () => {
                                var e;
                                e = [""], t(n.FP.unique([...s.filter((e => e.trim())).map((e => e.toLowerCase())), ...e]))
                            },
                            withLeftMargin: !0,
                            disabledStyle: j,
                            isDisabled: j,
                            children: (0, l.jsx)(r.Fk, {
                                isDisabled: j,
                                children: w.f.fb
                            })
                        })
                    }), null, (0, l.jsxs)("div", {
                        className: i.createButtonContainer,
                        children: [(0, l.jsx)(d, {
                            onPress: async e => {
                                await (null == p ? void 0 : p(e)), h(e)
                            },
                            type: "cancel",
                            label: f || w.f.fh
                        }), (0, l.jsx)(d, {
                            onPress: m,
                            type: "defaultAction",
                            label: !k && y ? y : b || w.f.fz,
                            isDisabled: !g.isAnyValid || !y && !k
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            GN: () => l,
            oT: () => d
        });
        var n = s(0),
            a = s(224),
            o = s.n(a),
            r = s(536),
            i = s(1);
        const c = e => {
                const t = e.replace("&", "");
                if (t.includes(" ")) {
                    const e = t.split(" ").filter(n.FP.identity),
                        s = 2 < e.length ? e.filter((e => e.toLowerCase() !== e && !e.endsWith(".") && !e.startsWith('"') && !e.endsWith('"'))) : e;
                    if (2 <= s.length) {
                        const [e, t] = s;
                        return "" + o().substr(e, 0, 1) + o().substr(t, 0, 1)
                    }
                }
                return "" + (o().substr(t, 0, 1) || "") + (o().substr(t, 1, 1) || "")
            },
            l = e => {
                const {
                    name: t,
                    size: s,
                    color: a
                } = e, [o, r] = n.React.useState(!1);
                return {
                    initials: c(t),
                    size: n.Styling.factoryAvatarSize(s || "normal"),
                    fontSize: n.Styling.factoryAvatarFontSize(s || "normal"),
                    color: n.Styling.factoryColor(a),
                    isImageLoaded: o,
                    onLoad: () => r(!0),
                    onError: () => r(!1)
                }
            },
            d = e => {
                const {
                    color: t,
                    size: s = "normal",
                    isTeam: a
                } = e, o = n.Styling.factoryAvatarDotSize(s), c = n.Styling.factoryAvatarSize(s), l = (c - c * Math.sqrt(2) / 2 - o) / 2 - (a ? n.Styling.vars.avatar.borderSize[s] : 0);
                return (0, i.jsx)("div", {
                    className: r.Z.dot,
                    style: {
                        backgroundColor: t,
                        width: o,
                        height: o,
                        borderRadius: o / 2,
                        borderWidth: n.Styling.vars.avatar.borderSize[s],
                        top: l,
                        right: l
                    }
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(333))),
            r = n.ReactUtils.lazy((() => s(549))),
            i = n.ReactUtils.lazy((() => s(550))),
            c = n.Hocs.compose()((e => {
                const {
                    isShowingThePast: t,
                    onToggleShowingThePast: s,
                    root: c,
                    sort: l,
                    closeMenu: d,
                    target: u,
                    switchSidebarContent: m,
                    onAddNewProject: h
                } = e, p = {
                    closeMenu: d,
                    target: u
                };
                return c instanceof n.Model.Models.ProjectGroup ? (0, a.jsx)(o, Object.assign({}, p, {
                    group: c,
                    isGroupShowingThePast: t,
                    toggleGroupShowingThePast: s,
                    sort: l,
                    onAddNewProject: h
                })) : c.id === n.Model.SidebarBuiltinGroups.Favorites ? (0, a.jsx)(r, Object.assign({}, p, {
                    sort: l
                })) : c.id === n.Model.SidebarBuiltinGroups.ProjectsActive || c.id === n.Model.SidebarBuiltinGroups.ProjectsFollowed ? (0, a.jsx)(i, Object.assign({}, p, {
                    groupRoot: c.id,
                    sort: l,
                    isCustomSortSupported: !0,
                    switchSidebarContent: m,
                    onAddNewProject: h
                })) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => y
        });
        var n = s(0),
            a = s(36);
        const {
            vars: o,
            mixins: r,
            zcolor: i,
            rgba: c
        } = a, {
            size: l,
            spacing: d,
            radius: u,
            color: m,
            layer: h,
            fontWeight: p
        } = o, g = s(563);
        var f = s(1);
        const b = e => {
                const {
                    hoursRemaining: t
                } = e, s = n.Hooks.useIntl();
                return 24 < t ? s.g("B$", {
                    daysRemaining: Math.floor(t / 24),
                    hoursRemaining: t % 24
                }) : 1 <= t ? s.g("B_", {
                    hoursRemaining: t
                }) : null
            },
            y = n.Hocs.compose()((e => {
                const {
                    promoSetting: t
                } = e, s = n.Hooks.useServices(), a = n.Hooks.useIntl(), {
                    expires_at: o
                } = t;
                invariant(o, "Promo expires_at is not set");
                const r = Math.floor((o - Date.now()) / 36e5),
                    i = n.Hooks.useForceUpdate();
                return n.React.useEffect((() => {
                    const e = setInterval(i, 9e5);
                    return () => clearInterval(e)
                }), [i]), n.React.useEffect((() => {
                    s.ab.ongoingPromoBaseline.trackOnce("rendered")
                }), [s.ab]), (0, f.jsxs)("div", {
                    className: g.root,
                    children: [(0, f.jsx)("span", {
                        className: g.text + " " + g.header,
                        children: a.g("Ca", {
                            freeMonths: t.months_free
                        })
                    }), 6 >= r ? (0, f.jsx)("div", {
                        className: g.lastChance,
                        children: (0, f.jsx)("span", {
                            className: g.text + " " + g.lastChanceText,
                            children: a.f.Cb
                        })
                    }) : (0, f.jsx)("span", {
                        className: g.text + " " + g.subtitle,
                        children: a.f.Cc
                    }), (0, f.jsx)("span", {
                        className: g.text + " " + g.countdown,
                        children: (0, f.jsx)(b, {
                            hoursRemaining: r
                        })
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => le
        });
        var n = s(0),
            a = s(206),
            o = s(79),
            r = s(139),
            i = s(167),
            c = s(81),
            l = s(103),
            d = s(199),
            u = s(14),
            m = s(50),
            h = s(86),
            p = s(62),
            g = s(96),
            f = s(354),
            b = s(19),
            y = s(16),
            v = s(126),
            w = s(203),
            k = s(65),
            x = s(1);
        const j = n.ReactUtils.lazy((() => s(333))),
            T = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withHooks((() => {
                const [e, t] = n.Hooks.useToggle(!1);
                return {
                    isShowingThePast: e,
                    toggleShowingThePast: t
                }
            })), n.Hocs.withObservables(["projectGroup"], (({
                projectGroup: e
            }) => ({
                team: e.team
            }))), n.Hocs.withObservables(["projectGroup", "isShowingThePast", "sort", "intl"], (({
                projectGroup: e,
                isShowingThePast: t,
                sort: s,
                intl: a
            }) => ({
                projectsWithGroupAssignment: (s ? (0, v.E5)({
                    query: t ? e.allProjects : e.activeProjects,
                    sort: s,
                    intl: a
                }).pipe() : e.activeProjects.pipe((0, k.T9)(a))).pipe(n.Rx.switchMap((t => n.Rx.combineLatestTuples(t.map((t => [t, t.groupAssignments.extend(b.Q.where(y.o.groupAssignments.groupId, e.id)).observeWithColumns([n.Model.Columns.groupAssignments.sidebarPosition]).pipe(n.Rx.map((([e]) => e)))])))))).pipe(n.Rx.map((e => (null == s ? void 0 : s.by) !== n.Model.SidebarGroupsSortBy.Custom ? e : (0, f.Nz)(e, a))))
            }))))((e => {
                const {
                    projectGroup: t,
                    projectsWithGroupAssignment: s,
                    showsCounters: a,
                    sort: o,
                    isShowingThePast: r,
                    toggleShowingThePast: i,
                    groupDragHandle: c,
                    onAddNewProject: d
                } = e, u = n.Hooks.useModalState();
                return (0, x.jsxs)(x.Fragment, {
                    children: [(0, x.jsx)(l.Hz, {
                        id: t.id,
                        name: t.name,
                        isPrivate: t.isPrivate,
                        items: s,
                        renderItem: (e, t) => {
                            const [s, r] = e;
                            return (0, x.jsx)(g.Z, {
                                id: r.id,
                                position: t,
                                type: m.x.SIDEBAR_GROUP_ITEM,
                                isDisabled: (null == o ? void 0 : o.by) !== n.Model.SidebarGroupsSortBy.Custom,
                                children: () => (0, x.jsx)(w.default, {
                                    project: s,
                                    showCounter: a,
                                    showFavFollowIcon: !1
                                }, s.id)
                            }, r.id)
                        },
                        targetRef: u.target,
                        onThreeDotsPress: u.open,
                        onPlusIconPress: d,
                        groupDragHandle: c
                    }), u.isOpen ? (0, x.jsx)(j, {
                        closeMenu: u.close,
                        target: u.target,
                        group: t,
                        sort: o,
                        isGroupShowingThePast: r,
                        toggleGroupShowingThePast: i
                    }) : null]
                })
            }));
        var S = s(39),
            P = s(330);
        const _ = n.ReactUtils.lazy((() => s(1290))),
            C = n.ReactUtils.lazy((() => s(1292))),
            R = n.ReactUtils.lazy((() => s(1293))),
            A = n.Hocs.compose(n.Hocs.withPersonalUI, n.Hocs.withIntl, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t,
                intl: s
            }) => ({
                builtinGroups: e.modelRoot.settings.sidebarBuiltinGroups.forTeam(t),
                projectGroups: t.projectGroupsOnSidebar.pipe((0, f.n4)(s)),
                projectGroupsSetting: e.modelRoot.settings.sidebarProjectGroups.forTeam(t)
            }))))((e => {
                const {
                    shouldRenderPersonalUI: t,
                    projectGroups: s,
                    projectGroupsSetting: a,
                    switchSidebarContent: o,
                    showsCounters: r,
                    onAddNewProject: i
                } = e, c = n.React.useMemo((() => Object.entries(e.builtinGroups).map((([e, t]) => "number" == typeof t.position ? Object.assign({}, t, {
                    id: e
                }) : null)).filter(Boolean)), [e.builtinGroups]), l = n.React.useMemo((() => [...s, ...c].sort(((e, t) => (0, P.c)(e) - (0, P.c)(t)))), [s, c]), {
                    onDragEnd: d
                } = function(e) {
                    const t = n.Hooks.useServices(),
                        {
                            currentTeam: s
                        } = n.Hooks.useIdentity();
                    return {
                        onDragEnd: async a => {
                            if (t.payments.remindExpired(s)) return;
                            const {
                                destination: o,
                                draggableId: r
                            } = a;
                            if (!o) return;
                            const [
                                [i], c
                            ] = n.FP.partition((e => e.id === r), e);
                            if (!i) return;
                            const l = Array.from((0, S.calculateReorders)(i, c, o.index, P.c)),
                                d = [],
                                u = [];
                            l.forEach((([e, t]) => {
                                e instanceof n.Model.Models.ProjectGroup ? d.push([e, t]) : u.push([e, t])
                            }));
                            const m = d.map((([e, t]) => e.prepareUpdate((e => {
                                    e.sidebarPosition = t
                                })))),
                                h = Object.fromEntries(u.map((([e, t]) => [e.id, t]))),
                                {
                                    database: p,
                                    modelRoot: {
                                        settings: g
                                    }
                                } = t;
                            await p.write((() => p.batch(m))), await g.reorderSidebarBuiltinGroups(h, s)
                        }
                    }
                }(l);
                return (0, x.jsx)(h.Z, {
                    onDragEnd: d,
                    children: (0, x.jsx)(p.Z, {
                        id: "sidebarGroups",
                        type: m.x.SIDEBAR_GROUP,
                        children: l.map(((e, s) => (0, x.jsx)(g.Z, {
                            id: e.id,
                            type: m.x.SIDEBAR_GROUP,
                            position: s,
                            useCustomDragHandle: !0,
                            children: ({
                                dragHandleProps: s
                            }) => ((e, s) => {
                                var c;
                                if (e instanceof n.Model.Models.ProjectGroup) return (0, x.jsx)(T, {
                                    projectGroup: e,
                                    showsCounters: r,
                                    sort: (null == (c = a[e.id]) ? void 0 : c.sort) || {
                                        by: n.Model.SidebarGroupsSortBy.Name,
                                        order: "ascending"
                                    },
                                    onAddNewProject: () => i({
                                        initialProjectGroups: [e]
                                    }),
                                    groupDragHandle: s
                                }, e.id);
                                switch (e.id) {
                                    case n.Model.SidebarBuiltinGroups.Favorites:
                                        return (0, x.jsx)(_, {
                                            sort: e.sort || {
                                                by: n.Model.SidebarGroupsSortBy.Custom
                                            },
                                            showsCounters: r,
                                            groupDragHandle: s
                                        }, e.id);
                                    case n.Model.SidebarBuiltinGroups.ProjectsFollowed:
                                        return t ? null : (0, x.jsx)(C, {
                                            sort: e.sort || {
                                                by: n.Model.SidebarGroupsSortBy.Custom
                                            },
                                            onAddNewProject: i,
                                            onSwitchSidebarContent: o,
                                            showsCounters: r,
                                            groupDragHandle: s
                                        }, e.id);
                                    case n.Model.SidebarBuiltinGroups.ProjectsActive:
                                        return (0, x.jsx)(R, {
                                            sort: e.sort || {
                                                by: n.Model.SidebarGroupsSortBy.Name,
                                                order: "ascending"
                                            },
                                            onAddNewProject: i,
                                            onSwitchSidebarContent: o,
                                            showsCounters: r,
                                            groupDragHandle: s
                                        }, e.id);
                                    default:
                                        return null
                                }
                            })(e, s)
                        }, e.id)))
                    })
                })
            })),
            I = n.Hocs.compose(n.Hocs.withPersonalUI, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                sidebarBuiltinGroups: e.modelRoot.settings.sidebarBuiltinGroups.forTeam(t)
            }))))((e => {
                const {
                    switchSidebarContent: t,
                    showsCounters: s,
                    shouldRenderPersonalUI: a,
                    sidebarBuiltinGroups: r
                } = e, i = n.Hooks.useIntl(), [c, d] = (0, l.ND)("other"), {
                    currentTeam: u
                } = n.Hooks.useIdentity(), m = r[n.Model.SidebarBuiltinGroups.ProjectsActive], h = "number" != typeof(null == m ? void 0 : m.position);
                return (0, x.jsxs)(x.Fragment, {
                    children: [(0, x.jsx)(l.pF, {
                        title: i.f.D6,
                        isCollapsed: c,
                        toggleSection: d
                    }), c ? null : (0, x.jsxs)(x.Fragment, {
                        children: [h ? (0, x.jsx)(o.Z, {
                            title: i.f.EF,
                            icon: "ş",
                            onPress: e => t(e, "projects"),
                            counter: s ? u.activeProjects.observeCount() : null
                        }) : null, (0, x.jsx)(o.Z, {
                            title: i.f.uz,
                            icon: "Ɲ",
                            onPress: e => t(e, "tags"),
                            counter: s ? u.tags.observeCount() : null
                        }), (0, x.jsx)(o.Z, {
                            title: a ? i.f.ED : i.f.EH,
                            testId: n.Misc.testIds.sidebar_team,
                            icon: "ơ",
                            onPress: e => t(e, "team"),
                            counter: s ? u.members.observeCount() : null
                        }), (0, x.jsx)(o.Z, {
                            title: i.f.D7,
                            icon: "°",
                            onPress: e => t(e, "projectsGroups"),
                            counter: s ? u.allProjectGroups.observeCount() : null
                        }), (0, x.jsx)(o.Z, {
                            title: i.f.D$,
                            icon: "ƣ",
                            onPress: e => t(e, "projectsTemplates"),
                            counter: s ? u.activeProjectTemplates.observeCount() : null
                        })]
                    })]
                })
            }));
        var N = s(160),
            E = s(130),
            O = s(82),
            M = s(11),
            D = s(18),
            H = s(13),
            F = s(551);
        const Z = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(["counter", "cacheKey"], (({
            counter: e,
            cacheKey: t,
            services: s
        }) => ({
            count: e && t ? n.Rx.cachedValue(s.database, t, "", e) : n.Rx.of("")
        }))), n.Hocs.withObservables(["linkTo"], (({
            services: e,
            linkTo: t
        }) => ({
            isActive: t ? e.history.matchesPath(t) : n.Rx.of(!1)
        }))))((e => {
            const {
                linkTo: t,
                onPress: s,
                title: a,
                icon: o,
                color: r,
                count: i,
                testId: c,
                isActive: l
            } = e;
            invariant((t || s) && !(t && s), "Box must have either linkTo or onPress, but not both at the same time");
            const d = n.Hooks.useDense(),
                u = n.Styling.factoryColor(r),
                m = n.React.useContext(E.l),
                h = m ? (0, N.Z)(u).brighten(15).toRgbString() : u,
                p = (0, x.jsxs)(M.Z, {
                    className: F.Z.container + (d ? " " + F.Z.containerDense : "") + " " + (e.className || ""),
                    style: Object.assign({
                        backgroundColor: n.Styling.rgba(u, m ? .3 : .08),
                        borderColor: l ? n.Styling.rgba(u, .7) : undefined,
                        "--hover-border-color": n.Styling.rgba(u, .2)
                    }, e.style),
                    webComponent: "div",
                    testId: c,
                    onPress: s,
                    children: [(0, x.jsx)(D.default, {
                        className: F.Z.title,
                        style: {
                            color: h
                        },
                        adjustsFontSizeToFit: !0,
                        children: a
                    }), (0, x.jsxs)("div", {
                        className: F.Z.bottomRow,
                        children: [(0, x.jsx)("span", {
                            className: F.Z.count,
                            style: {
                                color: h
                            },
                            children: i
                        }), (0, x.jsx)(H.default, {
                            name: o,
                            size: 22,
                            color: r
                        })]
                    })]
                });
            return (0, x.jsx)("div", {
                className: F.Z.root,
                children: (0, x.jsx)((({
                    children: e
                }) => t ? (0, x.jsx)(O.Z, {
                    to: t,
                    force: !0,
                    children: e
                }) : e), {
                    children: p
                })
            })
        }));
        var L = s(553),
            B = s(530);
        const z = n.ReactUtils.lazy((() => s(559))),
            U = n.ReactUtils.lazy((() => s(562))),
            W = n.Hocs.compose(n.Hocs.withPersonalUI, n.Hocs.withIntl, n.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                hasCurrentMemberAdminPowers: e.hasAdminPowers
            }))), n.Hocs.withObservables(["services", "currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                promoBannerSettings: e.modelRoot.settings.observePromoBannerSetting(t)
            }))), n.Hocs.withHooks((e => {
                const {
                    services: t,
                    intl: s,
                    currentMember: a,
                    currentTeam: o,
                    hasCurrentMemberAdminPowers: r,
                    shouldRenderPersonalUI: i,
                    promoBannerSettings: c
                } = e, l = (0, d.G5)(o), u = (0, d.bg)(o), m = Boolean((null == c ? void 0 : c.is_visible) && c.image_url), h = null == c ? void 0 : c.action, [p, g] = n.Hooks.useStateResettable([], [s.locale]);
                return {
                    newProjectModal: l,
                    newMemberModal: u,
                    showPromoBanner: m,
                    brokenBanners: p,
                    hideBrokenBanner: n.React.useCallback((e => {
                        g((t => {
                            const {
                                name: s
                            } = e;
                            return t.includes(s) ? t : t.concat(s)
                        }))
                    }), [g]),
                    bannerContext: n.React.useMemo((() => ({
                        services: t,
                        intl: s,
                        currentMember: a,
                        currentTeam: o,
                        prefersPersonalUI: i,
                        hasCurrentMemberAdminPowers: r,
                        isShowingSomeOtherPromo: m && ("buy_premium" === h || "buy_business" === h),
                        onOpenNewProjectModal: l.open,
                        onOpenNewMemberModal: u.open
                    })), [a, o, r, s, u.open, l.open, t, i, m, h])
                }
            })), n.Hocs.withObservables(["bannerContext", "brokenBanners"], (({
                bannerContext: e,
                brokenBanners: t
            }) => ({
                banners: (0, B.$)(e, {
                    omitBannersByName: t
                })
            }))))((e => {
                var t;
                const {
                    banners: s,
                    hideBrokenBanner: a,
                    showPromoBanner: o,
                    promoBannerSettings: r,
                    newProjectModal: i,
                    newMemberModal: c
                } = e, l = n.React.useMemo((() => [o && r ? t || (t = (0, x.jsx)(U, {
                    promoSetting: r
                }, "internal_promo_banner")) : null].concat(s.map((e => (0, x.jsx)(L.Z, {
                    banner: e,
                    onContentMissing: () => a(e)
                }, e.name)))).filter(Boolean)), [s, a, o, r]);
                return (0, x.jsxs)(x.Fragment, {
                    children: [(0, x.jsx)(z, {
                        children: l
                    }), i.render(), c.render()]
                })
            }));
        var G, V, q, Q, Y, J, K, $, X = s(360);
        const ee = s(107).wx,
            te = s(208).wx,
            se = n.ReactUtils.lazy((() => s(1537))),
            ne = n.ReactUtils.lazy((() => s(1294))),
            ae = n.ReactUtils.lazy((() => s(1538))),
            oe = n.ReactUtils.lazy((() => s(1539))),
            re = n.ReactUtils.lazy((() => s(1295))),
            ie = n.ReactUtils.lazy((() => s(1540))),
            ce = n.ReactUtils.lazy((() => s(1296))),
            le = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withIntl, n.Hocs.withPersonalUI, n.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                hasCurrentMemberAdminPowers: e.hasAdminPowers
            }))), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e,
                services: t
            }) => ({
                currentTeam: e,
                hasActivity: e.activityTasksCounter.pipe(n.Rx.map((e => 0 < e))),
                allMembers: e.members,
                promoBannerSettings: t.modelRoot.settings.observePromoBannerSetting(e)
            }))), n.Hocs.withObservables(["currentTeam", "shouldRenderPersonalUI"], (({
                currentTeam: e,
                shouldRenderPersonalUI: t
            }) => ({
                shouldShowMessages: e.activeMembers.observeCount().pipe(n.Rx.map((e => 1 < e && !t)))
            }))), n.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                localizationSettings: e.localization.settings,
                creditsGranted: e.modelRoot.settings.observeCreditsGrantedSetting(),
                isNativeOnboardingShown: e.uiState.isNativeOnboardingShown,
                showsCounters: e.modelRoot.settings.isSidebarShowingCounters.observe(),
                isUpdateAvaliable: e.appState.isUpdateAvaliable
            }))), n.Hocs.withObservables(["services", "localizationSettings"], (({
                services: e,
                localizationSettings: t
            }) => ({
                newsActivity: e.modelRoot.settings.observeNewsActivitySettings(t.locale)
            }))), n.Hocs.withFeatureBadges({
                placement: "sidebar_menu_button"
            }))((e => {
                const {
                    allMembers: t,
                    switchSidebarContent: s,
                    promoBannerSettings: m,
                    newsActivity: {
                        lastNewsAt: h,
                        lastSeenNewsAt: p
                    },
                    creditsGranted: g,
                    isNativeOnboardingShown: f,
                    showsCounters: b,
                    shouldRenderPersonalUI: y,
                    shouldShowMessages: v,
                    isUpdateAvaliable: w,
                    hasActivity: k,
                    featureBadges: j,
                    hasCurrentMemberAdminPowers: T
                } = e, S = n.Hooks.useIntl(), {
                    currentMember: P,
                    currentTeam: _
                } = n.Hooks.useIdentity(), C = n.Hooks.useServices(), R = n.Hooks.useDesktopLayout(), N = n.Hooks.useModalState(), E = n.Hooks.useModalState(), O = (0, d.G5)(_), M = (0, d.B)(_), D = (0, d.bg)(_);
                (e => {
                    const t = n.Hooks.useServices();
                    n.React.useEffect((() => {
                        const {
                            history: s
                        } = t, n = s.currentPath.subscribe((() => {
                            const {
                                state: t
                            } = s.currentLocation;
                            null != t && t.openNewMemberModal && e()
                        }));
                        return () => n.unsubscribe()
                    }), [e, t])
                })(D.open);
                const H = t.filter((e => e.isWaitingForApproval)),
                    F = T && !!H.length,
                    {
                        lastCreditsGrantedAt: L = 0,
                        lastCreditsSeenAt: B = 0
                    } = g || {},
                    z = Boolean(m && m.is_visible && m.image_url),
                    U = (() => {
                        if (!N.isOpen) return L > B || w ? c.a.Incoming : h > p ? c.a.Activity : j.placementBadge
                    })();
                return (0, x.jsxs)(l.fC, {
                    children: [(0, x.jsxs)(l.h4, {
                        menuTarget: N.target,
                        children: [(0, x.jsx)(l.z, {
                            className: X.Z.headerText,
                            children: _.name
                        }), (0, x.jsxs)(l.z6, {
                            children: [n.Misc.isElectron ? null : (0, x.jsx)(l.Ov, {
                                icon: "ƅ",
                                accessibilityLabel: S.f.pL,
                                keyboardShortcutID: "global.jumpTo",
                                testId: n.Misc.testIds.sidebar_search,
                                onPress: () => C.uiState.jumpToModal.open()
                            }), (0, x.jsx)(l.Ov, {
                                className: X.Z.menuButton + (N.isOpen ? " " + X.Z.menuButtonActive : ""),
                                icon: "Ɖ",
                                accessibilityLabel: S.f.db,
                                onPress: N.open,
                                badge: U,
                                testId: n.Misc.testIds.sidebar_settings
                            })]
                        })]
                    }), (0, x.jsxs)(l.SH, {
                        reachesBottomOfScreen: !1,
                        bottomBarInset: R ? 0 : 104,
                        children: [(0, x.jsxs)("div", {
                            className: X.Z.boxes,
                            children: [(0, x.jsx)(Z, {
                                title: S.f.zV,
                                linkTo: (0, u.pathToPriority)(_),
                                icon: "Ƙ",
                                color: "priority",
                                counter: _.activePriorityTasksCounter,
                                cacheKey: _.id + "_priority_count",
                                testId: n.Misc.testIds.sidebar_priority
                            }), (0, x.jsx)(Z, {
                                linkTo: (0, u.pathToIncoming)(_),
                                title: S.f.ny,
                                icon: "Ĵ",
                                color: "incoming",
                                counter: _.incomingTasksCounter,
                                cacheKey: _.id + "_incoming_count",
                                testId: n.Misc.testIds.sidebar_incoming
                            }), y ? null : (0, x.jsxs)(x.Fragment, {
                                children: [_.isPersonal ? null : (0, x.jsx)(Z, {
                                    linkTo: (0, u.pathToActivity)(_),
                                    title: S.f.y,
                                    icon: "±",
                                    color: "activity",
                                    counter: _.activityTasksCounter,
                                    cacheKey: _.id + "_activity_count",
                                    testId: n.Misc.testIds.sidebar_activity
                                }), (0, x.jsx)(Z, {
                                    linkTo: (0, u.pathToSingleTasks)(_),
                                    title: S.f.EG,
                                    icon: "ƒ",
                                    color: "singleTasks",
                                    counter: _.singleAndGrantedTasksCounter,
                                    cacheKey: _.id + "_singleTasks_count",
                                    testId: n.Misc.testIds.sidebar_singleTasks
                                })]
                            })]
                        }), (0, x.jsxs)(a.Z, {
                            children: [G || (G = (0, x.jsx)(W, {})), F ? (0, x.jsx)(r.Z, {
                                onPress: s,
                                onPressExtraParam: "team",
                                title: S.f.D5,
                                count: H.length
                            }) : null, V || (V = (0, x.jsx)(se, {})), q || (q = (0, x.jsx)(ne, {})), Q || (Q = (0, x.jsx)(ae, {})), _.isTrial && P.isOwner ? (0, x.jsx)(o.Z, {
                                onPress: E.open,
                                title: S.f.EI,
                                icon: "·",
                                iconColor: "purple",
                                textColor: "purple"
                            }) : null, y && k ? Y || (Y = (0, x.jsx)(ie, {})) : null, J || (J = (0, x.jsx)(oe, {})), y ? K || (K = (0, x.jsx)(re, {})) : null, v ? $ || ($ = (0, x.jsx)(ce, {})) : null, null, (0, x.jsx)(A, {
                                switchSidebarContent: s,
                                showsCounters: b,
                                onAddNewProject: O.open
                            }, _.id), (0, x.jsx)(I, {
                                switchSidebarContent: s,
                                showsCounters: b
                            })]
                        }), f ? (0, x.jsx)("div", {
                            className: X.Z.onboardingSpacer
                        }) : null]
                    }), R ? null : (0, x.jsx)(l.MT, {
                        children: (0, x.jsx)(i.Z, {
                            className: X.Z.quickAddPlusButton,
                            onPress: () => C.uiState.quickAddModal.open(),
                            color: "singleTasks",
                            icon: "ū",
                            accessibilityLabel: S.f.mF
                        })
                    }), N.isOpen ? (0, x.jsx)(ee.AppMenu, {
                        bundle$close: N.close,
                        closeMenu: N.close,
                        target: N.target,
                        isPromo: z
                    }) : null, O.render(), M.render(), D.render(), E.isOpen ? (0, x.jsx)(te.NozbePremiumExplainer, {
                        bundle$close: E.close,
                        onClose: E.close,
                        onBuyPress: () => {
                            C.payments.requirements.set(_, "plan-changing"), E.close()
                        }
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => b
        });
        var n = s(0),
            a = s(86),
            o = s(126),
            r = s(62),
            i = s(96),
            c = s(50),
            l = s(103);
        const d = n.ReactUtils.lazy((() => s(203))),
            u = n.ReactUtils.lazy((() => s(923))),
            m = n.ReactUtils.lazy((() => s(332)));
        var h = s(1);
        const p = n.ReactUtils.lazy((() => s(549))),
            g = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    favorites: t,
                    aboveTheFoldCount: s = -1,
                    showsCounters: a,
                    groupDragHandle: o,
                    sort: g
                } = e, {
                    currentMember: f,
                    currentTeam: b
                } = n.Hooks.useIdentity(), y = n.Hooks.useIntl(), [v, w] = (0, l.ND)(n.Model.SidebarBuiltinGroups.Favorites), k = n.Hooks.useModalState();
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(l.pF, {
                        title: y.f.D2,
                        toggleSection: w,
                        isCollapsed: v,
                        targetRef: k.target,
                        onThreeDotPress: k.open,
                        groupDragHandle: o
                    }), v ? null : (0, h.jsx)(r.Z, {
                        id: "favorite",
                        type: c.x.FAVORITE,
                        children: t.map(((e, t) => (0, h.jsx)(i.Z, {
                            id: e.id,
                            position: t,
                            type: c.x.FAVORITE,
                            isDisabled: g.by !== n.Model.SidebarGroupsSortBy.Custom,
                            children: () => n.React.createElement(function(e) {
                                if (e.table === n.Model.Tables.projects) return d;
                                if (e.table === n.Model.Tables.tags) return u;
                                if (e.table === n.Model.Tables.teamMembers) return m;
                                throw new Error("unreachable")
                            }(e), {
                                key: e.id,
                                project: e,
                                member: e,
                                shouldRenderYou: e === f,
                                tag: e,
                                team: b,
                                isBelowTheFold: t >= s,
                                showCounter: a,
                                showFavFollowIcon: !1
                            })
                        }, e.id)))
                    }), k.isOpen ? (0, h.jsx)(p, {
                        closeMenu: k.close,
                        target: k.target,
                        sort: g
                    }) : null]
                })
            }));
        var f = s(1291);
        const b = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withIntl, n.Hocs.withObservables(["currentTeam", "sort", "intl"], (({
            currentTeam: e,
            sort: t,
            intl: s
        }) => ({
            favorites: (0, o.v5)({
                team: e,
                sort: t,
                intl: s
            })
        }))))((e => {
            const {
                favorites: t,
                showsCounters: s,
                groupDragHandle: n,
                sort: o
            } = e, {
                onDragEnd: r
            } = (0, f.i)(t);
            return (0, h.jsx)(a.Z, {
                onDragEnd: r,
                children: (0, h.jsx)(g, {
                    favorites: t,
                    showsCounters: s,
                    groupDragHandle: n,
                    sort: o
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            i: () => a
        });
        var n = s(0);

        function a(e) {
            const {
                currentTeam: t
            } = n.Hooks.useIdentity();
            return n.Hooks.useDnd((() => ({
                getDroppedSection: () => ({
                    items: e
                }),
                updatePosition: async (e, s) => {
                    await e.updateSidebarPosition(s, t)
                },
                selector: e => e.asSidebarFavoritable(t).sidebarPosition,
                updater: (e, s) => {
                    e.asSidebarFavoritable(t).sidebarPosition = s
                }
            })))
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(126),
            o = s(86),
            r = s(568),
            i = s(1291),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withIntl, n.Hocs.withObservables(["sort", "intl"], (({
            currentTeam: e,
            sort: t,
            intl: s
        }) => ({
            projects: (0, a.E5)({
                query: e.followedNotFavoriteProjects,
                sort: t,
                intl: s
            })
        }))))((e => {
            const {
                projects: t,
                showsCounters: s,
                sort: a,
                onSwitchSidebarContent: l,
                onAddNewProject: d,
                groupDragHandle: u
            } = e, {
                onDragEnd: m
            } = (0, i.i)(t);
            return (0, c.jsx)(o.Z, {
                onDragEnd: m,
                children: (0, c.jsx)(r.Z, {
                    type: n.Model.SidebarBuiltinGroups.ProjectsFollowed,
                    projects: t,
                    showsCounters: s,
                    sort: a,
                    switchSidebarContent: l,
                    onAddNewProject: d,
                    groupDragHandle: u
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(207),
            o = s(86),
            r = s(126),
            i = s(568),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withServices, n.Hocs.withObservables(["currentTeam", "sort"], (({
            currentTeam: e,
            sort: t,
            services: s
        }) => ({
            projects: e.activeProjectsWithoutTemplates.observeWithColumns([n.Model.Columns.projects.name, n.Model.Columns.projects.createdAt]),
            projectsPositionMap: t.by === n.Model.SidebarGroupsSortBy.Custom ? (0, a.n)(e.id + "/active_projects", s.collections) : n.Rx.of({})
        }))))((e => {
            const {
                projects: t,
                showsCounters: s,
                sort: l,
                onSwitchSidebarContent: d,
                onAddNewProject: u,
                groupDragHandle: m,
                currentTeam: h,
                projectsPositionMap: p
            } = e, g = n.Hooks.useIntl(), f = n.Hooks.useServices(), b = n.React.useMemo((() => (0, r.CM)(t, l, g, p)), [t, l, g, p]);
            return (0, c.jsx)(o.Z, {
                onDragEnd: async e => {
                    const {
                        destination: t,
                        source: s
                    } = e;
                    if (!t || !s || t.droppableId !== s.droppableId) return;
                    const n = b[s.index];
                    invariant(n, "Unexpected missing draggedProject");
                    const o = (0, a.A)({
                        draggedItem: n,
                        items: b,
                        projectsPositionMap: p,
                        viewId: h.id + "/active_projects",
                        destinationIdx: t.index
                    });
                    await f.database.write((() => f.database.batch(o)))
                },
                children: (0, c.jsx)(i.Z, {
                    type: n.Model.SidebarBuiltinGroups.ProjectsActive,
                    projects: b,
                    showsCounters: s,
                    switchSidebarContent: d,
                    sort: l,
                    onAddNewProject: u,
                    groupDragHandle: m
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(139),
            o = s(1);
        const r = n.ReactUtils.lazy((() => s(565))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                taskInvitations: e.modelRoot.settings.taskInvitations.observeAll()
            }))))((e => {
                const {
                    taskInvitations: t,
                    services: s
                } = e, i = n.Hooks.useIntl(), c = n.Hooks.useModalState();
                return t.length ? (0, o.jsxs)(o.Fragment, {
                    children: [(0, o.jsx)(a.Z, {
                        title: i.f.Ew,
                        count: t.length,
                        onPress: () => {
                            if (1 < t.length) c.open();
                            else {
                                const e = t[0];
                                s.appState.startAcceptingTaskInvitation(e.invitation_id)
                            }
                        }
                    }), c.isOpen ? (0, o.jsx)(r, {
                        onClose: c.close,
                        invitations: t
                    }) : null]
                }) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(14),
            o = s(79),
            r = s(1);
        const i = n.Hocs.compose()((() => {
            const e = n.Hooks.useIntl(),
                {
                    currentTeam: t
                } = n.Hooks.useIdentity();
            return (0, r.jsx)(o.Z, {
                linkTo: (0, a.pathToSingleTasks)(t),
                title: e.f.EO,
                icon: "ƒ",
                iconColor: "singleTasks",
                counter: t.singleAndGrantedTasksCounter,
                testId: n.Misc.testIds.sidebar_singleTasks
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(79),
            o = s(14),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withFeatureBadges({
            placement: "sidebar"
        }), n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
            currentTeam: e
        }) => ({
            hasUnreadThreads: e.unreadThreadsCounter.pipe(n.Rx.map((e => 0 < e)))
        }))))((e => {
            const {
                featureBadges: t,
                hasUnreadThreads: s
            } = e, i = n.Hooks.useIntl(), {
                currentTeam: c
            } = n.Hooks.useIdentity();
            return (0, r.jsx)(a.Z, {
                linkTo: (0, o.pathToMessages)(c),
                title: i.f.Kc,
                iconColor: s ? "darkgreen" : void 0,
                textColor: s ? "darkgreen" : void 0,
                badge: t.get("messages"),
                icon: "Ķ",
                counter: c.unreadThreadsCounter
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            C0: () => b,
            GN: () => f,
            RO: () => v,
            f2: () => m,
            f_: () => y,
            g_: () => p,
            rx: () => h
        });
        var n = s(0),
            a = s(1298),
            o = s(78),
            r = s(37),
            i = s(1300),
            c = s(1);
        const l = n.ReactUtils.lazy((() => s(1301))),
            d = s(42).wx,
            {
                AutocompletePicker: u
            } = s(1302).wx,
            m = e => (0, c.jsx)("div", {
                className: i.Z.right,
                children: e.children
            }),
            h = e => {
                const {
                    modalType: t,
                    pickerTarget: s,
                    closeModal: a,
                    getSelectionStart: r,
                    setSelectionStart: i,
                    defaultResponsible: m,
                    newTaskFormState: h,
                    newTaskFormStateDispatch: p,
                    showProjectIcon: g,
                    showTeamIcon: f,
                    attachmentProps: b,
                    setIsPickingFiles: y,
                    setHasTouchedResponsible: v,
                    renderVacationNotice: w,
                    inputRef: k
                } = e, x = async e => {
                    if (a(), v(!0), e.isEmail) {
                        const t = await n.Rx.takeFirst(D.currentMember);
                        p({
                            type: "set_responsible_email",
                            payload: {
                                email: e.email,
                                currentMember: t
                            }
                        })
                    } else p({
                        type: "set_responsible_member",
                        payload: {
                            responsible: e.member,
                            shouldCheckAccess: e.shouldCheckAccess
                        }
                    })
                }, j = e => {
                    a(), p({
                        type: "set_reminders",
                        payload: e
                    })
                }, T = async e => {
                    a();
                    const t = await n.Rx.takeFirst(e.singleTasks),
                        s = await n.Rx.takeFirst(e.currentMember);
                    p({
                        type: "set_team",
                        payload: {
                            team: e,
                            singleTasks: t,
                            currentMember: s
                        }
                    })
                }, S = e => {
                    a(), p({
                        type: "set_project",
                        payload: e
                    })
                }, P = async ({
                    date: e,
                    recurrence: t
                }) => {
                    a();
                    const s = await n.Rx.takeFirst(D.currentMember);
                    p({
                        type: "set_due_date",
                        payload: {
                            dueDate: e,
                            recurrence: t,
                            currentMember: s
                        }
                    })
                }, _ = e => {
                    a(), p({
                        type: "set_tags",
                        payload: e
                    })
                }, C = e => {
                    p({
                        type: "set_hashtags_map",
                        payload: Object.assign({}, h.hashtagsMap, e)
                    })
                }, R = async e => {
                    switch (a(), e.type) {
                        case "responsible":
                            p({
                                type: "set_responsible_member",
                                payload: {
                                    responsible: e.value,
                                    shouldCheckAccess: !0
                                }
                            });
                            break;
                        case "project":
                            g ? p({
                                type: "set_project",
                                payload: e.value
                            }) : C({
                                project: e
                            });
                            break;
                        case "section":
                            C({
                                projectSection: e
                            });
                            break;
                        case "tag":
                            p({
                                type: "set_tags",
                                payload: {
                                    added: [e.value],
                                    removed: []
                                }
                            });
                            break;
                        case "dueDate":
                            n.Rx.takeFirst(D.currentMember).then((t => {
                                p({
                                    type: "set_due_date",
                                    payload: {
                                        dueDate: e.value,
                                        currentMember: t
                                    }
                                })
                            }));
                            break;
                        case "reminder":
                            h.reminders.some((t => (0, o.nd)(t, e.value))) || p({
                                type: "set_reminders",
                                payload: {
                                    added: [e.value],
                                    removed: []
                                }
                            });
                            break;
                        case "recurrence":
                            p({
                                type: "set_recurrence",
                                payload: e.value
                            });
                            break;
                        case "priority":
                            p({
                                type: "set_priority",
                                payload: !0
                            });
                            break;
                        default:
                            n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL, "Unexpected parameter type: " + e.type)
                    }
                    const t = r();
                    if ("number" == typeof t) {
                        const {
                            name: s
                        } = h, n = s.slice(0, t), a = s.slice(t), o = "#" === n[n.length - 1], r = o ? "" : " #", i = ["responsible", "dueDate", "recurrence", "reminder", "tag", "priority", ...g ? ["project"] : [], ...f ? ["team"] : []].includes(e.type) ? "" + (o ? n.slice(0, n.length - 1) : n) + a : "" + n + r + e.text + a + " ";
                        p({
                            type: "set_name",
                            payload: i
                        })
                    }
                }, {
                    recurrence: A,
                    dueDate: I,
                    responsible: N,
                    reminders: E,
                    hashtagsMap: O,
                    project: M,
                    team: D,
                    tags: H
                } = h;
                if (!t) return null;
                switch (t) {
                    case "dueDate":
                        return (0, c.jsx)(d.DueDate, {
                            bundle$close: a,
                            onConfirm: P,
                            target: s,
                            onClose: a,
                            currentRecurrence: A,
                            currentDueDate: I,
                            canChangeDueDateWithoutRecurrence: !1
                        });
                    case "responsible":
                        var F, Z;
                        return null != (F = O.project) && F.value || M ? (0, c.jsx)(d.Responsible, {
                            bundle$close: a,
                            onConfirm: x,
                            target: s,
                            onClose: a,
                            currentResponsibleId: null == N ? void 0 : N.id,
                            project: (null == (Z = O.project) ? void 0 : Z.value) || M,
                            hasDueDate: !!I
                        }) : null;
                    case "reminder":
                        return (0, c.jsx)(d.Reminders, {
                            bundle$close: a,
                            onConfirm: j,
                            currentReminders: E,
                            currentDueDate: I,
                            target: s,
                            onClose: a
                        });
                    case "team":
                        return (0, c.jsx)(d.Team, {
                            bundle$close: a,
                            onClose: a,
                            onConfirm: T,
                            target: s,
                            currentTeamId: D.id
                        });
                    case "project":
                        return (0, c.jsx)(d.Project, {
                            bundle$close: a,
                            onConfirm: S,
                            currentProjectId: M.id,
                            team: D,
                            target: s,
                            onClose: a
                        });
                    case "tag":
                        return (0, c.jsx)(d.Tags, {
                            bundle$close: a,
                            target: s,
                            onConfirm: _,
                            onClose: a,
                            currentTags: H,
                            showNoTagsItem: !1
                        });
                    case "autocomplete":
                        var L;
                        return (0, c.jsx)(u, {
                            bundle$close: a,
                            onClose: a,
                            hashtagsMap: O,
                            project: (null == (L = O.project) ? void 0 : L.value) || M,
                            selectedResponsible: N !== m ? N : null,
                            selectedRecurrence: A,
                            selectedDueDate: I,
                            onSelect: R,
                            target: s,
                            isPriorityActive: h.isPriority
                        });
                    case "attachments":
                        return b ? (b.pickAttachments(null, (() => {
                            y(!1)
                        })), a(), null) : b ? (0, c.jsx)(l, {
                            pickAttachments: e => b.pickAttachments(e, (() => {
                                y(!1), (null == k ? void 0 : k.current) && k.current.focus()
                            })),
                            addExternalAttachments: b.addExternalAttachments,
                            target: s,
                            closeMenu: a
                        }) : null;
                    case "confirmVacation":
                        return w({
                            onCancel: a,
                            onClose: a
                        });
                    default:
                        throw new Error("unexpected modal type")
                }
            },
            p = n.Hocs.compose(n.Hocs.memo, n.Hocs.withRemindExpired((({
                onCancel: e
            }) => ({
                onExpired: e
            }))), n.Hocs.withHooks((() => {
                const [e, t] = n.Hooks.useToggle(!1);
                return {
                    isPreviewModeEnabled: e,
                    togglePreviewMode: t
                }
            }))),
            g = e => e.reduce(((e, t) => t ? Array.isArray(t) ? e + g(t) : e + t.text.length + 2 : e), 0);

        function f(e) {
            const {
                position: t,
                inputRef: s,
                newTaskFormState: o,
                isDragged: r,
                isLastItemOnList: i,
                attachmentProps: c
            } = e, l = n.Hooks.useServices(), [d, u] = n.React.useState(!1), [m, h] = n.React.useState(), [p, f] = n.React.useState(null), [b, y] = n.React.useState(!1), {
                hashtagsMap: v,
                attachments: w
            } = o, k = "bottom" === t ? "down" : "up", x = n.React.useMemo((() => {
                const e = Object.keys(v).map((e => v[e]));
                return g(e)
            }), [v]), [j, T] = (0, a.Z)(), S = n.React.useCallback((async (e, t) => b ? (t(), !0) : T(e, t)), [b, T]);
            return {
                arrowState: k,
                pickerTarget: m,
                setWebTarget: h,
                modalType: p,
                openModal: n.React.useCallback(((e, t) => {
                    f(t), "attachments" === t && u(!0)
                }), [s]),
                closeModal: n.React.useCallback((() => {
                    f(null)
                }), [s, d]),
                preventCancelOnBlur: l.uiState.isNewTaskCancelOnBlurPrevented.getValue() || r || !!p || d || 0 < o.name.length || i && (!!w.length || !!c.attachedFiles.length),
                hashtagsLength: x,
                setIsPickingFiles: u,
                isPickingFiles: d,
                setHasTouchedResponsible: y,
                runOrAcknowledgeVacation: S,
                renderVacationNotice: j.render
            }
        }
        const b = (e, t) => {
                const s = e.indexOf("#"),
                    a = e.slice(s),
                    o = Object.keys(t).reduce(((e, s) => {
                        const a = t[s];
                        if (invariant(a, "Unexpected hashtagsParameter is undefined"), Array.isArray(a)) {
                            const t = ((e, t) => e.reduce(((e, t) => {
                                const s = "#" + t.text;
                                return e.notMatchedHashtagsStr.includes(s) ? {
                                    notMatchedHashtagsStr: e.notMatchedHashtagsStr.replace(s, "").trim(),
                                    matchedHashtags: n.FP.append(t, e.matchedHashtags)
                                } : e
                            }), {
                                matchedHashtags: [],
                                notMatchedHashtagsStr: t
                            }))(a, e.notMatchedHashtagsStr);
                            return t.matchedHashtags.length ? {
                                matchedHashtags: Object.assign({}, e.matchedHashtags, {
                                    [s]: t.matchedHashtags
                                }),
                                notMatchedHashtagsStr: t.notMatchedHashtagsStr
                            } : e
                        }
                        const o = "#" + a.text;
                        return e.notMatchedHashtagsStr.includes(o) ? {
                            matchedHashtags: Object.assign({}, e.matchedHashtags, {
                                [s]: a
                            }),
                            notMatchedHashtagsStr: e.notMatchedHashtagsStr.replace(o, "").trim()
                        } : e
                    }), {
                        matchedHashtags: {},
                        notMatchedHashtagsStr: a
                    });
                return {
                    matched: o.matchedHashtags,
                    taskname: e.replace(a, o.notMatchedHashtagsStr)
                }
            },
            y = (e, t) => b(e, t).matched,
            v = () => {
                const e = n.Hooks.useFastLocalStorage(),
                    [t, s] = n.React.useState(e.get(r.d.newTaskShowParams) || !1);
                return [t, n.React.useCallback((async t => {
                    s(t), await e.set(r.d.newTaskShowParams, t)
                }), [e])]
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(1299)));

        function r() {
            const {
                currentMember: e
            } = n.Hooks.useIdentity(), t = n.Hooks.useModal(((e, t) => {
                const {
                    member: s,
                    awayUntil: n,
                    onConfirm: r
                } = e.context, {
                    modalRef: i,
                    onCancel: c,
                    onClose: l
                } = t || {};
                return (0, a.jsx)(o, {
                    member: s,
                    awayUntil: n,
                    modalRef: i,
                    onConfirm: r,
                    onCancel: t => {
                        null == c || c(t), e.close()
                    },
                    onClose: t => {
                        null == l || l(t), e.close()
                    }
                })
            })), {
                open: s
            } = t;
            return [t, n.React.useCallback((async (t, a) => {
                if (t && e.id !== t.id) {
                    const e = await n.Rx.takeFirst(t.awayOnVacationUntil);
                    if (e) return s({
                        member: t,
                        awayUntil: e,
                        onConfirm: a
                    }), !1
                }
                return a(), !0
            }), [s, e.id])]
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(6),
            o = s(25),
            r = s(21),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            user: e.user,
            preferredName: e.preferredName
        }))))((e => {
            const {
                awayUntil: t,
                user: s,
                preferredName: c,
                modalRef: l,
                onConfirm: d,
                onCancel: u,
                onClose: m
            } = e, h = n.Hooks.useIntl();
            return (0, i.jsx)(o.default, {
                type: "confirm",
                onClose: m,
                confirmButtonMessage: "Continue",
                secondaryButtonMessage: "Back",
                onConfirmPress: d,
                onBackPress: u,
                modalRef: l,
                children: h.g("KE", {
                    memberName: (0, i.jsx)(a.u_.Emphasis, {
                        children: c
                    }, "memberName"),
                    awayUntil: (0, i.jsx)(a.u_.Emphasis, {
                        children: (0, r.formatVacationDateTime)({
                            dateTime: t.to,
                            intl: h,
                            timeZone: t.timeZone || s.timeZone,
                            format: "long"
                        })
                    }, "awayUntil")
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(571)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(32),
            o = s(20),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                target: t,
                closeMenu: s,
                pickAttachments: i
            } = e, c = n.Hooks.useServices(), [{
                closeAnimated: l
            }, d] = (0, a.XH)(), u = n.Hooks.useIntl(), m = e => () => i(e);
            return (0, r.jsxs)(a.ZP, {
                ref: d,
                target: t,
                onClose: s,
                hasArrow: !0,
                level: 90,
                children: [(0, r.jsx)(o.Z, {
                    label: u.f.xI,
                    icon: "T",
                    onPress: n.ReactUtils.callBoth(l, m("camera"))
                }), c.scene.nativeScene.canOpenPhotoLibrary() ? (0, r.jsx)(o.Z, {
                    label: u.f.xK,
                    icon: "Ĳ",
                    onPress: n.ReactUtils.callBoth(l, m("photoLibrary"))
                }) : null, (0, r.jsx)(o.Z, {
                    label: u.f.xJ,
                    icon: "=",
                    onPress: n.ReactUtils.callBoth(l, m("files"))
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => Promise.all([s.e(532), s.e(216), s.e(221)]).then(s.bind(s, 1500))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(20),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                onPress: t,
                selectionStateProps: s
            } = e, r = n.Hooks.useIntl(), [i, c] = s;
            return i.isSelecting ? null : (0, o.jsx)(a.Z, {
                icon: "Ƈ",
                label: r.f.Iq,
                onPress: e => {
                    t(e), c({
                        type: "enable"
                    })
                }
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => v
        });
        var n = s(0),
            a = s(153),
            o = s(78),
            r = s(189),
            i = s(41),
            c = s(274),
            l = s(102),
            d = s(64),
            u = s(146),
            m = s(145),
            h = s(21),
            p = s(14),
            g = s(1542),
            f = s(585);
        s(2), s(3);
        const b = s(587);
        var y = s(1);
        const v = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["task"], (({
            task: e,
            isSectionVisible: t
        }) => ({
            tags: e.allTags,
            timeAttributes: e.timeAttributes,
            commentCount: e.timeline.hasIncompleteTimeline_v2 ? e.observe().pipe(n.Rx.switchMap((t => t.timeline.hasIncompleteTimeline_v2 ? n.Rx.of(e.timeline.cachedCommentCount || 0) : t.timeline.activeComments.observeCount())), n.Rx.distinctUntilChanged()) : e.timeline.activeComments.observeCount(),
            reminders: e.dates.reminders.observe().pipe(n.Rx.map((t => (0, o.Fv)(t, e.dates.dueDate)))),
            project: e.observeCurrentProject(),
            sectionName: t && !e.isGranted ? e.projectSection.observe().pipe(n.Rx.map((e => (null == e ? void 0 : e.name) || ""))) : n.Rx.of(""),
            isDueDateRelative: n.Rx.from(e.dates.isDueDateRelative())
        }))), n.Hocs.withObservables(["task", "shouldHighlightUnreadComments"], (({
            shouldHighlightUnreadComments: e,
            task: t
        }) => ({
            hasUnreadComments: e ? t.timeline.unreadCommentsQuery.pipe(n.Rx.switchMap((e => e.observeCount())), n.Rx.map((e => 0 < e)), n.Rx.distinctUntilChanged()) : n.Rx.of(!1)
        }))), n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            isProjectPrivate: e ? e.permissions.isPrivate : n.Rx.of(!1)
        }))))((e => {
            const {
                task: t,
                task: {
                    isEnded: s,
                    isGhost: v,
                    doesNeedReview: w,
                    dates: {
                        isRecurring: k,
                        missedRepeats: x,
                        isOverdue: j,
                        dueDate: T
                    }
                },
                isSelected: S,
                project: P,
                isProjectVisible: _,
                isSectionVisible: C,
                reminders: R,
                commentCount: A,
                hasUnreadComments: I,
                tags: N,
                isProjectPrivate: E,
                timeAttributes: O,
                sectionName: M,
                showReviewIcon: D,
                isDense: H,
                isDueDateRelative: F,
                viewColor: Z
            } = e, L = n.Hooks.useServices(), B = n.Hooks.useIntl(), {
                currentTeam: z
            } = n.Hooks.useIdentity(), U = (0, f.s)({
                isSelected: S,
                isEnded: s,
                alreadyReviewed: !D && !w
            }), W = F ? (0, h.toAbsoluteDateTime)(T) : T, G = (() => {
                const {
                    endedAt: e
                } = t;
                if (!e || v) return null;
                const s = new Date;
                if ((0, r.Z)(e, {
                        start: (0, i.Z)((0, c.Z)(s, 1)),
                        end: (0, l.Z)((0, d.Z)(s, 1))
                    })) {
                    const t = (0, u.Z)(e, s);
                    return B.formatRelativeTime(t, "day", {
                        timeZone: (0, h.getTimeZone)(),
                        numeric: "auto"
                    })
                }
                return B.formatDate(e, {
                    month: "short",
                    day: "numeric",
                    year: (0, m.Z)(e, new Date) ? void 0 : "numeric"
                })
            })(), V = !F && j ? "red" : "textSecondary", q = !(!x || null != P && P.isTemplate), Q = _ ? async e => {
                if (!P) return;
                const t = await P.getCurrentTeam();
                t && (n.ReactUtils.stopPropagation(e), e.preventDefault(), L.router.goTo((0, p.smartPathToProject)(t, P)))
            }: n.FP.noop;
            return t.isThread ? null : (0, y.jsx)(y.Fragment, {
                children: (0, y.jsxs)("div", {
                    className: b.row + " " + b.attributesRow + (H ? " " + b.attributesRowDense : ""),
                    children: [G ? U({
                        iconName: t.isAbandoned ? "%" : "Ɵ",
                        label: n.FP.capitalize(G)
                    }) : null, _ || null != P && P.isSingleTasks || null != P && P.isFollowed || !t.isFollowed ? null : U({
                        iconName: "±",
                        iconColor: "blue"
                    }), _ && P ? U({
                        iconName: n.Styling.getProjectIcon(P),
                        iconColor: P.color,
                        label: n.Styling.getProjectName(P, B),
                        lock: E,
                        onPress: Q
                    }) : null, C && P && M ? U({
                        iconName: "Ɔ",
                        label: M
                    }) : null, A ? U(Object.assign({
                        iconName: "k",
                        label: A.toString()
                    }, I ? {
                        iconColor: "textPrimary",
                        textColor: "textPrimary",
                        isFadedOut: !1
                    } : {})) : null, W ? U({
                        iconName: !F && j ? "š" : "R",
                        iconColor: V,
                        textColor: V,
                        label: n.FP.capitalize(F ? (0, h.formatDateTimeRelativeFromNow)({
                            dateTime: W,
                            intl: B
                        }) : (0, h.formatDateTimeRelative)({
                            dateTime: W,
                            intl: B,
                            format: "short"
                        }))
                    }) : null, T && k && !t.isGranted ? U({
                        iconName: "ż",
                        iconColor: q ? "red" : null,
                        textColor: q ? "red" : null,
                        label: q ? String(x) : void 0
                    }) : null, R.length ? U({
                        iconName: "Ŗ",
                        label: n.FP.capitalize((0, o.Ne)({
                            taskReminders: R,
                            taskHasDueDate: !!T,
                            intl: B,
                            format: "short"
                        }))
                    }) : null, null != O && O.timeNeeded ? U({
                        iconName: "Ƭ",
                        label: (0, h.formatTimeAttribute)(O.timeNeeded, B, {
                            format: "short"
                        })
                    }) : null, null != O && O.timeSpent ? U({
                        iconName: "Ư",
                        label: (0, h.formatTimeAttribute)(O.timeSpent, B, {
                            format: "short"
                        })
                    }) : null, (0, a.Pj)(N, z, B).map((e => U({
                        key: e.id,
                        iconName: n.Styling.defaultTagIcon(e.icon),
                        iconColor: e.color
                    }))), (0, y.jsx)(g.m, {
                        background: S ? g.u(Z) : void 0
                    })]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(18),
            o = s(16),
            r = s(35),
            i = s(255),
            c = s(1542);
        s(2), s(3);
        const l = s(611);
        var d = s(1);
        const u = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            comment: e.timeline.activeComments.observeWithColumns([o.o.comments.body]).pipe(n.Rx.map((e => (0, r.mO)(e).slice(-1).pop()))),
            project: e.observeCurrentProject()
        }))), n.Hocs.withCloak((({
            comment: e
        }) => !e)), n.Hocs.withIdentity, n.Hocs.withIntl, n.Hocs.withServices, n.Hocs.withObservables(["comment", "currentMember", "intl"], (({
            comment: e,
            currentMember: t,
            intl: s
        }) => ({
            authorPreferredName: e.author.observe().pipe(n.Rx.switchMap((e => (null == e ? void 0 : e.id) === t.id ? n.Rx.of(s.f.uG) : e ? e.preferredName : n.Rx.of(void 0))))
        }))), n.Hocs.withObservables(["task", "comment", "project"], (({
            services: e,
            task: t,
            comment: s,
            project: n
        }) => ({
            commentParserContext: (0, r.bo)({
                services: e,
                task: t,
                project: n,
                comments: [s]
            })
        }))))((e => {
            const {
                task: {
                    isUnread: t
                },
                comment: s,
                authorPreferredName: n,
                isSelected: o,
                viewColor: r,
                commentParserContext: u
            } = e;
            return (0, d.jsxs)("div", {
                className: l.root + (t ? " " + l.rootUnread : ""),
                children: [(0, d.jsxs)(a.default, {
                    className: l.authorName,
                    children: [n, ":"]
                }), (0, d.jsx)(a.default, {
                    className: l.text,
                    children: (0, i.U)(s, u)
                }), (0, d.jsx)(c.m, {
                    background: o ? c.u(r) : void 0
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            A: () => n,
            X: () => a
        });
        s(0);

        function n(e) {
            return ["image/png", "image/jpeg", "image/gif"].includes(e) ? "image" : "text/html" === e ? "html" : e.startsWith("video/") ? "video" : "application/pdf" === e ? "pdf" : null
        }

        function a(e) {
            return !!n(e)
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(60),
            o = s(1543);
        var r = s(1);
        const i = n.ReactUtils.lazy((() => s(589))),
            c = n.Hocs.compose()((e => {
                const {
                    video: t,
                    video: {
                        title: s,
                        previewUrl: c
                    },
                    onClose: l
                } = e, d = n.React.useMemo((() => ({
                    url: c
                })), [c]), u = function(e) {
                    const {
                        url: t,
                        service: s,
                        icon: a,
                        color: o
                    } = e, r = n.Hooks.useIntl();
                    return {
                        label: {
                            youtube: r.f.eZ,
                            vimeo: r.f.eY
                        } [s],
                        icon: a,
                        color: o,
                        onPress: () => {
                            n.ReactUtils.openUrl(t)
                        }
                    }
                }(t);
                return (0, r.jsx)(i, {
                    title: s,
                    content: d,
                    footer: (0, r.jsx)(a.gq, {
                        justify: "center",
                        children: (0, r.jsx)(o.Z, {
                            label: u.label,
                            color: u.color,
                            icon: u.icon,
                            onPress: u.onPress
                        })
                    }),
                    onClose: l
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(94),
            o = s(11);

        function r() {
            const [e, t] = n.React.useState(1), [s, a] = n.React.useState([0, 0]), [o, r] = n.React.useState(!1), i = n.React.useRef(!1), c = e => {
                i.current = !1, r(e)
            }, l = e >= 2, [d, u] = n.React.useState("0 0"), m = e => {
                const t = e.target.getBoundingClientRect();
                return e.clientX - t.left + "px " + (e.clientY - t.top) + "px"
            }, h = n.React.useCallback((t => {
                if (!o || e <= 1) return;
                const [n, r] = s, c = (n || 0) + t.movementX, l = (r || 0) + t.movementY;
                a([c, l]), i.current = !0
            }), [o, e, s]);
            return {
                zoomStyles: {
                    container: {
                        cursor: i.current ? "grab" : l ? "zoom-out" : "zoom-in"
                    },
                    image: {
                        transform: "scale(" + e + ")",
                        transition: "transform .25s",
                        transformOrigin: d
                    },
                    panWrapper: Object.assign({}, s[0] && s[1] ? {
                        transform: "translate(" + s[0] + "px, " + s[1] + "px)"
                    } : {}, {
                        width: "100%",
                        height: "100%"
                    }, {
                        display: "flex",
                        flexDirection: "row",
                        alignItems: "center",
                        justifyContent: "center"
                    })
                },
                onImagePress: () => {
                    c(!0)
                },
                onWheel: s => {
                    const o = n.FP.clamp(e - s.deltaY / 10, 1, 2);
                    if (1 === o) return a([0, 0]), void t(o);
                    2 === e && 2 === o || (u(m(s)), t(o))
                },
                onImageMouseMove: h,
                onImagePressOut: s => {
                    (s => {
                        i.current || (u(m(s)), l ? (t(1), a([0, 0])) : (t(e + .5), h(s)))
                    })(s), c(!1)
                }
            }
        }
        s(2), s(3);
        const i = s(591);
        var c = s(1);
        const l = n.Hocs.compose()((e => {
            const {
                title: t,
                file: s
            } = e, l = n.Hooks.useFileUrl(s), {
                zoomStyles: d,
                onImagePress: u,
                onImageMouseMove: m,
                onImagePressOut: h,
                onWheel: p
            } = r();
            return (0, c.jsx)(o.Z, {
                className: i.root,
                style: d.container,
                __webFixBlurEventOrder: !0,
                onPress: u,
                onMouseMove: m,
                onPressOut: h,
                onWheel: p,
                children: (0, c.jsx)("div", {
                    style: d.panWrapper,
                    children: (0, c.jsx)(a.Z, {
                        className: i.image,
                        style: d.image,
                        source: l,
                        title: t
                    })
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(1310),
            o = s(6),
            r = s(1);
        const i = n.React.forwardRef(((e, t) => {
                const {
                    src: s,
                    title: n,
                    className: a,
                    onLoad: o,
                    onError: i
                } = e;
                return (0, r.jsx)("iframe", {
                    ref: t,
                    src: s,
                    title: n,
                    className: a,
                    onLoad: o,
                    onError: i
                })
            })),
            c = n.Hocs.compose()(i);
        s(2), s(3);
        const l = s(592),
            d = n.Hocs.compose(n.Hocs.withObservables(null, (() => ({
                periscopeUrl: n.Rx.from(u())
            }))))((e => {
                const {
                    title: t,
                    content: s,
                    periscopeUrl: i
                } = e, d = n.Hooks.useIntl(), u = n.React.useRef(), m = n.React.useRef(), [h, p] = n.React.useState(!1);
                return n.React.useEffect((() => {
                    const {
                        current: e
                    } = u;
                    invariant(e, "No frame found for mounting the periscope");
                    const t = new a.y({
                        frame: e
                    });
                    m.current = t;
                    let s = !0;
                    return t.up().then((() => {
                        s && p(!0)
                    })), () => {
                        s = !1, t.down()
                    }
                }), []), n.React.useEffect((() => {
                    const {
                        current: e
                    } = m;
                    invariant(e, "Tried to peek at an object through the periscope, but it is not initialized"), e.peek(s)
                }), [s]), (0, r.jsxs)("div", {
                    className: l.root,
                    children: [(0, r.jsx)(c, {
                        className: l.frame + (h ? " " + l.frameLoaded : ""),
                        ref: u,
                        src: i,
                        title: t
                    }), h ? null : (0, r.jsx)("div", {
                        className: l.loadingOverlay,
                        children: (0, r.jsx)(o.u_.Loader, {
                            isLoading: !0,
                            loadingMsg: d.f.e0
                        })
                    })]
                })
            }));
        async function u() {
            return "https://periscope.nozbe.app"
        }
    }, , (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(6),
            o = s(1);
        const r = n.Hocs.compose()((() => {
            const e = n.Hooks.useIntl();
            return (0, o.jsx)(a.u_.Error, {
                children: e.f.eS
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n = s(0),
            a = s(14),
            o = s(1142),
            r = s(17),
            i = s(29),
            c = (s(11), s(18)),
            l = s(13);
        s(2), s(3);
        const d = s(606);
        var u = s(1);
        const m = "onBackground3",
            h = e => (0, o.uJ)(e).pathname,
            p = n.Hocs.compose(n.Hocs.withIntl)((e => {
                const {
                    url: t,
                    model: s,
                    hash: o,
                    intl: p
                } = e, g = n.Hooks.useServices(), {
                    name: f,
                    icon: b,
                    color: y = m,
                    strikeThrough: v = !1
                } = ((e, t, s) => {
                    const a = {
                        name: s.f.n_,
                        icon: "ľ"
                    };
                    if (!e) {
                        const e = h(t);
                        return e.endsWith("/priority") ? {
                            name: s.f.zV,
                            icon: "Ƙ",
                            color: "purple"
                        } : e.endsWith("/single_tasks") ? {
                            name: s.f.EO,
                            icon: "ƒ"
                        } : e.endsWith("/activity") ? {
                            name: s.f.y,
                            icon: "±",
                            color: "activity"
                        } : e.endsWith("/incoming") ? {
                            name: s.f.ny,
                            icon: "Ĵ",
                            color: "incoming"
                        } : e.endsWith("/search") ? {
                            name: s.f.fT,
                            icon: "ƅ"
                        } : e.endsWith("/calendar") ? {
                            name: s.f.Ed,
                            icon: "O"
                        } : e.endsWith("/messages") ? {
                            name: s.f.Kc,
                            icon: "Ķ",
                            color: "darkgreen"
                        } : a
                    }
                    if (e instanceof r.Models.Project) return {
                        name: n.Styling.getProjectName(e, s),
                        icon: n.Styling.getProjectIcon(e),
                        strikeThrough: e.isEnded,
                        color: e.color || m
                    };
                    if (e instanceof r.Models.ProjectSection) return {
                        name: e.name,
                        icon: "Ɔ",
                        strikeThrough: e.isArchived
                    };
                    if (e instanceof r.Models.Tag) return {
                        name: e.name,
                        icon: e.icon || "Ɲ",
                        color: e.color || m,
                        strikeThrough: e.isArchived
                    };
                    if (e instanceof r.Models.Task) {
                        if (e.isThread) return {
                            name: s.f.Kc,
                            icon: "Ķ",
                            color: "darkgreen"
                        };
                        const t = (() => {
                            switch (e.status) {
                                case i.TE.ABANDONED:
                                    return "%";
                                case i.TE.COMPLETED:
                                    return "Ɵ";
                                default:
                                    return "ƞ"
                            }
                        })();
                        return {
                            name: e.name,
                            icon: t,
                            color: "purple",
                            strikeThrough: e.isEnded
                        }
                    }
                    return e instanceof Object && e.member instanceof r.Models.TeamMember ? {
                        name: e.preferredName,
                        icon: "ƶ",
                        strikeThrough: e.isArchived
                    } : a
                })(s, t, p), [w, k] = n.React.useState(!1), x = v ? .5 : 1, j = (v ? .085 : .1) + (w ? .1 : 0);
                return (0, u.jsxs)("a", {
                    className: d.root,
                    style: {
                        color: n.Styling.rgba(n.Styling.factoryColor(y), x),
                        backgroundColor: n.Styling.rgba(n.Styling.factoryColor(y), j)
                    },
                    onClick: async e => {
                        e && e.preventDefault(), n.ReactUtils.stopPropagation(e);
                        try {
                            const {
                                path: e
                            } = await (async (e, t, s) => {
                                if (!t || t instanceof r.Models.Project || t instanceof r.Models.ProjectSection || t instanceof r.Models.Tag || t.member instanceof r.Models.TeamMember) return {
                                    path: h(s)
                                };
                                const n = t,
                                    o = await n.fetchCurrentProject(),
                                    i = await o.getCurrentTeam();
                                return (0, a.smartPathToTask)(i, o, n)
                            })(0, s, t);
                            g.router.goTo({
                                path: e,
                                hash: o
                            })
                        } catch (e) {
                            n.ReactUtils.devAlert("BROKEN TASK LINK")
                        }
                    },
                    onMouseEnter: () => k(!0),
                    onMouseLeave: () => k(!1),
                    href: t,
                    children: [(0, u.jsx)(l.default, {
                        className: d.icon,
                        name: b,
                        color: y,
                        size: 14
                    }), (0, u.jsx)(c.default, {
                        className: d.text + (v ? " " + d.strikeThrough : ""),
                        style: {
                            color: n.Styling.rgba(n.Styling.factoryColor(y), x)
                        },
                        children: f
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(35),
            o = s(1);
        const r = s(158).wx,
            i = n.ReactUtils.lazy((() => s(1314))),
            c = n.ReactUtils.lazy((() => s(1315))),
            l = e => {
                const {
                    member: t,
                    groupMentionId: s,
                    group: l,
                    onClose: d,
                    target: u
                } = e, m = n.Hooks.useIntl();
                return (0, o.jsxs)(o.Fragment, {
                    children: [t ? (0, o.jsx)(r.UserCard, {
                        bundle$close: d,
                        closeMenu: d,
                        member: t,
                        target: u,
                        level: 90
                    }) : null, s && (0, a.sU)(s) ? (() => {
                        const {
                            description: e,
                            layers: t,
                            title: n
                        } = ((e, t) => {
                            switch (e) {
                                case "all":
                                    return {
                                        layers: [{
                                            iconName: "ę",
                                            color: "incoming",
                                            opacity: .3,
                                            size: 200
                                        }, {
                                            iconName: "Ě",
                                            color: "incoming",
                                            size: 200
                                        }, {
                                            iconName: "ě",
                                            color: "roosterRed",
                                            size: 200
                                        }], title: t.f.Kk, description: t.f.Kj
                                    };
                                case "following":
                                    return {
                                        layers: [{
                                            iconName: "õ",
                                            color: "incoming",
                                            opacity: .3,
                                            size: 200
                                        }, {
                                            iconName: "ö",
                                            color: "incoming",
                                            size: 200
                                        }, {
                                            iconName: "÷",
                                            color: "roosterRed",
                                            size: 200
                                        }], title: t.f.Km, description: t.f.Kl
                                    };
                                default:
                                    throw new Error("Unknown group mention type " + e)
                            }
                        })(s, m);
                        return (0, o.jsx)(i, {
                            closeMenu: d,
                            target: u,
                            iconStack: t,
                            title: n,
                            message: e
                        })
                    })() : null, l ? (0, o.jsx)(c, {
                        group: l,
                        isDesktopModal: !1,
                        isMention: !0,
                        onClose: d,
                        target: u
                    }) : null]
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(256),
            o = (s(12), s(1));
        const r = n.Hocs.compose()((e => {
            const {
                closeMenu: t,
                iconStack: s,
                title: r,
                message: i,
                target: c,
                boundTo: l,
                level: d,
                placement: u,
                minHeight: m,
                isDesktopModal: h
            } = e;
            n.Hooks.useIntl();
            return (0, o.jsx)(a.Z, {
                closeMenu: t,
                iconStack: s,
                title: r,
                message: i,
                target: c,
                boundTo: l,
                level: d,
                placement: u,
                minHeight: m,
                isDesktopModal: h,
                children: e => (0, o.jsx)(o.Fragment, {
                    children: null
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(152),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)({
            minWidth: 400
        }), n.Hocs.withObservables(["group"], (({
            group: e
        }) => ({
            allMembers: e.allMembers
        }))))((e => {
            const {
                group: t,
                isMention: s,
                allMembers: i
            } = e, {
                name: c
            } = t, l = n.Hooks.useIntl(), d = [l.g("q7", {
                count: i.length
            }), !!s && l.f.q6].filter(Boolean).join(" • ");
            return (0, r.jsxs)(r.Fragment, {
                children: [null, (0, r.jsxs)(a.u_.Content, {
                    children: [(0, r.jsx)(a.u_.Heading, {
                        children: l.g("q8", {
                            name: c
                        })
                    }), (0, r.jsxs)(a.u_.Paragraph, {
                        children: [" ", d, " "]
                    }), i.map((e => (0, r.jsx)(o.Z, {
                        member: e
                    }, e.id)))]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => H
        });
        s(9);
        var n = s(404),
            a = s(159),
            o = s.n(a),
            r = s(1525),
            i = s(191),
            c = s(1198),
            l = s(794),
            d = s(345);
        var u = s(0),
            m = s(362),
            h = s(614),
            p = s(80),
            g = s(113),
            f = s(149),
            b = s(417);
        const y = e => {
            const {
                setLayout: t,
                children: s
            } = e, n = u.Hooks.useServices(), {
                webWindow: a
            } = n.scene;
            return u.React.useLayoutEffect((() => {
                const e = () => {
                    const e = u.Styling.formatLayout({
                        width: a.innerWidth,
                        height: a.innerHeight
                    }, {
                        top: 0,
                        bottom: 0
                    });
                    n.layout.update(e), t(e)
                };
                return a.addEventListener("resize", e), e(), () => a.removeEventListener("resize", e)
            }), [n.layout, a, t]), s
        };
        var v = s(1);
        const w = e => {
            const {
                children: t
            } = e, [s, n] = u.React.useState(null), {
                topInset: a = 0,
                bottomInset: o = 0,
                variant: r = "wide"
            } = s || {}, i = u.React.useMemo((() => ({
                topInset: a,
                bottomInset: o
            })), [o, a]), c = u.React.useMemo((() => ({
                variant: r,
                isNarrowLayout: "narrow" === r,
                isStandardLayout: "standard" === r,
                isWideLayout: "wide" === r,
                isUltrawideLayout: "ultrawide" === r,
                isNarrowerThan: e => u.Styling.isLayoutNarrowerThan(r, e),
                isWiderThan: e => u.Styling.isLayoutWiderThan(r, e)
            })), [r]);
            return (0, v.jsx)(y, {
                setLayout: n,
                children: s ? (0, v.jsx)(b.VY.Provider, {
                    value: s,
                    children: (0, v.jsx)(b.ZX.Provider, {
                        value: i,
                        children: (0, v.jsx)(b.LJ.Provider, {
                            value: a,
                            children: (0, v.jsx)(b.Y2.Provider, {
                                value: o,
                                children: (0, v.jsx)(b.hU.Provider, {
                                    value: c,
                                    children: (0, v.jsx)(b.v9.Provider, {
                                        value: s.isDesktop,
                                        children: t
                                    })
                                })
                            })
                        })
                    })
                }) : null
            })
        };
        var k = s(829);
        const x = u.Hocs.compose(u.Hocs.withObservables(["intl"], (({
            intl: e
        }) => ({
            intl: e
        }))))((e => {
            const {
                intl: t,
                children: s
            } = e;
            return t ? (0, v.jsx)(k.zt, {
                value: t,
                children: s
            }) : null
        }));
        var j = s(250),
            T = s(37),
            S = s(472);
        const P = u.Hocs.compose(u.Hocs.withServices, u.Hocs.withObservables(null, (({
            services: e
        }) => ({
            usesDenseLayout: u.Rx.Observable.create((t => {
                e.db.adapter.underlyingAdapter.getLocal(T.d.usesDenseLayout, (e => {
                    t.next("true" === e.value), t.complete()
                }))
            })).pipe(u.Rx.tap((t => {
                e.uiState.usesDenseLayout.next(t)
            })), u.Rx.concat(e.uiState.usesDenseLayout), u.Rx.distinctUntilChanged())
        }))))((e => {
            const {
                usesDenseLayout: t
            } = e;
            return (0, v.jsx)(S.B.Provider, {
                value: t,
                children: e.children
            })
        }));
        var _ = s(416);
        const C = u.Hocs.compose(u.Hocs.withServices, u.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isFuzzySearchEnabled: e.modelRoot.settings.isFuzzySearchEnabled.observe()
            }))))((e => {
                const {
                    isFuzzySearchEnabled: t
                } = e, s = u.React.useMemo((() => ({
                    isFuzzySearchEnabled: t
                })), [t]);
                return (0, v.jsx)(_.Z.Provider, {
                    value: s,
                    children: e.children
                })
            })),
            R = u.Hocs.compose()((e => {
                const {
                    services: t,
                    children: s
                } = e;
                return (0, v.jsx)(j.Z, {
                    children: (0, v.jsx)(g.Xp, {
                        children: (0, v.jsx)(x, {
                            intl: t.localization._intl,
                            children: (0, v.jsx)(p.Router, {
                                history: t.history._history,
                                children: (0, v.jsx)(f.H.Provider, {
                                    value: t,
                                    children: (0, v.jsx)(P, {
                                        children: (0, v.jsx)(C, {
                                            children: (0, v.jsx)(w, {
                                                children: s
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            }));
        var A = s(615);
        const I = u.Hocs.compose(u.Hocs.withRouter, u.Hocs.withErrorBoundary({
                name: "Root",
                render: "screen"
            }), u.Hocs.withServices, u.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isLoggedIn: e.appState.isLoggedIn,
                isLoggingOut: e.appState.isLoggingOut,
                isForcingRelogin: e.appState.isForcingRelogin,
                hasCanceledAccount: e.appState.hasCanceledAccount
            }))), u.Hocs.withObservables(["isLoggedIn"], (({
                services: e,
                isLoggedIn: t
            }) => ({
                teamCount: t ? e.modelRoot.teams.observeCount() : u.Rx.of([])
            }))), u.Hocs.withObservables(null, (({
                isLoggedIn: e,
                services: t
            }) => ({
                _restoredLastRoute: e ? u.Rx.from(t.history.restoreLastRoute()) : u.Rx.of(void 0),
                theme: u.Styling.theme.asObservable()
            }))))((e => {
                const {
                    RootComponent: t,
                    theme: s,
                    location: n
                } = e, a = (e => {
                    const {
                        isLoggedIn: t,
                        isForcingRelogin: s,
                        isLoggingOut: n,
                        hasCanceledAccount: a,
                        teamCount: o
                    } = e;
                    if (s) return "forcingRelogin";
                    if (n) return "loggingOut";
                    if (t) return 0 === o ? "withoutTeam" : "loggedIn";
                    if (a) return "canceledAccount";
                    if (!t) return "loggedOut";
                    throw new Error("Unrecognizable root state")
                })(e);
                return u.React.createElement(t, {
                    key: s,
                    state: a,
                    location: n
                })
            })),
            N = u.Hocs.compose(u.Hocs.memo)((e => {
                const {
                    app: t,
                    sceneId: n,
                    webWindow: a
                } = e, o = u.React.useMemo((() => {
                    const e = (0, A.j$)(n),
                        s = new h.default({
                            app: t,
                            id: n,
                            webWindow: a
                        });
                    return e && s.router.handleExternalUrl(e), new m.default(t, s)
                }), [t, n, a]);
                return u.React.useEffect((() => () => o.scene.disconnectScene()), [o.scene]), (0, v.jsx)(R, {
                    services: o,
                    children: (0, v.jsx)(I, {
                        RootComponent: null != a && a.name.includes("quickadd") ? s(943).Q : s(943).Z
                    })
                })
            }));
        s(5);
        const E = "trigger_sync";
        var O = s(1151);
        const M = o().getParser(globalThis.navigator.userAgent);

        function D(e, t, s) {
            ! function(e, t) {
                const s = e.document.body;
                if (!s) return;
                const {
                    name: n,
                    version: a
                } = t.getBrowser(), o = t.getOSName();
                ("Chrome" === n || "Microsoft Edge" === n && 70 < parseInt(a, 10)) && s.classList.add("chrome"), t.isBrowser("safari") && s.classList.add("safari"), t.isBrowser("firefox") && s.classList.add("firefox"), (0, l.Z)() && s.classList.add("pwa"), d.Z && s.classList.add("electron"), "macOS" === o && s.classList.add("macos"), "Windows" === o && s.classList.add("windows")
            }(e, M), (0, r.Kz)(e), (0, i.C)(e), (0, c.t)(e);
            const a = e.document.getElementById("application");
            invariant(a, "#application not found");
            const o = (0, n.s)(a);
            return o.render((0, v.jsx)(N, {
                app: t,
                sceneId: s,
                webWindow: e
            })), () => {
                o.unmount()
            }
        }
        async function H(e) {
            "desktop" === M.getPlatformType() && globalThis.navigator.serviceWorker && async function(e) {
                await e.native.serviceWorker.register();
                const {
                    serviceWorker: t
                } = globalThis.navigator;
                null == t || t.addEventListener("message", (t => {
                    t.data.msg === E && e.sync.synchronize()
                }))
            }(e), (0, O.C0)(), await e.restoreUserSession(), D(globalThis, e, 0), globalThis.electron && function(e) {
                globalThis.__unsafeBootChild = t => {
                    const s = Number(t.name.replace("_nozbe_child_window_", "").replace("_nozbe_quickadd_window_", ""));
                    invariant(s && 0 !== s && !Number.isNaN(s), "Invalid child window sceneId");
                    const n = D(t, e, s);
                    t.onunload = () => {
                        n()
                    }
                }, globalThis.addEventListener("beforeunload", (() => {
                    e.scenes.forEach(((e, t) => {
                        var s;
                        0 < t && (null == (s = e.webWindow) || s.close())
                    }))
                }))
            }(e)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => g
        });
        s(5);
        var n = s(4),
            a = s(17),
            o = s(23),
            r = (s(8), s(36)),
            i = s(35),
            c = s(21);

        function l(e, t) {
            return t in e.searchParams
        }

        function d(e, t) {
            return e.searchParams[t]
        }

        function u(e, t) {
            const s = e.searchParams[t];
            if (!s) throw new Error("?" + t + "= is required");
            return s
        }

        function m(e, t) {
            const s = e.searchParams[t];
            if (!s) return null;
            if ("true" === s) return !0;
            if ("false" === s) return !1;
            throw new Error("?" + t + "=true or ?" + t + "=false expected")
        }
        async function h(e, t, s, n) {
            const a = u(e, n);
            return t.get(s).find(a)
        }
        const p = Object.freeze({
            "/add_task": async (e, t) => {
                const {
                    db: s
                } = e, n = e.localization.unsafeServicesIntl, o = await h(t, s, a.Tables.projects, "project_id");
                return {
                    task_id: (await o.do.addTask({
                        name: u(t, "name"),
                        isPriority: m(t, "is_priority") || !1,
                        responsibleId: await (async () => l(t, "responsible_id") ? d(t, "responsible_id") ? (await h(t, s, a.Tables.teamMembers, "responsible_id")).id : null : (await o._me).id)(),
                        dueDate: c.DateTime.fromLegacyDueDate((() => {
                            const e = function(e, t) {
                                const s = e.searchParams[t];
                                if (!s) return null;
                                const n = Number(s);
                                if (Number.isNaN(n)) throw new Error("?" + t + "= is not a number");
                                return n
                            }(t, "due_at");
                            return e ? {
                                date: new Date(e),
                                isAllDay: m(t, "is_all_day") || !1
                            } : null
                        })()),
                        comment: (() => {
                            const e = d(t, "comment");
                            return e ? (0, i.mL)({
                                body: e
                            }, n) : void 0
                        })(),
                        shouldCheckAccess: !0
                    })).id
                }
            },
            "/add_project": async (e, t) => {
                const {
                    db: s
                } = e, n = await h(t, s, a.Tables.teams, "team_id");
                return {
                    project_id: (await n.do.createProject({
                        name: u(t, "name"),
                        description: d(t, "description"),
                        isOpen: !!m(t, "is_open"),
                        color: (() => {
                            const e = d(t, "color");
                            if (e && !r.projectColors.includes(e)) throw new Error("?color=" + e + " is not a valid color");
                            return e
                        })()
                    })).id
                }
            },
            "/update_task": async (e, t) => {
                const {
                    db: s
                } = e, n = await h(t, s, a.Tables.tasks, "task_id");
                return l(t, "is_priority") && (m(t, "is_priority") ? await n.do.markAsPriority() : await n.do.removePriority()), l(t, "is_completed") && (m(t, "is_completed") ? await n.do.complete() : await n.do.restore()), {}
            }
        });
        async function g(e, t) {
            const s = n.parseUrl(t);
            if ("x-callback-url" !== s.host) return;
            const a = await e.modelRoot.settings.xCallbackUrlSecret.fetch();
            if (a) try {
                if (s.searchParams.secret !== a) throw new Error("?secret= is incorrect");
                const t = p[s.pathname];
                if (!t) throw new Error("unknown command " + s.pathname);
                ! function(e, t) {
                    const s = e.searchParams["x-success"];
                    if (!s) return;
                    try {
                        const e = n.parseUrl(s);
                        e.searchParams = Object.assign({}, e.searchParams, t, {
                            "x-source": "Nozbe"
                        }), o.openUrl(n.encodeUrl(e))
                    } catch (e) {
                        f(new Error("Invalid ?x-success=, " + String(e)))
                    }
                }(s, await t(e, s))
            } catch (e) {
                ! function(e, t) {
                    const s = e.searchParams["x-error"];
                    if (!s) return void f(t);
                    try {
                        const e = n.parseUrl(s);
                        e.searchParams = Object.assign({}, e.searchParams, {
                            "x-source": "Nozbe",
                            errorCode: "1",
                            errorMessage: String(t)
                        }), o.openUrl(n.encodeUrl(e))
                    } catch (e) {
                        f(new Error("Invalid ?x-error=, " + String(e)))
                    }
                }(s, e)
            } else f(new Error("x-callback-url automation not enabled"))
        }

        function f(e) {
            o.devAlert("x-callback-url error: " + String(e))
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => L
        });
        var n = s(0),
            a = s(1);
        const o = () => {
            const e = n.Hooks.useLayoutBottomInset();
            return (0, a.jsx)("div", {
                style: {
                    height: e
                }
            })
        };
        var r = s(86),
            i = s(96),
            c = s(50),
            l = s(199),
            d = s(124),
            u = s(130),
            m = s(56),
            h = s(106),
            p = s(215),
            g = s(229);
        s(2), s(3);
        const f = s(619),
            b = "teamSwitch",
            y = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["team"], (({
                team: e
            }) => ({
                team: e,
                teamCurrentMember: e._unsafeCurrentMember,
                business: e.business
            }))))((e => {
                const {
                    team: t,
                    isActive: s,
                    onPress: o,
                    teamCurrentMember: r,
                    business: i
                } = e, c = n.Hooks.useIntl(), l = n.Styling.getTeamName(t, c);
                return (0, a.jsx)(g.tL, {
                    className: e.className,
                    style: e.style,
                    children: (0, a.jsxs)(g.GT, {
                        isActive: s,
                        onPress: e => o(e, t),
                        webComponent: "div",
                        androidBorderless: !0,
                        testId: n.Misc.testIds.sidebar_spaceSwitch,
                        children: [(0, a.jsxs)(g.MW, {
                            isActive: s,
                            children: [t.isPersonal ? (0, a.jsx)(m.default, {
                                member: r,
                                size: b
                            }) : (0, a.jsx)(h.default, {
                                team: t,
                                size: b,
                                showDots: !s && !!r
                            }), i ? (0, a.jsx)("div", {
                                className: f.businessMarkWrapper,
                                children: (0, a.jsx)(p.Z, {
                                    business: i
                                })
                            }) : null]
                        }), (0, a.jsx)(g.iA, {
                            isActive: s,
                            children: l
                        })]
                    })
                })
            }));
        var v = s(335);
        const w = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                teamName: t,
                label: s = t,
                color: n,
                showIncomingDot: o,
                onPress: r,
                avatarSource: i
            } = e;
            return (0, a.jsx)(g.tL, {
                children: (0, a.jsxs)(g.GT, {
                    onPress: r,
                    webComponent: "div",
                    androidBorderless: !0,
                    children: [(0, a.jsx)(g.MW, {
                        children: (0, a.jsx)(v.Z, {
                            avatarSource: i,
                            name: t,
                            color: n,
                            size: "teamSwitch",
                            dotColor: o ? "incoming" : void 0
                        })
                    }), (0, a.jsx)(g.iA, {
                        children: s
                    })]
                })
            })
        }));
        var k = s(155);
        const x = n.Hocs.compose((0, k.Z)((({
            invitation: e
        }) => ({
            avatarId: e.avatar_url,
            teamId: e.team_id
        }))))((e => {
            const {
                invitation: t,
                onPress: s,
                avatarSource: n
            } = e;
            return (0, a.jsx)(w, {
                avatarSource: n,
                teamName: t.team_name,
                color: "orange",
                showIncomingDot: !0,
                onPress: () => s(t)
            })
        }));
        var j = s(133);
        const T = s(621);
        n.Hocs.compose()((e => {
            const {
                onPress: t,
                isActive: s,
                menuTarget: o
            } = e, r = n.Hooks.useIntl();
            return (0, a.jsx)(j.Z, {
                className: T.createButton,
                iconName: "ū",
                iconColor: "backgroundPrimary",
                iconActiveColor: "backgroundPrimary",
                backgroundColor: "onBackground4",
                backgroundHoverColor: n.Styling.mix("purple", "onBackground4", 20),
                borderRadius: 1e3,
                accessibilityLabel: r.f.Ey,
                modalWebTarget: o,
                onPress: t,
                isActive: s
            })
        }));
        var S = s(62);
        const P = s(622),
            _ = e => (0, a.jsx)("div", {
                className: P.bottomButtonsContainer,
                children: e.children
            }),
            C = e => (0, a.jsx)(S.Z, {
                className: null,
                id: e.id,
                type: e.type,
                children: e.children
            });
        var R, A, I;
        const N = s(230).wx,
            E = s(105).wx,
            O = (n.ReactUtils.lazy((() => s(1319))), n.ReactUtils.lazy((() => s(1320)))),
            M = n.ReactUtils.lazy((() => s(625))),
            D = n.ReactUtils.lazy((() => s(1545))),
            H = n.ReactUtils.lazy((() => s(1326))),
            F = n.ReactUtils.lazy((() => s(1327))),
            Z = 1 / 0,
            L = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e,
                intl: t
            }) => ({
                switchableTeams: e.modelRoot.teams.observeWithColumns(d.xv).pipe(n.Rx.map((0, d.Hc)(t))),
                teamInvitations: e.modelRoot.settings.teamInvitations.observeAll(),
                joinRequests: e.modelRoot.settings.joinRequests.observeAll(),
                isSyncButtonEnabled: e.modelRoot.settings.isSyncButtonEnabled.observe(),
                hasNPAccount: e.modelRoot.settings.hasNPAccount.observe()
            }))), n.Hocs.withObservables(["switchableTeams"], (({
                switchableTeams: e
            }) => ({
                activeTeams: n.Rx.combineLatestTuples(e.map((e => [e, e.isPending]))).pipe(n.Rx.map((e => e.filter((([, e]) => !e)).map((([e]) => e)))))
            }))))((e => {
                var t;
                const {
                    switchableTeams: s,
                    activeTeams: d,
                    setDisplayedTeam: m,
                    teamInvitations: h,
                    joinRequests: p,
                    hasNPAccount: g
                } = e, f = n.Hooks.useIntl(), b = n.Hooks.useServices(), {
                    currentTeam: v
                } = n.Hooks.useIdentity(), k = (n.Hooks.useLayoutBottomInset(), n.Hooks.useModalState()), j = (0, l.Ny)(v), T = (0, l.B)(v), S = (0, l.bg)(v), L = n.Hooks.useModalState(), [B, z] = n.FP.splitAt(Z, s), [U, W] = n.FP.splitAt(Z - B.length, h), [G, V] = n.FP.splitAt(Z - B.length - U.length, p), [q, Q] = n.React.useState(null), [Y, J] = n.React.useState(null), [K, $] = n.React.useState(null), X = n.Hooks.useModalState(), ee = e => {
                    Q(e)
                }, te = e => {
                    J(e)
                }, se = async (e, t) => {
                    d.includes(t) ? m(e, t) : $(t)
                }, ne = () => {
                    b.uiState.addTeamModal.open()
                }, {
                    onDragEnd: ae
                } = n.Hooks.useDnd((() => ({
                    getDroppedSection: () => ({
                        items: B
                    }),
                    updatePosition: async (e, t) => {
                        await e.do.updateSidebarPosition(t), b.app.native.syncIosWidget("Nozbe4AddNewTaskLockScreen")
                    },
                    selector: e => e.sidebarPosition,
                    updater: (e, t) => {
                        e.sidebarPosition = t
                    }
                }))), oe = n.Hooks.useModalState(), re = null != (t = e.isSyncButtonEnabled) ? t : g, ie = n.React.useContext(u.l);
                return (0, a.jsxs)("div", {
                    className: P.root + (ie ? " " + P.rootDark : ""),
                    style: void 0,
                    children: [(0, a.jsxs)("div", {
                        className: P.wrapper,
                        children: [(0, a.jsx)(r.Z, {
                            onDragEnd: ae,
                            children: (0, a.jsxs)(C, {
                                id: "teams",
                                type: c.x.TEAM,
                                children: [B.map(((e, t) => (0, a.jsx)(i.Z, {
                                    id: e.id,
                                    position: t,
                                    type: c.x.TEAM,
                                    children: ({
                                        isDragging: t
                                    }) => (0, a.jsx)(y, {
                                        team: e,
                                        isActive: !t && e === v,
                                        onPress: se,
                                        style: void 0
                                    }, e.id)
                                }, e.id))), U.map((e => (0, a.jsx)(x, {
                                    invitation: e,
                                    onPress: ee
                                }, e.invitation_id))), G.map((e => (0, a.jsx)(w, {
                                    label: f.f.Er,
                                    teamName: e.invite_code,
                                    color: "avatarColor4",
                                    showIncomingDot: "pending" !== e.status,
                                    onPress: () => te(e)
                                }, e.invite_code)))]
                            })
                        }), (0, a.jsx)(a.Fragment, {
                            children: (0, a.jsx)(O, {
                                modalWebTarget: X.target,
                                onPress: () => {
                                    d.length ? X.open() : ne()
                                }
                            })
                        }), (0, a.jsxs)(_, {
                            children: [null, re ? R || (R = (0, a.jsx)(H, {})) : null, A || (A = (0, a.jsx)(D, {})), null]
                        })]
                    }), I || (I = (0, a.jsx)(o, {})), q ? (0, a.jsx)(M, {
                        token: {
                            inviteId: q.invitation_id,
                            teamName: q.team_name
                        },
                        onInvalidToken: () => {
                            b.modelRoot.settings.dismissTeamInvitation(q)
                        },
                        onClose: () => Q(null)
                    }) : null, Y ? (0, a.jsx)(N.JoinRequestModal, {
                        bundle$close: () => J(null),
                        onClose: () => J(null),
                        joinRequest: Y
                    }) : null, K ? (0, a.jsx)(N.PendingTeamModal, {
                        bundle$close: () => $(null),
                        onClose: () => $(null),
                        team: K
                    }) : null, oe.isOpen ? (0, a.jsx)(N.ShowMoreModal, {
                        bundle$close: oe.close,
                        onClose: oe.close,
                        teams: z,
                        selectedTeam: v,
                        onTeamItemPress: se,
                        teamInvitations: W,
                        joinRequests: V,
                        onManagePress: X.open,
                        onTeamInvitationPress: ee,
                        onJoinRequestPress: te
                    }) : null, X.isOpen ? (0, a.jsx)(N.ManageMenu, {
                        bundle$close: X.close,
                        target: X.target,
                        closeMenu: X.close,
                        activeTeams: d,
                        onAddTeamPress: ne
                    }) : null, k.isOpen ? (0, a.jsx)(F, {
                        onClose: k.close,
                        target: k.target,
                        onAddMessagePress: L.open,
                        onAddProjectPress: j.open,
                        onAddTagPress: T.open,
                        onInviteMemberPress: S.open
                    }) : null, j.render(), T.render(), S.render(), L.isOpen ? (0, a.jsx)(E.Thread, {
                        bundle$close: L.close,
                        onClose: L.close,
                        team: v,
                        maxWidth: 500,
                        minWidth: 500
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(1286);
        s(2), s(3);
        const o = s(623);
        var r = s(133),
            i = s(229),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.withObservables(["teams"], (({
            teams: e
        }) => ({
            containsIncomingTasks: n.Rx.combineLatest(e.map((e => e.incomingTasksCounter))).pipe(n.Rx.map((e => e.some((e => 0 < e)))))
        }))))((e => {
            const {
                isActive: t,
                containsIncomingTasks: s,
                hasPendingTeamInvitation: l,
                hasUpdatedJoinRequests: d,
                onPress: u
            } = e, m = n.Hooks.useIntl();
            return (0, c.jsxs)(i.tL, {
                className: o.root,
                children: [(0, c.jsxs)(i.MW, {
                    isActive: t,
                    children: [(0, c.jsx)(r.Z, {
                        iconName: "Ʀ",
                        accessibilityLabel: m.f.Es,
                        onPress: u
                    }), s || l || d ? (0, c.jsx)(a.oT, {
                        color: n.Styling.vars.color.incoming,
                        size: "teamSwitch",
                        isTeam: !0
                    }) : null]
                }), (0, c.jsx)(i.iA, {
                    children: m.f.Es
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(133),
            o = s(229);
        s(2), s(3);
        const r = s(624);
        var i = s(1);
        const c = n.React.Fragment,
            l = n.Hocs.compose()((e => {
                const {
                    onPress: t,
                    modalWebTarget: s
                } = e, l = n.Hooks.useIntl();
                return (0, i.jsxs)(o.tL, {
                    className: r.root,
                    children: [(0, i.jsx)(c, {
                        children: (0, i.jsx)(a.Z, {
                            iconName: "Ʀ",
                            accessibilityLabel: l.f.fa,
                            onPress: t,
                            modalWebTarget: s
                        })
                    }), (0, i.jsx)(o.iA, {
                        children: l.f.AO
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n = s(0),
            a = s(6),
            o = s(304),
            r = s(127),
            i = s(12),
            c = s(90),
            l = s(57);
        s(2), s(3);
        const d = s(640);
        var u, m = s(1);
        const h = n.Hocs.compose()((e => {
            const {
                onClose: t,
                onSubmit: s
            } = e, h = n.Hooks.useIntl(), [p, g] = n.React.useState(""), [f, b] = n.React.useState(!1), y = n.Hooks.useIsMounted(), v = p.includes(" ") ? 7 : 6, w = async e => {
                b(!0);
                try {
                    const t = e.trim().replace(" ", "");
                    await s(t)
                } finally {
                    y.current && b(!1)
                }
            }, k = async () => {
                w(p)
            };
            return (0, m.jsxs)(a.u_, {
                onClose: t,
                children: [(0, m.jsx)(a.u_.Header, {
                    children: h.f.i6
                }), (0, m.jsx)(a.u_.Content, {
                    keyboardShouldPersistTaps: "handled",
                    children: (0, m.jsx)(r.Z, {
                        className: d.root,
                        style: {
                            paddingBottom: 8
                        },
                        children: f ? u || (u = (0, m.jsx)(l.default, {})) : (0, m.jsxs)(m.Fragment, {
                            children: [(0, m.jsx)(o.xd, {
                                centered: !0,
                                children: h.f.i5
                            }), (0, m.jsx)(c.Z, {
                                onChange: e => {
                                    (6 === e.length || 7 === e.length) && 1 < e.length - p.length && w(e), g(e)
                                },
                                placeholder: h.f.bo,
                                autoComplete: "oneTimeCode",
                                keyboardType: "number-pad",
                                type: void 0,
                                onSubmit: k,
                                autoFocus: !0
                            }), (0, m.jsx)(i.default, {
                                onPress: k,
                                label: h.f.fi,
                                marginTop: "small",
                                type: "submit",
                                color: "incoming",
                                isDisabled: p.length < v,
                                variant: "opaque"
                            })]
                        })
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => f
        });
        var n = s(0),
            a = s(93),
            o = s(155),
            r = s(121),
            i = s(882),
            c = s(1);
        const l = n.Hocs.compose()((e => {
            const {
                invitation: {
                    inviterName: t,
                    inviterAvatarUrl: s,
                    teamId: l,
                    teamName: d,
                    teamAvatarUrl: u
                },
                color: m
            } = e, h = n.Hooks.useServices();
            return (0, c.jsx)(i.Z, {
                left: (0, c.jsx)(r.Z, {
                    observables: {
                        avatarSource: (0, o.O)(h, {
                            avatarId: s
                        })
                    },
                    resetOn: [s],
                    children: ({
                        avatarSource: e
                    }) => (0, c.jsx)(a.default, {
                        name: t,
                        color: m,
                        size: "large",
                        source: e
                    })
                }),
                right: (0, c.jsx)(r.Z, {
                    observables: {
                        avatarSource: (0, o.O)(h, {
                            avatarId: u,
                            teamId: l
                        })
                    },
                    resetOn: [u, l],
                    children: ({
                        avatarSource: e
                    }) => (0, c.jsx)(a.default, {
                        name: d || "",
                        color: m,
                        size: "large",
                        source: e,
                        isTeam: !0
                    })
                })
            })
        }));
        var d, u = s(871),
            m = s(6),
            h = s(12),
            p = s(1323);
        const g = Object.freeze({
                Accept: "accept",
                Dismiss: "dismiss"
            }),
            f = n.Hocs.compose()((e => {
                const {
                    onClose: t,
                    invitation: s,
                    invitation: {
                        inviteId: a,
                        teamName: o,
                        inviterEmail: r,
                        inviterName: i
                    }
                } = e, f = n.Hooks.useServices(), b = n.Hooks.useIntl(), y = n.Hooks.useAsyncState(), v = n.Hooks.useErrorHandler(), w = n.Hooks.useAsyncFetcher(y, (async () => {
                    await f.api.account.resolveTeamInvitation({
                        inviteToken: a,
                        accept: !0
                    }), await f.app.forceRelogin()
                })), k = e => {
                    w({
                        onSuccess: () => {
                            t(e)
                        },
                        onError: e => {
                            e.context.attemptedOperation = g.Accept
                        }
                    })
                }, x = n.Hooks.useAsyncFetcher(y, (async () => {
                    await f.api.account.resolveTeamInvitation({
                        inviteToken: a,
                        accept: !1
                    }), await f.sync.synchronize()
                })), j = e => {
                    x({
                        onSuccess: () => {
                            t(e)
                        },
                        onError: e => {
                            e.context.attemptedOperation = g.Dismiss
                        }
                    })
                };
                return y.map.activity({
                    busy: () => d || (d = (0, c.jsx)(m.u_.Loader, {
                        isLoading: !0
                    })),
                    idle: e => e.map.result({
                        unresolved: () => (0, c.jsxs)(c.Fragment, {
                            children: [(0, c.jsx)(u.G, {
                                children: (0, c.jsx)(l, {
                                    invitation: s,
                                    color: "orange"
                                })
                            }), (0, c.jsx)(m.u_.Heading, {
                                variant: "vibrant",
                                children: b.f.Jp
                            }), (0, c.jsx)(m.u_.Paragraph, {
                                children: b.g("Jq", {
                                    teamName: (0, c.jsx)(m.u_.Emphasis, {
                                        children: o
                                    }, "register-" + (o || "")),
                                    inviterName: (0, c.jsx)(m.u_.Emphasis, {
                                        children: i
                                    }, "register-" + (i || "")),
                                    inviterEmail: (0, c.jsx)(m.u_.Emphasis, {
                                        children: r
                                    }, "register-" + (r || ""))
                                })
                            }), (0, c.jsxs)(m.u_.Buttons, {
                                direction: "row-reverse",
                                children: [(0, c.jsx)(h.default, {
                                    label: b.f.e_,
                                    onPress: k,
                                    variant: "opaque",
                                    color: "orange"
                                }), (0, c.jsx)(h.default, {
                                    label: b.f.fK,
                                    onPress: j
                                })]
                            })]
                        }),
                        error: ({
                            error: e
                        }) => {
                            const s = v.translate(e),
                                n = (() => {
                                    switch (e.context.attemptedOperation) {
                                        case g.Accept:
                                            return k;
                                        case g.Dismiss:
                                            return j;
                                        default:
                                            return
                                    }
                                })();
                            return (0, c.jsx)(p.a, {
                                message: s,
                                onRetry: n,
                                onClose: t
                            })
                        }
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            a: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(1);
        const i = e => {
            const {
                message: t,
                onRetry: s,
                onClose: i
            } = e, c = n.Hooks.useIntl();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Error, {
                    children: t
                }), (0, r.jsxs)(a.u_.Buttons, {
                    children: [(0, r.jsx)(o.default, {
                        label: c.f.fh,
                        onPress: i
                    }), s ? (0, r.jsx)(o.default, {
                        label: c.f.f4,
                        onPress: s
                    }) : null]
                })]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(1323),
            i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                joinCode: t,
                onClose: s
            } = e, c = n.Hooks.useServices(), l = n.Hooks.useIntl(), d = n.Hooks.useAsyncState(), u = n.Hooks.useAsyncFetcher(d, (async () => {
                invariant(t, "Missing joinCode"), await c.api.account.requestJoinTeam({
                    joinCode: t
                })
            }));
            return (0, i.jsxs)(a.u_.Loader, {
                state: d,
                renderError: () => (0, i.jsx)(r.a, {
                    message: l.f.ke,
                    onRetry: () => u(),
                    onClose: s
                }),
                renderSuccess: () => (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(a.u_.Success, {
                        children: l.f.Jt
                    }), (0, i.jsx)(a.u_.Buttons, {
                        children: (0, i.jsx)(o.default, {
                            label: l.f.fy,
                            onPress: s
                        })
                    })]
                }),
                children: [(0, i.jsx)(a.u_.Paragraph, {
                    children: l.f.Js
                }), (0, i.jsxs)(a.u_.Buttons, {
                    children: [(0, i.jsx)(o.default, {
                        label: l.f.fh,
                        onPress: s
                    }), (0, i.jsx)(o.default, {
                        label: l.f.fW,
                        onPress: () => u(),
                        variant: "opaque",
                        color: "orange"
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(12),
            o = s(6),
            r = s(216),
            i = s(14),
            c = s(1);
        const l = n.Hocs.compose()((e => {
            const {
                token: t
            } = e, {
                isLimitedAccount: s
            } = n.Hooks.useIdentity(), l = n.Hooks.useIntl(), d = n.Hooks.useServices();
            invariant(!("valid" !== t.status && "conflict" !== t.status || "team_code" !== t.type && "team_invitations" !== t.type), "Expected a valid team invitation (either join code or join link)"), invariant(s, "Only a guest account can upgrade the account");
            const u = n.Hooks.useAsyncState(),
                m = n.Hooks.useAsyncFetcher(u, (async () => {
                    const e = await d.keychain.apiToken;
                    invariant(e, "Expected API token to be available when upgrading account");
                    const s = await n.Rx.takeFirst(d.modelRoot.currentUser);
                    invariant(s, "Expected current user to be available when upgrading account"), await (0, r.Z)({
                        services: d,
                        intl: l,
                        shouldPushHistory: !1,
                        onLoggedOut: () => {
                            const n = "team_code" === t.type ? {
                                teamCodeToken: {
                                    id: t.id,
                                    status: "valid",
                                    type: "team_code",
                                    payload: Object.assign({}, null == t ? void 0 : t.payload, {
                                        apiToken: e,
                                        email: s.myEmail
                                    })
                                }
                            } : {
                                teamInvitationToken: {
                                    id: t.id,
                                    status: "valid",
                                    type: "team_invitations",
                                    payload: Object.assign({}, null == t ? void 0 : t.payload, {
                                        apiToken: e,
                                        email: s.myEmail
                                    })
                                }
                            };
                            setTimeout((() => {
                                d.router.goTo(i.pathToRoot, n)
                            }), 0)
                        }
                    })
                }));
            return (0, c.jsxs)(c.Fragment, {
                children: [(0, c.jsx)(o.u_.Paragraph, {
                    children: l.f.Ju
                }), (0, c.jsx)(o.u_.Buttons, {
                    children: (0, c.jsx)(a.default, {
                        label: l.f.h,
                        variant: "opaque",
                        color: "purple",
                        isDisabled: u.isBusy,
                        onPress: () => m()
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0);
        s(2), s(3);
        const a = s(644);
        var o = s(133),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(["services"], (({
            services: e
        }) => ({
            isSyncing: e.sync.isSyncing
        }))))((e => {
            const {
                isSyncing: t
            } = e, s = n.Hooks.useServices(), i = n.Hooks.useIntl(), c = n.Hooks.useRemindExpired(n.FP.noop), l = function(e) {
                const [t, s] = n.React.useState(!1), a = n.React.useRef(null);
                return n.React.useEffect((() => {
                    e ? (a.current && clearTimeout(a.current), s(!0)) : a.current = setTimeout((() => {
                        s(!1)
                    }), 500)
                }), [e]), t
            }(t), d = n.React.useMemo((() => ({
                className: l ? a.syncing : void 0
            })), [l]);
            return (0, r.jsx)(o.Z, {
                iconName: "Ɯ",
                accessibilityLabel: i.f.ex,
                onPress: c((() => {
                    s.sync.synchronize()
                })),
                iconStyle: d
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(20),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                onAddProjectPress: t,
                onAddMessagePress: s,
                onAddTagPress: i,
                onInviteMemberPress: c,
                onClose: l,
                target: d
            } = e, u = n.Hooks.useServices(), m = n.Hooks.useIntl(), [{
                closeAnimated: h
            }, p] = (0, a.P9)();
            return (0, r.jsxs)(a.u_, {
                onClose: l,
                ref: p,
                target: d,
                children: [null, (0, r.jsxs)(a.u_.Content, {
                    children: [(0, r.jsx)(o.Z, {
                        label: m.f.DP,
                        icon: "Ɵ",
                        iconColor: "onBackground4",
                        hasArrow: !0,
                        onPress: e => {
                            h(e), u.uiState.quickAddModal.open()
                        }
                    }), (0, r.jsx)(o.Z, {
                        label: m.f.DN,
                        icon: "ƌ",
                        iconColor: "onBackground4",
                        hasArrow: !0,
                        onPress: e => {
                            h(e), t()
                        }
                    }), (0, r.jsx)(o.Z, {
                        label: m.f.DM,
                        icon: "Ķ",
                        iconColor: "onBackground4",
                        hasArrow: !0,
                        onPress: e => {
                            h(e), s()
                        }
                    }), (0, r.jsx)(o.Z, {
                        label: m.f.DO,
                        icon: "Ɲ",
                        iconColor: "onBackground4",
                        hasArrow: !0,
                        onPress: e => {
                            h(e), i()
                        }
                    }), (0, r.jsx)(o.Z, {
                        label: m.f.DL,
                        icon: "Ƹ",
                        iconColor: "onBackground4",
                        hasArrow: !0,
                        onPress: e => {
                            h(e), c()
                        }
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => s.e(584).then(s.bind(s, 1503))))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            wx: () => r
        });
        var n = s(58);
        const {
            getImported: a,
            render: o,
            components: r
        } = (0, n.Zv)((() => s.e(90).then(s.bind(s, 1504))))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n, a, o = s(0),
            r = s(57),
            i = s(12),
            c = s(6),
            l = s(30),
            d = s(648),
            u = s(1);
        const m = o.ReactUtils.lazy((() => s(258))),
            h = o.Hocs.compose(o.Hocs.withServices, o.Hocs.withObservables(null, (({
                services: e
            }) => ({
                isSyncing: e.sync.isSyncing,
                notificationState: o.Rx.from(e.notifications.areNotificationsEnabled())
            }))))((e => {
                const {
                    code: t,
                    provider: s,
                    isNewAccount: h,
                    isSyncing: p,
                    notificationState: g
                } = e, f = o.Hooks.useServices(), b = o.Hooks.useIntl(), [y, v] = o.React.useState(!1), w = o.React.useRef(null), k = o.React.useCallback((e => f.account.signInWithThirdParty({
                    code: e.code,
                    provider: e.provider,
                    marketingConsent: e.marketingConsent
                })), [f]), {
                    submit: x,
                    error: j,
                    isSyncingNice: T,
                    renderNotificationExplainModal: S
                } = (0, l.f0)({
                    isSyncing: p,
                    notificationState: g,
                    signIn: k,
                    invalidErrorMessage: b.g("i$", {
                        provider: s
                    })
                });
                o.React.useEffect((() => {
                    if (!h) {
                        const e = () => x({
                            code: t,
                            provider: s
                        });
                        w.current = e, e()
                    }
                }), []);
                const P = (0, l.AG)(),
                    _ = (0, l.Rg)();
                o.Hooks.useBackButton((() => (_(), !0)));
                const C = h ? b.f.jh : b.f.i4;
                return h && !y ? (0, u.jsx)(l.xD, {
                    title: C,
                    children: (0, u.jsxs)(d.i, {
                        children: [P ? n || (n = (0, u.jsx)(l.TR, {
                            size: "medium"
                        })) : null, (0, u.jsx)(m, {
                            goToNext: e => {
                                x({
                                    code: t,
                                    provider: s,
                                    marketingConsent: e
                                })
                            },
                            goBack: () => _(),
                            setMarketingConsent: () => v(!0)
                        })]
                    })
                }) : (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsxs)(l.xD, {
                        isCentered: !1,
                        title: T ? void 0 : C,
                        children: [P ? (0, u.jsx)(l.TR, {
                            size: T ? "medium" : "small"
                        }) : null, j ? (0, u.jsxs)(u.Fragment, {
                            children: [(0, u.jsx)(c.u_.Error, {
                                style: {
                                    marginTop: 18
                                },
                                children: j
                            }), w.current ? (0, u.jsx)(i.default, {
                                onPress: w.current,
                                marginTop: "big",
                                label: b.f.f4
                            }) : null, (0, u.jsx)(i.default, {
                                onPress: () => _(),
                                marginTop: w.current ? "small" : "big",
                                label: b.f.fd
                            })]
                        }) : (0, u.jsxs)(u.Fragment, {
                            children: [(0, u.jsx)(l.v0, {
                                text: b.f.jb,
                                atBottom: !1
                            }), a || (a = (0, u.jsx)(r.default, {}))]
                        })]
                    }), S()]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => p
        });
        var n = s(0),
            a = s(43),
            o = s(11),
            r = s(1536),
            i = s(12),
            c = s(1460),
            l = s(30);
        s(2), s(3);
        const d = s(661);
        var u = s(1);
        const m = 1 / 0,
            h = n.ReactUtils.lazy((() => s(1332))),
            p = n.Hocs.compose()((e => {
                const {
                    setMembers: t,
                    initialMembers: s,
                    goToNext: p,
                    goBack: g
                } = e, f = n.Hooks.useIntl(), b = (n.Hooks.useServices(), n.Hooks.useModalState()), [y, v] = n.React.useState(0 < s.length ? s : [""]), w = y.length >= m, k = e => {
                    v(e.slice(0, m))
                }, x = n.Hooks.useMultipleValidation([a.Jh], y), j = n.FP.keys(x.validResults), T = y.filter(((e, t) => !!e && j.includes("" + t))), S = () => {
                    x.isAnyValid && t(T)
                }, P = () => {
                    C ? (n.ReactUtils.dismissKeyboard(), b.open()) : (S(), p())
                }, _ = T.length, C = _ > 4;
                return (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsx)(l.bu, {
                        label: _ ? f.g("jJ", {
                            memberCount: _
                        }) : f.f.jK,
                        rightLabel: C ? f.f.jM : f.f.jL,
                        rightLabelColor: C ? "purple" : "textSecondary",
                        description: f.f.jI
                    }), (0, u.jsxs)("div", {
                        className: d.scroll,
                        children: [(0, u.jsx)(r.Z, {
                            placeholder: y.length ? f.f.jO : f.f.jN,
                            forEntryViews: !0,
                            onChange: k,
                            values: y,
                            type: "email",
                            autoComplete: "email",
                            validation: x,
                            autoFocus: !0,
                            onSubmit: P
                        }), w ? null : (0, u.jsx)(o.Z, {
                            className: d.emailWrapper,
                            onPress: () => (e => {
                                const t = n.FP.unique([...y.filter((e => e.trim())), ...e]);
                                k(t)
                            })([""]),
                            children: (0, u.jsx)("span", {
                                className: d.emailText,
                                children: "+"
                            })
                        })]
                    }), (0, u.jsxs)(c.Z, {
                        paddingToKeyboard: 12,
                        children: [(0, u.jsx)(i.default, {
                            onPress: P,
                            marginTop: "big",
                            variant: "opaque",
                            color: "purple",
                            label: 0 === _ ? f.f.fB : f.f.fD
                        }), null]
                    }), (0, u.jsx)(i.default, {
                        marginTop: "big",
                        onPress: g,
                        label: f.f.fd
                    }), b.isOpen ? (0, u.jsx)(h, {
                        onClose: b.close,
                        onConfirm: n.ReactUtils.callBoth(S, p),
                        invitesCount: _
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(64),
            o = s(6),
            r = s(40),
            i = s(53),
            c = s(30);
        s(2), s(3);
        const l = s(662);
        var d = s(1);
        const u = n.Hocs.compose()((e => {
            const {
                onClose: t,
                onConfirm: s,
                invitesCount: u
            } = e, m = n.Hooks.useIntl(), h = n.Hooks.useLayoutBottomInset(), p = m.formatDate((0, a.Z)(new Date, 30), {
                month: "long",
                day: "numeric"
            }), [{
                closeAnimated: g
            }, f] = (0, o.P9)();
            return (0, d.jsx)(o.u_, {
                ref: f,
                onClose: t,
                size: "content",
                children: (0, d.jsxs)("div", {
                    className: l.root,
                    style: {
                        paddingBottom: h || void 0
                    },
                    children: [(0, d.jsx)(r.default, {
                        className: l.icon,
                        layers: [{
                            iconName: "Ģ",
                            color: "orange",
                            opacity: 1,
                            size: 210
                        }, {
                            iconName: "ģ",
                            color: "orange",
                            opacity: .3,
                            size: 210
                        }]
                    }), (0, d.jsx)(c.bu, {
                        label: m.f.jQ,
                        description: m.g("jP", {
                            invitesCount: u,
                            endDateFormatted: p
                        })
                    }), (0, d.jsxs)("div", {
                        className: l.buttonContainer,
                        children: [(0, d.jsx)(i.default, {
                            onPress: g,
                            isDisabled: !1,
                            withFlexOnWeb: !0,
                            label: m.f.fd
                        }), (0, d.jsx)(i.default, {
                            onPress: s,
                            withFlexOnWeb: !0,
                            type: "incoming",
                            label: m.f.fi
                        })]
                    })]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n = s(0),
            a = s(12),
            o = s(57),
            r = s(30),
            i = s(366);
        s(2), s(3);
        const c = s(664);
        var l, d, u = s(1);
        const m = (e, t) => "account_exists" === e ? t.f.ko : t.f.kn,
            h = n.Hocs.compose(n.Hocs.withErrorBoundary({
                name: "Submit",
                render: "screen"
            }))((e => {
                const {
                    onBack: t,
                    email: s,
                    onSubmit: h,
                    signUpStatus: p,
                    signUpError: g
                } = e, f = n.Hooks.useIntl();
                n.React.useEffect((() => {
                    h()
                }), []);
                const b = (0, r.AG)();
                return (0, u.jsx)(u.Fragment, {
                    children: {
                        busy: (0, u.jsxs)("div", {
                            className: c.wrapper + " " + c.centered,
                            children: [b ? (0, u.jsx)(r.TR, {
                                size: "medium",
                                withFlex: !1
                            }) : null, (0, u.jsxs)("div", {
                                className: c.container,
                                children: [(0, u.jsx)(r.v0, {
                                    text: f.f.e$,
                                    atBottom: !1
                                }), l || (l = (0, u.jsx)(o.default, {}))]
                            })]
                        }),
                        confirmation_required: (0, u.jsx)(i.Z, {
                            email: s,
                            onSendAgain: () => {
                                h()
                            }
                        }),
                        error: (0, u.jsxs)("div", {
                            className: c.wrapper + ("account_exists" === g ? " " + c.centered : ""),
                            children: [b ? d || (d = (0, u.jsx)(r.TR, {
                                size: "medium"
                            })) : null, (0, u.jsx)(r.v0, {
                                text: m(g, f),
                                atBottom: !1
                            }), "account_exists" !== g ? (0, u.jsxs)(u.Fragment, {
                                children: [(0, u.jsx)(a.default, {
                                    className: c.button,
                                    onPress: h,
                                    label: f.f.f4
                                }), (0, u.jsx)(a.default, {
                                    className: c.button,
                                    marginTop: "big",
                                    onPress: t,
                                    label: f.f.fd
                                })]
                            }) : null]
                        })
                    } [p]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => U
        });
        var n = s(0),
            a = s(29),
            o = s(315),
            r = s(1);
        s(259).wx;
        const i = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "ProjectFollowTour",
            render: "alert"
        }), n.Hocs.withServices, n.Hocs.withObservables(["services"], (({
            services: e
        }) => ({
            requiresNewOnboarding: e.modelRoot.settings.requiresNewOnboarding.observe(),
            sawGeneralOnboarding: e.modelRoot.settings.sawGeneralOnboarding.observe(),
            sawProjectFollowOnboarding: e.modelRoot.settings.sawProjectFollowOnboarding.observe()
        }))))((e => {
            const {
                requiresNewOnboarding: t,
                sawGeneralOnboarding: a,
                sawProjectFollowOnboarding: o,
                projectName: i
            } = e, {
                isLimitedAccount: c
            } = n.Hooks.useIdentity();
            if (!c && t && a && !o) {
                const e = s(892).Z;
                return (0, r.jsx)(e, {
                    projectName: i
                })
            }
            return null
        }));
        var c = s(14),
            l = s(17),
            d = s(89),
            u = s(74),
            m = s(167),
            h = s(50),
            p = s(48),
            g = s(44),
            f = s(1364),
            b = s(47),
            y = s(70),
            v = s(75),
            w = s(62),
            k = s(96),
            x = s(22),
            j = s(97);
        const T = s(310).wx,
            S = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["section"], (({
                section: e
            }) => ({
                section: e
            }))), n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                project: e,
                team: e.currentTeam
            }))), n.Hocs.withObservables(["groupCounters"], (({
                groupCounters: e
            }) => ({
                groupCounters: e || n.Rx.of(null)
            }))))((e => {
                const {
                    section: t,
                    project: s,
                    isSectionShowingThePast: a,
                    isProjectShowingThePast: i,
                    toggleSectionShowingThePast: c,
                    tasks: l,
                    onNewTaskFormShow: d,
                    setNewTaskFormPosition: u,
                    sections: m,
                    team: h,
                    hasActivity: g,
                    needsReview: f,
                    isCollapsed: b,
                    isHighlighted: y,
                    groupCounters: v
                } = e, w = n.Hooks.useServices(), k = n.Hooks.useIntl(), S = n.Hooks.useModalState(), P = n.React.useRef(null), _ = () => null == e.toggleCollapse ? void 0 : e.toggleCollapse(s.id + ":" + t.id), C = () => {
                    b && _(), d(), u({
                        position: "top",
                        section: t
                    })
                }, R = "section-" + t.id, A = () => {
                    const e = P.current;
                    e && function(e, t, s, a = !0) {
                        setTimeout((() => {
                            a && n.ReactUtils.scrollIntoView({
                                element: e,
                                alignment: "bottom",
                                scrollMode: "always"
                            }), n.ReactUtils.scrollIntoView({
                                element: e,
                                alignment: "top",
                                scrollMode: "always"
                            })
                        }), 100)
                    }(e)
                }, I = t === m[0], N = t === m[m.length - 1];
                n.React.useEffect((() => {
                    y && A()
                }), [y, P.current, w.scene]);
                const E = (0, p.h$)();
                return (0, r.jsxs)(r.Fragment, {
                    children: [(0, r.jsx)(j.Z, {
                        headerRef: P,
                        testId: R,
                        hasThreeDots: !0,
                        onCollapsePress: _,
                        isCollapsed: b,
                        hasActivity: g,
                        needsReview: f,
                        counters: null == v ? void 0 : v.activeTasks,
                        onCountersPress: () => {
                            null == E || E.showForSection(t)
                        },
                        right: s.isEnded || t.isArchived ? null : (0, r.jsx)(x.default, {
                            name: "ū",
                            iconSize: 28,
                            color: "onBackground3",
                            onPress: () => {
                                C()
                            },
                            accessibilityLabel: k.f.mJ
                        }),
                        onMenuPress: S.open,
                        menuTarget: S.target,
                        hasHairline: !N && !l.length,
                        isEnded: t.isArchived,
                        tasks: l,
                        viewColor: s.color,
                        children: t.name
                    }), S.isOpen ? (0, r.jsx)(T.SectionMenu, {
                        bundle$close: S.close,
                        closeMenu: S.close,
                        isSectionShowingThePast: a,
                        isProjectShowingThePast: i,
                        toggleSectionShowingThePast: c,
                        team: h,
                        target: S.target,
                        section: t,
                        isReadOnly: s.isEnded,
                        isFirst: I,
                        isLast: N,
                        moveUp: async () => {
                            await (0, o.Rw)({
                                section: t,
                                sections: m,
                                offset: -1
                            }), A()
                        },
                        moveDown: async () => {
                            await (0, o.Rw)({
                                section: t,
                                sections: m,
                                offset: 1
                            }), A()
                        },
                        showNewTaskForm: C
                    }) : null]
                })
            })),
            P = n.ReactUtils.lazy((() => s(1366))),
            _ = ({
                project: e,
                toggleSectionCollapse: t,
                toggleSectionShowingThePast: s,
                taskGroups: a,
                sections: o,
                isProjectShowingThePast: i,
                newTaskFormProps: {
                    setPositionGroup: c
                },
                highlightedSectionId: d,
                counters: u
            }, m) => p => {
                var g;
                invariant(p instanceof l.Models.ProjectSection, "Section is not instance of ProjectSection");
                const f = n.FP.find((e => e.root === p), a);
                invariant(f, "Unexpected missing taskGroup");
                const b = "hidden" !== f.endedTasksState,
                    {
                        isCollapsed: y
                    } = f,
                    v = n.FP.indexOf(f, a),
                    w = null == u || null == (g = u.groups) ? void 0 : g.get(f);
                return (0, r.jsx)(k.Z, {
                    id: "" + h.M.draggable + p.id,
                    position: v - 1,
                    type: h.x.SECTION,
                    children: () => (0, r.jsx)(S, {
                        hasActivity: f.items.some((e => e.isUnread)),
                        needsReview: f.items.some((e => e.doesNeedReview)),
                        isSectionShowingThePast: b,
                        isProjectShowingThePast: i,
                        toggleSectionShowingThePast: s,
                        onNewTaskFormShow: m,
                        tasks: f.items,
                        sections: o,
                        toggleCollapse: t,
                        isCollapsed: y,
                        setNewTaskFormPosition: c,
                        project: e,
                        section: p,
                        isHighlighted: p.id === d,
                        groupCounters: w
                    })
                }, "section_header-" + ((null == p ? void 0 : p.id) || "WITHOUT_SECTION"))
            },
            C = (e, t) => {
                const {
                    root: s
                } = e, n = s instanceof l.Models.ProjectSection ? s.id : "none";
                return (0, r.jsx)(w.Z, {
                    id: "" + h.M.droppable + n,
                    type: h.x.TASK,
                    children: t
                }, "droppable-" + n)
            },
            R = e => t => (invariant(t instanceof l.Models.Project, "Unexpected project is not instance of Project"), e ? (0, r.jsx)(P, {
                project: t
            }) : null);
        s(2), s(3);
        const A = s(740),
            I = e => (0, r.jsx)(w.Z, {
                className: A.droppable,
                id: "sections",
                children: e.children
            }),
            N = n.ReactUtils.lazy((() => s(1367))),
            E = n.ReactUtils.lazy((() => s(1368))),
            O = n.ReactUtils.lazy((() => s(1369))),
            M = n.ReactUtils.lazy((() => s(1370))),
            D = n.Hocs.compose(n.Hocs.memo)((e => {
                var t, s, a, o;
                const {
                    project: i,
                    isShowingDevInfo: c,
                    taskGroups: l,
                    onSetEndedTasksState: d,
                    newTaskFormProps: u,
                    isDndEnabled: m,
                    filterState: h,
                    taskDetailsProps: p
                } = e;
                n.Hooks.useModel(i);
                const f = (0, g.aO)(u.onShow, p),
                    {
                        description: b,
                        shouldHidePurpose: y,
                        isShared: w,
                        hasPendingInvitation: k,
                        isTemplate: x
                    } = i,
                    j = n.React.useCallback((() => (0, r.jsxs)(r.Fragment, {
                        children: [b && !y ? t || (t = (0, r.jsx)(N, {
                            project: i
                        })) : null, w || i.hasBeenUnshared ? s || (s = (0, r.jsx)(E, {
                            project: i
                        })) : null, x ? a || (a = (0, r.jsx)(O, {
                            project: i
                        })) : null, k ? o || (o = (0, r.jsx)(M, {
                            project: i
                        })) : null]
                    })), [b, k, w, x, i, y]);
                return (0, r.jsx)(v.Z, {
                    taskGroups: l,
                    filterState: h,
                    renderSectionHeader: _(e, f),
                    viewColor: i.color,
                    newTaskFormProps: u,
                    rootRecord: i,
                    isDndEnabled: m,
                    hasMasterPlus: !0,
                    renderListFooter: R(c),
                    renderListHeader: j,
                    renderSectionItemsContainer: C,
                    ContentWrapperWeb: I,
                    onSetEndedTasksState: d,
                    isProjectVisible: !1
                })
            }));
        s(5), s(4);
        const H = /[?#]section=([^#]*)&?/,
            F = e => {
                const {
                    state: t,
                    hash: s
                } = e;
                if (null != t && t.section) return t.section;
                const n = s.match(H);
                return n ? n[1] : null
            },
            Z = ({
                droppedListId: e,
                taskGroups: t
            }) => {
                const s = t.find((({
                    root: t
                }) => "none" === e ? null === t : (invariant("string" != typeof t, "Dropped section is a string not a Model"), ((null == t ? void 0 : t.id) || null) === e)));
                return invariant(s, "Unexpected missing task group"), s
            },
            L = n.ReactUtils.lazy((() => s(1371))),
            B = n.ReactUtils.lazy((() => s(1372)));
        const z = s(310).wx,
            U = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withErrorBoundary({
                name: "Project",
                onReset: ({
                    services: e,
                    currentTeam: t,
                    isLimitedAccount: s
                }) => {
                    e.router.goTo((0, c.getPathToCurrentTeamRoot)(t, s))
                }
            }), n.Hocs.withHooks((({
                match: e,
                location: t
            }) => ({
                projectId: e.params.projectId,
                highlightedSectionId: F(t)
            }))), n.Hocs.withObservables(["projectId"], (({
                projectId: e,
                services: t,
                currentTeam: s,
                isLimitedAccount: a
            }) => ({
                project: t.db.get(l.Tables.projects).findAndObserve(e).pipe(n.Rx.doOnErrorComplete((() => {
                    t.router.goTo((0, c.getPathToCurrentTeamRoot)(s, a))
                })))
            }))), (0, y.hp)((({
                project: e
            }) => ({
                viewId: e.id,
                initialState: {
                    filterProject: e.id,
                    filterProjects: [e.id],
                    disabledOptions: ["project", "projects", "groups", "groupBy"]
                }
            }))), n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                justEndedTasks: e.uiState.forTeam(t).justEndedTasks
            }))), n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                sections: e.activeSections.pipe(o.K3)
            }))), n.Hocs.withObservables(["project", "filterState", "justEndedTasks"], (({
                filterState: e,
                services: t,
                project: s,
                justEndedTasks: n
            }) => {
                var o;
                return {
                    tasks: t.database.get(l.Tables.tasks).query(...(0, d.Z)(Object.assign({}, (0, y.LB)(e), {
                        projectId: s.id
                    }))).pipe((0, a.EF)(n, null != (o = e.sort) ? o : {
                        by: "projectPosition",
                        order: "ascending"
                    }, !!e.sort))
                }
            })), n.Hocs.withHooks((({
                project: e,
                services: t,
                currentTeam: s,
                isLimitedAccount: a
            }) => (n.React.useEffect((() => {
                e.team.id === s.id || e.isShared || t.router.goTo((0, c.getPathToCurrentTeamRoot)(s, a))
            })), {}))), n.Hocs.withHooks((({
                project: e
            }) => (0, g.Nk)(e))), n.Hocs.withObservables(["project", "isShowingThePast"], (({
                project: e,
                isShowingThePast: t
            }) => ({
                archivedSections: t ? e.archivedSections.pipe(o.K3) : n.Rx.of([])
            }))), n.Hocs.withHooks((({
                filterState: e,
                setFilterState: t,
                tasks: s,
                justEndedTasks: o,
                sections: r,
                project: i,
                archivedSections: c,
                endedTasksStates: l,
                isShowingThePast: d
            }) => {
                const {
                    activeAndJustEndedTasks: u
                } = n.React.useMemo((() => (0, a.rq)(s, o)), [s, o]), {
                    collapsedSectionsStates: m,
                    toggleSectionCollapse: h
                } = (0, g.SK)(), p = n.React.useMemo((() => [null, ...r, ...c]), [r, c]), {
                    taskGroups: b,
                    sortedTasks: y
                } = (0, f.U)({
                    sections: p,
                    groupTasksBySection: () => (0, g.YU)((e => e.projectSection.id), s),
                    getTasksForSection: (e, t) => t.get((null == e ? void 0 : e.id) || null) || [],
                    justEndedTasks: o,
                    listRootId: i.id,
                    endedTasksStates: l,
                    collapsedSectionsStates: m,
                    isShowingThePast: d
                }), v = n.React.useMemo((() => b.map((e => ((e, t) => {
                    const {
                        items: s
                    } = t, n = s.filter((t => e.includes(t)));
                    return Object.assign({}, t, {
                        items: n
                    })
                })(u, e)))), [b, u]);
                return {
                    taskGroups: b,
                    activeTaskGroups: v,
                    sortedTasks: y,
                    filterState: e,
                    setFilterState: t,
                    toggleSectionCollapse: h
                }
            })))((e => {
                const {
                    project: t,
                    isShowingThePast: s,
                    toggleShowThePast: a,
                    tasks: o,
                    sortedTasks: l,
                    taskGroups: d,
                    activeTaskGroups: f,
                    setEndedTasksState: y,
                    toggleSectionShowingThePast: v,
                    toggleSectionCollapse: w,
                    sections: k,
                    services: x,
                    setFilterState: j,
                    filterState: T,
                    highlightedSectionId: S
                } = e, P = n.Hooks.useIntl(), _ = n.Hooks.useModalState(), {
                    currentTeam: C,
                    isLimitedAccount: R
                } = n.Hooks.useIdentity(), A = function(e) {
                    var t, s;
                    const {
                        currentMember: a
                    } = n.Hooks.useIdentity(), o = n.Hooks.useModalState();
                    n.React.useEffect((() => {
                        const t = !e.hasBeenUnshared && (e.hasAcceptedInvitation || e.hasRejectedInvitation),
                            {
                                invitation: s
                            } = e;
                        if (t && s) {
                            const {
                                invited_by: e
                            } = s;
                            e === a.id && o.open()
                        }
                    }), [a.id, o, e]);
                    const i = async () => {
                        o.close(), await e.do.clearInvitation()
                    };
                    return () => {
                        if (o.isOpen) {
                            if (e.hasAcceptedInvitation) return t || (t = (0, r.jsx)(L, {
                                project: e,
                                onClose: i
                            }));
                            if (e.hasRejectedInvitation) return s || (s = (0, r.jsx)(B, {
                                project: e,
                                onClose: i
                            }))
                        }
                        return null
                    }
                }(t), I = t.isActive && !t.isFollowed && !_.isOpen, N = n.React.useMemo((() => !t.isFollowed && t.isActive ? ((e, t, s, a) => () => (0, r.jsxs)(r.Fragment, {
                    children: [a ? (0, r.jsx)(i, {
                        projectName: n.Styling.getProjectName(e, s)
                    }) : null, (0, r.jsx)(m.Z, {
                        onPress: t,
                        color: e.color,
                        accessibilityLabel: s.f.mG,
                        testId: n.Misc.testIds.taskList_follow,
                        children: s.f.fx
                    })]
                }))(t, (() => t.follow()), P, I) : null), [t.isFollowed, t.isActive, t, P, I]), E = (0, g.Or)(c.routeToProjectTask), {
                    newTaskFormProps: O,
                    newTaskFormVisibility: M
                } = (0, g.G8)({
                    defaultProject: t,
                    taskGroups: d,
                    rootRecord: t
                }), H = n.Hooks.useDnd((e => e.type === h.x.TASK ? ((e, t) => {
                    const {
                        setNewTaskFormPosition: s,
                        activeTaskGroups: n
                    } = e;
                    return {
                        setNewTaskFormPosition: s,
                        selector: e => e.projectPosition,
                        updater: (e, t) => {
                            e.projectPosition = t
                        },
                        updatePosition: async (e, s, n) => {
                            var a;
                            (null == (a = t.destination) ? void 0 : a.droppableId) === t.source.droppableId ? await e.do.updateProjectPosition(s) : await e.do.moveToSection(n, {
                                position: s
                            })
                        },
                        getDroppedSection: () => {
                            var e;
                            return Z({
                                droppedListId: null == (e = t.destination) ? void 0 : e.droppableId,
                                taskGroups: n
                            })
                        },
                        getSourceList: () => Z({
                            droppedListId: t.source.droppableId,
                            taskGroups: n
                        }).items
                    }
                })({
                    setNewTaskFormPosition: G,
                    activeTaskGroups: f
                }, e) : (e => ({
                    selector: e => e.position,
                    getDroppedSection: () => ({
                        items: e
                    }),
                    updatePosition: async (e, t) => {
                        await e.do.updatePosition(t)
                    }
                }))(k))), {
                    onDragEnd: F
                } = H, U = n.Hooks.useModalState(), {
                    positionGroup: W,
                    setPositionGroup: G
                } = O, V = n.React.useCallback((() => {
                    null !== W.section && G({
                        position: "top",
                        section: null
                    })
                }), [W, G]);
                n.React.useEffect((() => {
                    t.isSingleTasks ? x.router.goTo((0, c.getPathToCurrentTeamRoot)(C, R)) : t.do.markAsSeen()
                }), [t]);
                const q = n.Rx.of(l.filter((e => e.isActive)).length),
                    Q = (0, b.x)(l, n.Styling.getProjectName(t, P)),
                    Y = (0, p.W$)(d, t),
                    {
                        stats: J,
                        renderStatsModal: K
                    } = (0, p.bB)({
                        root: t,
                        tasks: o,
                        taskGroups: d,
                        filterState: T
                    });
                return t.sharedTeam.id !== C.id && t.team.id !== C.id ? null : (0, r.jsx)(p.MV, {
                    counters: Y,
                    children: (0, r.jsx)(p.aq, {
                        stats: J,
                        children: (0, r.jsx)(u.Z, {
                            rootRecord: t,
                            title: n.Styling.getProjectName(t, P),
                            color: t.color,
                            leftIcon: n.Styling.getProjectIcon(t),
                            openViewMenu: _.open,
                            taskDetailsProps: E,
                            menuTarget: _.target,
                            activeTasksCounter: q,
                            renderExtraMasterButtons: N,
                            onMasterPlusPress: V,
                            onDragEnd: F,
                            sortedTasks: l,
                            isEnded: t.isEnded,
                            newTaskFormVisibility: M,
                            project: t,
                            newTaskFormProps: O,
                            setFilterState: j,
                            filterState: T,
                            children: (0, r.jsxs)(r.Fragment, {
                                children: [(0, r.jsx)(D, {
                                    project: t,
                                    taskGroups: d,
                                    sections: k,
                                    onSetEndedTasksState: y,
                                    isProjectShowingThePast: s,
                                    toggleSectionShowingThePast: v,
                                    toggleSectionCollapse: w,
                                    isShowingDevInfo: U.isOpen,
                                    newTaskFormProps: O,
                                    taskDetailsProps: E,
                                    isDndEnabled: !T.sort,
                                    highlightedSectionId: S,
                                    counters: Y,
                                    filterState: T
                                }), _.isOpen ? (0, r.jsx)(z.Menu, {
                                    bundle$close: _.close,
                                    project: t,
                                    closeMenu: _.close,
                                    isShowingThePast: s,
                                    onToggleThePast: a,
                                    onPressShowDevInfo: U.open,
                                    target: _.target,
                                    saveToCSV: Q,
                                    newTaskFormProps: O
                                }) : null, A(), K()]
                            })
                        })
                    })
                })
            }))
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        s(2), s(3);
        const n = s(672)
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(14),
            o = s(585);
        s(2), s(3);
        const r = s(676);
        var i = s(1);
        const c = n.Hocs.compose(n.Hocs.withObservables(["comment"], (({
            comment: e
        }) => ({
            task: e.task
        }))), n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            project: e.observeCurrentProject(),
            section: e.isGranted ? n.Rx.of(null) : e.projectSection
        }))), n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            isProjectPrivate: e.permissions.isPrivate
        }))))((e => {
            const {
                task: t,
                project: s,
                isProjectPrivate: c,
                section: l
            } = e, d = n.Hooks.useIntl(), u = n.Hooks.useServices(), m = (0, o.s)({
                isSelected: !1,
                alreadyReviewed: !1
            });
            return (0, i.jsxs)("div", {
                className: r.root,
                children: [m({
                    iconName: t.isEnded ? "Ɵ" : "ƞ",
                    iconColor: "textPrimary",
                    isCrossedOut: t.isEnded,
                    textColor: "textPrimary",
                    label: t.name,
                    lock: !1,
                    onPress: async () => {
                        const e = await s.getCurrentTeam();
                        u.router.goTo(a.smartPathToTask(e, s, t))
                    }
                }), m({
                    iconName: n.Styling.getProjectIcon(s),
                    iconColor: s.color,
                    isCrossedOut: s.isEnded,
                    textColor: "textPrimary",
                    label: n.Styling.getProjectName(s, d),
                    lock: c,
                    onPress: async e => {
                        if (!s) return;
                        const t = await s.getCurrentTeam();
                        t && (n.ReactUtils.stopPropagation(e), e.preventDefault(), u.router.goTo(a.smartPathToProject(t, s)))
                    }
                }), l ? m({
                    iconName: "Ɔ",
                    iconColor: "textPrimary",
                    textColor: "textPrimary",
                    label: l.name,
                    lock: !1
                }) : null]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(680))),
            r = n.Hocs.compose(n.Hocs.withObservables(["comment"], (({
                comment: e
            }) => ({
                attachments: e.latestAttachmentVersions
            }))))((e => {
                const {
                    attachments: t,
                    comment: s
                } = e;
                return (0, a.jsx)(a.Fragment, {
                    children: t.map((e => (0, a.jsx)(o, {
                        latestVersion: e,
                        comment: s
                    }, e.id)))
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => y
        });
        var n = s(0),
            a = s(589),
            o = s(6),
            r = s(22),
            i = s(60),
            c = s(109),
            l = s(1);
        const d = n.Hocs.compose()((e => {
            const {
                type: t,
                isDisabled: s,
                onPress: a
            } = e, o = n.Hooks.useIntl(), i = "next" === t;
            return n.Hooks.useEventListener({
                eventName: "keydown",
                handler: e => {
                    const t = i ? "ArrowRight" : "ArrowLeft";
                    e.key !== t || s || (n.ReactUtils.stopPropagation(e), n.ReactUtils.preventDefault(e), a())
                }
            }), (0, l.jsx)(r.default, {
                name: i ? "9" : "7",
                color: "onBackground3",
                withHover: !0,
                size: 44,
                iconSize: 33,
                accessibilityLabel: i ? o.f.fD : o.f.fd,
                onPress: a,
                isDisabled: s
            })
        }));
        var u = s(204),
            m = s(92);
        const h = n.Hocs.compose()((e => {
            const {
                files: t,
                onDownloadError: s
            } = e, a = n.Hooks.useIntl(), o = n.Hooks.useServices(), r = n.Hooks.useAsyncState(), i = n.Hooks.useAsyncFetcher(r, (async () => {
                await Promise.all(t.map((async e => {
                    if (e instanceof n.Model.Models.AttachmentVersion) {
                        const [t] = await (0, u.Ve)(e, o);
                        await t
                    } else n.ReactUtils.downloadBlob(e, e.name)
                })))
            }));
            return (0, l.jsx)(m.Z, {
                label: r.isBusy ? a.f.eJ : 1 < t.length ? a.f.ft : a.f.eP,
                isDisabled: r.isBusy,
                isFullWidth: !1,
                onPress: () => i({
                    onError: s
                })
            })
        }));
        var p = s(1543);

        function g(e) {
            return e && (0, u.Rw)(e) ? e : null
        }
        s(2), s(3);
        const f = s(681),
            b = n.ReactUtils.lazy((() => s(1340))),
            y = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["comment"], (({
                comment: e
            }) => ({
                allAttachments: e.latestAttachmentVersions
            }))))((e => {
                const {
                    allAttachments: t,
                    attachmentVersion: s,
                    openers: m,
                    onClose: y
                } = e, v = n.Hooks.useIntl(), w = n.Hooks.useErrorHandler({
                    DownladingFailed: v.f.eQ,
                    [n.Misc.BuiltInErrorCodes.Gone]: {
                        translate: v.f.eR,
                        handle: () => {
                            const e = s.asExternalAttachment;
                            (null == e ? void 0 : e.integration) === c.md.OneDrive && 1 === m.length && (m[0].trigger(), y())
                        }
                    },
                    [n.Misc.BuiltInErrorCodes.Unknown]: v.f.eS
                }), {
                    previewedAttachment: k,
                    setPreviewedAttachment: x,
                    currentPreviewRequest: j
                } = function({
                    initialAttachment: e,
                    onFetchError: t
                }) {
                    const s = n.Hooks.useServices(),
                        a = n.React.useMemo((() => g(e)), [e]),
                        [o, r] = n.Hooks.useStateResettable(a, [e]),
                        i = n.Hooks.useAsyncState(),
                        c = n.Hooks.useAsyncFetcherWithParams(i, (async ({
                            params: {
                                attachment: e
                            }
                        }) => {
                            invariant((0, u.Rw)(e), "Expected a previewable attachment");
                            const [t] = s.api.attachments.downloadAttachmentAsBlob(e), n = await t;
                            return {
                                file: new globalThis.File([n], e.name, {
                                    type: e.mimeType
                                })
                            }
                        }));
                    return n.Hooks.useAsyncEffect((async ({
                        isPending: e
                    }) => {
                        o ? await c({
                            params: {
                                attachment: o
                            },
                            isPending: e,
                            onError: t
                        }) : i.transition.toInitialState()
                    }), [o]), {
                        previewedAttachment: o,
                        setPreviewedAttachment: e => {
                            const t = g(e);
                            r(t)
                        },
                        currentPreviewRequest: i
                    }
                }({
                    initialAttachment: s,
                    onFetchError: e => {
                        w.handle(e)
                    }
                }), {
                    availableAttachments: T,
                    canNavigateBack: S,
                    canNavigateForward: P,
                    navigateBack: _,
                    navigateForward: C
                } = function({
                    currentAttachment: e,
                    allAttachments: t,
                    onChangeAttachment: s
                }) {
                    const a = n.React.useMemo((() => t.filter((e => (0, u.Rw)(e)))), [t]),
                        o = n.React.useMemo((() => {
                            if (e) {
                                const t = a.findIndex((t => e.id === t.id));
                                if (-1 < t) return t
                            }
                            return 0
                        }), [e, a]),
                        r = 0 < a.length,
                        i = r && 0 < o,
                        c = r && o < a.length - 1;
                    return {
                        availableAttachments: a,
                        canNavigateBack: i,
                        canNavigateForward: c,
                        navigateBack: () => {
                            if (i) {
                                const e = a[o - 1];
                                s(e)
                            }
                        },
                        navigateForward: () => {
                            if (c) {
                                const e = a[o + 1];
                                s(e)
                            }
                        }
                    }
                }({
                    allAttachments: t,
                    currentAttachment: k,
                    onChangeAttachment: x
                }), {
                    isGridActive: R,
                    isGridDisabled: A,
                    toggleGrid: I
                } = function({
                    availableAttachments: e
                }) {
                    const t = 2 > e.length,
                        [s, a] = n.Hooks.useStateResettable(!1, [t]);
                    return {
                        isGridActive: s,
                        isGridDisabled: t,
                        toggleGrid: () => {
                            t || a(!s)
                        }
                    }
                }({
                    availableAttachments: T
                });
                if (!k) return null;
                const N = k.name,
                    E = A ? null : (0, l.jsx)(r.default, {
                        name: R ? "Ĳ" : "Ɔ",
                        onPress: I,
                        color: "onBackground3",
                        accessibilityLabel: v.f.e1
                    });
                t.filter((e => (0, u.Hn)(e)));
                return R ? (0, l.jsx)(a.default, {
                    title: N,
                    header: E,
                    content: () => (0, l.jsx)(b, {
                        attachments: T,
                        onPress: (e, t) => {
                            x(t), I()
                        }
                    }),
                    footer: void 0,
                    allowContentOverflow: !0,
                    onClose: y
                }) : (0, l.jsx)(a.default, {
                    title: N,
                    header: E,
                    content: ({
                        renderInnerContent: e
                    }) => j.map.activity({
                        busy: () => (0, l.jsx)(o.u_.Loader, {
                            isLoading: !0,
                            loadingMsg: v.f.eJ
                        }),
                        idle: t => t.map.result({
                            value: ({
                                value: t
                            }) => e(t),
                            error: ({
                                error: e
                            }) => (0, l.jsx)(o.u_.Error, {
                                children: w.translate(e)
                            })
                        })
                    }),
                    footer: (0, l.jsxs)("div", {
                        className: f.previewerFooter,
                        children: [(0, l.jsx)(d, {
                            type: "previous",
                            isDisabled: !S,
                            onPress: _
                        }), (0, l.jsxs)(i.gq, {
                            justify: "center",
                            gap: 8,
                            children: [(0, u.Hn)(k) ? (0, l.jsx)(h, {
                                files: [k],
                                onDownloadError: () => {
                                    const e = w.boom(w.ErrorCodes.DownladingFailed);
                                    j.transition.toError(e)
                                }
                            }) : null, m.map((e => (0, l.jsx)(p.Z, {
                                label: e.label,
                                color: e.color,
                                icon: e.icon,
                                onPress: e.trigger
                            }, e.label)))]
                        }), (0, l.jsx)(d, {
                            type: "next",
                            isDisabled: !P,
                            onPress: C
                        })]
                    }),
                    onClose: y
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(438),
            o = s(1552);
        s(2), s(3);
        const r = s(682);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                attachments: t,
                onPress: s
            } = e;
            return (0, i.jsx)(a.Z, {
                children: (0, i.jsx)("div", {
                    className: r.root,
                    children: t.map((e => (0, i.jsx)("div", {
                        className: r.item,
                        children: (0, i.jsx)(o.Z, {
                            attachmentVersion: e,
                            onPress: t => {
                                s(t, e)
                            }
                        })
                    }, e.id)))
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => n
        });
        const n = s(0).ReactUtils.identityElement
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(87);
        s(23);
        var o = s(683);
        s(2), s(3);
        const r = s(689);
        var i = s(1);
        const c = ({
                children: e
            }) => (0, i.jsx)("div", {
                className: r.root,
                children: e
            }),
            l = n.Hocs.compose(n.Hocs.memo)((e => {
                const {
                    comment: t
                } = e, s = n.Hooks.useServices(), {
                    currentTeam: r
                } = n.Hooks.useIdentity(), l = n.Hooks.useIntl();
                n.Hooks.useModel(t);
                const d = n.Hooks.useModalState();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(c, {
                        onLongPress: d.open,
                        children: (0, i.jsx)(o.Z, {
                            comment: t,
                            iconSize: 23,
                            onReactionPress: async (e, n) => {
                                t.do.toggleReaction(n);
                                const o = await t.task.fetch();
                                await (0, a.markTaskAsReviewedWithSnackbar)(s, l, o, r)
                            },
                            openPicker: d.open,
                            areUnselectedHidden: !1
                        })
                    }), !1]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => g
        });
        var n = s(0),
            a = s(14),
            o = s(35),
            r = s(6),
            i = s(25),
            c = s(87),
            l = s(683),
            d = s(32),
            u = s(20);
        s(2), s(3);
        const m = s(691);
        var h = s(1);
        const p = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withHooks((({
                currentMember: e,
                comment: t,
                task: s
            }) => ({
                isAuthor: e.id === t.author.id,
                canMarkAsUnread: s.isRead
            }))), n.Hocs.withObservables(["comment"], (({
                comment: e
            }) => ({
                canEdit: n.Rx.from(e.canBeEdited()),
                canMarkAsTeam: n.Rx.from(e.canBeMarkedAsTeam()),
                draft: e.draft,
                authorName: e.author.observe().pipe(n.Rx.switchMap((e => e ? e.preferredName : n.Rx.of(null))))
            }))))((e => {
                const {
                    onPressReply: t,
                    onPressCreateTask: s,
                    isAuthor: a,
                    closeMenu: r,
                    target: i,
                    copy: p,
                    restore: g,
                    comment: f,
                    showDestroyConfirm: b,
                    showDiscardDraftConfirm: y,
                    showMarkAsTeamConfirm: v,
                    markAsUnread: w,
                    canEdit: k,
                    canMarkAsUnread: x,
                    canMarkAsTeam: j,
                    authorName: T,
                    draft: S,
                    onPressEdit: P,
                    task: _,
                    currentTeam: C
                } = e, R = n.Hooks.useIntl(), A = (0, o._i)(f.body), I = n.Hooks.useServices(), [{
                    closeAnimated: N
                }, E] = (0, d.XH)();
                return (0, h.jsxs)(d.ZP, {
                    onClose: r,
                    target: i,
                    boundTo: "right",
                    ref: E,
                    children: [A ? (0, h.jsx)(d.ZP.Header, {
                        label: R.g("he", {
                            source: A.sourceApp,
                            author: null != T ? T : R.f.q5
                        })
                    }) : null, (0, h.jsx)(d.ZP.Header, {
                        label: R.formatDate(f.createdAt, {
                            month: "long",
                            day: "numeric",
                            year: "numeric",
                            hour: "2-digit",
                            minute: "2-digit"
                        })
                    }), f.isRestorable ? (0, h.jsx)(u.Z, {
                        icon: "ž",
                        label: R.f.hl,
                        onPress: n.ReactUtils.callBoth(g, N)
                    }) : null, f.isDeleted ? null : (0, h.jsxs)(h.Fragment, {
                        children: [(0, h.jsx)(u.Z, {
                            icon: "Ũ",
                            label: f.isPinned ? R.f.hm : R.f.hj,
                            onPress: n.ReactUtils.callBoth((async () => {
                                await f.do.togglePin()
                            }), N)
                        }), k ? (0, h.jsx)(u.Z, {
                            icon: "Ƥ",
                            label: R.f.fu,
                            onPress: n.ReactUtils.callBoth((async e => {
                                (!!!f._bodyJSON || await n.ReactUtils.devConfirm(R.f.g9)) && P(e, f)
                            }), N)
                        }) : null, j ? (0, h.jsx)(u.Z, {
                            icon: "ơ",
                            label: R.f.hg,
                            onPress: v
                        }) : null, k && S ? (0, h.jsx)(u.Z, {
                            icon: "Ƥ",
                            label: R.f.hd,
                            onPress: y,
                            iconColor: "red",
                            textColor: "red"
                        }) : null, (0, h.jsx)(u.Z, {
                            icon: "ƈ",
                            label: R.f.hk,
                            onPress: n.ReactUtils.callBoth(t, N),
                            onPressExtraParam: f
                        }), !a && x ? (0, h.jsx)(u.Z, {
                            icon: "ƴ",
                            label: R.f.hf,
                            onPress: n.ReactUtils.callBoth(N, (async () => {
                                await w(f)
                            }))
                        }) : null, (0, h.jsx)(u.Z, {
                            icon: "o",
                            label: R.f.g$,
                            onPress: n.ReactUtils.callBoth(N, p)
                        }), (0, h.jsx)(u.Z, {
                            icon: "ū",
                            label: _.isThread ? R.f.hc : R.f.g_,
                            onPress: n.ReactUtils.callBoth(s, N)
                        }), A ? (0, h.jsx)(u.Z, {
                            icon: "Ş",
                            label: R.g("hi", {
                                app: A.sourceApp
                            }),
                            onPress: n.ReactUtils.callBoth(N, (() => {
                                A && n.ReactUtils.openUrl(A.sourceUrl)
                            }))
                        }) : null, a && (0, h.jsx)(u.Z, {
                            icon: "Ʊ",
                            hasArrow: !0,
                            label: R.f.fp,
                            onPress: b,
                            iconColor: "red",
                            textColor: "red"
                        }), (0, h.jsx)("div", {
                            className: m.reactionsContainer,
                            children: (0, h.jsx)(l.Z, {
                                comment: f,
                                iconSize: 30,
                                hasAbsoluteFill: !0,
                                onReactionPress: n.ReactUtils.callBoth((async (e, t) => {
                                    f.do.toggleReaction(t), await (0, c.markTaskAsReviewedWithSnackbar)(I, R, _, C)
                                }), N),
                                pickerStyle: !0
                            })
                        })]
                    })]
                })
            })),
            g = n.Hocs.compose(n.Hocs.memo, n.Hocs.withRemindExpired((({
                closeMenu: e
            }) => ({
                onExpired: e
            }))), n.Hocs.withIdentity, n.Hocs.withObservables(["comment"], (({
                comment: e
            }) => ({
                comment: e,
                task: e.task
            }))))((e => {
                const {
                    onPressEdit: t,
                    onPressReply: s,
                    closeMenu: c,
                    target: l,
                    comment: d,
                    task: u,
                    markAsUnread: m
                } = e, g = n.Hooks.useIntl(), f = n.Hooks.useServices(), {
                    currentMember: b
                } = n.Hooks.useIdentity(), y = async () => {
                    c(), await d.do.deleteComment()
                }, v = async () => {
                    d.isRestorable && await d.do.restore()
                }, w = () => {
                    const e = d._bodyJSON ? (0, o.Ds)(d.body, !0) : d._bodyText;
                    n.ReactUtils.copyToClipboard(e, g.formatMessage)
                }, k = async () => {
                    const e = d._bodyJSON ? (0, o.Ds)(d.body, !0) : d._bodyText,
                        t = await u.fetchCurrentProject(),
                        s = await t.getCurrentTeam(),
                        r = (0, a.smartPathToTaskId)(s, u.id).path,
                        i = "" + n.ReactUtils.webAppUrl + r,
                        c = await d.author.fetch(),
                        l = c ? await n.Rx.takeFirst(c.preferredName) : "",
                        m = c && c.id !== b.id ? g.g("ha", {
                            authorName: l
                        }) + "\n" : "";
                    f.uiState.quickAddModal.open({
                        commentBody: g.g("hb", {
                            taskLink: i
                        }) + "\n" + m + "\n" + e,
                        fromCommentId: d.id,
                        projectId: t.id
                    })
                }, x = async () => {
                    d.removeDraft(), c()
                }, j = () => {
                    d.do.markAsTeam(), c()
                }, [T, S] = n.Hooks.useStateMachine("menu");
                return (0, h.jsx)(h.Fragment, {
                    children: T.map({
                        confirmDestroy: () => (0, h.jsx)(i.default, {
                            type: "delete",
                            onConfirmPress: y,
                            onBackPress: c,
                            onClose: c,
                            children: g.f.g7
                        }),
                        confirmDiscardDraft: () => (0, h.jsx)(i.default, {
                            type: "delete",
                            onConfirmPress: x,
                            onBackPress: c,
                            onClose: c,
                            children: g.f.g8
                        }),
                        confirmMarkAsTeam: () => (0, h.jsx)(i.default, {
                            type: "confirm",
                            onConfirmPress: j,
                            onBackPress: c,
                            onClose: c,
                            hasTextContent: !1,
                            children: (0, h.jsxs)(h.Fragment, {
                                children: [(0, h.jsx)(r.u_.IconStack, {
                                    stack: [{
                                        iconName: "þ",
                                        color: "orange",
                                        size: 200
                                    }]
                                }), (0, h.jsx)(r.u_.Paragraph, {
                                    children: g.f.hh
                                })]
                            })
                        }),
                        menu: () => (0, h.jsx)(p, {
                            comment: d,
                            task: u,
                            restore: v,
                            copy: w,
                            onPressEdit: n.ReactUtils.callBoth(t, c),
                            onPressReply: n.ReactUtils.callBoth(s, c),
                            onPressCreateTask: n.ReactUtils.callBoth(k, c),
                            showDestroyConfirm: S("confirmDestroy"),
                            showDiscardDraftConfirm: S("confirmDiscardDraft"),
                            showMarkAsTeamConfirm: S("confirmMarkAsTeam"),
                            closeMenu: c,
                            target: l,
                            markAsUnread: m
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(579);
        s(2), s(3);
        const o = s(699);
        var r = s(1);
        const i = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            threadMembers: e.isThread ? e.observeThreadMembers() : n.Rx.of([]),
            threadName: e.isThread ? e.observeThreadName() : n.Rx.of("")
        }))), n.Hocs.withIdentity, n.Hocs.withObservables(["threadMembers", "currentMember"], (({
            threadMembers: e,
            currentMember: t
        }) => {
            var s;
            return {
                taskSharedWithName: e ? n.Rx.wrap(null == (s = e.find((e => (null == e ? void 0 : e.id) !== t.id))) ? void 0 : s.preferredName) : n.Rx.of("")
            }
        })))((e => {
            const {
                threadName: t
            } = e, s = n.Hooks.useIntl();
            return (0, r.jsxs)("div", {
                className: o.root,
                children: [(0, r.jsx)(a.default, {
                    task: e.task,
                    size: "medium"
                }), (0, r.jsx)("span", {
                    className: o.text,
                    children: s.g("rd", {
                        memberName: (0, r.jsxs)("span", {
                            className: o.memberName,
                            children: ["@", t]
                        }, "name")
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(13),
            o = s(12);
        s(2), s(3);
        const r = s(700);
        var i = s(1);
        const c = n.Hocs.compose()((() => {
            const e = n.Hooks.useServices(),
                {
                    currentMember: t,
                    currentTeam: s
                } = n.Hooks.useIdentity(),
                c = n.Hooks.useIntl();
            return n.React.useEffect((() => {
                e.ab.historyLimits.trackOnce("seenLimits"), e.ab.historyLimits.trackEvery("seenLimitsCount")
            }), [e.ab]), (0, i.jsx)("div", {
                className: r.root,
                children: (0, i.jsxs)("div", {
                    className: r.box,
                    children: [(0, i.jsx)(a.default, {
                        name: "Ť",
                        color: "onBackground2",
                        size: 64
                    }), (0, i.jsx)("span", {
                        className: r.header,
                        children: c.f.Gl
                    }), (0, i.jsx)("span", {
                        className: r.text,
                        children: c.f.Gm
                    }), (0, i.jsx)("span", {
                        className: r.text,
                        children: c.f.Gn
                    }), (0, i.jsx)(o.default, {
                        className: r.button,
                        variant: "opaque",
                        color: "darkgreen",
                        label: t.isOwner ? c.f.Gq : c.f.Go,
                        subLabel: t.isOwner ? c.f.Gr : c.f.Gp,
                        onPress: () => {
                            t.isOwner ? (e.ab.historyLimits.trackOnce("upgradeClicked"), e.ab.historyLimits.trackEvery("upgradeClickedCount")) : (e.ab.historyLimits.trackOnce("notifyOwnerClicked"), e.ab.historyLimits.trackEvery("notifyOwnerClickedCount")), e.payments.proposeUpgrade(s, "unlock-history")
                        }
                    })]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(11),
            o = s(13);
        s(2), s(3);
        const r = s(701);
        var i = s(1);
        const c = n.Hocs.compose()((() => {
            const e = n.Hooks.useIntl(),
                t = n.Hooks.useServices(),
                {
                    isLimitedAccount: s
                } = n.Hooks.useIdentity();
            return s ? (0, i.jsxs)(a.Z, {
                className: r.root,
                onPress: () => t.uiState.accountUpgradeModal.open(),
                children: [(0, i.jsx)("span", {
                    className: r.text,
                    children: e.f.Gs
                }), (0, i.jsx)(o.default, {
                    name: "Ʀ",
                    color: "purple"
                })]
            }) : null
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => p
        });
        var n, a = s(0),
            o = s(11),
            r = s(18),
            i = s(67),
            c = s(169),
            l = s(61),
            d = s(694),
            u = s(693),
            m = s(368),
            h = s(1);
        const p = a.Hocs.compose(a.Hocs.withObservables(["comment"], (({
            comment: e
        }) => ({
            author: e.author
        }))))((e => {
            const {
                comment: t,
                author: s,
                onRestore: p
            } = e, {
                currentMember: g
            } = a.Hooks.useIdentity(), f = a.Hooks.useIntl(), [b, y] = a.Hooks.useToggle(!1), [v, w] = a.React.useState(!1), k = a.React.useCallback((async () => {
                await p(t)
            }), [t, p]), x = a.Styling.factoryColor(v ? "textPrimary" : "textSecondary");
            return (0, h.jsx)(d.i, {
                children: (0, h.jsxs)("div", {
                    className: m.Z.root,
                    children: [(0, h.jsxs)(o.Z, {
                        className: m.Z.labels,
                        onPress: y,
                        webComponent: "div",
                        onMouseEnter: () => w(!0),
                        onMouseLeave: () => w(!1),
                        children: [(0, h.jsx)("div", {
                            className: m.Z.headerContainer,
                            children: (0, h.jsx)("div", {
                                className: m.Z.textContainer + (b ? " " + m.Z.openedTextContainer : ""),
                                children: (0, h.jsx)(r.default, {
                                    className: m.Z.text,
                                    style: {
                                        color: x
                                    },
                                    children: n || (n = (0, h.jsx)(l.Z, {
                                        id: "GT"
                                    }))
                                })
                            })
                        }), b ? (0, h.jsx)("div", {
                            className: m.Z.footer,
                            children: (0, h.jsxs)("span", {
                                className: m.Z.text,
                                style: {
                                    color: x
                                },
                                children: [(0, h.jsx)(i.default, {
                                    className: m.Z.footerText + " " + m.Z.member,
                                    member: s,
                                    shouldRenderYou: !!s && s.id === g.id
                                }), s ? ", " : null, (0, h.jsx)(c.Z, {
                                    className: m.Z.footerText,
                                    date: t.editedAt || t.createdAt,
                                    showTime: !0
                                })]
                            })
                        }) : null]
                    }), b && t.isRestorable ? (0, h.jsx)("div", {
                        className: m.Z.actions,
                        children: (0, h.jsx)(u.Z, {
                            icon: "ž",
                            color: "onBackground3",
                            onPress: k,
                            accessibilityLabel: f.f.hl
                        })
                    }) : null]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Aq: () => m,
            HL: () => l,
            Le: () => d,
            Lr: () => c,
            P8: () => r,
            TF: () => i,
            nq: () => u
        });
        s(0);
        var n = s(23),
            a = s(703),
            o = s(1);
        const r = e => (0, o.jsx)("div", {
                className: a.Z.tickContainer + (e.areAttributesMinimized ? " " + a.Z.hiddenTick : ""),
                children: e.children
            }),
            i = e => (0, o.jsx)("div", {
                className: a.Z.titleBar + (e.areAttributesMinimized ? " " + a.Z.condensedTitleBar : ""),
                style: {
                    paddingRight: e.paddingRight
                },
                children: e.children
            }),
            c = e => (0, o.jsx)("div", {
                className: a.Z.iconsContainer,
                children: e.children
            }),
            l = n.identityElement,
            d = n.identityElement,
            u = "div",
            m = n.identityElement
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => _
        });
        var n = s(0),
            a = s(43),
            o = s(17),
            r = s(29),
            i = s(48),
            c = s(104),
            l = s(81),
            d = s(22),
            u = s(361),
            m = s(11),
            h = s(138),
            p = s(25),
            g = s(87),
            f = s(369),
            b = s(705),
            y = s(1348),
            v = s(261),
            w = s(703),
            k = s(1);
        const x = n.ReactUtils.lazy((() => s(1350))),
            j = n.ReactUtils.lazy((() => s(1352))),
            T = n.ReactUtils.lazy((() => s(1354))),
            S = n.ReactUtils.lazy((() => s(71))),
            P = (e, t) => {
                switch (e) {
                    case r.TE.ABANDONED:
                        return "%";
                    case r.TE.COMPLETED:
                        return "Ɵ";
                    default:
                        return t ? "ƞ" : "{"
                }
            },
            _ = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                areTaskDetailsMaximized: e.layout.areTaskDetailsMaximized
            }))), n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                task: e,
                taskAccess: e.taskAccess,
                project: e.observeCurrentProject(),
                numberOfPinnedComments: e.timeline.pinnedComments.observeCount()
            }))), n.Hocs.withObservables(["project", "canNavigateToProject"], (({
                project: e,
                canNavigateToProject: t
            }) => ({
                showGoToProject: n.Rx.from(t(e))
            }))), n.Hocs.withFeatureBadges({
                placement: "task_details_header"
            }))((e => {
                const {
                    task: t,
                    task: {
                        name: s,
                        isPriority: _,
                        status: C,
                        doesNeedReview: R,
                        reviewReason: A,
                        isGhost: I,
                        dates: {
                            isRecurring: N,
                            missedRepeats: E
                        }
                    },
                    project: {
                        color: O
                    },
                    project: M,
                    markAsUnread: D,
                    toggleShowPinnedOnly: H,
                    areAttributesMinimized: F,
                    isShowingPinnedOnly: Z,
                    numberOfPinnedComments: L,
                    setAreAttributesMinimized: B,
                    animatedValues: {
                        translateYStyle: z,
                        attributesOpacityStyle: U,
                        expandedOpacityStyle: W,
                        colorStyle: G,
                        elevationStyle: V,
                        hairlineWidthStyle: q,
                        attributesGesture: Q,
                        blurViewTranslateYStyle: Y
                    },
                    setHeaderHeight: J,
                    headerHeight: K,
                    isAtTop: $,
                    linkToTaskList: X,
                    taskAccess: ee,
                    areTaskDetailsMaximized: te,
                    blockExpandOnHover: se,
                    featureBadges: ne,
                    showGoToProject: ae
                } = e;
                n.Hooks.useDocumentTitle(t.name);
                const oe = n.Hooks.useIntl(),
                    re = n.Hooks.useServices(),
                    {
                        currentTeam: ie,
                        isLimitedAccount: ce
                    } = n.Hooks.useIdentity(),
                    le = n.Hooks.useModalState(),
                    de = n.Hooks.useModalState(),
                    ue = n.Hooks.useLayoutTopInset(),
                    me = n.Hooks.useDesktopLayout(),
                    he = n.Hooks.useRemindExpired(n.FP.noop),
                    {
                        isHovering: pe,
                        onMouseEnter: ge,
                        onMouseLeave: fe
                    } = n.Hooks.useHover(),
                    be = n.Hooks.useModalState(),
                    {
                        completeTask: ye,
                        abandonTask: ve
                    } = (0, i.dR)(t),
                    we = n.Hooks.useModalState(),
                    ke = C === r.TE.ACTIVE ? "onBackground3" : O || "purple",
                    xe = he((async () => {
                        await t.do.togglePriority(), await (0, g.markTaskAsReviewedWithSnackbar)(re, oe, t, ie)
                    })),
                    je = n.React.useRef(),
                    Te = async () => {
                        await (0, g.markTaskAsReviewed)(re, t, ie)
                    }, Se = [s, F, ee, M.areTimeAttributesEnabled];
                n.React.useLayoutEffect((() => {
                    const e = je.current;
                    invariant(e, "unexpected headerRef null"), F || J(e.clientHeight)
                }), Se);
                const Pe = F ? ue + f.j : void 0,
                    _e = () => B(!1),
                    Ce = n.React.useRef(F),
                    Re = F !== Ce.current;
                n.React.useEffect((() => {
                    Ce.current = F
                }));
                const Ae = he(de.open),
                    Ie = F ? _e : Ae,
                    Ne = he((async () => {
                        t.isActive && (re.native.haptics.success(), re.uiState.forTeam(ie).toggleJustEndedTask(t, !0), await (0, g.markTaskAsReviewedWithSnackbar)(re, oe, t, ie), await ye(), re.engager.onDidCompleteTask())
                    })),
                    Ee = he((async () => {
                        t.isActive && await ve()
                    })),
                    Oe = he((async () => {
                        if (!ie.isFree || !t.isEndedMoreThan7DaysAgo)
                            if (t.isGranted) we.open();
                            else if (!t.isActive) {
                            const e = await t.do.restore();
                            await (0, g.markTaskAsReviewedWithSnackbar)(re, oe, t, ie), re.uiState.forTeam(ie).toggleJustEndedTask(t, !1), e && !t.responsible.id && be.open()
                        }
                    })),
                    Me = () => {
                        re.router.goTo(X)
                    },
                    De = () => {
                        const e = re.history.currentPath.getValue();
                        e && re.history.isFirstRoute() ? re.router.goTo({
                            path: e.split("tasks")[0]
                        }) : re.router.goBack()
                    };
                n.Hooks.useBackButton((() => (De(), !0))), n.Hooks.useShortcutProviders([{
                    id: "task.complete",
                    action: t.isActive ? Ne : Oe
                }, {
                    id: "task.abandon",
                    action: t.isActive ? Ee : Oe
                }, {
                    id: "task.star",
                    action: xe
                }, {
                    id: "task.close",
                    action: Me
                }, {
                    id: "task.rename",
                    action: Ae
                }]);
                const He = F ? 100 + ue + f.j + 0 : "100%",
                    Fe = K ? ue + K + 100 : He;
                n.Hooks.useStatusBar({
                    style: "auto",
                    level: n.Hooks.useStatusBar.levels.taskDetails
                });
                const Ze = N && E && !M.isTemplate && !F,
                    Le = !ce && t.isActive && M.isActive && !t.isGhost,
                    Be = (() => {
                        if (!F) return 8;
                        return 32 + 40 * (0 + (Le ? 1 : 0))
                    })();
                return (0, k.jsxs)("div", {
                    className: w.Z.root,
                    ref: je,
                    children: [(0, k.jsx)(y.Aq, {
                        styles: [{
                            height: Fe,
                            top: K ? -100 : 0
                        }, G, V, q, Y]
                    }), (0, k.jsx)(y.Le, {
                        gesture: Q,
                        children: (0, k.jsxs)(y.nq, {
                            className: w.Z.wrapper,
                            style: {
                                paddingTop: ue,
                                height: Pe
                            },
                            children: [(0, k.jsxs)("div", {
                                className: w.Z.content + (F ? " " + w.Z.contentCondensed : ""),
                                children: [le.isOpen ? (0, k.jsx)(x, {
                                    task: t,
                                    closeMenu: le.close,
                                    target: le.target,
                                    markAsReviewed: Te,
                                    markAsUnread: D,
                                    restore: Oe,
                                    abandon: Ee,
                                    showGoToProject: ae
                                }) : null, de.isOpen ? (0, k.jsx)(c.default, {
                                    onClose: de.close,
                                    onConfirm: async (e, s) => {
                                        await t.do.rename(s), await (0, g.markTaskAsReviewedWithSnackbar)(re, oe, t, ie)
                                    },
                                    validators: [a.C1],
                                    isSingleLine: !0,
                                    currentValue: t.name,
                                    title: oe.f.fM,
                                    placeholder: oe.f.Ja,
                                    confirmButtonLabel: oe.f.fM,
                                    maxLength: o.MaxLengths.tasks.name
                                }) : null, (0, k.jsxs)(y.Lr, {
                                    children: [Ze ? (0, k.jsx)(y.nq, {
                                        style: W,
                                        children: (0, k.jsx)(b.CI, {
                                            count: E
                                        })
                                    }) : null, L && !F ? (0, k.jsx)(y.nq, {
                                        style: W,
                                        children: (0, k.jsx)(b.oF, {
                                            toggleShowPinnedOnly: H,
                                            numberOfPinnedComments: L,
                                            isShowingPinnedOnly: Z
                                        })
                                    }) : null, R && A && !F && A ? (0, k.jsx)(y.nq, {
                                        style: W,
                                        children: (0, k.jsx)(b.au, {
                                            reviewReason: A,
                                            markAsReviewed: Te
                                        })
                                    }) : null, null, Le ? (0, k.jsx)("div", {
                                        className: w.Z.starButtonContainer,
                                        children: (0, k.jsx)(u.Z, {
                                            keyboardShortcutID: "task.star",
                                            onPress: xe,
                                            isPriority: _,
                                            outlineColor: "onBackground3",
                                            fillColor: O || "purple"
                                        })
                                    }) : null]
                                })]
                            }), (0, k.jsxs)(y.TF, {
                                styles: [z, {
                                    paddingRight: Be
                                }, F && w.Z.condensedTitleBar],
                                areAttributesMinimized: F,
                                paddingRight: Be,
                                children: [(0, k.jsx)(y.P8, {
                                    styles: [W],
                                    areAttributesMinimized: F,
                                    children: (0, k.jsx)(d.default, {
                                        color: ke,
                                        name: P(C, pe),
                                        isDisabled: !!I,
                                        iconSize: 30,
                                        accessibilityLabel: t.isActive ? oe.f.mU : oe.f.m1,
                                        keyboardShortcutID: "task.complete",
                                        onPress: t.isActive ? Ne : Oe,
                                        testId: n.Misc.testIds.task_complete,
                                        onMouseEnter: ge,
                                        onMouseLeave: fe
                                    })
                                }), we.isOpen ? (0, k.jsx)(p.default, {
                                    type: "confirm",
                                    onConfirmPress: we.close,
                                    onClose: we.close,
                                    confirmButtonMessage: oe.f.fy,
                                    children: oe.f.Jc
                                }) : null, (0, k.jsx)(S, {
                                    renderLabel: oe.f.IE,
                                    timeToActivite: 500,
                                    children: (0, k.jsx)(m.Z, {
                                        className: w.Z.textContainer,
                                        webComponent: "div",
                                        onPress: Ie,
                                        isDisabled: !!I,
                                        androidBorderless: !0,
                                        children: (0, k.jsx)("span", {
                                            className: w.Z.text + (F ? " " + w.Z.textInOneLine : ""),
                                            children: s
                                        })
                                    })
                                })]
                            }), (0, k.jsx)(y.HL, {
                                styles: [U, z],
                                children: F ? (0, k.jsx)(T, {
                                    task: t,
                                    onPress: () => B(!1),
                                    blockExpandOnHover: se
                                }) : (0, k.jsx)(j, {
                                    animated: Re,
                                    task: t,
                                    project: M,
                                    taskAccess: ee,
                                    onCloseTaskDetails: Me,
                                    isAtTop: $,
                                    responsiblePickerState: be
                                })
                            })]
                        })
                    }), (0, k.jsx)(v.x, {
                        onPress: me ? Me : De,
                        areTaskDetailsMaximized: te,
                        topInset: ue
                    }), (0, k.jsxs)(y.nq, {
                        className: w.Z.menuButtonContainer,
                        style: {
                            top: ue
                        },
                        children: [(0, k.jsx)("div", {
                            className: w.Z.menuTarget,
                            ref: le.target
                        }), (0, k.jsx)(h.Z, {
                            color: "onBackground3",
                            onPress: () => {
                                le.open(), _e()
                            },
                            badge: R && F ? l.a.Incoming : ne.placementBadge
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => I
        });
        var n = s(0),
            a = s(43),
            o = s(14),
            r = s(67),
            i = s(316),
            c = s(854),
            l = s(32),
            d = s(25),
            u = s(6),
            m = s(170),
            h = s(20),
            p = s(81),
            g = s(104),
            f = s(13),
            b = s(18),
            y = s(12),
            v = s(125);
        s(2), s(3);
        const w = s(709);
        var k, x, j, T, S = s(1);
        const P = n.ReactUtils.lazy((() => s(317))),
            _ = n.ReactUtils.lazy((() => s(1351))),
            C = n.ReactUtils.lazy((() => s(1553))),
            R = n.ReactUtils.lazy((() => s(1554))),
            A = s(42).wx,
            I = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.memo, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                areTaskDetailsMaximized: e.layout.areTaskDetailsMaximized,
                canMoveTasks: e.modelRoot.hasManyActiveTeams
            }))), n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                task: e,
                taskAccessMember: e.observeCurrentTaskAccessMember(),
                taskAccess: e.taskAccess,
                project: e.observeCurrentProject(),
                canBeManaged: n.Rx.from(e.canBeManaged()),
                canBeCloned: n.Rx.from(e.canBeCloned()),
                canBeConvertedToProject: n.Rx.from(e.canBeConvertedToProject())
            }))), n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                canEnableTimeAttributes: n.Rx.from(e.canEnableTimeAttributes())
            }))), n.Hocs.withFeatureBadges({
                placement: "task_details_menu"
            }))((e => {
                var t, s, I;
                const {
                    task: N,
                    taskAccess: E,
                    taskAccessMember: O,
                    project: M,
                    showGoToProject: D,
                    canBeManaged: H,
                    canBeCloned: F,
                    canBeConvertedToProject: Z,
                    canEnableTimeAttributes: L,
                    target: B,
                    abandon: z,
                    restore: U,
                    closeMenu: W,
                    markAsUnread: G,
                    markAsReviewed: V,
                    services: q,
                    areTaskDetailsMaximized: Q,
                    featureBadges: Y,
                    canMoveTasks: J
                } = e, K = n.Hooks.useIntl(), {
                    currentTeam: $,
                    isLimitedAccount: X
                } = n.Hooks.useIdentity(), ee = n.Hooks.useRemindExpired((() => W())), te = (0, S.jsxs)("div", {
                    className: w.projectDescription,
                    children: [(0, S.jsx)(f.default, {
                        className: w.projectIcon,
                        name: n.Styling.getProjectIcon(M),
                        color: n.Styling.getProjectIconColor(M),
                        size: 14
                    }), (0, S.jsx)(b.default, {
                        className: w.projectName,
                        children: n.Styling.getProjectName(M, K)
                    })]
                }), se = N.isRead, ne = !X && $.isFree && N.isEndedMoreThan7DaysAgo, ae = N.isEnded, oe = !X && !M.areTimeAttributesEnabled && ($.isFree || L), re = async (e, t) => {
                    await N.do.rename(t)
                }, ie = async () => {
                    await N.do.setFollow(!N.isFollowed)
                }, ce = async () => {
                    W(), await N.canBeManaged() && await q.db.write((() => N.experimentalMarkAsDeleted()))
                }, le = async () => {
                    const e = await M.getCurrentTeam();
                    q.router.goTo((0, o.smartPathToProject)(e, M))
                }, de = async () => {
                    const e = await M.getCurrentTeam(),
                        t = (0, o.smartPathToTaskId)(e, N.id).path,
                        s = "" + n.ReactUtils.webAppUrl + t,
                        a = N.name,
                        r = s;
                    n.ReactUtils.share({
                        message: r,
                        url: s,
                        title: a,
                        formatMessage: K.formatMessage
                    })
                }, ue = n.Hooks.useDesktopLayout() && !Q, [me, he] = n.Hooks.useStateMachine("menu"), {
                    renderEmailToNozbeListItem: pe,
                    renderEmailToNozbeMenu: ge,
                    renderEmailToNozbeConfirm: fe,
                    isEmailToNozbeOpen: be
                } = (0, i.BK)({
                    team: $,
                    parentRecord: N,
                    next: he,
                    onClose: W,
                    strings: (0, c.B)(K)
                }), [{
                    closeAnimated: ye
                }, ve] = (0, l.XH)(), we = !N.isGranted && !M.isTemplate, ke = O ? (0, S.jsx)(r.default, {
                    member: O
                }, O.id) : (null == E ? void 0 : E.granteeEmail) || null, xe = (e, t, s) => {
                    var n;
                    const a = async () => {
                        await N.do.shareWithEmail(t), s ? s(e) : ye(e)
                    };
                    (async () => {
                        await N.canBeGranted() ? await a() : he("grantAccessError", {
                            email: t,
                            onConfirmPress: a,
                            selectedMemberName: n || (n = (0, S.jsx)(b.default, {
                                children: t
                            }, "shareWithEmailMember"))
                        })()
                    })()
                };
                return (0, S.jsx)(S.Fragment, {
                    children: me.map({
                        error: () => (0, S.jsx)(d.default, {
                            type: "confirm",
                            onConfirmPress: W,
                            onClose: W,
                            confirmButtonMessage: K.f.fy,
                            children: K.f.kV
                        }),
                        confirmDestroy: () => (0, S.jsx)(P, {
                            message: K.f.IQ,
                            confirmationText: N.name,
                            placeholderText: K.f.uB,
                            onConfirmPress: he("confirm_confirm_destroy"),
                            onBackPress: W,
                            onClose: W
                        }),
                        confirm_confirm_destroy: () => (0, S.jsx)(d.default, {
                            type: "delete",
                            onConfirmPress: ce,
                            onBackPress: W,
                            onClose: W,
                            children: K.f.IR
                        }),
                        easier_confirmDestroy: () => (0, S.jsx)(d.default, {
                            type: "delete",
                            onConfirmPress: async () => {
                                await (async () => {
                                    const e = await N.fetchCurrentProject();
                                    return await n.Rx.takeFirst(e.permissions.isPrivate) && !E
                                })() ? await ce(): he("easier_confirmDestroyFinal")()
                            },
                            closeOnConfirm: !1,
                            onBackPress: W,
                            onClose: W,
                            children: K.f.IR
                        }),
                        easier_confirmDestroyFinal: () => (0, S.jsxs)(d.default, {
                            type: "delete",
                            onConfirmPress: ce,
                            onBackPress: W,
                            onClose: W,
                            hasTextContent: !1,
                            children: [(0, S.jsx)(d.default.Paragraph, {
                                style: {
                                    paddingBottom: 0
                                },
                                children: K.f.IS
                            }), (0, S.jsx)(u.u_.Section, {
                                children: (0, S.jsx)(v.Z, {
                                    hint: K.f.IT,
                                    helpPageUrl: n.ReactUtils.helpUrl(K, "taskmanagement/new-tasks/#tasks_complete")
                                })
                            }), (0, S.jsx)(u.u_.Section, {
                                children: (0, S.jsx)(y.default, {
                                    onPress: () => {
                                        N.do.abandon(), W()
                                    },
                                    label: K.f.IP,
                                    iconName: "%",
                                    color: "darkgreen"
                                })
                            })]
                        }),
                        confirm_clone: () => t || (t = (0, S.jsx)(_, {
                            onClose: W,
                            task: N
                        })),
                        confirmConvertToProject: () => s || (s = (0, S.jsx)(C, {
                            task: N,
                            project: M,
                            onClose: W
                        })),
                        enableTimeAttributes: () => I || (I = (0, S.jsx)(R, {
                            project: M,
                            onClose: W
                        })),
                        rename: () => (0, S.jsx)(g.default, {
                            onClose: W,
                            onConfirm: re,
                            validators: [a.C1],
                            currentValue: N.name,
                            title: K.f.fM,
                            placeholder: K.f.Ja,
                            confirmButtonLabel: K.f.fM,
                            maxLength: n.Model.MaxLengths.tasks.name
                        }),
                        menu: () => {
                            return (0, S.jsxs)(l.ZP, {
                                ref: ve,
                                onClose: W,
                                target: B,
                                boundTo: "right",
                                children: [se && !N.isGhost ? (0, S.jsx)(h.Z, {
                                    icon: "ƴ",
                                    label: K.f.I6,
                                    onPress: ee(n.ReactUtils.callBoth(G, ye))
                                }) : null, N.doesNeedReview ? (0, S.jsx)(h.Z, {
                                    icon: "ſ",
                                    iconColor: "incoming",
                                    label: K.f.I5,
                                    onPress: ee(n.ReactUtils.callBoth(V, ye))
                                }) : null, D ? (0, S.jsx)(h.Z, {
                                    icon: "»",
                                    label: K.f.AN,
                                    bottomDescription: te,
                                    onPress: n.ReactUtils.callBoth(ye, le)
                                }) : null, oe ? (0, S.jsx)(h.Z, {
                                    icon: "Ƭ",
                                    label: K.f.I3,
                                    badge: $.isFree ? p.a.Premium : Y.get("time_needed"),
                                    bottomDescription: te,
                                    onPress: he("enableTimeAttributes")
                                }) : null, (se || N.doesNeedReview || D) && !N.isGhost ? k || (k = (0, S.jsx)(l.ZP.Separator, {})) : null, M.isActive && !N.isGhost ? (0, S.jsxs)(S.Fragment, {
                                    children: [N.isActive ? (0, S.jsx)(h.Z, {
                                        icon: "Ƥ",
                                        label: K.f.fM,
                                        onPress: ee(he("rename"))
                                    }) : null, ae ? (0, S.jsx)(h.Z, {
                                        icon: "ž",
                                        label: K.f.fP,
                                        isDisabled: ne,
                                        onPress: n.ReactUtils.callBoth(ye, U)
                                    }) : null, N.isActive ? (0, S.jsx)(h.Z, {
                                        icon: "%",
                                        label: K.f.IP,
                                        onPress: n.ReactUtils.callBoth(ye, z)
                                    }) : null, H || N.isAbandoned ? (0, S.jsx)(h.Z, {
                                        icon: "Ʊ",
                                        label: K.f.fp,
                                        onPress: (e = "easier_confirmDestroy", async () => {
                                            H ? he(e)() : he("error")()
                                        }),
                                        iconColor: "red",
                                        textColor: "red"
                                    }) : null, x || (x = (0, S.jsx)(l.ZP.Separator, {}))]
                                }) : null, M.isFollowed || X || N.isGhost ? null : (0, S.jsxs)(S.Fragment, {
                                    children: [(0, S.jsx)(m.Z, {
                                        variant: "follow",
                                        isActive: N.isFollowed,
                                        onChange: ie
                                    }), j || (j = (0, S.jsx)(l.ZP.Separator, {}))]
                                }), (0, S.jsx)(h.Z, {
                                    icon: "ľ",
                                    label: K.f.I2,
                                    onPress: n.ReactUtils.callBoth(ye, de)
                                }), !M.isActive || X || N.isGhost ? null : (0, S.jsxs)(S.Fragment, {
                                    children: [F ? (0, S.jsx)(h.Z, {
                                        icon: "a",
                                        label: K.f.fg,
                                        onPress: ee(he("confirm_clone"))
                                    }) : null, Z ? (0, S.jsx)(h.Z, {
                                        icon: "n",
                                        label: K.f.fk,
                                        onPress: ee(he("confirmConvertToProject"))
                                    }) : null, Z && J ? (0, S.jsx)(h.Z, {
                                        icon: ";",
                                        label: K.f.I7,
                                        badge: Y.get("move_task"),
                                        onPress: () => {
                                            q.uiState.moveTasksModal.open({
                                                tasks: [N]
                                            }), W()
                                        }
                                    }) : null, we ? (0, S.jsx)(h.Z, {
                                        icon: "Ŀ",
                                        label: K.f.zi,
                                        badge: Y.get("share_with_anyone"),
                                        onPress: he("shareWithAnyonePrompt", {
                                            email: ""
                                        })
                                    }) : null, pe(), be ? ge() : null]
                                }), ue ? (0, S.jsxs)(S.Fragment, {
                                    children: [T || (T = (0, S.jsx)(l.ZP.Separator, {})), (0, S.jsx)(h.Z, {
                                        icon: "µ",
                                        label: K.f.I4,
                                        onPress: e => {
                                            q.layout.maximizeTaskDetails(), ye(e)
                                        }
                                    })]
                                }) : null]
                            });
                            var e
                        },
                        email_to_nozbe_menu: ge,
                        email_to_nozbe_confirm: fe,
                        shareWithAnyonePrompt: ({
                            email: e
                        }) => (0, S.jsx)(A.GTMInvitationPrompt, {
                            bundle$close: W,
                            task: N,
                            taskAccess: E,
                            onClose: W,
                            onShareByEmail: xe,
                            initialEmail: null != e ? e : ""
                        }),
                        grantAccessError: ({
                            email: e,
                            selectedMemberName: t,
                            onConfirmPress: s
                        }) => (0, S.jsx)(d.default, {
                            type: "delete",
                            headerIcon: "Ɗ",
                            onConfirmPress: s,
                            onBackPress: he("shareWithAnyonePrompt", {
                                email: e
                            }),
                            confirmButtonMessage: K.f.zf,
                            onClose: W,
                            children: K.g("zg", {
                                currentMember: ke,
                                selectedMember: t
                            })
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(14),
            o = s(6),
            r = s(45),
            i = s(150),
            c = s(876),
            l = s(1);
        const d = n.Hocs.compose((0, o.LU)(), n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            initialProject: e.observeCurrentProject(),
            initialProjectSection: e.projectSection,
            currentResponsible: e.responsible,
            canTaskBeGranted: n.Rx.from(e.canBeGranted())
        }))))((e => {
            const {
                task: t,
                initialProject: s,
                initialProjectSection: d,
                currentResponsible: u,
                canTaskBeGranted: m
            } = e, h = n.Hooks.useServices(), p = n.Hooks.useIntl(), {
                closeAnimated: g
            } = (0, o.vR)(), [f, b] = n.React.useState(s), [y, v] = n.React.useState(d), {
                currentMember: w
            } = n.Hooks.useIdentity(), k = u && u.team.id === w.team.id ? u : ((e, t) => e.dates.dueDate ? t : null)(t, w), [x, j] = n.React.useState([k]), [T, S] = n.Hooks.useToggle(!0), [P, _] = n.React.useState((() => p.g("Ix", {
                taskName: t.name
            })));
            return (0, l.jsxs)(c.o2, {
                header: p.f.Iu,
                description: p.f.Iv + (m ? "" : p.f.Iw),
                helpPageUrl: n.ReactUtils.helpUrl(p, "taskmanagement/new-tasks/#tasks_clone"),
                isCloneButtonDisabled: !P.length,
                onClonePress: n.ReactUtils.callBoth(g, (async () => {
                    const e = await f.getCurrentTeam(),
                        {
                            path: s
                        } = (0, a.smartPathToTask)(e, f, t.id),
                        o = p.g("It", {
                            originalTaskUrl: "" + n.ReactUtils.webAppUrl + s
                        }),
                        [r] = await Promise.all(x.map((e => t.do.clone({
                            name: P,
                            annotation: o,
                            withAllComments: !T,
                            withEndedTasks: !1,
                            selectedProject: f,
                            section: y,
                            selectedResponsible: e,
                            shouldCheckAccess: !0
                        }))));
                    h.router.goTo((0, a.smartPathToTask)(e, f, r.id))
                })),
                children: [(0, l.jsx)(o.u_.Heading, {
                    children: p.f.Iy
                }), (0, l.jsx)(o.u_.Section, {
                    children: (0, l.jsx)(r.default, {
                        autoFocus: !0,
                        value: P,
                        onChange: _,
                        forEntryViews: !0,
                        placeholder: p.f.Iz
                    })
                }), (0, l.jsxs)(i.Wr, {
                    children: [(0, l.jsx)(c.Hk, {
                        project: f,
                        onProjectChange: e => {
                            b(e), v(null)
                        }
                    }), (0, l.jsx)(c.zm, {
                        project: f,
                        section: y,
                        onSectionChange: e => v(e)
                    }), (0, l.jsx)(c.so, {
                        project: f,
                        members: x,
                        onMembersChange: j
                    })]
                }), (0, l.jsx)(c.rD, {
                    onlyPinnedComments: T,
                    toggleOnlyPinnedComments: S
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => te
        });
        var n = s(0),
            a = s(48),
            o = s(21),
            r = s(87),
            i = s(78),
            c = s(52),
            l = s(40),
            d = s(18),
            u = s(11);
        s(2), s(3);
        const m = s(715);
        var h = s(1);
        const p = n.ReactUtils.lazy((() => s(71))),
            g = e => {
                const {
                    hasValue: t,
                    children: s,
                    onPress: a,
                    pickerTarget: o,
                    isDisabled: r,
                    testId: i,
                    keyboardShortcutID: c,
                    accessibilityLabel: l,
                    hasDot: d
                } = e;
                return n.Hooks.useShortcutProviders(c && a && !r ? [{
                    id: c,
                    action: a
                }] : []), (0, h.jsxs)("div", {
                    className: m.dotWrapper,
                    children: [(0, h.jsx)(u.Z, {
                        className: m.root + (t ? " " + m.hasValue : "") + (r ? " " + m.isDisabled : ""),
                        webComponent: "div",
                        onPress: a,
                        ref: o,
                        isDisabled: r,
                        testId: i,
                        children: (0, h.jsx)((({
                            children: e
                        }) => c && l ? (0, h.jsx)(p, {
                            keyboardShortcutID: c,
                            renderLabel: l,
                            timeToActivite: 500,
                            children: e
                        }) : (0, h.jsx)(h.Fragment, {
                            children: e
                        })), {
                            children: (0, h.jsx)("div", {
                                className: m.container,
                                ref: o,
                                children: s
                            })
                        })
                    }), d ? (0, h.jsx)("div", {
                        className: m.dot
                    }) : null]
                })
            },
            f = s(716),
            b = ["label", "subLabel", "icon", "topIcon", "topIconColor", "color"],
            y = n.Hocs.compose(n.Hocs.withHooks((({
                color: e,
                hasValue: t
            }) => ({
                color: t ? e || "onBackground3" : "textSecondary"
            }))))((e => {
                const {
                    label: t,
                    subLabel: s,
                    icon: n,
                    topIcon: a,
                    topIconColor: o,
                    color: r
                } = e, i = (0, c.Z)(e, b), u = [{
                    iconName: n,
                    color: r,
                    size: 22
                }, ...a ? [{
                    iconName: a,
                    color: o || "onBackground3",
                    size: 22
                }] : []];
                return (0, h.jsxs)(g, Object.assign({}, i, {
                    children: [(0, h.jsx)(l.default, {
                        layers: u
                    }), (0, h.jsxs)("div", {
                        className: f.labelContainer,
                        children: [(0, h.jsx)(d.default, {
                            className: f.label + (i.hasValue ? " " + f.hasValue : "") + (s ? " " + f.hasSubLabel : ""),
                            allowFontScaling: !1,
                            children: t
                        }), s ? (0, h.jsx)(d.default, {
                            className: f.subLabel,
                            allowFontScaling: !1,
                            hasValue: i.hasValue,
                            children: s
                        }) : null]
                    })]
                }))
            })),
            v = s(42).wx,
            w = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                taskReminders: e.dates.reminders
            }))))((e => {
                const {
                    task: t,
                    project: s,
                    taskReminders: a,
                    onPickerConfirm: o
                } = e, r = n.Hooks.useIntl(), c = n.Hooks.useModalState(), l = t.dates.dueDate, d = a.some((e => !e.isRelative || !!l)), u = t.isGhost || s.isEnded, m = n.React.useMemo((() => n.FP.capitalize((0, i.Ne)({
                    taskReminders: (0, i.Fv)(a, l),
                    taskHasDueDate: !!l,
                    intl: r,
                    format: "long"
                }))), [a, l, r]);
                return (0, h.jsxs)(h.Fragment, {
                    children: [d ? (0, h.jsx)(y, {
                        keyboardShortcutID: "task.set_reminders",
                        accessibilityLabel: r.f.lA,
                        label: m,
                        icon: "ź",
                        onPress: c.open,
                        isDisabled: t.isGhost,
                        hasValue: d,
                        pickerTarget: c.target,
                        testId: n.Misc.testIds.task_reminders
                    }) : (0, h.jsx)(y, {
                        keyboardShortcutID: "task.set_reminders",
                        accessibilityLabel: r.f.lA,
                        icon: "ź",
                        label: r.f.Gw,
                        pickerTarget: c.target,
                        onPress: c.open,
                        isDisabled: u,
                        hasValue: !1,
                        testId: n.Misc.testIds.task_reminders
                    }), c.isOpen && (0, h.jsx)(v.Reminders, {
                        bundle$close: c.close,
                        onConfirm: o,
                        target: c.target,
                        onClose: c.close,
                        removeOnly: u,
                        currentReminders: a.map((e => e.remindAt)),
                        currentDueDate: l
                    })]
                })
            })),
            k = s(42).wx,
            x = n.ReactUtils.lazy((() => s(25))),
            j = n.Hocs.compose()((e => {
                const {
                    task: t,
                    project: s,
                    onPickerConfirm: a
                } = e, o = n.Hooks.useIntl(), {
                    isLimitedAccount: r
                } = n.Hooks.useIdentity(), [i, c] = n.Hooks.useStateMachine(null), l = c(null), d = n.Hooks.useModalState(), u = r || t.isGhost || t.isEnded || t.isGranted;
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(y, {
                        accessibilityLabel: o.f.lz,
                        keyboardShortcutID: "task.set_project",
                        label: n.Styling.getProjectName(s, o),
                        icon: n.Styling.getProjectIcon(s),
                        hasValue: !0,
                        onPress: d.open,
                        color: s.color,
                        isDisabled: u,
                        pickerTarget: d.target
                    }), d.isOpen ? (0, h.jsx)(k.Project, {
                        bundle$close: d.close,
                        onConfirm: async e => {
                            if (s.isShared)
                                if (await s.isHostSharedProject || await t.canBeManaged()) {
                                    const t = await s.sharedTeam.fetch();
                                    c("confirm", {
                                        selectedProject: e,
                                        guestTeamName: null == t ? void 0 : t.name
                                    })()
                                } else c("change_forbidden")();
                            else a(e)
                        },
                        onClose: d.close,
                        target: d.target,
                        currentProjectId: s.id,
                        showSharedOnly: !1
                    }) : null, i.map({
                        confirm: ({
                            selectedProject: e,
                            guestTeamName: t
                        }) => (0, h.jsx)(x, {
                            type: "confirm",
                            onConfirmPress: () => {
                                a(e)
                            },
                            onBackPress: l,
                            onClose: l,
                            headerIcon: "Ĺ",
                            children: o.g("yR", {
                                sharedTeam: " " + (null != t ? t : "")
                            })
                        }),
                        change_forbidden: () => (0, h.jsx)(x, {
                            type: "delete",
                            onConfirmPress: l,
                            onClose: l,
                            confirmButtonMessage: o.f.fh,
                            headerIcon: "Ĺ",
                            children: o.f.yS
                        })
                    })]
                })
            }));
        var T = s(56),
            S = s(67);
        const P = s(717),
            _ = ["responsible", "shouldRenderYou"],
            C = e => {
                const {
                    responsible: t,
                    shouldRenderYou: s
                } = e, n = (0, c.Z)(e, _);
                return (0, h.jsxs)(g, Object.assign({}, n, {
                    children: [(0, h.jsx)("div", {
                        className: P.avatarContainer,
                        children: (0, h.jsx)(T.default, {
                            member: t,
                            size: "tiny"
                        })
                    }), (0, h.jsx)(S.default, {
                        className: P.caption,
                        member: t,
                        shouldRenderYou: s,
                        allowFontScaling: !1
                    })]
                }))
            },
            R = s(42).wx,
            A = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                currentResponsible: e.responsible,
                taskAccess: e.taskAccess
            }))))((e => {
                const {
                    currentResponsible: t,
                    project: s,
                    task: a,
                    onPickerConfirm: o,
                    pickerState: r,
                    taskAccess: i
                } = e, {
                    currentMember: c
                } = n.Hooks.useIdentity(), l = n.Hooks.useIntl(), d = a.isGhost || a.isEnded || s.isEnded;
                return (0, h.jsxs)(h.Fragment, {
                    children: [t ? (0, h.jsx)(C, {
                        keyboardShortcutID: "task.set_responsible",
                        accessibilityLabel: l.f.lx,
                        responsible: t,
                        hasValue: !0,
                        onPress: r.open,
                        isDisabled: d,
                        pickerTarget: r.target,
                        testId: n.Misc.testIds.task_responsible,
                        shouldRenderYou: t.id === c.id,
                        hasDot: null == i ? void 0 : i.isGranteePending
                    }) : (0, h.jsx)(y, {
                        keyboardShortcutID: "task.set_responsible",
                        accessibilityLabel: l.f.lx,
                        label: l.f.uv,
                        icon: "ƶ",
                        hasValue: !1,
                        onPress: r.open,
                        isDisabled: d,
                        pickerTarget: r.target,
                        testId: n.Misc.testIds.task_responsible,
                        hasDot: null == i ? void 0 : i.isGranteePending
                    }), r.isOpen && (0, h.jsx)(R.Responsible, {
                        bundle$close: r.close,
                        onConfirm: o,
                        task: a || void 0,
                        onClose: r.close,
                        currentResponsibleId: null == t ? void 0 : t.id,
                        target: r.target,
                        project: s,
                        hasDueDate: !(null == a || !a.dates.dueDate),
                        hasRecurrence: !(null == a || !a.dates.recurrence.id)
                    })]
                })
            })),
            I = s(42).wx,
            N = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                currentSection: e.isGranted ? n.Rx.of(null) : e.projectSection
            }))), n.Hocs.withObservables(["task", "project"], (({
                task: e,
                project: t
            }) => ({
                sharerName: n.Rx.wrap(e.isGranted || t.isSingleTasks ? e.observeCurrentTaskAccessMember().pipe(n.Rx.switchMap((e => n.Rx.wrap((null == e ? void 0 : e.preferredName) || null)))) : null)
            }))))((e => {
                const {
                    onPickerConfirm: t,
                    task: s,
                    project: a,
                    currentSection: o,
                    modalProps: r,
                    sharerName: i
                } = e, {
                    isLimitedAccount: c
                } = n.Hooks.useIdentity(), l = n.Hooks.useIntl(), d = a.isSingleTasks || c || s.isGhost || s.isEnded || a.isEnded, u = (({
                    section: e,
                    sharerName: t,
                    intl: s
                }) => t ? s.g("Is", {
                    member: t
                }) : e ? e.name : s.f.uw)({
                    section: o,
                    sharerName: i,
                    intl: l
                });
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(y, {
                        accessibilityLabel: l.f.lB,
                        keyboardShortcutID: "task.set_section",
                        label: u,
                        icon: "Ɔ",
                        hasValue: !!o,
                        onPress: r.open,
                        isDisabled: d,
                        pickerTarget: r.target,
                        testId: n.Misc.testIds.task_section
                    }), r.isOpen ? (0, h.jsx)(I.Section, {
                        bundle$close: r.close,
                        onConfirm: t,
                        onClose: r.close,
                        target: r.target,
                        currentSectionId: null == o ? void 0 : o.id,
                        project: a
                    }) : null]
                })
            }));
        var E = s(153),
            O = s(13),
            M = s(121),
            D = s(254);
        const H = s(718),
            F = e => (0, h.jsx)("div", {
                className: H.attribute + (e.justText ? " " + H.justText : ""),
                children: e.children
            }),
            Z = e => (0, h.jsx)(d.default, {
                className: H.caption + (e.justText ? " " + H.justText : ""),
                allowFontScaling: e.allowFontScaling,
                children: e.children
            }),
            L = e => (0, h.jsx)(D.Z, {
                className: H.gradient,
                children: e.children
            }),
            B = e => (0, h.jsx)("div", {
                className: H.content,
                children: e.children
            });
        var z;
        const U = s(42).wx,
            W = n.Hocs.compose(n.Hocs.withIntl, n.Hocs.withIdentity, n.Hocs.withObservables(["task", "currentTeam", "intl"], (({
                task: e,
                currentTeam: t,
                intl: s
            }) => ({
                currentTags: e.allTags.pipe((0, E.Hb)(t, s))
            }))))((e => {
                const {
                    task: t,
                    project: s,
                    currentTags: a,
                    onPickerConfirm: o
                } = e, {
                    isLimitedAccount: r
                } = n.Hooks.useIdentity(), i = n.Hooks.useIntl(), c = n.Hooks.useModalState(), l = 0 < a.length, d = r || t.isGhost || t.isEnded || s.isEnded;
                return (0, h.jsxs)(h.Fragment, {
                    children: [l ? (0, h.jsx)(g, {
                        keyboardShortcutID: "task.set_tags",
                        accessibilityLabel: i.f.lC,
                        onPress: c.open,
                        hasValue: l,
                        isDisabled: d,
                        pickerTarget: c.target,
                        children: (0, h.jsxs)(B, {
                            children: [a.map((e => (0, h.jsx)(M.Z, {
                                resetOn: [e],
                                observables: {
                                    tag: e.observe()
                                },
                                children: ({
                                    tag: e
                                }) => (0, h.jsxs)(F, {
                                    children: [(0, h.jsx)(O.default, {
                                        name: n.Styling.defaultTagIcon(e.icon),
                                        color: e.color || "onBackground3",
                                        size: 22
                                    }), (0, h.jsx)(Z, {
                                        allowFontScaling: !1,
                                        children: e.name
                                    })]
                                })
                            }, e.id))), z || (z = (0, h.jsx)(L, {}))]
                        })
                    }) : (0, h.jsx)(y, {
                        keyboardShortcutID: "task.set_tags",
                        accessibilityLabel: i.f.lC,
                        icon: "Ɲ",
                        label: i.f.uz,
                        pickerTarget: c.target,
                        onPress: c.open,
                        isDisabled: d,
                        hasValue: !1
                    }), c.isOpen && (0, h.jsx)(U.Tags, {
                        bundle$close: c.close,
                        target: c.target,
                        onConfirm: o,
                        onClose: c.close,
                        currentTags: a,
                        showNoTagsItem: !1
                    })]
                })
            }));
        var G = s(29),
            V = s(301);
        const q = s(42).wx,
            Q = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                currentRecurrence: e.dates.recurrence,
                canUpdateRecurrence: n.Rx.from(e.dates.canUpdateRecurrence())
            }))), n.Hocs.withObservables(["task", "project"], (({
                task: e
            }) => ({
                isDueDateRelative: n.Rx.from(e.dates.isDueDateRelative())
            }))))((e => {
                const {
                    task: t,
                    project: s,
                    currentRecurrence: a,
                    canUpdateRecurrence: r,
                    onPickerConfirm: i,
                    isDueDateRelative: c
                } = e, l = n.Hooks.useIntl(), d = n.Hooks.useModalState(), u = c ? (0, o.toAbsoluteDateTime)(t.dates.dueDate) : t.dates.dueDate, m = r && !!a && t.isEnded && s.isActive, p = t.isGhost || s.isEnded || t.isEnded && !m, g = r ? m ? "endedTaskRecurrence" : "standard" : "noTaskRecurrence";
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(y, {
                        keyboardShortcutID: "task.set_due_date",
                        accessibilityLabel: l.f.ly,
                        label: u ? n.FP.capitalize(c ? (0, o.formatDateTimeRelativeFromNow)({
                            dateTime: u,
                            intl: l
                        }) : (0, o.formatDateTimeRelative)({
                            dateTime: u,
                            intl: l,
                            format: "long"
                        })) : l.f.ue,
                        subLabel: a ? (0, V.rs)(a.rawPattern, l) : null,
                        icon: !c && t.isActive && (0, G.GY)(u) ? "s" : a ? "v" : "R",
                        topIcon: !c && t.isActive && (0, G.GY)(u) ? "t" : void 0,
                        topIconColor: "red",
                        hasValue: !!u,
                        onPress: d.open,
                        isDisabled: p,
                        pickerTarget: d.target,
                        testId: n.Misc.testIds.task_dueDate
                    }), d.isOpen ? (0, h.jsx)(q.DueDate, {
                        bundle$close: d.close,
                        onConfirm: i,
                        target: d.target,
                        onClose: d.close,
                        variant: g,
                        currentDueDate: u,
                        currentRecurrenceOrigin: t.dates.recurrenceOrigin,
                        currentRecurrence: null == a ? void 0 : a.rawPattern,
                        canChangeDueDateWithoutRecurrence: !c,
                        shouldWarnAboutSetInPast: !c,
                        isAllWeek: !1
                    }) : null]
                })
            })),
            Y = s(42).wx,
            J = n.Hocs.compose()((e => {
                const {
                    value: t,
                    onChange: s,
                    unsetLabel: a,
                    icon: r,
                    isDisabled: i,
                    keyboardShortcutID: c,
                    accessibilityLabel: l
                } = e, {
                    hours: d,
                    minutes: u
                } = n.React.useMemo((() => (0, o.parseTimeAttribute)(t)), [t]), m = n.Hooks.useModalState(), p = n.Hooks.useIntl(), g = t ? p.g("Ga", {
                    hours: d,
                    minutes: u
                }) : null;
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(y, {
                        label: g || a,
                        icon: r,
                        hasValue: !!t,
                        onPress: m.open,
                        isDisabled: i,
                        pickerTarget: m.target,
                        keyboardShortcutID: c,
                        accessibilityLabel: l
                    }), m.isOpen ? (0, h.jsx)(Y.TimeAttribute, {
                        bundle$close: m.close,
                        hours: d,
                        minutes: u,
                        onClose: m.close,
                        onConfirm: s,
                        target: m.target,
                        header: a
                    }) : null]
                })
            })),
            K = s(719),
            $ = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                task: e,
                project: e.observeCurrentProject(),
                timeAttributes: e.timeAttributes
            }))), n.Hocs.withObservables(["task", "project"], (({
                task: e
            }) => ({
                canUpdateTimeAttributes: n.Rx.from(e.canUpdateTimeAttributes())
            }))))((e => {
                const {
                    task: t,
                    project: s,
                    canUpdateTimeAttributes: i,
                    timeAttributes: c,
                    responsiblePickerState: l
                } = e, d = n.Hooks.useModalState(), u = n.Hooks.useIntl(), {
                    currentTeam: m
                } = n.Hooks.useIdentity(), p = n.Hooks.useServices(), g = (0, a.dR)(t), f = n.Hooks.useRemindExpired(n.FP.noop), b = f((async ({
                    date: e,
                    recurrence: s,
                    recurrenceOriginDate: n,
                    timeNeeded: a
                }) => {
                    (0, o.dateTimeEquals)(e, t.dates.dueDate) && a === (null == c ? void 0 : c.timeNeeded) || await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m);
                    const i = await t.dates.isDueDateRelative(),
                        l = e && i ? (0, o.toRelativeDateTime)(e) : e;
                    await t.dates.canUpdateRecurrence() ? await t.dates.do.updateDueDateAndRecurrence(l, s, n) : await t.dates.do.updateDueDate(l, n)
                })), y = f((async e => {
                    await t.do.moveToProject(e), await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m);
                    0 < await e.activeSections.fetchCount() && d.open()
                })), v = f((async e => {
                    await t.do.moveToSection(e), await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m)
                })), k = f((async e => {
                    await t.dates.do.updateReminders(e), (e.added.length || e.removed.length) && await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m)
                })), x = f((async e => {
                    await t.do.updateTags(e), await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m)
                })), T = f((async e => {
                    e !== (null == c ? void 0 : c.timeNeeded) && (await t.do.updateTimeNeeded(e), await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m))
                })), S = f((async e => {
                    e !== (null == c ? void 0 : c.timeSpent) && (await t.do.updateTimeSpent(e), await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m))
                }));
                return (0, h.jsxs)("div", {
                    className: K.root,
                    children: [(0, h.jsxs)("div", {
                        className: K.leftColumn,
                        children: [(0, h.jsx)(j, {
                            task: t,
                            project: s,
                            onPickerConfirm: y
                        }), (0, h.jsx)(A, {
                            task: t,
                            project: s,
                            onPickerConfirm: async e => {
                                await (0, r.markTaskAsReviewedWithSnackbar)(p, u, t, m), await g.assignTaskResponsible(e)
                            },
                            pickerState: l
                        }), (0, h.jsx)(Q, {
                            task: t,
                            project: s,
                            onPickerConfirm: b
                        }), c ? (0, h.jsx)(J, {
                            value: c.timeNeeded,
                            onChange: T,
                            icon: "Ƭ",
                            unsetLabel: u.f.uE,
                            isDisabled: !i,
                            keyboardShortcutID: "task.set_time_needed",
                            accessibilityLabel: u.f.lD
                        }) : null]
                    }), (0, h.jsxs)("div", {
                        className: K.rightColumn,
                        children: [(0, h.jsx)(N, {
                            task: t,
                            project: s,
                            modalProps: d,
                            onPickerConfirm: v
                        }), (0, h.jsx)(W, {
                            task: t,
                            project: s,
                            onPickerConfirm: x
                        }), (0, h.jsx)(w, {
                            task: t,
                            project: s,
                            onPickerConfirm: k
                        }), c ? (0, h.jsx)(J, {
                            value: c.timeSpent,
                            onChange: S,
                            icon: "Ư",
                            unsetLabel: u.f.uF,
                            isDisabled: !i,
                            keyboardShortcutID: "task.set_time_spent",
                            accessibilityLabel: u.f.lE
                        }) : null]
                    })]
                })
            })),
            X = s(720),
            ee = n.ReactUtils.lazy((() => s(1353))),
            te = n.Hocs.compose(n.Hocs.withObservables(["task"], (({
                task: e
            }) => ({
                hasTimeAttributes: e.timeAttributes.pipe(n.Rx.map((e => !!e)))
            }))))((e => {
                const {
                    task: t,
                    isAtTop: s,
                    animated: a,
                    taskAccess: o,
                    onCloseTaskDetails: r,
                    hasTimeAttributes: i,
                    responsiblePickerState: c
                } = e, {
                    isLimitedAccount: l
                } = n.Hooks.useIdentity(), d = !!o && !l, u = d ? 12 : 0, m = i ? 184 : 140, p = d ? 40 : 0;
                return (0, h.jsxs)("div", {
                    className: X.root + (s ? "" : " " + X.rootNotAtTop) + (a ? " " + X.animated : ""),
                    style: {
                        height: m + 0 + p + u
                    },
                    children: [(0, h.jsx)($, {
                        task: t,
                        responsiblePickerState: c
                    }), d && o ? (0, h.jsx)(ee, {
                        task: t,
                        taskAccess: o,
                        onCloseTaskDetails: r
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => g
        });
        var n = s(0),
            a = s(67),
            o = s(25),
            r = s(18),
            i = s(22),
            c = s(13);
        s(2), s(3);
        const l = s(721);
        var d = s(1);
        const u = e => (0, d.jsx)(r.default, {
                className: l.text,
                children: e.children
            }),
            m = e => (0, d.jsx)("span", {
                className: l.text,
                children: e.children
            }),
            h = n.Hocs.compose()((e => {
                const {
                    text: t,
                    color: s,
                    leftIcon: a,
                    rightIcon: o,
                    onIconPress: r,
                    multiLine: h
                } = e, p = h ? m : u, g = n.Hooks.useIntl();
                return (0, d.jsx)(d.Fragment, {
                    children: (0, d.jsxs)("div", {
                        className: l.root + (h ? " " + l.rootMultiline : ""),
                        style: {
                            borderColor: n.Styling.rgba(n.Styling.factoryColor(s), .3)
                        },
                        children: [(0, d.jsx)(c.default, {
                            className: l.icon,
                            name: a,
                            size: 22,
                            color: s
                        }), (0, d.jsx)(p, {
                            children: t
                        }), (0, d.jsx)(i.default, {
                            name: o,
                            size: 22,
                            color: s,
                            onPress: r,
                            accessibilityLabel: g.f.mH
                        })]
                    })
                })
            })),
            p = ({
                task: e,
                taskAccess: t,
                grantee: s,
                granter: n,
                intl: o
            }) => {
                if (e.isGranted) return o.g("GC", {
                    member: (0, d.jsx)(a.default, {
                        className: l.memberName,
                        member: n
                    }, n.id)
                });
                if (s) return o.g("GB", {
                    member: (0, d.jsx)(a.default, {
                        className: l.memberName,
                        member: s
                    }, s.id)
                });
                if (t.isGTMLinkActive) return o.f.GD;
                const {
                    granteeEmail: r
                } = t;
                return invariant(r, "Expected task access to have grantee's email"), o.g("GA", {
                    granteeEmail: r
                })
            },
            g = n.Hocs.compose(n.Hocs.withErrorBoundary({
                name: "SharedTaskBanner"
            }), n.Hocs.withObservables(["taskAccess"], (({
                taskAccess: e
            }) => ({
                granter: e.granter
            }))), n.Hocs.withHooks((({
                taskAccess: e
            }) => (n.Hooks.useModel(e), {
                isGranteePending: e.isGranteePending
            }))), n.Hocs.withObservables(["taskAccess", "isGranteePending"], (({
                isGranteePending: e,
                taskAccess: t
            }) => ({
                grantee: e ? n.Rx.of(null) : t.grantee
            }))))((e => {
                const {
                    granter: t,
                    task: s,
                    grantee: i,
                    onCloseTaskDetails: c,
                    taskAccess: l
                } = e, u = n.Hooks.useIntl(), m = n.Hooks.useModalState(), g = (() => {
                    if (l.isGTMLinkActive) return null;
                    if (i) return (0, d.jsx)(a.default, {
                        member: i
                    }, i.id);
                    if (l.granteeEmail) return (0, d.jsx)(r.default, {
                        children: l.granteeEmail
                    }, "shareWithEmailMember");
                    throw new Error("Missing grantee ID or email")
                })();
                return (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsx)(h, {
                        color: "priority",
                        leftIcon: "ľ",
                        rightIcon: "b",
                        onIconPress: m.open,
                        text: (0, d.jsx)(r.default, {
                            children: p({
                                task: s,
                                taskAccess: l,
                                grantee: i,
                                granter: t,
                                intl: u
                            })
                        })
                    }), m.isOpen ? (0, d.jsx)(o.default, {
                        type: "delete",
                        onClose: m.close,
                        onBackPress: m.close,
                        secondaryButtonMessage: u.f.fe,
                        confirmButtonMessage: u.f.Cv,
                        onConfirmPress: () => {
                            s.isGranted && c(), (async () => {
                                await s.do.revokeAccess()
                            })(), m.close()
                        },
                        children: l.isGTMLinkActive ? u.f.Cx : s.isGranted ? u.g("Cw", {
                            member: g
                        }) : u.g("Cy", {
                            member: g
                        })
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => b
        });
        var n = s(0),
            a = s(67),
            o = s(11),
            r = s(21),
            i = s(78),
            c = s(153),
            l = s(13),
            d = s(56),
            u = s(18);
        s(2), s(3);
        const m = s(722);
        var h = s(1);
        const p = e => {
                const {
                    member: t,
                    label: s,
                    iconName: n,
                    iconColor: a,
                    maxWidth: o
                } = e;
                return (0, h.jsxs)("div", {
                    className: m.root,
                    style: {
                        maxWidth: o + "%"
                    },
                    children: [n ? (0, h.jsx)(l.default, {
                        name: n,
                        size: 24,
                        color: a || "onBackground3"
                    }) : null, t ? (0, h.jsx)(d.default, {
                        member: t,
                        size: "tiny"
                    }) : null, (0, h.jsx)("div", {
                        className: m.labelContainer,
                        children: (0, h.jsx)(u.default, {
                            className: m.label,
                            children: s
                        })
                    })]
                })
            },
            g = s(723),
            f = (e, t) => (0, r.formatTimeAttribute)(e, t, {
                format: "short"
            }),
            b = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIntl, n.Hocs.withIdentity, n.Hocs.withObservables(["task"], (({
                task: e,
                currentTeam: t,
                intl: s
            }) => ({
                project: e.observeCurrentProject(),
                member: e.responsible,
                sectionName: e.isGranted ? n.Rx.of("") : e.projectSection.observe().pipe(n.Rx.map((e => (null == e ? void 0 : e.name) || ""))),
                taskReminders: e.dates.reminders,
                tags: e.allTags.pipe((0, c.Hb)(t, s)),
                taskAttributes: e.timeAttributes
            }))))((e => {
                const {
                    onPress: t,
                    member: s,
                    sectionName: c,
                    taskReminders: l,
                    tags: d,
                    task: {
                        isActive: u,
                        dates: {
                            dueDate: m
                        }
                    },
                    timeAttributes: b,
                    project: y,
                    blockExpandOnHover: v
                } = e, w = n.Hooks.useIntl(), {
                    currentMember: k
                } = n.Hooks.useIdentity(), x = n.React.useRef(null), [j, T] = n.React.useState(!1), S = n.React.useMemo((() => n.FP.capitalize(m ? (0, r.formatDateTime)({
                    dateTime: m,
                    intl: w
                }) : w.f.ue)), [m, w]), P = (e => e.map((e => e.name)).join(", "))(d), _ = n.Styling.getProjectName(y, w), C = n.Styling.getProjectIcon(y), R = y.color, A = n.React.useMemo((() => n.FP.capitalize((0, i.Ne)({
                    taskReminders: (0, i.Fv)(l, m),
                    taskHasDueDate: !!m,
                    intl: w,
                    format: "short"
                }))), [l, m, w]), [I, N] = n.React.useMemo((() => {
                    if (!b) return [null, null];
                    const {
                        timeNeeded: e,
                        timeSpent: t
                    } = b;
                    return [e ? f(e, w) : null, t ? f(t, w) : null]
                }), [w, b]), E = n.FP.reduce(((e, t) => e + Number(!!t)), 1, [s, m, l.length, c, d.length, I, N]), O = 100 / Math.min(E, 4);
                return n.Hooks.useShortcutProviders([{
                    id: "task.set_project",
                    action: t
                }, {
                    id: "task.set_section",
                    action: t
                }, {
                    id: "task.set_responsible",
                    action: t
                }, {
                    id: "task.set_tags",
                    action: t
                }, {
                    id: "task.set_due_date",
                    action: t
                }, {
                    id: "task.set_reminders",
                    action: t
                }]), (0, h.jsx)("div", {
                    className: g.hoverRoot,
                    onMouseEnter: v ? void 0 : () => {
                        T(!0), x.current = setTimeout(t, 250)
                    },
                    onMouseLeave: v ? void 0 : () => {
                        clearTimeout(x.current), T(!1)
                    },
                    children: (0, h.jsxs)(o.Z, {
                        className: g.root,
                        onPress: t,
                        children: [(0, h.jsxs)("div", {
                            className: g.attributes + (u ? "" : " " + g.endedAttributes),
                            children: [(0, h.jsx)(p, {
                                label: _,
                                iconName: C,
                                iconColor: R,
                                maxWidth: O
                            }), s ? (0, h.jsx)(p, {
                                member: s,
                                label: (0, h.jsx)(a.default, {
                                    member: s,
                                    shouldRenderYou: s.id === k.id
                                }),
                                maxWidth: O
                            }) : null, m ? (0, h.jsx)(p, {
                                label: S,
                                iconName: "R",
                                maxWidth: O
                            }) : null, l.length ? (0, h.jsx)(p, {
                                label: A,
                                iconName: "ź",
                                maxWidth: O
                            }) : null, 5 >= E && c ? (0, h.jsx)(p, {
                                label: c,
                                iconName: "Ɔ",
                                maxWidth: O
                            }) : null, 4 >= E && d.length ? (0, h.jsx)(p, {
                                label: P,
                                iconName: n.Styling.defaultTagIcon(d[0].icon),
                                iconColor: d[0].color || "onBackground3",
                                maxWidth: O
                            }) : null, 4 >= E && I ? (0, h.jsx)(p, {
                                label: I,
                                iconName: "Ƭ",
                                maxWidth: O
                            }) : null, 4 >= E && N ? (0, h.jsx)(p, {
                                label: N,
                                iconName: "Ư",
                                maxWidth: O
                            }) : null]
                        }), (0, h.jsx)("div", {
                            className: g.handle + (j ? " " + g.hoverHandle : "")
                        })]
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(503),
            o = s(1257),
            r = s(705),
            i = s(261),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withServices, n.Hocs.withObservables(["task"], (({
            task: e
        }) => ({
            threadName: e.isThread ? e.observeThreadName() : n.Rx.of(null),
            numberOfPinnedComments: e.timeline.pinnedComments.observeCount()
        }))), n.Hocs.withObservables(["currentMember"], (({
            currentMember: e
        }) => ({
            myName: e.preferredName
        }))), n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            areTaskDetailsMaximized: e.layout.areTaskDetailsMaximized
        }))))((e => {
            var t;
            const {
                threadName: s,
                myName: l,
                setHeaderHeight: d,
                areTaskDetailsMaximized: u,
                linkToTaskList: m,
                toggleShowPinnedOnly: h,
                numberOfPinnedComments: p,
                isShowingPinnedOnly: g
            } = e, f = n.Hooks.useIntl();
            n.Hooks.useDocumentTitle(f.g("rn", {
                threadName: s
            }));
            const b = n.Hooks.useDesktopLayout(),
                y = n.Hooks.useServices(),
                v = n.React.useRef();
            n.React.useLayoutEffect((() => {
                const e = v.current;
                invariant(e, "unexpected headerRef null"), d(e.clientHeight)
            }), []);
            const w = () => {
                const e = y.history.currentPath.getValue();
                e && y.history.isFirstRoute() ? y.router.goTo({
                    path: e.split("tasks")[0]
                }) : y.router.goBack()
            };
            n.Hooks.useBackButton((() => (w(), !0)));
            const k = () => {
                y.router.goTo(m)
            };
            n.Hooks.useShortcutProviders([{
                id: "task.close",
                action: k
            }]);
            const x = "darkgreen";
            return (0, c.jsx)(a.Z, {
                headerRef: v,
                renderTitle: e => (0, c.jsxs)(o.e, {
                    color: e,
                    children: [" ", null != s ? s : l]
                }),
                onLeftIconPress: b ? k : w,
                renderLeft: e => (0, c.jsx)(i.x, {
                    isAboveContent: !1,
                    onPress: b ? k : w,
                    color: e,
                    areTaskDetailsMaximized: u
                }),
                color: x,
                leftIcon: "Ķ",
                renderRight: p ? () => t || (t = (0, c.jsx)(r.oF, {
                    color: x,
                    areColorsInverted: !0,
                    toggleShowPinnedOnly: h,
                    numberOfPinnedComments: p,
                    isShowingPinnedOnly: g
                })) : void 0
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(1);
        const o = s(42).wx,
            r = n.ReactUtils.lazy((() => s(1357))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                isEvernoteConnected: e.modelRoot.settings.observeIntegrationState(t, "evernote_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled))))
            }))))((e => {
                const {
                    isEvernoteConnected: t,
                    onPickNotes: s,
                    onClose: n,
                    level: i
                } = e;
                return t ? (0, a.jsx)(o.EvernoteNote, {
                    bundle$close: n,
                    onConfirm: s,
                    onClose: n,
                    level: i
                }) : (0, a.jsx)(r, {
                    onClose: n,
                    level: i
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(897),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)())((() => {
            const e = n.Hooks.useIntl(),
                {
                    closeAnimated: t
                } = (0, a.vR)();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Header, {
                    children: e.f.cx
                }), (0, r.jsx)(a.u_.Content, {
                    children: (0, r.jsx)(o.default, {
                        onCancel: t
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(1359))),
            r = n.ReactUtils.lazy((() => s(262))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                isDropboxConnected: e.modelRoot.settings.observeIntegrationState(t, "dropbox_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled))))
            }))))((e => {
                const {
                    isDropboxConnected: t,
                    onPickFiles: s,
                    onClose: i,
                    level: c
                } = e, l = n.Hooks.useServices(), d = n.Hooks.useIntl(), {
                    currentTeam: u
                } = n.Hooks.useIdentity();
                return t ? (0, a.jsx)(r, {
                    title: d.f.nH,
                    accentColor: "blue",
                    level: c,
                    onLoad: e => {
                        const t = null == e ? void 0 : e.path_lower;
                        return l.api.integrations.fetchDropboxFiles(u, t)
                    },
                    onConfirm: s,
                    onClose: i
                }) : (0, a.jsx)(o, {
                    onClose: i,
                    level: c
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(933),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)())((() => {
            const e = n.Hooks.useIntl(),
                {
                    closeAnimated: t
                } = (0, a.vR)();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Header, {
                    children: e.f.ch
                }), (0, r.jsx)(a.u_.Content, {
                    children: (0, r.jsx)(o.default, {
                        onCancel: t
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(1361))),
            r = n.ReactUtils.lazy((() => s(262))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                isGoogleDriveConnected: e.modelRoot.settings.observeIntegrationState(t, "gdrive_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled))))
            }))))((e => {
                const {
                    isGoogleDriveConnected: t,
                    onPickFiles: s,
                    onClose: i,
                    level: c
                } = e, l = n.Hooks.useIntl(), d = n.Hooks.useServices(), {
                    currentTeam: u
                } = n.Hooks.useIdentity();
                return t ? (0, a.jsx)(r, {
                    title: l.f.nX,
                    accentColor: "orange",
                    level: c,
                    onLoad: e => {
                        const t = null == e ? void 0 : e.id;
                        return d.api.integrations.fetchGoogleDriveFiles(u, t)
                    },
                    onConfirm: s,
                    onClose: i
                }) : (0, a.jsx)(o, {
                    onClose: i,
                    level: c
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(934),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)())((() => {
            const e = n.Hooks.useIntl(),
                {
                    closeAnimated: t
                } = (0, a.vR)();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Header, {
                    children: e.f.ch
                }), (0, r.jsx)(a.u_.Content, {
                    children: (0, r.jsx)(o.default, {
                        onCancel: t
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(1363))),
            r = n.ReactUtils.lazy((() => s(262))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                isOneDriveConnected: e.modelRoot.settings.observeIntegrationState(t, "onedrive_integration").pipe(n.Rx.map((e => Boolean(null == e ? void 0 : e.enabled))))
            }))))((e => {
                const {
                    isOneDriveConnected: t,
                    onPickFiles: s,
                    onClose: i,
                    level: c
                } = e, l = n.Hooks.useServices(), d = n.Hooks.useIntl(), {
                    currentTeam: u
                } = n.Hooks.useIdentity();
                return t ? (0, a.jsx)(r, {
                    title: d.f.n1,
                    accentColor: "lightblue",
                    level: c,
                    onLoad: e => {
                        const t = null == e ? void 0 : e.id;
                        return l.api.integrations.fetchOneDriveFiles(u, t)
                    },
                    onConfirm: s,
                    onClose: i
                }) : (0, a.jsx)(o, {
                    onClose: i,
                    level: c
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(935),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)())((() => {
            const e = n.Hooks.useIntl(),
                {
                    closeAnimated: t
                } = (0, a.vR)();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Header, {
                    children: e.f.c$
                }), (0, r.jsx)(a.u_.Content, {
                    children: (0, r.jsx)(o.default, {
                        onCancel: t
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            U: () => d
        });
        var n = s(9),
            a = (s(17), s(5), s(4), s(29)),
            o = s(44),
            r = s(114);
        const i = (e, t, s) => {
                if ("hidden" === e) return t ? "showingEndedToday" : s ? r.VH : null;
                if ("showingEndedToday" === e && s) return r.VH;
                if ("number" == typeof e && s) {
                    const t = e,
                        s = Math.floor(t / 5);
                    return t + r.VH + s
                }
                return null
            },
            c = e => ({
                completed: e.filter((e => e.isCompleted)).length,
                abandoned: e.filter((e => e.isAbandoned)).length
            }),
            l = (e, t, s, n) => ("hidden" === e && "showingEndedToday" === t || "number" == typeof t) && !n && 0 < s.length,
            d = ({
                sections: e,
                getTasksForSection: t,
                groupTasksBySection: s,
                listRootId: r,
                isShowingThePast: d = !1,
                endedTasksStates: u,
                collapsedSectionsStates: m,
                justEndedTasks: h = [],
                shouldRenderSection: p,
                forceShowMoreEndedTasks: g
            }) => {
                const f = n.useMemo((() => {
                        const n = s ? s() : new Map;
                        return e.map((e => ({
                            root: e,
                            tasks: t(e, n)
                        })))
                    }), [s, e, t]),
                    b = n.useMemo((() => f.reduce(((e, t) => {
                        const {
                            root: s,
                            tasks: n
                        } = t, f = s && "object" == typeof s ? s.id : s || null, b = !!r && !(null == m || !m.some((e => r + ":" + (f || "") === e)));
                        if (!u) {
                            const t = Object.assign({
                                root: s,
                                tasks: n,
                                items: n,
                                isCollapsed: b,
                                hasFooter: !1
                            }, (0, o.xr)());
                            return p && !p(t) || e.push(t), e
                        }
                        invariant(void 0 !== h && void 0 !== d, "justEndedTasks and isShowingThePast parameters are required for taskGroups with endedTasksStates");
                        const {
                            endedTodayTasks: y,
                            endedBeforeTodayTasks: v,
                            activeAndJustEndedTasks: w
                        } = (0, a.rq)(n, h), k = null == u ? void 0 : u.find((e => e.groupId === f)), x = 0 < w.length, j = ((e, t, s, n, a) => {
                            const o = 0 < s.length,
                                r = "number" == typeof e ? e : 0,
                                l = n.length > r || !!a;
                            return {
                                endedTasksState: e,
                                nextEndedTasksState: i(e, o, l),
                                hasEndedToday: o,
                                isCollapsed: t,
                                endedTodayCounters: c(s)
                            }
                        })(k ? k.state : "hidden", b, x ? y : [], v, g), T = j.endedTasksState ? ((e, t, s, n) => {
                            const {
                                activeAndJustEndedTasks: o,
                                endedTodayTasks: r,
                                endedBeforeTodayTasks: i
                            } = (0, a.rq)(e, s);
                            return n ? [...o, ...r, ...i] : "number" == typeof t ? [...o, ...r, ...i.slice(0, t)] : "showingEndedToday" === t ? [...o, ...r] : o
                        })(n, j.endedTasksState, h, d) : n, S = Object.assign({
                            root: s,
                            items: T,
                            tasks: n
                        }, j, {
                            isCollapsed: b,
                            hasFooter: l(j.endedTasksState, j.nextEndedTasksState, T, d)
                        });
                        return p && !p(S) || e.push(S), e
                    }), [])), [f, u, m, h, r, g, d, p]),
                    y = n.useMemo((() => b.reduce(((e, t) => [...e, ...t.items]), [])), [b]);
                return {
                    taskGroups: b,
                    sortedTasks: y
                }
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => f
        });
        var n = s(0),
            a = s(14),
            o = s(13),
            r = s(40),
            i = s(68),
            c = s(11),
            l = s(18);
        s(2), s(3);
        const d = s(736);
        var u = s(1);
        const m = e => {
                const {
                    label: t,
                    onPress: s,
                    onPressExtraParam: a,
                    color: o
                } = e, [r, i] = n.React.useState(!1);
                return (0, u.jsx)(c.Z, {
                    className: d.touchable,
                    style: {
                        backgroundColor: n.Styling.rgba(n.Styling.factoryColor(o), .1),
                        borderColor: r ? n.Styling.rgba(n.Styling.factoryColor(o), .3) : void 0
                    },
                    onPress: s,
                    onPressExtraParam: a,
                    onMouseEnter: () => i(!0),
                    onMouseLeave: () => i(!1),
                    children: (0, u.jsx)("div", {
                        className: d.content,
                        children: (0, u.jsx)(l.default, {
                            className: d.text,
                            style: {
                                color: n.Styling.factoryColor(o)
                            },
                            children: t
                        })
                    })
                })
            },
            h = s(737);
        var p;
        const g = n.ReactUtils.lazy((() => s(223))),
            f = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                hasSkippedTeamSetup: e.modelRoot.settings.hasSkippedTeamSetup.observe()
            }))), n.Hocs.withPersonalUI, n.Hocs.withObservables(["currentMember"], (({
                currentMember: e
            }) => ({
                hasCurrentMemberAdminPowers: e.hasAdminPowers
            }))), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                hasTasksInPriority: e.activePriorityTasksCounter.pipe(n.Rx.map((e => 0 < e))),
                hasTasksInIncoming: e.incomingTasksCounter.pipe(n.Rx.map((e => 0 < e))),
                hasNoMembersInTeam: e.isTeamOfOne,
                hasTasksInActivity: e.activityTasksCounter.pipe(n.Rx.map((e => 0 < e)))
            }))))((e => {
                const {
                    onPress: t,
                    title: s,
                    message: c,
                    buttonText: l,
                    color: d,
                    renderListHeader: f,
                    rootRecord: b,
                    currentTeam: y,
                    isLimitedAccount: v,
                    hasTasksInIncoming: w,
                    hasTasksInPriority: k,
                    hasNoMembersInTeam: x,
                    hasTasksInActivity: j,
                    hasSkippedTeamSetup: T,
                    shouldRenderPersonalUI: S,
                    hasCurrentMemberAdminPowers: P
                } = e, _ = d || "onBackground3", C = n.React.useMemo((() => (e => {
                    const t = [
                        [{
                            iconName: "Û",
                            color: "white",
                            size: 240
                        }, {
                            iconName: "Ü",
                            color: e,
                            opacity: .3,
                            size: 240
                        }, {
                            iconName: "Ý",
                            color: e,
                            size: 240
                        }],
                        [{
                            iconName: "Ø",
                            color: "white",
                            size: 240
                        }, {
                            iconName: "Ù",
                            color: e,
                            opacity: .3,
                            size: 240
                        }, {
                            iconName: "Ú",
                            color: e,
                            size: 240
                        }],
                        [{
                            iconName: "Õ",
                            color: "white",
                            size: 240
                        }, {
                            iconName: "Ö",
                            color: e,
                            opacity: .3,
                            size: 240
                        }, {
                            iconName: "×",
                            color: e,
                            size: 240
                        }]
                    ];
                    return t[Math.floor(Math.random() * t.length)]
                })(_)), [_]), R = n.Hooks.useServices(), A = n.Hooks.useIntl(), I = n.Hooks.useModalState(), {
                    buttonText: N,
                    buttonOnPress: E
                } = v ? {
                    buttonText: null,
                    buttonOnPress: null
                } : (({
                    currentTeam: e,
                    hasTasksInIncoming: t,
                    hasTasksInPriority: s,
                    hasAdminPowers: n,
                    hasNoMembersInTeam: o,
                    openInviteModal: r,
                    hasTasksInActivity: i,
                    hasSkippedTeamSetup: c,
                    shouldRenderPersonalUI: l,
                    intl: d,
                    services: u
                }) => s ? {
                    buttonText: d.f.iH,
                    buttonOnPress: () => {
                        u.router.goTo((0, a.pathToPriority)(e))
                    }
                } : t ? {
                    buttonText: d.f.iG,
                    buttonOnPress: () => {
                        u.router.goTo((0, a.pathToIncoming)(e))
                    }
                } : o && n && !c && !l ? {
                    buttonText: d.f.iI,
                    buttonOnPress: r
                } : i && !l ? {
                    buttonText: d.f.iF,
                    buttonOnPress: () => {
                        u.router.goTo((0, a.pathToActivity)(e))
                    }
                } : {
                    buttonText: null,
                    buttonOnPress: null
                })({
                    hasTasksInIncoming: w,
                    hasTasksInPriority: k,
                    hasNoMembersInTeam: x,
                    hasAdminPowers: P,
                    openInviteModal: I.open,
                    hasTasksInActivity: j,
                    hasSkippedTeamSetup: T,
                    shouldRenderPersonalUI: S,
                    services: R,
                    intl: A,
                    currentTeam: y
                }), O = N || l, M = E || t, D = n.Hooks.useDesktopLayout() ? 8 : 4, H = n.React.useMemo((() => ({
                    flex: void 0,
                    paddingLeft: D,
                    paddingRight: D
                })), [D]), F = !v && b instanceof n.Model.Models.Project && !b.isEnded;
                return (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsxs)(i.Z, {
                        contentContainerStyle: H,
                        topBarInset: 0,
                        reachesTopOfScreen: !1,
                        isAbsoluteFilled: !1,
                        children: [f && b ? f(b) : null, F ? null : (0, u.jsxs)("div", {
                            className: h.root,
                            children: [(0, u.jsx)(r.default, {
                                className: h.animation,
                                layers: C
                            }), s ? (0, u.jsx)("span", {
                                className: h.title,
                                children: s
                            }) : null, c ? (0, u.jsxs)("span", {
                                className: h.text,
                                children: [c, " "]
                            }) : null, M && O ? (0, u.jsx)("div", {
                                className: h.buttonContainer,
                                children: (0, u.jsx)(m, {
                                    color: _,
                                    label: O,
                                    onPress: M
                                })
                            }) : null]
                        })]
                    }), F ? (0, u.jsxs)("div", {
                        className: h.pointyHandContainer,
                        children: [(0, u.jsx)("div", {
                            className: h.pointyHandTextWrapper,
                            children: (0, u.jsxs)("span", {
                                className: h.pointyHandText,
                                children: [A.f.iJ, p || (p = (0, u.jsx)("br", {})), A.f.iK]
                            })
                        }), (0, u.jsx)(o.default, {
                            name: "ć",
                            size: 230,
                            color: d || "purple"
                        })]
                    }) : null, I.isOpen ? (0, u.jsx)(g, {
                        team: y,
                        onClose: I.close
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(1556),
            o = s(169),
            r = s(67);
        s(2), s(3);
        const i = s(739);
        var c = s(1);
        const l = n.Hocs.compose(n.Hocs.memo, n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            project: e,
            events: e.events.observe().pipe(n.Rx.map(a.N))
        }))))((e => {
            const {
                project: t,
                events: s
            } = e;
            return (0, c.jsxs)(c.Fragment, {
                children: [(0, c.jsxs)("span", {
                    className: i.text,
                    children: ["Created: ", (0, c.jsx)(o.Z, {
                        date: t.createdAt
                    }), "by", (0, c.jsx)(r.default, {
                        member: t.author
                    })]
                }), (0, c.jsxs)("span", {
                    className: i.text,
                    children: ["Last event:", (0, c.jsx)(o.Z, {
                        date: t.lastEventAt
                    })]
                }), (0, c.jsxs)("span", {
                    className: i.text,
                    children: ["Last seen event:", t.lastSeenEventAt ? (0, c.jsx)(o.Z, {
                        date: t.lastSeenEventAt
                    }) : "never"]
                }), !!t.endedAt && (0, c.jsxs)("span", {
                    className: i.text,
                    children: ["Ended:", (0, c.jsx)(o.Z, {
                        date: t.endedAt
                    })]
                }), (0, c.jsx)("span", {
                    className: i.text,
                    children: "Events: "
                }), s.map((e => (0, c.jsxs)("span", {
                    className: i.text,
                    children: [e.type, " at ", (0, c.jsx)(o.Z, {
                        date: e.createdAt
                    }), "by", (0, c.jsx)(r.default, {
                        member: e.author
                    })]
                }, e.id)))]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(741),
            o = s(745),
            r = s(742),
            i = s(1);
        const c = s(310).wx,
            l = n.Hocs.compose()((e => {
                const {
                    project: t
                } = e, s = n.Hooks.useDesktopLayout(), l = n.Hooks.useIntl(), d = n.Hooks.useModalState();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(a.Z, {
                        isDesktop: s,
                        headerText: l.f.z9,
                        buttonIconName: "Ʀ",
                        onButtonPress: d.open,
                        children: (0, i.jsx)(r.e, {
                            children: (0, i.jsx)(o.Z, {
                                project: t
                            })
                        })
                    }), d.isOpen ? (0, i.jsx)(c.PurposePrompt, {
                        bundle$close: d.close,
                        project: t,
                        onClose: d.close
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(179),
            o = s(337),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.withObservables(["project"], (({
            project: e
        }) => ({
            isGuestSharedProject: n.Rx.from(e.isGuestSharedProject)
        }))), n.Hocs.withObservables(["project", "isGuestSharedProject"], (({
            project: e,
            isGuestSharedProject: t
        }) => ({
            sharedTeam: t ? e.team : e.sharedTeam
        }))))((e => {
            const {
                project: t,
                isGuestSharedProject: s,
                sharedTeam: i
            } = e, c = n.Hooks.useIntl();
            if (!t.isShared && !t.hasBeenUnshared) return null;
            const l = (e => {
                if (t.isEnded || t.hasBeenUnshared) return c.f.BR;
                const n = (0, r.jsx)(o.j, {
                    children: null != (e = null == i ? void 0 : i.name) ? e : ""
                });
                return s ? c.g("BQ", {
                    team: n
                }) : c.g("BX", {
                    team: n
                })
            })();
            return (0, r.jsx)(a.Z, {
                text: n.React.Children.toArray(l)
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(179),
            o = s(92);
        s(2), s(3);
        const r = s(748);
        var i = s(1);
        const c = s(105).wx,
            l = n.Hocs.compose(n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                team: e.team,
                groups: e.groups
            }))))((e => {
                const {
                    project: t,
                    team: s,
                    groups: l
                } = e, d = n.Hooks.useIntl(), u = n.Hooks.useModalState();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(a.Z, {
                        icon: "Ƣ",
                        color: "orange",
                        text: d.f.B0,
                        right: t.isActive ? (0, i.jsx)(o.Z, {
                            className: r.pillButton,
                            label: d.f.BY,
                            onPress: u.open
                        }) : void 0
                    }), u.isOpen ? (0, i.jsx)(c.Project, {
                        bundle$close: u.close,
                        team: s,
                        onClose: u.close,
                        initialGroups: l,
                        projectToClone: t,
                        shouldRedirectToNewProject: !0
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(61),
            o = s(179),
            r = s(337),
            i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                project: t
            } = e;
            if (t.isShared || !t.hasPendingInvitation || !t.invitation) return null;
            const s = (0, i.jsx)(r.j, {
                    children: t.invitation.email
                }),
                n = (0, i.jsx)(a.Z, {
                    id: "BU",
                    values: {
                        email: s
                    }
                });
            return (0, i.jsx)(o.Z, {
                text: n
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n, a = s(0),
            o = s(39),
            r = s(123),
            i = s(6),
            c = s(12),
            l = s(13),
            d = s(150),
            u = s(1);
        const m = a.Hocs.compose(a.Hocs.withIntl, a.Hocs.withIdentity, a.Hocs.withObservables(["project"], (({
            currentMember: e,
            project: t,
            intl: s
        }) => ({
            isHostSharedProject: a.Rx.from(t.isHostSharedProject.then((e => (invariant(e, "Project has not been shared by current team"), e)))),
            members: t.permissions.members.pipe(a.Rx.switchMap((e => e.observeWithColumns(r.HI))), a.Rx.switchMap((0, r.dd)(s)), a.Rx.map((t => o.moveRecordToListBeginning(e.id, t))))
        }))), a.Hocs.withObservables(["isHostSharedProject", "project"], (({
            project: e
        }) => ({
            hostTeam: e.team,
            guestTeam: e.sharedTeam
        }))))((e => {
            const {
                project: t,
                hostTeam: s,
                guestTeam: o,
                members: r,
                onClose: m
            } = e, h = a.Hooks.useIntl(), [p, g] = (0, i.P9)(), [f, b] = a.FP.partition((e => e.team.id === s.id), r), [y, v] = a.Hooks.useStateMachine("summary");
            return (0, u.jsx)(u.Fragment, {
                children: y.map({
                    summary: () => (0, u.jsxs)(i.u_, {
                        ref: g,
                        onClose: m,
                        minWidth: 400,
                        children: [(0, u.jsx)(i.u_.Header, {
                            children: h.f.BT
                        }), (0, u.jsxs)(i.u_.Content, {
                            padded: !0,
                            children: [n || (n = (0, u.jsx)(i.u_.IconStack, {
                                stack: d.eN
                            })), (0, u.jsx)(i.u_.Heading, {
                                children: h.f.Ao
                            }), (0, u.jsx)(i.u_.Paragraph, {
                                children: a.React.Children.toArray(h.g("BS", {
                                    invitedTeamName: (0, u.jsx)(i.u_.Emphasis, {
                                        children: o.name
                                    }),
                                    projectName: (0, u.jsx)(i.u_.Emphasis, {
                                        children: a.Styling.getProjectName(t, h)
                                    }),
                                    teamName: o.name
                                }))
                            }), (0, u.jsx)(d.Wr, {
                                children: (0, u.jsx)(d.NW, {
                                    label: h.g("Aj", {
                                        memberCount: r.length
                                    }),
                                    topDescription: h.f.Ah,
                                    icon: "ķ",
                                    contentHeight: 56,
                                    onPress: v("members"),
                                    renderRight: () => (0, u.jsx)(l.default, {
                                        name: "9",
                                        color: "onBackground2"
                                    })
                                })
                            }), (0, u.jsx)(i.u_.Buttons, {
                                children: (0, u.jsx)(c.default, {
                                    label: h.f.fF,
                                    color: "incoming",
                                    variant: "opaque",
                                    onPress: p.closeAnimated
                                })
                            })]
                        })]
                    }),
                    members: e => (0, u.jsxs)(i.u_, {
                        ref: g,
                        onClose: m,
                        minWidth: 400,
                        children: [(0, u.jsx)(i.u_.Header, {
                            children: h.f.BT
                        }), (0, u.jsxs)(i.u_.Content, {
                            padded: !0,
                            isStatic: !0,
                            containsScroll: !0,
                            children: [(0, u.jsx)(i.u_.Switch, {
                                selectedOptionId: e ? "host" : "guest",
                                options: [{
                                    id: "guest",
                                    label: o.name
                                }, {
                                    id: "host",
                                    label: s.name
                                }],
                                selectOption: v("members", !e)
                            }), (0, u.jsx)(i.u_.Paragraph, {
                                children: h.f.Am
                            }), (0, u.jsx)(d.r1, {
                                children: (e ? f : b).map((e => (0, u.jsx)(d.MB, {
                                    member: e,
                                    contentHeight: 50
                                }, e.id)))
                            }), (0, u.jsx)(i.u_.Buttons, {
                                direction: "column",
                                children: (0, u.jsx)(c.default, {
                                    label: h.f.fh,
                                    onPress: p.closeAnimated,
                                    variant: "opaque",
                                    color: "incoming"
                                })
                            })]
                        })]
                    })
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n, a = s(0),
            o = s(6),
            r = s(12),
            i = s(150),
            c = s(1);
        const l = a.Hocs.compose((0, o.LU)({
            minWidth: 400
        }))((e => {
            const {
                project: t
            } = e, {
                invitation: s
            } = t, l = a.Hooks.useIntl(), {
                closeAnimated: d
            } = (0, o.vR)();
            return invariant(s, "Expected rejected project invitation to be defined"), (0, c.jsxs)(c.Fragment, {
                children: [(0, c.jsx)(o.u_.Header, {
                    children: l.f.BD
                }), (0, c.jsxs)(o.u_.Content, {
                    padded: !0,
                    children: [n || (n = (0, c.jsx)(o.u_.IconStack, {
                        stack: i.eN
                    })), (0, c.jsx)(o.u_.Heading, {
                        children: l.f.BW
                    }), (0, c.jsx)(o.u_.Paragraph, {
                        children: l.g("BV", {
                            email: (0, c.jsx)(o.u_.Emphasis, {
                                children: s.email
                            }, "project_shared_invitationRejected_email"),
                            projectName: (0, c.jsx)(o.u_.Emphasis, {
                                children: a.Styling.getProjectName(t, l)
                            }, "project_shared_invitationRejected_projectName")
                        })
                    }), (0, c.jsx)(o.u_.Buttons, {
                        children: (0, c.jsx)(r.default, {
                            label: l.f.fh,
                            onPress: d
                        })
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => w
        });
        var n, a, o, r = s(0),
            i = s(43),
            c = s(17),
            l = s(32),
            d = s(170),
            u = s(20),
            m = s(111),
            h = s(104),
            p = s(25),
            g = s(66),
            f = s(84),
            b = s(47),
            y = s(1);
        const v = s(42).wx,
            w = e => {
                var t;
                const {
                    target: s,
                    isShowingThePast: w,
                    onToggleThePast: k,
                    tag: x,
                    closeMenu: j,
                    saveToCSV: T
                } = e, S = r.Hooks.useIntl(), P = r.Hooks.useModalState(), _ = r.Hooks.useModalState(), {
                    currentTeam: C
                } = r.Hooks.useIdentity(), {
                    isFavorite: R
                } = x.asSidebarFavoritable(C), [{
                    closeAnimated: A
                }, I] = (0, l.XH)(), N = r.Hooks.useRemindExpired((() => A(r.ReactUtils.nullEvent()))), E = async () => {
                    R ? await x.unfavorite(C) : await x.favorite(C)
                }, O = () => (0, y.jsx)(v.Color, {
                    bundle$close: j,
                    onClose: j,
                    onConfirm: e => x.do.updateColor(e),
                    selectedColor: x.color,
                    level: 1,
                    placement: "right",
                    target: _.target
                }), M = () => (0, y.jsx)(v.Icon, {
                    bundle$close: j,
                    onClose: j,
                    onConfirm: e => x.do.updateIcon(e),
                    selectedIcon: x.icon,
                    level: 1,
                    placement: "right",
                    target: P.target,
                    color: x.color
                }), D = (0, g.Bd)(), [H, F] = r.Hooks.useStateMachine("menu");
                return (0, y.jsx)(y.Fragment, {
                    children: H.map({
                        pick_color: () => O(),
                        pick_icon: () => M(),
                        rename: () => (0, y.jsx)(h.default, {
                            title: S.f.fM,
                            placeholder: S.f.FU,
                            confirmButtonLabel: S.f.fM,
                            onConfirm: (e, t) => x.do.rename(t),
                            onClose: j,
                            validators: [i.C1],
                            currentValue: x.name,
                            maxLength: c.MaxLengths.tags.name
                        }),
                        menu: () => (0, y.jsxs)(l.ZP, {
                            ref: I,
                            target: s,
                            onClose: j,
                            children: [(0, y.jsx)(u.Z, {
                                icon: "Ƥ",
                                label: S.f.fM,
                                onPress: N(F("rename")),
                                hasArrow: !0
                            }), (0, y.jsx)(u.Z, {
                                onPress: N(_.open),
                                label: S.f.ub,
                                modalWebTarget: _.target,
                                iconColor: x.color || "onBackground3",
                                icon: "h",
                                hasArrow: !0
                            }), _.isOpen ? O() : null, (0, y.jsx)(u.Z, {
                                onPress: N(P.open),
                                modalWebTarget: P.target,
                                label: S.f.FT,
                                iconColor: x.color || "onBackground3",
                                icon: r.Styling.defaultTagIcon(x.icon),
                                hasArrow: !0
                            }), P.isOpen ? M() : null, x.isActive ? (0, y.jsx)(u.Z, {
                                label: S.f.fc,
                                icon: "1",
                                onPress: F("confirm_archive")
                            }) : (0, y.jsx)(u.Z, {
                                label: S.f.fP,
                                icon: "ž",
                                onPress: N(F("confirm_restore"))
                            }), x.isActive ? (0, y.jsxs)(y.Fragment, {
                                children: [n || (n = (0, y.jsx)(l.ZP.Separator, {})), (0, y.jsx)(d.Z, {
                                    variant: "favorite",
                                    isActive: R,
                                    onChange: N(E)
                                })]
                            }) : null, a || (a = (0, y.jsx)(l.ZP.Separator, {})), (0, y.jsx)(f.Z, {
                                isShowingThePast: w,
                                onPress: r.ReactUtils.callBoth(A, k)
                            }), D(A), o || (o = (0, y.jsx)(l.ZP.Separator, {})), t || (t = (0, y.jsx)(m.Z, {
                                type: "tag",
                                item: x,
                                onPress: A
                            })), (0, y.jsx)(b.Z, {
                                onPress: r.ReactUtils.callBoth(A, T)
                            })]
                        }),
                        confirm_archive: () => (0, y.jsx)(p.default, {
                            type: "confirm",
                            onConfirmPress: () => x.do.archive(),
                            onBackPress: j,
                            onClose: j,
                            children: S.f.FR
                        }),
                        confirm_restore: () => (0, y.jsx)(p.default, {
                            type: "confirm",
                            onConfirmPress: () => x.do.restore(),
                            onBackPress: j,
                            onClose: j,
                            children: S.f.FS
                        })
                    })
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n = s(0),
            a = s(48),
            o = s(75),
            r = s(749),
            i = s(62),
            c = s(50),
            l = s(855),
            d = s(1);
        const u = (e, t, s, a, o) => i => {
                var c;
                invariant(i instanceof n.Model.Models.Project, "Unexpected project is not instance of Project");
                const l = s.id + ":" + i.id,
                    u = a.find((e => e.root === i)),
                    m = u ? null == o || null == (c = o.groups) ? void 0 : c.get(u) : null;
                return (0, d.jsx)(r.Z, {
                    isCollapsed: t.includes(l),
                    toggleCollapse: () => e(l),
                    needsReview: null == u ? void 0 : u.items.some((e => e.doesNeedReview)),
                    hasActivity: null == u ? void 0 : u.items.some((e => e.isUnread)),
                    project: i,
                    counters: m,
                    tasks: null == u ? void 0 : u.items,
                    viewColor: s.color
                }, "section_header-" + i.id)
            },
            m = (e, t) => {
                const s = (0, l.r)(e.root);
                return (0, d.jsx)(i.Z, {
                    id: s,
                    type: c.x.TASK,
                    children: t
                }, "droppable-" + s)
            },
            h = e => {
                const {
                    tag: t,
                    taskGroups: s,
                    newTaskFormProps: n,
                    setEndedTasksState: r,
                    toggleSectionCollapse: i,
                    collapsedSectionsStates: c,
                    filterState: l
                } = e, h = (0, a.y)();
                return (0, d.jsx)(o.Z, {
                    taskGroups: s,
                    filterState: l,
                    onSetEndedTasksState: r,
                    rootRecord: t,
                    toggleSectionCollapse: i,
                    viewColor: t.color,
                    hasMasterPlus: !0,
                    renderSectionHeader: u(i, c, t, s, h),
                    isProjectVisible: "project" !== l.groupBy,
                    newTaskFormProps: n,
                    isSectionVisible: !0,
                    withSwipeLeft: !0,
                    isDndEnabled: !l.sort && !l.groupBy,
                    renderSectionItemsContainer: m
                })
            }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => g
        });
        var n, a, o, r = s(0),
            i = s(170),
            c = s(32),
            l = s(938),
            d = s(66),
            u = s(84),
            m = s(111),
            h = s(47),
            p = s(1);
        r.ReactUtils.lazy((() => s(157)));
        const g = r.Hocs.compose(r.Hocs.memo, r.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            user: e.user
        }))))((e => {
            const {
                target: t,
                isShowingThePast: s,
                onToggleThePast: g,
                member: f,
                closeMenu: b,
                saveToCSV: y,
                user: v
            } = e, [{
                closeAnimated: w
            }, k] = (0, c.XH)(), x = (0, d.Bd)();
            return (0, p.jsxs)(l.default, {
                ref: k,
                member: f,
                closeMenu: b,
                target: t,
                openMemberOnArchive: !0,
                children: [n || (n = (0, p.jsx)(c.ZP.Separator, {})), (0, p.jsx)(i.Z, {
                    variant: "favorite",
                    isActive: f.isFavorite,
                    onChange: async () => {
                        f.isFavorite ? await f.unfavorite() : await f.favorite()
                    }
                }), a || (a = (0, p.jsx)(c.ZP.Separator, {})), (0, p.jsx)(u.Z, {
                    isShowingThePast: s,
                    onPress: r.ReactUtils.callBoth(w, g)
                }), x(w), o || (o = (0, p.jsx)(c.ZP.Separator, {})), (0, p.jsx)(m.Z, {
                    type: "member",
                    item: f,
                    onPress: w
                }), (0, p.jsx)(h.Z, {
                    onPress: r.ReactUtils.callBoth(w, y)
                }), null]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => j
        });
        var n = s(0),
            a = s(6),
            o = s(60),
            r = s(25),
            i = s(12),
            c = s(326),
            l = s(21),
            d = s(20),
            u = s(1);

        function m({
            intl: e,
            vacation: t,
            team: s,
            business: a
        }) {
            return function(e) {
                return e.vacationer instanceof n.Model.Models.BusinessMember
            }(t) && a ? a.name : n.Styling.getTeamName(s, e)
        }
        const h = n.Hocs.compose()((e => {
            const {
                vacation: t,
                team: s,
                business: a,
                hasBottomDescription: o,
                hasArrow: r,
                onPress: i
            } = e, c = n.Hooks.useIntl();
            return (0, u.jsx)(d.Z, {
                label: (0, l.formatVacation)({
                    vacation: t,
                    intl: c,
                    format: "long"
                }),
                bottomDescription: o ? m({
                    intl: c,
                    vacation: t,
                    team: s,
                    business: a
                }) : null,
                hasArrow: r,
                isTextBolded: t.isOngoing,
                icon: "ƹ",
                iconColor: "textPrimary",
                onPress: i
            })
        }));
        var p = s(192),
            g = s(41),
            f = s(215),
            b = s(336),
            y = s(77);
        s(2), s(3);
        const v = s(753),
            w = s(42).wx;

        function k(e, t) {
            return (0, p.Z)((0, g.Z)(e), (0, g.Z)(t))
        }
        const x = n.Hocs.compose()((e => {
            var t, s, o;
            const {
                teamMember: r,
                business: m,
                businessMember: h,
                currentVacation: p,
                onConfirm: g,
                onRemove: x,
                onClose: j
            } = e, T = n.Hooks.useIntl(), [S, P] = null != (t = null == p ? void 0 : p.dates.map((e => e.day))) ? t : [null, null], [
                [_, C], R
            ] = n.React.useState([S, P]), A = null != (s = null != (o = null == p ? void 0 : p.vacationer) ? o : h) ? s : r, [I, N] = n.React.useState(A), E = !(!_ || !C || _.equals(S) && C.equals(P) && I.id === A.id), O = n.Hooks.useModal((({
                close: e,
                target: t
            }) => {
                const s = new Date;
                return (0, u.jsx)(w.Date, {
                    bundle$close: e,
                    onClose: e,
                    target: t,
                    title: T.f.KC,
                    webShowHeader: !0,
                    currentDateTime: _,
                    isDateDisabled: e => k(e, s),
                    onDayPress: n.FP.noop,
                    onCancel: e,
                    onConfirm: e => (e && (!C || C.isBefore(e) ? (R([e, e]), M.open()) : R([e, C])), {
                        shouldClose: !0
                    }),
                    level: 20
                })
            })), M = n.Hooks.useModal((({
                close: e,
                target: t
            }) => {
                const s = new Date;
                return (0, u.jsx)(w.Date, {
                    bundle$close: e,
                    onClose: e,
                    target: t,
                    currentDateTime: C,
                    onCancel: e,
                    onDayPress: n.FP.noop,
                    title: T.f.Ky,
                    webShowHeader: !0,
                    onConfirm: e => (e && (!_ || e.isBefore(_) ? (R([e, e]), O.open()) : R([_, e])), {
                        shouldClose: !0
                    }),
                    isDateDisabled: e => k(e, s) || !!_ && k(e, _.local),
                    level: 20
                })
            }));
            return (0, u.jsxs)(u.Fragment, {
                children: [(0, u.jsxs)(a.u_, {
                    minWidth: 500,
                    level: 20,
                    onClose: j,
                    children: [(0, u.jsx)(a.u_.Header, {
                        children: p ? T.f.Kz : T.f.KA
                    }), (0, u.jsxs)(a.u_.Content, {
                        children: [(0, u.jsxs)(a.u_.Section, {
                            noGutter: !1,
                            children: [(0, u.jsx)(d.Z, {
                                label: T.f.KC,
                                isTextBolded: !0,
                                renderRight: () => (0, u.jsx)(b.Z, {
                                    className: v.dateButton,
                                    onPress: O.open,
                                    accentColor: "blue",
                                    buttonRef: O.target,
                                    children: _ ? (0, l.formatVacationDateTime)({
                                        dateTime: _,
                                        timeZone: null,
                                        intl: T,
                                        format: "long"
                                    }) : T.f.KB
                                })
                            }), (0, u.jsx)(d.Z, {
                                label: T.f.Ky,
                                isTextBolded: !0,
                                renderRight: () => (0, u.jsx)(b.Z, {
                                    className: v.dateButton,
                                    onPress: M.open,
                                    accentColor: "blue",
                                    buttonRef: M.target,
                                    children: C ? (0, l.formatVacationDateTime)({
                                        dateTime: C,
                                        timeZone: null,
                                        intl: T,
                                        format: "long"
                                    }) : T.f.KB
                                })
                            })]
                        }), m && h ? (0, u.jsx)(u.Fragment, {
                            children: (0, u.jsx)(a.u_.Section, {
                                noGutter: !1,
                                children: (0, u.jsx)(y.Z, {
                                    label: T.f.Kx,
                                    bottomDescription: T.g("Kw", {
                                        businessName: m.name
                                    }),
                                    left: (0, u.jsx)(f.Z, {
                                        business: m,
                                        size: 16
                                    }),
                                    colorActive: "blue",
                                    isActive: I instanceof n.Model.Models.BusinessMember,
                                    onChange: () => N(I instanceof n.Model.Models.BusinessMember ? r : h)
                                })
                            })
                        }) : null, (0, u.jsxs)(a.u_.Buttons, {
                            direction: "row",
                            children: [p ? (0, u.jsx)(i.default, {
                                label: T.f.fL,
                                onPress: () => x(p)
                            }) : null, (0, u.jsx)(i.default, {
                                label: p ? T.f.ff : T.f.fS,
                                isDisabled: !E,
                                color: "blue",
                                variant: "opaque",
                                onPress: () => {
                                    const e = c.od.fromDates(function(e, t) {
                                        return invariant(e && t, "Invalid vacation dates"), [e.withTime([0, 0]), t.withTime([23, 59])]
                                    }(_, C), I);
                                    g(e)
                                }
                            })]
                        })]
                    })]
                }), O.render(), M.render()]
            })
        }));
        const j = n.Hocs.compose(n.Hocs.withObservables(["member"], (({
            member: e
        }) => ({
            user: e.user,
            team: e.team,
            vacations: e.allActiveVacations,
            businessMember: e.businessMember
        }))), n.Hocs.withObservables(["businessMember"], (({
            businessMember: e
        }) => {
            var t;
            return {
                business: null != (t = null == e ? void 0 : e.business) ? t : n.Rx.of(null)
            }
        })))((e => {
            const {
                user: t,
                member: s,
                team: d,
                businessMember: m,
                business: p,
                onClose: g
            } = e, f = n.Hooks.useIntl(), [{
                closeAnimated: b
            }, y] = (0, a.P9)();
            invariant(t.isMe, "Vacation modal can only be opened for the current user");
            const v = n.React.useMemo((() => (0, c.bD)(e.vacations)), [e.vacations]),
                [w, k] = n.Hooks.useStateMachine("main"),
                j = function(e) {
                    return 1 < new Set(e.map((({
                        vacationer: e
                    }) => e.id))).size
                }(v);
            return w.map({
                main: () => {
                    return (0, u.jsxs)(a.u_, {
                        ref: y,
                        minWidth: 500,
                        onClose: g,
                        children: [(0, u.jsx)(a.u_.Header, {
                            children: f.f.qY
                        }), (0, u.jsxs)(a.u_.Content, {
                            children: [(0, u.jsx)(a.u_.IconStack, {
                                stack: (e = v.length ? 100 : 190, [{
                                    iconName: "ħ",
                                    color: "orange",
                                    opacity: .3,
                                    size: e
                                }, {
                                    iconName: "Ĩ",
                                    color: "orange",
                                    opacity: .7,
                                    size: e
                                }, {
                                    iconName: "ĩ",
                                    color: "orange",
                                    size: e
                                }])
                            }), (0, u.jsx)(a.u_.Paragraph, {
                                children: f.f.Kv
                            }), v.length ? (0, u.jsxs)(u.Fragment, {
                                children: [(0, u.jsx)(a.u_.Heading, {
                                    children: f.f.KD
                                }), (0, u.jsx)(a.u_.Section, {
                                    noGutter: !1,
                                    children: v.map((e => (0, u.jsx)(u.Fragment, {
                                        children: (0, u.jsx)(h, {
                                            vacation: e,
                                            team: d,
                                            business: p,
                                            hasArrow: !0,
                                            hasBottomDescription: j,
                                            onPress: k("editor", e)
                                        }, e.id)
                                    })))
                                })]
                            }) : null, t.isMe ? (0, u.jsx)(a.u_.Buttons, {
                                children: (0, u.jsx)(i.default, {
                                    label: f.f.Kr,
                                    color: "blue",
                                    variant: "opaque",
                                    onPress: k("editor")
                                })
                            }) : null]
                        })]
                    });
                    var e
                },
                editor: e => (0, u.jsx)(x, {
                    teamMember: s,
                    businessMember: m,
                    business: p,
                    currentVacation: e,
                    onConfirm: async t => {
                        e && invariant(!e.equals(t), "New vacation is the same as the current one");
                        const s = (e ? v.filter((t => t.id !== e.id)) : v).filter((e => t.overlapsWith(e) && t.vacationer.id === e.vacationer.id));
                        s.length ? k("confirmOverlap", {
                            newVacation: t,
                            currentVacation: e,
                            overlappingVacations: s
                        })() : e ? k("confirmChange", {
                            currentVacation: e,
                            newVacation: t
                        })() : (await t.schedule(), k("main")())
                    },
                    onRemove: e => k("confirmRemove", e)(),
                    onClose: g
                }),
                confirmOverlap: ({
                    newVacation: e,
                    currentVacation: t,
                    overlappingVacations: s
                }) => (0, u.jsx)(r.default, {
                    modalRef: y,
                    type: "confirm",
                    level: 20,
                    hasTextContent: !1,
                    onClose: k("main"),
                    onBackPress: k("editor", e),
                    onConfirmPress: async s => {
                        t ? k("confirmChange", {
                            currentVacation: t,
                            newVacation: e
                        })() : (await e.schedule(), b(s))
                    },
                    closeOnConfirm: !1,
                    children: (0, u.jsxs)(o.tu, {
                        children: [(0, u.jsx)(r.default.Paragraph, {
                            children: f.g("Kt", {
                                selectedVacationDate: (0, u.jsx)(a.u_.Emphasis, {
                                    children: (0, l.formatVacation)({
                                        vacation: e,
                                        intl: f,
                                        format: "short"
                                    })
                                }, "selectedVacationDate")
                            })
                        }), (0, u.jsx)(a.u_.Section, {
                            hasGutter: !0,
                            children: s.map((e => (0, u.jsx)(h, {
                                vacation: e,
                                team: d,
                                business: p,
                                hasBottomDescription: j
                            }, e.id)))
                        })]
                    })
                }),
                confirmChange: ({
                    currentVacation: e,
                    newVacation: t
                }) => (0, u.jsx)(r.default, {
                    type: "confirm",
                    level: 20,
                    confirmButtonMessage: f.f.ff,
                    onClose: k("main"),
                    onBackPress: k("main"),
                    onConfirmPress: async () => {
                        e ? await e.replaceWith(t) : await t.schedule()
                    },
                    children: f.g("Ks", {
                        previousVacationDate: (0, u.jsx)(a.u_.Emphasis, {
                            children: (0, l.formatVacation)({
                                vacation: e,
                                intl: f,
                                format: "long"
                            })
                        }, "previousVacationDate"),
                        newVacationDate: (0, u.jsx)(a.u_.Emphasis, {
                            children: (0, l.formatVacation)({
                                vacation: t,
                                intl: f,
                                format: "long"
                            })
                        }, "newVacationDate")
                    })
                }),
                confirmRemove: e => (0, u.jsx)(r.default, {
                    type: "confirm",
                    level: 20,
                    onClose: k("main"),
                    onBackPress: k("editor", e),
                    confirmButtonMessage: f.f.fL,
                    onConfirmPress: () => e.cancel(),
                    children: f.g("Ku", {
                        vacationDate: (0, u.jsx)(a.u_.Emphasis, {
                            children: (0, l.formatVacation)({
                                vacation: e,
                                intl: f,
                                format: "long"
                            })
                        }, "vacationDate")
                    })
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => k
        });
        var n = s(0),
            a = s(14),
            o = s(29),
            r = s(89),
            i = s(70),
            c = s(74),
            l = s(48),
            d = s(44),
            u = s(1364),
            m = s(47),
            h = s(62),
            p = s(50),
            g = s(75),
            f = s(1);
        const b = (e, t) => (0, f.jsx)(h.Z, {
                id: "none",
                type: p.x.TASK,
                children: t
            }, "droppable-priority"),
            y = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity)((e => {
                const {
                    currentTeam: t,
                    taskGroups: s,
                    onSetEndedTasksState: a,
                    newTaskFormProps: o,
                    isDndEnabled: r,
                    filterState: i
                } = e, c = n.Hooks.useIntl();
                return (0, f.jsx)(g.Z, {
                    taskGroups: s,
                    filterState: i,
                    onSetEndedTasksState: a,
                    rootRecord: t,
                    newTaskFormProps: o,
                    isDndEnabled: r,
                    hasMasterPlus: !0,
                    renderSectionItemsContainer: b,
                    withSwipeLeft: !0,
                    emptyListTitle: c.f.zU,
                    emptyListMessage: c.f.zT,
                    viewColor: "priority"
                })
            })),
            v = n.ReactUtils.lazy((() => s(1378))),
            w = async (e, t, s) => e.do.getPriorityPositionForForm(t.position, s.filter((e => e.isActive))), k = n.Hocs.compose(n.Hocs.memo, n.Hocs.withIdentity, n.Hocs.withServices, n.Hocs.withHooks((() => {
                var e, t;
                const s = (0, d.Nk)(),
                    {
                        endedTasksStates: n
                    } = s;
                return Object.assign({}, s, {
                    endedTasksState: null != (e = null == (t = n[0]) ? void 0 : t.state) ? e : "hidden"
                })
            })), (0, i.hp)((({
                currentTeam: e
            }) => ({
                viewId: e.id + "/priority",
                initialState: {
                    disabledOptions: ["priority", "groupBy"]
                }
            }))), n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                justEndedTasks: e.uiState.forTeam(t).justEndedTasks,
                singleTasks: t.singleTasks
            }))), n.Hocs.withObservables(["currentTeam", "justEndedTasks", "filterState"], (({
                currentTeam: e,
                justEndedTasks: t,
                filterState: s
            }) => ({
                tasks: e.currentPriorityTasks.pipe(n.Rx.switchMap((e => {
                    var n;
                    return e.extend(...(0, r.Z)((0, i.LB)(s))).pipe((0, o.EF)(t, null != (n = s.sort) ? n : {
                        by: "priorityPosition",
                        order: "ascending"
                    }, !!s.sort))
                })))
            }))), n.Hocs.withHooks((({
                tasks: e,
                justEndedTasks: t,
                endedTasksStates: s,
                isShowingThePast: n
            }) => {
                const {
                    activeAndJustEndedTasks: a
                } = (0, o.rq)(e, t), {
                    taskGroups: r,
                    sortedTasks: i
                } = (0, u.U)({
                    sections: [null],
                    getTasksForSection: () => e,
                    justEndedTasks: t,
                    isShowingThePast: n,
                    endedTasksStates: s
                });
                return {
                    sortedTasks: i,
                    taskGroups: r,
                    activeAndJustEndedTasks: a
                }
            })), n.Hocs.withFeatureBadges({
                placement: "priority_menu_button"
            }))((e => {
                const {
                    currentTeam: t,
                    tasks: s,
                    taskGroups: o,
                    isShowingThePast: r,
                    setEndedTasksState: i,
                    toggleShowThePast: u,
                    singleTasks: h,
                    activeAndJustEndedTasks: p,
                    filterState: g,
                    setFilterState: b,
                    featureBadges: k
                } = e, x = n.Hooks.useIntl(), j = n.Hooks.useModalState(), T = (0, d.Or)(a.routeToTaskListTask), {
                    newTaskFormProps: S,
                    newTaskFormVisibility: P
                } = (0, d.G8)({
                    defaultProject: h,
                    taskGroups: o,
                    rootRecord: null,
                    mapNewTaskOptions: async e => Object.assign({}, e, {
                        priorityPosition: e.isPriority ? await w(t, S.positionGroup, s) : void 0
                    }),
                    isPriorityActive: !0
                }), _ = n.Hooks.useDnd((() => ({
                    setNewTaskFormPosition: e => S.setPositionGroup(e),
                    selector: e => e.priorityPosition,
                    updater: (e, t) => {
                        e.priorityPosition = t
                    },
                    updatePosition: async (e, t) => {
                        await e.do.updatePriorityPosition(t)
                    },
                    getDroppedSection: () => ({
                        items: p
                    })
                }))), C = n.Rx.of(s.filter((e => e.isActive)).length), R = (0, l.W$)(o), A = (0, m.x)(s, x.f.zV);
                return (0, f.jsx)(l.MV, {
                    counters: R,
                    children: (0, f.jsx)(c.Z, {
                        rootRecord: t,
                        title: x.f.zV,
                        color: "priority",
                        leftIcon: "Ƙ",
                        taskDetailsProps: T,
                        menuTarget: j.target,
                        menuBadge: k.placementBadge,
                        openViewMenu: j.open,
                        onDragEnd: _.onDragEnd,
                        filterState: g,
                        setFilterState: b,
                        activeTasksCounter: C,
                        newTaskFormVisibility: P,
                        sortedTasks: s,
                        newTaskFormProps: S,
                        children: (0, f.jsxs)(f.Fragment, {
                            children: [(0, f.jsx)(y, {
                                taskGroups: o,
                                onSetEndedTasksState: i,
                                newTaskFormProps: S,
                                isDndEnabled: !g.sort,
                                filterState: g
                            }), j.isOpen ? (0, f.jsx)(v, {
                                isShowingThePast: r,
                                onToggleThePast: u,
                                closeMenu: j.close,
                                target: j.target,
                                saveToCSV: A
                            }) : null]
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => w
        });
        var n = s(0),
            a = s(32),
            o = s(20),
            r = s(47),
            i = s(111),
            c = s(66),
            l = s(171),
            d = s(754),
            u = s(6),
            m = s(25),
            h = s(77);
        s(2), s(3);
        const p = s(755);
        var g = s(1);
        const f = ["delegated", "due_date", "overdue", "mention", "reminder"];

        function b(e, t) {
            switch (e) {
                case "delegated":
                    return t.f.ni;
                case "due_date":
                    return t.f.nk;
                case "overdue":
                    return t.f.nn;
                case "mention":
                    return t.f.nm;
                case "reminder":
                    return t.f.no;
                default:
                    return ""
            }
        }

        function y(e, t, s) {
            switch (e) {
                case "delegated":
                    return s.g("nd", {
                        tasksCount: t
                    });
                case "due_date":
                    return s.g("ne", {
                        tasksCount: t
                    });
                case "overdue":
                    return s.g("ng", {
                        tasksCount: t
                    });
                case "mention":
                    return s.g("nf", {
                        tasksCount: t
                    });
                case "reminder":
                    return s.g("nh", {
                        tasksCount: t
                    });
                default:
                    return ""
            }
        }
        const v = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                incomingPrioritizationSetting: e.modelRoot.settings.incomingPrioritization.observe()
            }))))((e => {
                const {
                    onClose: t,
                    target: s,
                    services: o,
                    incomingPrioritizationSetting: r
                } = e, i = n.Hooks.useIntl(), {
                    currentTeam: c
                } = n.Hooks.useIdentity(), [v, w] = n.Hooks.useStateMachine("main");
                return v.map({
                    main: () => (0, g.jsxs)(a.ZP, {
                        onClose: t,
                        target: s,
                        placement: "right",
                        children: [(0, g.jsx)(u.u_.Section, {
                            className: p.descriptionSection,
                            children: (0, g.jsx)(u.u_.Text, {
                                children: i.f.nj
                            })
                        }), f.map((e => (0, g.jsx)(h.Z, {
                            isActive: !!r[e],
                            label: b(e, i),
                            onChange: () => {
                                (async e => {
                                    if (!r[e]) {
                                        const t = await n.Rx.takeFirst(c.getIncomingTasksNotInPriorityFor(e).pipe(n.Rx.switchMap((e => e.fetch()))));
                                        0 < t.length && w("confirm", {
                                            type: e,
                                            tasks: t
                                        })()
                                    }
                                    await o.modelRoot.settings.incomingPrioritization.setWith((t => Object.assign({}, t, {
                                        [e]: !t[e]
                                    })))
                                })(e)
                            }
                        }, e)))]
                    }),
                    confirm: ({
                        type: e,
                        tasks: t
                    }) => (0, g.jsx)(m.default, {
                        onClose: w("main"),
                        onConfirmPress: () => (async (e, t) => {
                            const s = c.id + "/incoming",
                                [a, r] = await Promise.all([n.Rx.takeFirst((0, l.C)(s, o.collections)), n.Rx.takeFirst(o.uiState.forTeam(c).justEndedTasks)]),
                                i = (0, d.m)(t, e, r, a);
                            await c.do.markTasksAsPriority(i)
                        })(t, e),
                        type: "confirm",
                        confirmButtonMessage: i.f.nc,
                        onBackPress: w("main"),
                        secondaryButtonMessage: i.f.f3,
                        children: y(e, t.length, i)
                    })
                })
            })),
            w = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withFeatureBadges({
                placement: "priority_menu"
            }))((e => {
                const {
                    target: t,
                    isShowingThePast: s,
                    onToggleThePast: l,
                    closeMenu: d,
                    saveToCSV: u,
                    featureBadges: m
                } = e, h = n.Hooks.useIntl(), p = (0, c.Bd)(), [{
                    closeAnimated: f
                }, b] = (0, a.XH)(), y = n.Hooks.useModalState();
                return (0, g.jsxs)(g.Fragment, {
                    children: [(0, g.jsxs)(a.ZP, {
                        ref: b,
                        onClose: d,
                        target: t,
                        children: [(0, g.jsx)(o.Z, {
                            icon: "Ť",
                            label: s ? h.f.hr : h.f.hs,
                            onPress: n.ReactUtils.callBoth(f, l)
                        }), p(f), (0, g.jsx)(i.Z, {
                            type: "priority",
                            item: void 0,
                            onPress: f
                        }), (0, g.jsx)(r.Z, {
                            onPress: n.ReactUtils.callBoth(f, u)
                        }), (0, g.jsx)(o.Z, {
                            icon: "D",
                            label: h.f.nl,
                            hasArrow: !0,
                            onPress: () => {
                                y.open()
                            },
                            modalWebTarget: y.target,
                            badge: m.get("priority_incoming")
                        })]
                    }), y.isOpen ? (0, g.jsx)(v, {
                        onClose: y.close,
                        target: y.target
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(32),
            o = s(47),
            r = s(111),
            i = s(66),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                target: t,
                closeMenu: s,
                saveToCSV: l
            } = e, d = (0, i.Bd)(), [{
                closeAnimated: u
            }, m] = (0, a.XH)();
            return (0, c.jsxs)(a.ZP, {
                ref: m,
                onClose: s,
                target: t,
                children: [d(u), (0, c.jsx)(r.Z, {
                    type: "incoming",
                    item: void 0,
                    onPress: u
                }), (0, c.jsx)(o.Z, {
                    onPress: n.ReactUtils.callBoth(u, l)
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => w
        });
        var n = s(0),
            a = s(14),
            o = s(6),
            r = s(11),
            i = s(18),
            c = s(13);
        s(2), s(3);
        const l = s(756);
        var d = s(1);
        const u = n.Hocs.compose()((e => {
            const {
                label: t,
                color: s,
                icon: a,
                isActive: o,
                onPress: u
            } = e;
            return (0, d.jsxs)(r.Z, {
                className: l.root + " " + (e.className || ""),
                style: Object.assign({}, o ? {
                    borderColor: n.Styling.factoryColor(s),
                    borderWidth: 2
                } : void 0, e.style),
                onPress: u,
                children: [(0, d.jsx)(c.default, {
                    className: l.icon,
                    name: a,
                    color: s,
                    size: 22,
                    opacity: !1 === o ? .5 : 1
                }), (0, d.jsx)(i.default, {
                    className: l.label,
                    style: o ? {
                        color: n.Styling.factoryColor(o ? s : "textPrimary")
                    } : void 0,
                    children: t
                })]
            })
        }));
        var m = s(213);
        const h = s(757),
            p = e => {
                const {
                    isFollowed: t,
                    isFavorite: s,
                    toggleFollow: a,
                    toggleFavorite: o
                } = e, r = n.Hooks.useIntl();
                return (0, d.jsxs)(m.Z, {
                    className: h.root + " " + (e.className || ""),
                    style: e.style,
                    direction: "row",
                    spacing: 8,
                    flexChildren: !0,
                    children: [(0, d.jsx)(u, {
                        label: r.f.fx,
                        icon: t ? "±" : "²",
                        color: "activity",
                        isActive: t,
                        onPress: a
                    }), (0, d.jsx)(u, {
                        label: r.f.AK,
                        icon: s ? "Á" : "Â",
                        isActive: s,
                        color: "red",
                        onPress: o
                    })]
                })
            };
        var g = s(745);
        const f = s(758);
        var b;
        const y = [{
                iconName: "ü",
                color: "activity",
                opacity: .4,
                size: 140
            }, {
                iconName: "ý",
                color: "activity",
                size: 140
            }],
            v = (e, {
                isFollowed: t,
                isFavorite: s
            }) => {
                const a = n.React.useRef({
                    isFollowed: t,
                    isFavorite: s
                });
                n.React.useEffect((() => {
                    a.current = {
                        isFollowed: t,
                        isFavorite: s
                    }
                }), [t, s]), n.React.useEffect((() => () => {
                    (async () => {
                        const t = a.current;
                        t.isFavorite ? (await e.favorite(), await e.do.markAsSeen()) : t.isFollowed && (await e.follow(), await e.do.markAsSeen())
                    })()
                }), [e])
            },
            w = n.Hocs.compose((0, o.LU)({
                minWidth: 500
            }), n.Hocs.withObservables(["project"], (({
                project: e
            }) => ({
                team: e.team
            }))))((e => {
                const {
                    project: t,
                    eventType: s,
                    team: r
                } = e, c = n.Hooks.useServices(), l = n.Hooks.useIntl(), [{
                    isFollowed: m,
                    isFavorite: h
                }, w] = (e => {
                    const [t, s] = n.React.useState({
                        isFollowed: e.isFollowed,
                        isFavorite: e.isFavorite
                    });
                    return v(e, t), [t, s]
                })(t), k = (() => {
                    switch (s) {
                        case "created":
                            return l.f.p;
                        case "restored":
                            return l.f.u;
                        default:
                            throw new Error('Unsupported event type "' + s + '" in project activity modal')
                    }
                })();
                return (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsx)(o.u_.Header, {
                        children: k
                    }), (0, d.jsxs)(o.u_.Content, {
                        padded: !0,
                        children: [b || (b = (0, d.jsx)(o.u_.IconStack, {
                            stack: y
                        })), (0, d.jsxs)(o.u_.Section, {
                            className: f.projectNameSection,
                            children: [(0, d.jsx)(i.default, {
                                className: f.projectNameLabel,
                                children: l.f.A3
                            }), (0, d.jsx)(i.default, {
                                className: f.projectName,
                                children: n.Styling.getProjectName(t, l)
                            })]
                        }), (0, d.jsx)(o.u_.Paragraph, {
                            children: t.description ? (0, d.jsx)(g.Z, {
                                project: t
                            }) : l.f.o
                        }), (0, d.jsxs)(o.u_.Section, {
                            children: [(0, d.jsx)(p, {
                                className: f.favFollowButtons,
                                isFollowed: m,
                                isFavorite: h,
                                toggleFollow: () => {
                                    w({
                                        isFollowed: !m,
                                        isFavorite: !1
                                    })
                                },
                                toggleFavorite: () => {
                                    w({
                                        isFollowed: !0,
                                        isFavorite: !h
                                    })
                                }
                            }), (0, d.jsx)(u, {
                                label: l.f.AN,
                                icon: "»",
                                color: "blue",
                                onPress: async () => {
                                    await t.do.markAsSeen(), c.router.goTo((0, a.smartPathToProject)(r, t))
                                }
                            })]
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(32),
            o = s(47),
            r = s(111),
            i = s(66),
            c = s(1);
        const l = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                target: t,
                closeMenu: s,
                saveToCSV: l
            } = e, d = (0, i.Bd)(), [{
                closeAnimated: u
            }, m] = (0, a.XH)();
            return (0, c.jsxs)(a.ZP, {
                ref: m,
                onClose: s,
                target: t,
                children: [d(u), (0, c.jsx)(r.Z, {
                    type: "activity",
                    item: void 0,
                    onPress: u
                }), (0, c.jsx)(o.Z, {
                    onPress: n.ReactUtils.callBoth(u, l)
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => D
        });
        var n, a = s(0),
            o = s(17),
            r = s(29),
            i = s(89),
            c = s(14),
            l = s(74),
            d = s(48),
            u = s(44),
            m = s(1364),
            h = s(70),
            p = s(47),
            g = s(62),
            f = s(50),
            b = s(75),
            y = s(1);
        const v = a.ReactUtils.lazy((() => s(1383))),
            w = (e, t) => {
                const {
                    root: s
                } = e, n = s && "string" != typeof s ? s.id : s;
                return (0, y.jsx)(g.Z, {
                    id: "none",
                    type: f.x.TASK,
                    children: t
                }, "droppable-" + (n || "WITHOUT_SECTION"))
            },
            k = a.Hocs.compose(a.Hocs.memo)((e => {
                const {
                    singleTasks: t,
                    taskGroups: s,
                    onSetEndedTasksState: o,
                    renderSectionHeader: r,
                    newTaskFormProps: i,
                    filterState: c
                } = e, l = a.Hooks.useIntl(), {
                    isLimitedAccount: d
                } = a.Hooks.useIdentity(), u = a.React.useCallback((() => d ? n || (n = (0, y.jsx)(v, {})) : null), [d]);
                return (0, y.jsx)(b.Z, {
                    taskGroups: s,
                    filterState: c,
                    onSetEndedTasksState: o,
                    rootRecord: t,
                    renderSectionHeader: r,
                    hasMasterPlus: !0,
                    viewColor: "singleTasks",
                    isDndEnabled: !1,
                    renderSectionItemsContainer: w,
                    isProjectVisible: !1,
                    newTaskFormProps: i,
                    renderListHeader: u,
                    emptyListTitle: l.f.zU,
                    emptyListMessage: l.f.zT
                })
            }));
        var x = s(97),
            j = s(13),
            T = s(83);
        const S = "sharedViaLink";

        function P(e) {
            return e === S
        }

        function _(e) {
            return !P(e) && T.Ej.test(e)
        }
        s(2), s(3);
        const C = s(759),
            R = a.ReactUtils.lazy((() => s(56))),
            A = a.ReactUtils.lazy((() => s(93))),
            I = a.ReactUtils.lazy((() => s(1385))),
            N = a.Hocs.compose(a.Hocs.withServices, a.Hocs.withObservables(["memberIdOrEmail"], (({
                memberIdOrEmail: e,
                services: t
            }) => {
                return {
                    member: (s = e, P(s) || _(s) ? a.Rx.of(null) : t.collections.get(a.Model.Tables.teamMembers).findAndObserve(e))
                };
                var s
            })), a.Hocs.withObservables(["member"], (({
                member: e
            }) => ({
                preferredName: e ? e.preferredName : a.Rx.of(null)
            }))), a.Hocs.withObservables(["counters"], (({
                counters: e
            }) => ({
                counters: a.Rx.wrap(e)
            }))))((e => {
                var t;
                const {
                    memberIdOrEmail: s,
                    preferredName: n,
                    member: o,
                    isViewShowingThePast: r,
                    isSectionShowingThePast: i,
                    toggleSectionShowingThePast: c,
                    counters: l,
                    tasks: d
                } = e, u = a.Hooks.useModalState(), m = a.Hooks.useIntl(), h = P(s), p = (() => {
                    if (o || !s) return t || (t = (0, y.jsx)(R, {
                        member: o,
                        size: "small"
                    }));
                    if (h) {
                        const e = a.Styling.factoryAvatarSize("small");
                        return (0, y.jsx)(y.Fragment, {
                            children: (0, y.jsx)(A, {
                                className: C.linkShareContainer,
                                color: "gray2",
                                name: "",
                                children: (0, y.jsx)(j.default, {
                                    size: e,
                                    color: "gray6",
                                    name: "Ŀ"
                                })
                            })
                        })
                    }
                    return (0, y.jsx)(A, {
                        name: s,
                        color: "avatarColor10"
                    })
                })();
                return (0, y.jsxs)(y.Fragment, {
                    children: [(0, y.jsx)(x.Z, {
                        left: p,
                        hasThreeDots: !0,
                        menuTarget: u.target,
                        onMenuPress: u.open,
                        counters: null == l ? void 0 : l.activeTasks,
                        tasks: d,
                        viewColor: "singleTasks",
                        children: h ? m.f.EM : m.g("EN", {
                            username: null != n ? n : s
                        })
                    }), u.isOpen ? (0, y.jsx)(I, {
                        closeMenu: u.close,
                        section: (null == o ? void 0 : o.id) || s,
                        target: u.target,
                        isViewShowingThePast: r,
                        isSectionShowingThePast: i,
                        toggleSectionShowingThePast: c
                    }) : null]
                })
            })),
            E = a.ReactUtils.lazy((() => s(1386))),
            O = (e, t) => s => {
                if (!s) return null;
                const n = e.taskGroups.find((e => e.root === s));
                invariant(n, "Missing taskGroup for member " + s);
                const {
                    isShowingThePast: a,
                    toggleSectionShowingThePast: o
                } = e, r = "hidden" !== n.endedTasksState, i = null == t ? void 0 : t.groups.get(n);
                return (0, y.jsx)(N, {
                    memberIdOrEmail: s,
                    isViewShowingThePast: a,
                    toggleSectionShowingThePast: o,
                    isSectionShowingThePast: r,
                    counters: i,
                    tasks: n.items
                })
            },
            M = {
                by: "projectPosition",
                order: "ascending"
            },
            D = a.Hocs.compose(a.Hocs.memo, a.Hocs.withIdentity, a.Hocs.withServices, a.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                singleTasks: t.singleTasks,
                justEndedTasks: e.uiState.forTeam(t).justEndedTasks
            }))), (0, h.hp)((({
                singleTasks: e,
                currentTeam: t
            }) => ({
                viewId: t.id + "/single_tasks",
                initialState: {
                    filterProject: e.id,
                    filterProjects: [e.id],
                    disabledOptions: ["project", "projects", "groups", "groupBy"]
                }
            }))), a.Hocs.withObservables(["singleTasks", "currentMember", "filterState", "justEndedTasks"], (({
                singleTasks: e,
                services: t,
                currentMember: s,
                filterState: n,
                justEndedTasks: o
            }) => ({
                tasks: a.Rx.nowAndEveryDay().pipe(a.Rx.switchMap((() => {
                    var s;
                    return t.database.get(a.Model.Tables.tasks).query(...(0, i.Z)(Object.assign({}, (0, h.LB)(n), {
                        projectId: e.id
                    }))).pipe((0, r.EF)(o, null != (s = n.sort) ? s : M, !!n.sort))
                }))),
                taskAccesses: s.taskAccesses.observe()
            }))), a.Hocs.withObservables(["taskAccesses", "singleTasks", "filterState", "justEndedTasks"], (({
                taskAccesses: e,
                singleTasks: t,
                services: s,
                filterState: n,
                justEndedTasks: c
            }) => {
                var l;
                const d = a.FP.omit(["filterProject", "filterProjects"], n);
                return {
                    tasksWithoutProject: s.database.get(a.Model.Tables.tasks).query(...(0, i.Z)(Object.assign({}, (0, h.LB)(d))), o.Q.where(o.Columns.id, o.Q.oneOf(e.map((e => e.task.id)))), o.Q.or(o.Q.where(o.Columns.tasks.projectId, t.id), o.Q.where(o.Columns.tasks.projectId, r.sW))).pipe((0, r.EF)(c, null != (l = n.sort) ? l : M, !!n.sort))
                }
            })), a.Hocs.withHooks((({
                taskAccesses: e,
                currentMember: t,
                tasksWithoutProject: s,
                tasks: n,
                justEndedTasks: o,
                isLimitedAccount: r
            }) => {
                const i = a.React.useMemo((() => [null, ...e.reduce(((e, s) => {
                        const n = s.granter.id === t.id ? s.grantee.id || s.granteeEmail || S : s.granter.id;
                        return e.includes(n) || e.push(null != n ? n : null), e
                    }), [])]), [e, t]),
                    c = (0, u.Nk)(r),
                    {
                        endedTasksStates: l
                    } = c,
                    [d, h] = r ? [!0, a.FP.noop] : [c.isShowingThePast, c.toggleShowThePast],
                    {
                        taskGroups: p,
                        sortedTasks: g
                    } = (0, m.U)({
                        sections: i,
                        getTasksForSection: t => {
                            if (null === t) return n.filter((e => !s.includes(e)));
                            const a = P(t),
                                o = _(t),
                                r = e.filter((e => {
                                    if (e.isGranteePending) {
                                        if (a) return e.isGTMLinkActive;
                                        if (o) return e.granteeEmail === t
                                    }
                                    return e.grantee.id === t || e.granter.id === t
                                })).map((e => e.task.id));
                            return s.filter((e => r.includes(e.id)))
                        },
                        justEndedTasks: o,
                        endedTasksStates: l,
                        isShowingThePast: d,
                        shouldRenderSection: e => null === e.root || 0 < e.items.length
                    });
                return Object.assign({}, c, {
                    isShowingThePast: d,
                    toggleShowThePast: h,
                    taskGroups: p,
                    sortedTasks: g
                })
            })))((e => {
                const {
                    singleTasks: t,
                    tasks: s,
                    tasksWithoutProject: n,
                    taskGroups: o,
                    isShowingThePast: r,
                    setEndedTasksState: i,
                    toggleShowThePast: m,
                    currentTeam: h,
                    sortedTasks: g,
                    filterState: f,
                    setFilterState: b
                } = e, v = a.Hooks.useIntl(), w = a.Hooks.useModalState(), {
                    newTaskFormProps: x,
                    newTaskFormVisibility: j
                } = (0, u.G8)({
                    defaultProject: t,
                    taskGroups: o,
                    rootRecord: t
                }), T = o.find((e => null === e.root));
                invariant(T, "Missing single tasks group");
                const S = a.Hooks.useDnd((() => ({
                        setNewTaskFormPosition: x.setPositionGroup,
                        selector: e => e.projectPosition,
                        updater: (e, t) => {
                            e.projectPosition = t
                        },
                        updatePosition: async (e, t) => {
                            await e.do.updateProjectPosition(t)
                        },
                        getDroppedSection: () => ({
                            items: T.items
                        })
                    }))),
                    P = (0, u.Or)(c.routeToTaskListTask),
                    _ = (0, d.W$)(o, t),
                    {
                        stats: C,
                        renderStatsModal: R
                    } = (0, d.bB)({
                        root: t,
                        tasks: a.React.useMemo((() => a.FP.unique([...s, ...n])), [s, n]),
                        taskGroups: o,
                        filterState: f
                    }),
                    A = (0, p.x)(g, v.f.EO);
                return (0, y.jsx)(d.MV, {
                    counters: _,
                    children: (0, y.jsx)(d.aq, {
                        stats: C,
                        children: (0, y.jsx)(l.Z, {
                            rootRecord: t,
                            title: v.f.EO,
                            color: "singleTasks",
                            leftIcon: "ƒ",
                            onDragEnd: S.onDragEnd,
                            taskDetailsProps: P,
                            activeTasksCounter: h.singleAndGrantedTasksCounter,
                            openViewMenu: w.open,
                            menuTarget: w.target,
                            sortedTasks: g,
                            filterState: f,
                            setFilterState: b,
                            newTaskFormVisibility: j,
                            newTaskFormProps: x,
                            children: (0, y.jsxs)(y.Fragment, {
                                children: [(0, y.jsx)(k, {
                                    singleTasks: t,
                                    renderSectionHeader: O(e, _),
                                    taskGroups: o,
                                    onSetEndedTasksState: i,
                                    newTaskFormProps: x,
                                    isDndEnabled: !f.sort,
                                    filterState: f
                                }), w.isOpen ? (0, y.jsx)(E, {
                                    singleTasks: t,
                                    isShowingThePast: r,
                                    onToggleThePast: m,
                                    closeMenu: w.close,
                                    target: w.target,
                                    saveToCSV: A
                                }) : null, R()]
                            })
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n, a = s(0),
            o = s(1);
        const r = a.ReactUtils.lazy((() => s(1384))),
            i = a.Hocs.compose()((() => {
                const {
                    isLimitedAccount: e
                } = a.Hooks.useIdentity();
                return e ? n || (n = (0, o.jsx)(r, {})) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => u
        });
        var n = s(0),
            a = s(216),
            o = s(37),
            r = s(179),
            i = s(92),
            c = s(939),
            l = s(1);
        const d = n.ReactUtils.lazy((() => s(104))),
            u = n.Hocs.compose()((() => {
                const e = n.Hooks.useIntl(),
                    t = n.Hooks.useServices(),
                    {
                        currentMember: s,
                        currentUser: u
                    } = n.Hooks.useIdentity(),
                    [m, h, p] = n.Hooks.useLoadingState({
                        status: "loading",
                        result: void 0
                    }),
                    g = n.Hooks.useModalState();
                n.Hooks.useAsyncEffect((async e => {
                    h();
                    try {
                        const s = await t.api.account.checkEmailAvailability({
                            email: u.myEmail
                        });
                        e.isPending() && p(s.isAvailable ? void 0 : u.myEmail)
                    } catch (t) {
                        e.isPending() && p(void 0)
                    }
                }), [t.api, s]);
                const f = n.Hooks.useAsyncState(),
                    b = n.Hooks.useAsyncFetcher(f, (async () => {
                        const s = await t.localStorage.get(o.d.taskInvitationId);
                        invariant(s, "Expected invitationId to be available when upgrading account");
                        const r = await t.keychain.apiToken;
                        invariant(r, "Expected API token to be available when upgrading account");
                        const i = await n.Rx.takeFirst(t.modelRoot.currentUser);
                        invariant(i, "Expected current user to be available when upgrading account"), await t.sync.synchronize(), await (0, a.Z)({
                            services: t,
                            intl: e,
                            shouldPushHistory: !1,
                            onLoggedOut: () => {
                                (0, c.T)({
                                    services: t,
                                    invitationId: s,
                                    apiToken: r,
                                    user: i,
                                    shouldOpenLogin: !0
                                })
                            }
                        })
                    })),
                    y = !!m.result;
                return (0, l.jsxs)(l.Fragment, {
                    children: [(0, l.jsx)(r.Z, {
                        text: y ? e.f.EK : e.f.EJ,
                        color: "purple",
                        right: (0, l.jsx)(i.Z, {
                            color: "purple",
                            label: y ? e.f.i4 : e.f.h,
                            onPress: async () => {
                                y ? await b() : t.uiState.accountUpgradeModal.open()
                            }
                        })
                    }), !y && (0, l.jsx)(r.Z, {
                        text: e.f.EL,
                        color: "purple",
                        right: (0, l.jsx)(i.Z, {
                            color: "purple",
                            label: e.f.jz,
                            onPress: g.open
                        })
                    }), g.isOpen && (0, l.jsx)(d, {
                        onClose: g.close,
                        onConfirm: (e, t) => (async e => {
                            await u.do.rename(e)
                        })(t),
                        currentValue: u.name,
                        title: e.f.jy,
                        description: e.f.EL,
                        placeholder: e.f.jz,
                        confirmButtonLabel: e.f.fY,
                        maxLength: n.Model.MaxLengths.users.name,
                        level: 100
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(32),
            o = s(84),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                isViewShowingThePast: t,
                isSectionShowingThePast: s,
                section: i,
                toggleSectionShowingThePast: c,
                closeMenu: l,
                target: d
            } = e;
            n.React.useEffect((() => {
                t && l()
            }));
            const [{
                closeAnimated: u
            }, m] = (0, a.XH)();
            return (0, r.jsx)(a.ZP, {
                ref: m,
                onClose: l,
                target: d,
                minWidth: 320,
                children: (0, r.jsx)(o.Z, {
                    isShowingThePast: s,
                    onPress: n.ReactUtils.callBoth(u, c),
                    onPressExtraParam: i
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => p
        });
        var n, a, o = s(0),
            r = s(32),
            i = s(66),
            c = s(84),
            l = s(47),
            d = s(940),
            u = s(316),
            m = s(854),
            h = s(1);
        const p = o.Hocs.compose(o.Hocs.memo, o.Hocs.withObservables(["singleTasks"], (({
            singleTasks: e
        }) => ({
            team: e.currentTeam
        }))))((e => {
            var t;
            const {
                singleTasks: s,
                target: p,
                isShowingThePast: g,
                onToggleThePast: f,
                closeMenu: b,
                team: y,
                saveToCSV: v
            } = e, w = o.Hooks.useIntl(), k = (0, i.Bd)(), [{
                closeAnimated: x
            }, j] = (0, r.XH)(), [T, S] = o.Hooks.useStateMachine("menu"), {
                renderEmailToNozbeListItem: P,
                renderEmailToNozbeMenu: _,
                renderEmailToNozbeConfirm: C,
                isEmailToNozbeOpen: R
            } = (0, u.BK)({
                team: y,
                next: S,
                onClose: b,
                strings: (0, m.I)(w),
                getRecordName: () => o.Styling.getProjectName(s, w)
            });
            return T.map({
                menu: () => (0, h.jsxs)(r.ZP, {
                    ref: j,
                    onClose: b,
                    target: p,
                    children: [t || (t = (0, h.jsx)(d.Z, {
                        project: s
                    })), n || (n = (0, h.jsx)(r.ZP.Separator, {})), (0, h.jsx)(c.Z, {
                        isShowingThePast: g,
                        onPress: o.ReactUtils.callBoth(x, f)
                    }), k(x), (0, h.jsx)(l.Z, {
                        onPress: o.ReactUtils.callBoth(x, v)
                    }), a || (a = (0, h.jsx)(r.ZP.Separator, {})), P(), R ? _() : null]
                }),
                email_to_nozbe_menu: _,
                email_to_nozbe_confirm: C
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            ALL_WEEKDAYS: () => n,
            Frequency: () => q,
            RRule: () => ze,
            RRuleSet: () => Ye,
            Weekday: () => a,
            datetime: () => y,
            rrulestr: () => Ge
        });
        var n = ["MO", "TU", "WE", "TH", "FR", "SA", "SU"],
            a = function() {
                function e(e, t) {
                    if (0 === t) throw new Error("Can't create weekday with n == 0");
                    this.weekday = e, this.n = t
                }
                return e.fromStr = function(t) {
                    return new e(n.indexOf(t))
                }, e.prototype.nth = function(t) {
                    return this.n === t ? this : new e(this.weekday, t)
                }, e.prototype.equals = function(e) {
                    return this.weekday === e.weekday && this.n === e.n
                }, e.prototype.toString = function() {
                    var e = n[this.weekday];
                    return this.n && (e = (this.n > 0 ? "+" : "") + String(this.n) + e), e
                }, e.prototype.getJsWeekday = function() {
                    return 6 === this.weekday ? 0 : this.weekday + 1
                }, e
            }(),
            o = function(e) {
                return null != e
            },
            r = function(e) {
                return "number" == typeof e
            },
            i = function(e) {
                return "string" == typeof e && n.includes(e)
            },
            c = Array.isArray,
            l = function(e, t) {
                void 0 === t && (t = e), 1 === arguments.length && (t = e, e = 0);
                for (var s = [], n = e; n < t; n++) s.push(n);
                return s
            },
            d = function(e, t) {
                var s = 0,
                    n = [];
                if (c(e))
                    for (; s < t; s++) n[s] = [].concat(e);
                else
                    for (; s < t; s++) n[s] = e;
                return n
            };

        function u(e, t, s) {
            void 0 === s && (s = " ");
            var n = String(e);
            return t >>= 0, n.length > t ? String(n) : ((t -= n.length) > s.length && (s += d(s, t / s.length)), s.slice(0, t) + String(n))
        }
        var m = function(e, t, s) {
                var n = e.split(t);
                return s ? n.slice(0, s).concat([n.slice(s).join(t)]) : n
            },
            h = function(e, t) {
                var s = e % t;
                return s * t < 0 ? s + t : s
            },
            p = function(e, t) {
                return {
                    div: Math.floor(e / t),
                    mod: h(e, t)
                }
            },
            g = function(e) {
                return !o(e) || 0 === e.length
            },
            f = function(e) {
                return !g(e)
            },
            b = function(e, t) {
                return f(e) && -1 !== e.indexOf(t)
            },
            y = function(e, t, s, n, a, o) {
                return void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 === o && (o = 0), new Date(Date.UTC(e, t - 1, s, n, a, o))
            },
            v = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
            w = 864e5,
            k = 9999,
            x = y(1970, 1, 1),
            j = [6, 0, 1, 2, 3, 4, 5],
            T = function(e) {
                return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
            },
            S = function(e) {
                return e instanceof Date
            },
            P = function(e) {
                return S(e) && !isNaN(e.getTime())
            },
            _ = function(e) {
                return t = x, s = e.getTime() - t.getTime(), Math.round(s / w);
                var t, s
            },
            C = function(e) {
                return new Date(x.getTime() + e * w)
            },
            R = function(e) {
                var t = e.getUTCMonth();
                return 1 === t && T(e.getUTCFullYear()) ? 29 : v[t]
            },
            A = function(e) {
                return j[e.getUTCDay()]
            },
            I = function(e, t) {
                var s = y(e, t + 1, 1);
                return [A(s), R(s)]
            },
            N = function(e, t) {
                return t = t || e, new Date(Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()))
            },
            E = function(e) {
                return new Date(e.getTime())
            },
            O = function(e) {
                for (var t = [], s = 0; s < e.length; s++) t.push(E(e[s]));
                return t
            },
            M = function(e) {
                e.sort((function(e, t) {
                    return e.getTime() - t.getTime()
                }))
            },
            D = function(e, t) {
                void 0 === t && (t = !0);
                var s = new Date(e);
                return [u(s.getUTCFullYear().toString(), 4, "0"), u(s.getUTCMonth() + 1, 2, "0"), u(s.getUTCDate(), 2, "0"), "T", u(s.getUTCHours(), 2, "0"), u(s.getUTCMinutes(), 2, "0"), u(s.getUTCSeconds(), 2, "0"), t ? "Z" : ""].join("")
            },
            H = function(e) {
                var t = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/.exec(e);
                if (!t) throw new Error("Invalid UNTIL value: ".concat(e));
                return new Date(Date.UTC(parseInt(t[1], 10), parseInt(t[2], 10) - 1, parseInt(t[3], 10), parseInt(t[5], 10) || 0, parseInt(t[6], 10) || 0, parseInt(t[7], 10) || 0))
            },
            F = function(e, t) {
                return e.toLocaleString("sv-SE", {
                    timeZone: t
                }).replace(" ", "T") + "Z"
            };
        const Z = function() {
            function e(e, t) {
                this.minDate = null, this.maxDate = null, this._result = [], this.total = 0, this.method = e, this.args = t, "between" === e ? (this.maxDate = t.inc ? t.before : new Date(t.before.getTime() - 1), this.minDate = t.inc ? t.after : new Date(t.after.getTime() + 1)) : "before" === e ? this.maxDate = t.inc ? t.dt : new Date(t.dt.getTime() - 1) : "after" === e && (this.minDate = t.inc ? t.dt : new Date(t.dt.getTime() + 1))
            }
            return e.prototype.accept = function(e) {
                ++this.total;
                var t = this.minDate && e < this.minDate,
                    s = this.maxDate && e > this.maxDate;
                if ("between" === this.method) {
                    if (t) return !0;
                    if (s) return !1
                } else if ("before" === this.method) {
                    if (s) return !1
                } else if ("after" === this.method) return !!t || (this.add(e), !1);
                return this.add(e)
            }, e.prototype.add = function(e) {
                return this._result.push(e), !0
            }, e.prototype.getValue = function() {
                var e = this._result;
                switch (this.method) {
                    case "all":
                    case "between":
                        return e;
                    default:
                        return e.length ? e[e.length - 1] : null
                }
            }, e.prototype.clone = function() {
                return new e(this.method, this.args)
            }, e
        }();
        var L = s(27);
        const B = function(e) {
            function t(t, s, n) {
                var a = e.call(this, t, s) || this;
                return a.iterator = n, a
            }
            return (0, L.ZT)(t, e), t.prototype.add = function(e) {
                return !!this.iterator(e, this._result.length) && (this._result.push(e), !0)
            }, t
        }(Z);
        const z = {
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            tokens: {
                SKIP: /^[ \r\n\t]+|^\.$/,
                number: /^[1-9][0-9]*/,
                numberAsText: /^(one|two|three)/i,
                every: /^every/i,
                "day(s)": /^days?/i,
                "weekday(s)": /^weekdays?/i,
                "week(s)": /^weeks?/i,
                "hour(s)": /^hours?/i,
                "minute(s)": /^minutes?/i,
                "month(s)": /^months?/i,
                "year(s)": /^years?/i,
                on: /^(on|in)/i,
                at: /^(at)/i,
                the: /^the/i,
                first: /^first/i,
                second: /^second/i,
                third: /^third/i,
                nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
                last: /^last/i,
                for: /^for/i,
                "time(s)": /^times?/i,
                until: /^(un)?til/i,
                monday: /^mo(n(day)?)?/i,
                tuesday: /^tu(e(s(day)?)?)?/i,
                wednesday: /^we(d(n(esday)?)?)?/i,
                thursday: /^th(u(r(sday)?)?)?/i,
                friday: /^fr(i(day)?)?/i,
                saturday: /^sa(t(urday)?)?/i,
                sunday: /^su(n(day)?)?/i,
                january: /^jan(uary)?/i,
                february: /^feb(ruary)?/i,
                march: /^mar(ch)?/i,
                april: /^apr(il)?/i,
                may: /^may/i,
                june: /^june?/i,
                july: /^july?/i,
                august: /^aug(ust)?/i,
                september: /^sep(t(ember)?)?/i,
                october: /^oct(ober)?/i,
                november: /^nov(ember)?/i,
                december: /^dec(ember)?/i,
                comma: /^(,\s*|(and|or)\s*)+/i
            }
        };
        var U = function(e, t) {
                return -1 !== e.indexOf(t)
            },
            W = function(e) {
                return e.toString()
            },
            G = function(e, t, s) {
                return "".concat(t, " ").concat(s, ", ").concat(e)
            };
        const V = function() {
            function e(e, t, s, n) {
                if (void 0 === t && (t = W), void 0 === s && (s = z), void 0 === n && (n = G), this.text = [], this.language = s || z, this.gettext = t, this.dateFormatter = n, this.rrule = e, this.options = e.options, this.origOptions = e.origOptions, this.origOptions.bymonthday) {
                    var a = [].concat(this.options.bymonthday),
                        r = [].concat(this.options.bynmonthday);
                    a.sort((function(e, t) {
                        return e - t
                    })), r.sort((function(e, t) {
                        return t - e
                    })), this.bymonthday = a.concat(r), this.bymonthday.length || (this.bymonthday = null)
                }
                if (o(this.origOptions.byweekday)) {
                    var i = c(this.origOptions.byweekday) ? this.origOptions.byweekday : [this.origOptions.byweekday],
                        l = String(i);
                    this.byweekday = {
                        allWeeks: i.filter((function(e) {
                            return !e.n
                        })),
                        someWeeks: i.filter((function(e) {
                            return Boolean(e.n)
                        })),
                        isWeekdays: -1 !== l.indexOf("MO") && -1 !== l.indexOf("TU") && -1 !== l.indexOf("WE") && -1 !== l.indexOf("TH") && -1 !== l.indexOf("FR") && -1 === l.indexOf("SA") && -1 === l.indexOf("SU"),
                        isEveryDay: -1 !== l.indexOf("MO") && -1 !== l.indexOf("TU") && -1 !== l.indexOf("WE") && -1 !== l.indexOf("TH") && -1 !== l.indexOf("FR") && -1 !== l.indexOf("SA") && -1 !== l.indexOf("SU")
                    };
                    var d = function(e, t) {
                        return e.weekday - t.weekday
                    };
                    this.byweekday.allWeeks.sort(d), this.byweekday.someWeeks.sort(d), this.byweekday.allWeeks.length || (this.byweekday.allWeeks = null), this.byweekday.someWeeks.length || (this.byweekday.someWeeks = null)
                } else this.byweekday = null
            }
            return e.isFullyConvertible = function(t) {
                if (!(t.options.freq in e.IMPLEMENTED)) return !1;
                if (t.origOptions.until && t.origOptions.count) return !1;
                for (var s in t.origOptions) {
                    if (U(["dtstart", "tzid", "wkst", "freq"], s)) return !0;
                    if (!U(e.IMPLEMENTED[t.options.freq], s)) return !1
                }
                return !0
            }, e.prototype.isFullyConvertible = function() {
                return e.isFullyConvertible(this.rrule)
            }, e.prototype.toString = function() {
                var t = this.gettext;
                if (!(this.options.freq in e.IMPLEMENTED)) return t("RRule error: Unable to fully convert this rrule to text");
                if (this.text = [t("every")], this[ze.FREQUENCIES[this.options.freq]](), this.options.until) {
                    this.add(t("until"));
                    var s = this.options.until;
                    this.add(this.dateFormatter(s.getUTCFullYear(), this.language.monthNames[s.getUTCMonth()], s.getUTCDate()))
                } else this.options.count && this.add(t("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? t("times") : t("time"));
                return this.isFullyConvertible() || this.add(t("(~ approximate)")), this.text.join("")
            }, e.prototype.HOURLY = function() {
                var e = this.gettext;
                1 !== this.options.interval && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("hours") : e("hour"))
            }, e.prototype.MINUTELY = function() {
                var e = this.gettext;
                1 !== this.options.interval && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("minutes") : e("minute"))
            }, e.prototype.DAILY = function() {
                var e = this.gettext;
                1 !== this.options.interval && this.add(this.options.interval.toString()), this.byweekday && this.byweekday.isWeekdays ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(this.plural(this.options.interval) ? e("days") : e("day")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday ? this._byweekday() : this.origOptions.byhour && this._byhour()
            }, e.prototype.WEEKLY = function() {
                var e = this.gettext;
                1 !== this.options.interval && this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? e("weeks") : e("week")), this.byweekday && this.byweekday.isWeekdays ? 1 === this.options.interval ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(e("on")).add(e("weekdays")) : this.byweekday && this.byweekday.isEveryDay ? this.add(this.plural(this.options.interval) ? e("days") : e("day")) : (1 === this.options.interval && this.add(e("week")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday(), this.origOptions.byhour && this._byhour())
            }, e.prototype.MONTHLY = function() {
                var e = this.gettext;
                this.origOptions.bymonth ? (1 !== this.options.interval && (this.add(this.options.interval.toString()).add(e("months")), this.plural(this.options.interval) && this.add(e("in"))), this._bymonth()) : (1 !== this.options.interval && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("months") : e("month"))), this.bymonthday ? this._bymonthday() : this.byweekday && this.byweekday.isWeekdays ? this.add(e("on")).add(e("weekdays")) : this.byweekday && this._byweekday()
            }, e.prototype.YEARLY = function() {
                var e = this.gettext;
                this.origOptions.bymonth ? (1 !== this.options.interval && (this.add(this.options.interval.toString()), this.add(e("years"))), this._bymonth()) : (1 !== this.options.interval && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("years") : e("year"))), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday(), this.options.byyearday && this.add(e("on the")).add(this.list(this.options.byyearday, this.nth, e("and"))).add(e("day")), this.options.byweekno && this.add(e("in")).add(this.plural(this.options.byweekno.length) ? e("weeks") : e("week")).add(this.list(this.options.byweekno, void 0, e("and")))
            }, e.prototype._bymonthday = function() {
                var e = this.gettext;
                this.byweekday && this.byweekday.allWeeks ? this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, e("or"))).add(e("the")).add(this.list(this.bymonthday, this.nth, e("or"))) : this.add(e("on the")).add(this.list(this.bymonthday, this.nth, e("and")))
            }, e.prototype._byweekday = function() {
                var e = this.gettext;
                this.byweekday.allWeeks && !this.byweekday.isWeekdays && this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext)), this.byweekday.someWeeks && (this.byweekday.allWeeks && this.add(e("and")), this.add(e("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, e("and"))))
            }, e.prototype._byhour = function() {
                var e = this.gettext;
                this.add(e("at")).add(this.list(this.origOptions.byhour, void 0, e("and")))
            }, e.prototype._bymonth = function() {
                this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")))
            }, e.prototype.nth = function(e) {
                var t;
                e = parseInt(e.toString(), 10);
                var s = this.gettext;
                if (-1 === e) return s("last");
                var n = Math.abs(e);
                switch (n) {
                    case 1:
                    case 21:
                    case 31:
                        t = n + s("st");
                        break;
                    case 2:
                    case 22:
                        t = n + s("nd");
                        break;
                    case 3:
                    case 23:
                        t = n + s("rd");
                        break;
                    default:
                        t = n + s("th")
                }
                return e < 0 ? t + " " + s("last") : t
            }, e.prototype.monthtext = function(e) {
                return this.language.monthNames[e - 1]
            }, e.prototype.weekdaytext = function(e) {
                var t = r(e) ? (e + 1) % 7 : e.getJsWeekday();
                return (e.n ? this.nth(e.n) + " " : "") + this.language.dayNames[t]
            }, e.prototype.plural = function(e) {
                return e % 100 != 1
            }, e.prototype.add = function(e) {
                return this.text.push(" "), this.text.push(e), this
            }, e.prototype.list = function(e, t, s, n) {
                var a = this;
                void 0 === n && (n = ","), c(e) || (e = [e]);
                t = t || function(e) {
                    return e.toString()
                };
                var o = function(e) {
                    return t && t.call(a, e)
                };
                return s ? function(e, t, s) {
                    for (var n = "", a = 0; a < e.length; a++) 0 !== a && (a === e.length - 1 ? n += " " + s + " " : n += t + " "), n += e[a];
                    return n
                }(e.map(o), n, s) : e.map(o).join(n + " ")
            }, e
        }();
        var q, Q = function() {
            function e(e) {
                this.done = !0, this.rules = e
            }
            return e.prototype.start = function(e) {
                return this.text = e, this.done = !1, this.nextSymbol()
            }, e.prototype.isDone = function() {
                return this.done && null === this.symbol
            }, e.prototype.nextSymbol = function() {
                var e, t;
                this.symbol = null, this.value = null;
                do {
                    if (this.done) return !1;
                    for (var s in e = null, this.rules) {
                        var n = this.rules[s].exec(this.text);
                        n && (null === e || n[0].length > e[0].length) && (e = n, t = s)
                    }
                    if (null != e && (this.text = this.text.substr(e[0].length), "" === this.text && (this.done = !0)), null == e) return this.done = !0, this.symbol = null, void(this.value = null)
                } while ("SKIP" === t);
                return this.symbol = t, this.value = e, !0
            }, e.prototype.accept = function(e) {
                if (this.symbol === e) {
                    if (this.value) {
                        var t = this.value;
                        return this.nextSymbol(), t
                    }
                    return this.nextSymbol(), !0
                }
                return !1
            }, e.prototype.acceptNumber = function() {
                return this.accept("number")
            }, e.prototype.expect = function(e) {
                if (this.accept(e)) return !0;
                throw new Error("expected " + e + " but found " + this.symbol)
            }, e
        }();

        function Y(e, t) {
            void 0 === t && (t = z);
            var s = {},
                n = new Q(t.tokens);
            return n.start(e) ? (function() {
                n.expect("every");
                var e = n.acceptNumber();
                e && (s.interval = parseInt(e[0], 10));
                if (n.isDone()) throw new Error("Unexpected end");
                switch (n.symbol) {
                    case "day(s)":
                        s.freq = ze.DAILY, n.nextSymbol() && (o(), l());
                        break;
                    case "weekday(s)":
                        s.freq = ze.WEEKLY, s.byweekday = [ze.MO, ze.TU, ze.WE, ze.TH, ze.FR], n.nextSymbol(), o(), l();
                        break;
                    case "week(s)":
                        s.freq = ze.WEEKLY, n.nextSymbol() && (a(), o(), l());
                        break;
                    case "hour(s)":
                        s.freq = ze.HOURLY, n.nextSymbol() && (a(), l());
                        break;
                    case "minute(s)":
                        s.freq = ze.MINUTELY, n.nextSymbol() && (a(), l());
                        break;
                    case "month(s)":
                        s.freq = ze.MONTHLY, n.nextSymbol() && (a(), l());
                        break;
                    case "year(s)":
                        s.freq = ze.YEARLY, n.nextSymbol() && (a(), l());
                        break;
                    case "monday":
                    case "tuesday":
                    case "wednesday":
                    case "thursday":
                    case "friday":
                    case "saturday":
                    case "sunday":
                        s.freq = ze.WEEKLY;
                        var t = n.symbol.substr(0, 2).toUpperCase();
                        if (s.byweekday = [ze[t]], !n.nextSymbol()) return;
                        for (; n.accept("comma");) {
                            if (n.isDone()) throw new Error("Unexpected end");
                            var d = i();
                            if (!d) throw new Error("Unexpected symbol " + n.symbol + ", expected weekday");
                            s.byweekday.push(ze[d]), n.nextSymbol()
                        }
                        o(),
                            function() {
                                n.accept("on"), n.accept("the");
                                var e = c();
                                if (!e) return;
                                s.bymonthday = [e], n.nextSymbol();
                                for (; n.accept("comma");) {
                                    if (!(e = c())) throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
                                    s.bymonthday.push(e), n.nextSymbol()
                                }
                            }(), l();
                        break;
                    case "january":
                    case "february":
                    case "march":
                    case "april":
                    case "may":
                    case "june":
                    case "july":
                    case "august":
                    case "september":
                    case "october":
                    case "november":
                    case "december":
                        if (s.freq = ze.YEARLY, s.bymonth = [r()], !n.nextSymbol()) return;
                        for (; n.accept("comma");) {
                            if (n.isDone()) throw new Error("Unexpected end");
                            var u = r();
                            if (!u) throw new Error("Unexpected symbol " + n.symbol + ", expected month");
                            s.bymonth.push(u), n.nextSymbol()
                        }
                        a(), l();
                        break;
                    default:
                        throw new Error("Unknown symbol")
                }
            }(), s) : null;

            function a() {
                var e = n.accept("on"),
                    t = n.accept("the");
                if (e || t)
                    do {
                        var a = c(),
                            o = i(),
                            l = r();
                        if (a) o ? (n.nextSymbol(), s.byweekday || (s.byweekday = []), s.byweekday.push(ze[o].nth(a))) : (s.bymonthday || (s.bymonthday = []), s.bymonthday.push(a), n.accept("day(s)"));
                        else if (o) n.nextSymbol(), s.byweekday || (s.byweekday = []), s.byweekday.push(ze[o]);
                        else if ("weekday(s)" === n.symbol) n.nextSymbol(), s.byweekday || (s.byweekday = [ze.MO, ze.TU, ze.WE, ze.TH, ze.FR]);
                        else if ("week(s)" === n.symbol) {
                            n.nextSymbol();
                            var d = n.acceptNumber();
                            if (!d) throw new Error("Unexpected symbol " + n.symbol + ", expected week number");
                            for (s.byweekno = [parseInt(d[0], 10)]; n.accept("comma");) {
                                if (!(d = n.acceptNumber())) throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
                                s.byweekno.push(parseInt(d[0], 10))
                            }
                        } else {
                            if (!l) return;
                            n.nextSymbol(), s.bymonth || (s.bymonth = []), s.bymonth.push(l)
                        }
                    } while (n.accept("comma") || n.accept("the") || n.accept("on"))
            }

            function o() {
                if (n.accept("at"))
                    do {
                        var e = n.acceptNumber();
                        if (!e) throw new Error("Unexpected symbol " + n.symbol + ", expected hour");
                        for (s.byhour = [parseInt(e[0], 10)]; n.accept("comma");) {
                            if (!(e = n.acceptNumber())) throw new Error("Unexpected symbol " + n.symbol + "; expected hour");
                            s.byhour.push(parseInt(e[0], 10))
                        }
                    } while (n.accept("comma") || n.accept("at"))
            }

            function r() {
                switch (n.symbol) {
                    case "january":
                        return 1;
                    case "february":
                        return 2;
                    case "march":
                        return 3;
                    case "april":
                        return 4;
                    case "may":
                        return 5;
                    case "june":
                        return 6;
                    case "july":
                        return 7;
                    case "august":
                        return 8;
                    case "september":
                        return 9;
                    case "october":
                        return 10;
                    case "november":
                        return 11;
                    case "december":
                        return 12;
                    default:
                        return !1
                }
            }

            function i() {
                switch (n.symbol) {
                    case "monday":
                    case "tuesday":
                    case "wednesday":
                    case "thursday":
                    case "friday":
                    case "saturday":
                    case "sunday":
                        return n.symbol.substr(0, 2).toUpperCase();
                    default:
                        return !1
                }
            }

            function c() {
                switch (n.symbol) {
                    case "last":
                        return n.nextSymbol(), -1;
                    case "first":
                        return n.nextSymbol(), 1;
                    case "second":
                        return n.nextSymbol(), n.accept("last") ? -2 : 2;
                    case "third":
                        return n.nextSymbol(), n.accept("last") ? -3 : 3;
                    case "nth":
                        var e = parseInt(n.value[1], 10);
                        if (e < -366 || e > 366) throw new Error("Nth out of range: " + e);
                        return n.nextSymbol(), n.accept("last") ? -e : e;
                    default:
                        return !1
                }
            }

            function l() {
                if ("until" === n.symbol) {
                    var e = Date.parse(n.text);
                    if (!e) throw new Error("Cannot parse until date:" + n.text);
                    s.until = new Date(e)
                } else n.accept("for") && (s.count = parseInt(n.value[0], 10), n.expect("number"))
            }
        }

        function J(e) {
            return e < q.HOURLY
        }! function(e) {
            e[e.YEARLY = 0] = "YEARLY", e[e.MONTHLY = 1] = "MONTHLY", e[e.WEEKLY = 2] = "WEEKLY", e[e.DAILY = 3] = "DAILY", e[e.HOURLY = 4] = "HOURLY", e[e.MINUTELY = 5] = "MINUTELY", e[e.SECONDLY = 6] = "SECONDLY"
        }(q || (q = {}));
        var K = function(e, t) {
                return void 0 === t && (t = z), new ze(Y(e, t) || void 0)
            },
            $ = ["count", "until", "interval", "byweekday", "bymonthday", "bymonth"];
        V.IMPLEMENTED = [], V.IMPLEMENTED[q.HOURLY] = $, V.IMPLEMENTED[q.MINUTELY] = $, V.IMPLEMENTED[q.DAILY] = ["byhour"].concat($), V.IMPLEMENTED[q.WEEKLY] = $, V.IMPLEMENTED[q.MONTHLY] = $, V.IMPLEMENTED[q.YEARLY] = ["byweekno", "byyearday"].concat($);
        var X = V.isFullyConvertible,
            ee = function() {
                function e(e, t, s, n) {
                    this.hour = e, this.minute = t, this.second = s, this.millisecond = n || 0
                }
                return e.prototype.getHours = function() {
                    return this.hour
                }, e.prototype.getMinutes = function() {
                    return this.minute
                }, e.prototype.getSeconds = function() {
                    return this.second
                }, e.prototype.getMilliseconds = function() {
                    return this.millisecond
                }, e.prototype.getTime = function() {
                    return 1e3 * (60 * this.hour * 60 + 60 * this.minute + this.second) + this.millisecond
                }, e
            }(),
            te = function(e) {
                function t(t, s, n, a, o, r, i) {
                    var c = e.call(this, a, o, r, i) || this;
                    return c.year = t, c.month = s, c.day = n, c
                }
                return (0, L.ZT)(t, e), t.fromDate = function(e) {
                    return new this(e.getUTCFullYear(), e.getUTCMonth() + 1, e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.valueOf() % 1e3)
                }, t.prototype.getWeekday = function() {
                    return A(new Date(this.getTime()))
                }, t.prototype.getTime = function() {
                    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime()
                }, t.prototype.getDay = function() {
                    return this.day
                }, t.prototype.getMonth = function() {
                    return this.month
                }, t.prototype.getYear = function() {
                    return this.year
                }, t.prototype.addYears = function(e) {
                    this.year += e
                }, t.prototype.addMonths = function(e) {
                    if (this.month += e, this.month > 12) {
                        var t = Math.floor(this.month / 12),
                            s = h(this.month, 12);
                        this.month = s, this.year += t, 0 === this.month && (this.month = 12, --this.year)
                    }
                }, t.prototype.addWeekly = function(e, t) {
                    t > this.getWeekday() ? this.day += -(this.getWeekday() + 1 + (6 - t)) + 7 * e : this.day += -(this.getWeekday() - t) + 7 * e, this.fixDay()
                }, t.prototype.addDaily = function(e) {
                    this.day += e, this.fixDay()
                }, t.prototype.addHours = function(e, t, s) {
                    for (t && (this.hour += Math.floor((23 - this.hour) / e) * e);;) {
                        this.hour += e;
                        var n = p(this.hour, 24),
                            a = n.div,
                            o = n.mod;
                        if (a && (this.hour = o, this.addDaily(a)), g(s) || b(s, this.hour)) break
                    }
                }, t.prototype.addMinutes = function(e, t, s, n) {
                    for (t && (this.minute += Math.floor((1439 - (60 * this.hour + this.minute)) / e) * e);;) {
                        this.minute += e;
                        var a = p(this.minute, 60),
                            o = a.div,
                            r = a.mod;
                        if (o && (this.minute = r, this.addHours(o, !1, s)), (g(s) || b(s, this.hour)) && (g(n) || b(n, this.minute))) break
                    }
                }, t.prototype.addSeconds = function(e, t, s, n, a) {
                    for (t && (this.second += Math.floor((86399 - (3600 * this.hour + 60 * this.minute + this.second)) / e) * e);;) {
                        this.second += e;
                        var o = p(this.second, 60),
                            r = o.div,
                            i = o.mod;
                        if (r && (this.second = i, this.addMinutes(r, !1, s, n)), (g(s) || b(s, this.hour)) && (g(n) || b(n, this.minute)) && (g(a) || b(a, this.second))) break
                    }
                }, t.prototype.fixDay = function() {
                    if (!(this.day <= 28)) {
                        var e = I(this.year, this.month - 1)[1];
                        if (!(this.day <= e))
                            for (; this.day > e;) {
                                if (this.day -= e, ++this.month, 13 === this.month && (this.month = 1, ++this.year, this.year > k)) return;
                                e = I(this.year, this.month - 1)[1]
                            }
                    }
                }, t.prototype.add = function(e, t) {
                    var s = e.freq,
                        n = e.interval,
                        a = e.wkst,
                        o = e.byhour,
                        r = e.byminute,
                        i = e.bysecond;
                    switch (s) {
                        case q.YEARLY:
                            return this.addYears(n);
                        case q.MONTHLY:
                            return this.addMonths(n);
                        case q.WEEKLY:
                            return this.addWeekly(n, a);
                        case q.DAILY:
                            return this.addDaily(n);
                        case q.HOURLY:
                            return this.addHours(n, t, o);
                        case q.MINUTELY:
                            return this.addMinutes(n, t, o, r);
                        case q.SECONDLY:
                            return this.addSeconds(n, t, o, r, i)
                    }
                }, t
            }(ee);

        function se(e) {
            for (var t = [], s = 0, n = Object.keys(e); s < n.length; s++) {
                var a = n[s];
                b(Be, a) || t.push(a), S(e[a]) && !P(e[a]) && t.push(a)
            }
            if (t.length) throw new Error("Invalid options: " + t.join(", "));
            return (0, L.pi)({}, e)
        }

        function ne(e) {
            var t = (0, L.pi)((0, L.pi)({}, Le), se(e));
            if (o(t.byeaster) && (t.freq = ze.YEARLY), !o(t.freq) || !ze.FREQUENCIES[t.freq]) throw new Error("Invalid frequency: ".concat(t.freq, " ").concat(e.freq));
            if (t.dtstart || (t.dtstart = new Date((new Date).setMilliseconds(0))), o(t.wkst) ? r(t.wkst) || (t.wkst = t.wkst.weekday) : t.wkst = ze.MO.weekday, o(t.bysetpos)) {
                r(t.bysetpos) && (t.bysetpos = [t.bysetpos]);
                for (var s = 0; s < t.bysetpos.length; s++) {
                    if (0 === (d = t.bysetpos[s]) || !(d >= -366 && d <= 366)) throw new Error("bysetpos must be between 1 and 366, or between -366 and -1")
                }
            }
            if (!(Boolean(t.byweekno) || f(t.byweekno) || f(t.byyearday) || Boolean(t.bymonthday) || f(t.bymonthday) || o(t.byweekday) || o(t.byeaster))) switch (t.freq) {
                case ze.YEARLY:
                    t.bymonth || (t.bymonth = t.dtstart.getUTCMonth() + 1), t.bymonthday = t.dtstart.getUTCDate();
                    break;
                case ze.MONTHLY:
                    t.bymonthday = t.dtstart.getUTCDate();
                    break;
                case ze.WEEKLY:
                    t.byweekday = [A(t.dtstart)]
            }
            if (o(t.bymonth) && !c(t.bymonth) && (t.bymonth = [t.bymonth]), o(t.byyearday) && !c(t.byyearday) && r(t.byyearday) && (t.byyearday = [t.byyearday]), o(t.bymonthday))
                if (c(t.bymonthday)) {
                    var n = [],
                        l = [];
                    for (s = 0; s < t.bymonthday.length; s++) {
                        var d;
                        (d = t.bymonthday[s]) > 0 ? n.push(d) : d < 0 && l.push(d)
                    }
                    t.bymonthday = n, t.bynmonthday = l
                } else t.bymonthday < 0 ? (t.bynmonthday = [t.bymonthday], t.bymonthday = []) : (t.bynmonthday = [], t.bymonthday = [t.bymonthday]);
            else t.bymonthday = [], t.bynmonthday = [];
            if (o(t.byweekno) && !c(t.byweekno) && (t.byweekno = [t.byweekno]), o(t.byweekday))
                if (r(t.byweekday)) t.byweekday = [t.byweekday], t.bynweekday = null;
                else if (i(t.byweekday)) t.byweekday = [a.fromStr(t.byweekday).weekday], t.bynweekday = null;
            else if (t.byweekday instanceof a) !t.byweekday.n || t.freq > ze.MONTHLY ? (t.byweekday = [t.byweekday.weekday], t.bynweekday = null) : (t.bynweekday = [
                [t.byweekday.weekday, t.byweekday.n]
            ], t.byweekday = null);
            else {
                var u = [],
                    m = [];
                for (s = 0; s < t.byweekday.length; s++) {
                    var h = t.byweekday[s];
                    r(h) ? u.push(h) : i(h) ? u.push(a.fromStr(h).weekday) : !h.n || t.freq > ze.MONTHLY ? u.push(h.weekday) : m.push([h.weekday, h.n])
                }
                t.byweekday = f(u) ? u : null, t.bynweekday = f(m) ? m : null
            } else t.bynweekday = null;
            return o(t.byhour) ? r(t.byhour) && (t.byhour = [t.byhour]) : t.byhour = t.freq < ze.HOURLY ? [t.dtstart.getUTCHours()] : null, o(t.byminute) ? r(t.byminute) && (t.byminute = [t.byminute]) : t.byminute = t.freq < ze.MINUTELY ? [t.dtstart.getUTCMinutes()] : null, o(t.bysecond) ? r(t.bysecond) && (t.bysecond = [t.bysecond]) : t.bysecond = t.freq < ze.SECONDLY ? [t.dtstart.getUTCSeconds()] : null, {
                parsedOptions: t
            }
        }

        function ae(e) {
            var t = e.split("\n").map(re).filter((function(e) {
                return null !== e
            }));
            return (0, L.pi)((0, L.pi)({}, t[0]), t[1])
        }

        function oe(e) {
            var t = {},
                s = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(e);
            if (!s) return t;
            var n = s[1],
                a = s[2];
            return n && (t.tzid = n), t.dtstart = H(a), t
        }

        function re(e) {
            if (!(e = e.replace(/^\s+|\s+$/, "")).length) return null;
            var t = /^([A-Z]+?)[:;]/.exec(e.toUpperCase());
            if (!t) return ie(e);
            var s = t[1];
            switch (s.toUpperCase()) {
                case "RRULE":
                case "EXRULE":
                    return ie(e);
                case "DTSTART":
                    return oe(e);
                default:
                    throw new Error("Unsupported RFC prop ".concat(s, " in ").concat(e))
            }
        }

        function ie(e) {
            var t = oe(e.replace(/^RRULE:/i, ""));
            return e.replace(/^(?:RRULE|EXRULE):/i, "").split(";").forEach((function(s) {
                var n = s.split("="),
                    o = n[0],
                    r = n[1];
                switch (o.toUpperCase()) {
                    case "FREQ":
                        t.freq = q[r.toUpperCase()];
                        break;
                    case "WKST":
                        t.wkst = Ze[r.toUpperCase()];
                        break;
                    case "COUNT":
                    case "INTERVAL":
                    case "BYSETPOS":
                    case "BYMONTH":
                    case "BYMONTHDAY":
                    case "BYYEARDAY":
                    case "BYWEEKNO":
                    case "BYHOUR":
                    case "BYMINUTE":
                    case "BYSECOND":
                        var i = function(e) {
                                if (-1 !== e.indexOf(",")) {
                                    return e.split(",").map(ce)
                                }
                                return ce(e)
                            }(r),
                            c = o.toLowerCase();
                        t[c] = i;
                        break;
                    case "BYWEEKDAY":
                    case "BYDAY":
                        t.byweekday = function(e) {
                            var t = e.split(",");
                            return t.map((function(e) {
                                if (2 === e.length) return Ze[e];
                                var t = e.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
                                if (!t || t.length < 3) throw new SyntaxError("Invalid weekday string: ".concat(e));
                                var s = Number(t[1]),
                                    n = t[2],
                                    o = Ze[n].weekday;
                                return new a(o, s)
                            }))
                        }(r);
                        break;
                    case "DTSTART":
                    case "TZID":
                        var l = oe(e);
                        t.tzid = l.tzid, t.dtstart = l.dtstart;
                        break;
                    case "UNTIL":
                        t.until = H(r);
                        break;
                    case "BYEASTER":
                        t.byeaster = Number(r);
                        break;
                    default:
                        throw new Error("Unknown RRULE property '" + o + "'")
                }
            })), t
        }

        function ce(e) {
            return /^[+-]?\d+$/.test(e) ? Number(e) : e
        }
        var le = function() {
            function e(e, t) {
                if (isNaN(e.getTime())) throw new RangeError("Invalid date passed to DateWithZone");
                this.date = e, this.tzid = t
            }
            return Object.defineProperty(e.prototype, "isUTC", {
                get: function() {
                    return !this.tzid || "UTC" === this.tzid.toUpperCase()
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.toString = function() {
                var e = D(this.date.getTime(), this.isUTC);
                return this.isUTC ? ":".concat(e) : ";TZID=".concat(this.tzid, ":").concat(e)
            }, e.prototype.getTime = function() {
                return this.date.getTime()
            }, e.prototype.rezonedDate = function() {
                return this.isUTC ? this.date : function(e, t) {
                    var s = Intl.DateTimeFormat().resolvedOptions().timeZone,
                        n = new Date(F(e, s)),
                        a = new Date(F(e, null != t ? t : "UTC")).getTime() - n.getTime();
                    return new Date(e.getTime() - a)
                }(this.date, this.tzid)
            }, e
        }();

        function de(e) {
            for (var t, s = [], n = "", i = Object.keys(e), l = Object.keys(Le), d = 0; d < i.length; d++)
                if ("tzid" !== i[d] && b(l, i[d])) {
                    var u = i[d].toUpperCase(),
                        m = e[i[d]],
                        h = "";
                    if (o(m) && (!c(m) || m.length)) {
                        switch (u) {
                            case "FREQ":
                                h = ze.FREQUENCIES[e.freq];
                                break;
                            case "WKST":
                                h = r(m) ? new a(m).toString() : m.toString();
                                break;
                            case "BYWEEKDAY":
                                u = "BYDAY", h = (t = m, c(t) ? t : [t]).map((function(e) {
                                    return e instanceof a ? e : c(e) ? new a(e[0], e[1]) : new a(e)
                                })).toString();
                                break;
                            case "DTSTART":
                                n = ue(m, e.tzid);
                                break;
                            case "UNTIL":
                                h = D(m, !e.tzid);
                                break;
                            default:
                                if (c(m)) {
                                    for (var p = [], g = 0; g < m.length; g++) p[g] = String(m[g]);
                                    h = p.toString()
                                } else h = String(m)
                        }
                        h && s.push([u, h])
                    }
                } var f = s.map((function(e) {
                    var t = e[0],
                        s = e[1];
                    return "".concat(t, "=").concat(s.toString())
                })).join(";"),
                y = "";
            return "" !== f && (y = "RRULE:".concat(f)), [n, y].filter((function(e) {
                return !!e
            })).join("\n")
        }

        function ue(e, t) {
            return e ? "DTSTART" + new le(new Date(e), t).toString() : ""
        }

        function me(e, t) {
            return Array.isArray(e) ? !!Array.isArray(t) && (e.length === t.length && e.every((function(e, s) {
                return e.getTime() === t[s].getTime()
            }))) : e instanceof Date ? t instanceof Date && e.getTime() === t.getTime() : e === t
        }
        var he = function() {
                function e() {
                    this.all = !1, this.before = [], this.after = [], this.between = []
                }
                return e.prototype._cacheAdd = function(e, t, s) {
                    t && (t = t instanceof Date ? E(t) : O(t)), "all" === e ? this.all = t : (s._value = t, this[e].push(s))
                }, e.prototype._cacheGet = function(e, t) {
                    var s = !1,
                        n = t ? Object.keys(t) : [],
                        a = function(e) {
                            for (var s = 0; s < n.length; s++) {
                                var a = n[s];
                                if (!me(t[a], e[a])) return !0
                            }
                            return !1
                        },
                        o = this[e];
                    if ("all" === e) s = this.all;
                    else if (c(o))
                        for (var r = 0; r < o.length; r++) {
                            var i = o[r];
                            if (!n.length || !a(i)) {
                                s = i._value;
                                break
                            }
                        }
                    if (!s && this.all) {
                        var l = new Z(e, t);
                        for (r = 0; r < this.all.length && l.accept(this.all[r]); r++);
                        s = l.getValue(), this._cacheAdd(e, s, t)
                    }
                    return c(s) ? O(s) : s instanceof Date ? E(s) : s
                }, e
            }(),
            pe = (0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)([], d(1, 31), !0), d(2, 28), !0), d(3, 31), !0), d(4, 30), !0), d(5, 31), !0), d(6, 30), !0), d(7, 31), !0), d(8, 31), !0), d(9, 30), !0), d(10, 31), !0), d(11, 30), !0), d(12, 31), !0), d(1, 7), !0),
            ge = (0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)([], d(1, 31), !0), d(2, 29), !0), d(3, 31), !0), d(4, 30), !0), d(5, 31), !0), d(6, 30), !0), d(7, 31), !0), d(8, 31), !0), d(9, 30), !0), d(10, 31), !0), d(11, 30), !0), d(12, 31), !0), d(1, 7), !0),
            fe = l(1, 29),
            be = l(1, 30),
            ye = l(1, 31),
            ve = l(1, 32),
            we = (0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)([], ve, !0), be, !0), ve, !0), ye, !0), ve, !0), ye, !0), ve, !0), ve, !0), ye, !0), ve, !0), ye, !0), ve, !0), ve.slice(0, 7), !0),
            ke = (0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)([], ve, !0), fe, !0), ve, !0), ye, !0), ve, !0), ye, !0), ve, !0), ve, !0), ye, !0), ve, !0), ye, !0), ve, !0), ve.slice(0, 7), !0),
            xe = l(-28, 0),
            je = l(-29, 0),
            Te = l(-30, 0),
            Se = l(-31, 0),
            Pe = (0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)([], Se, !0), je, !0), Se, !0), Te, !0), Se, !0), Te, !0), Se, !0), Se, !0), Te, !0), Se, !0), Te, !0), Se, !0), Se.slice(0, 7), !0),
            _e = (0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)((0, L.ev)([], Se, !0), xe, !0), Se, !0), Te, !0), Se, !0), Te, !0), Se, !0), Se, !0), Te, !0), Se, !0), Te, !0), Se, !0), Se.slice(0, 7), !0),
            Ce = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366],
            Re = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
            Ae = function() {
                for (var e = [], t = 0; t < 55; t++) e = e.concat(l(7));
                return e
            }();

        function Ie(e, t) {
            var s, n, a = y(e, 1, 1),
                o = T(e) ? 366 : 365,
                r = T(e + 1) ? 366 : 365,
                i = _(a),
                c = A(a),
                l = (0, L.pi)((0, L.pi)({
                    yearlen: o,
                    nextyearlen: r,
                    yearordinal: i,
                    yearweekday: c
                }, function(e) {
                    var t = T(e) ? 366 : 365,
                        s = y(e, 1, 1),
                        n = A(s);
                    if (365 === t) return {
                        mmask: pe,
                        mdaymask: ke,
                        nmdaymask: _e,
                        wdaymask: Ae.slice(n),
                        mrange: Re
                    };
                    return {
                        mmask: ge,
                        mdaymask: we,
                        nmdaymask: Pe,
                        wdaymask: Ae.slice(n),
                        mrange: Ce
                    }
                }(e)), {
                    wnomask: null
                });
            if (g(t.byweekno)) return l;
            l.wnomask = d(0, o + 7);
            var u = s = h(7 - c + t.wkst, 7);
            u >= 4 ? (u = 0, n = l.yearlen + h(c - t.wkst, 7)) : n = o - u;
            for (var m = Math.floor(n / 7), p = h(n, 7), f = Math.floor(m + p / 4), v = 0; v < t.byweekno.length; v++) {
                var w = t.byweekno[v];
                if (w < 0 && (w += f + 1), w > 0 && w <= f) {
                    var k = void 0;
                    w > 1 ? (k = u + 7 * (w - 1), u !== s && (k -= 7 - s)) : k = u;
                    for (var x = 0; x < 7 && (l.wnomask[k] = 1, k++, l.wdaymask[k] !== t.wkst); x++);
                }
            }
            if (b(t.byweekno, 1)) {
                k = u + 7 * f;
                if (u !== s && (k -= 7 - s), k < o)
                    for (v = 0; v < 7 && (l.wnomask[k] = 1, k += 1, l.wdaymask[k] !== t.wkst); v++);
            }
            if (u) {
                var j = void 0;
                if (b(t.byweekno, -1)) j = -1;
                else {
                    var S = A(y(e - 1, 1, 1)),
                        P = h(7 - S.valueOf() + t.wkst, 7),
                        C = T(e - 1) ? 366 : 365,
                        R = void 0;
                    P >= 4 ? (P = 0, R = C + h(S - t.wkst, 7)) : R = o - u, j = Math.floor(52 + h(R, 7) / 4)
                }
                if (b(t.byweekno, j))
                    for (k = 0; k < u; k++) l.wnomask[k] = 1
            }
            return l
        }
        const Ne = function() {
            function e(e) {
                this.options = e
            }
            return e.prototype.rebuild = function(e, t) {
                var s = this.options;
                if (e !== this.lastyear && (this.yearinfo = Ie(e, s)), f(s.bynweekday) && (t !== this.lastmonth || e !== this.lastyear)) {
                    var n = this.yearinfo,
                        a = n.yearlen,
                        r = n.mrange,
                        i = n.wdaymask;
                    this.monthinfo = function(e, t, s, n, a, o) {
                        var r = {
                                lastyear: e,
                                lastmonth: t,
                                nwdaymask: []
                            },
                            i = [];
                        if (o.freq === ze.YEARLY)
                            if (g(o.bymonth)) i = [
                                [0, s]
                            ];
                            else
                                for (var c = 0; c < o.bymonth.length; c++) t = o.bymonth[c], i.push(n.slice(t - 1, t + 1));
                        else o.freq === ze.MONTHLY && (i = [n.slice(t - 1, t + 1)]);
                        if (g(i)) return r;
                        for (r.nwdaymask = d(0, s), c = 0; c < i.length; c++)
                            for (var l = i[c], u = l[0], m = l[1] - 1, p = 0; p < o.bynweekday.length; p++) {
                                var f = void 0,
                                    b = o.bynweekday[p],
                                    y = b[0],
                                    v = b[1];
                                v < 0 ? (f = m + 7 * (v + 1), f -= h(a[f] - y, 7)) : (f = u + 7 * (v - 1), f += h(7 - a[f] + y, 7)), u <= f && f <= m && (r.nwdaymask[f] = 1)
                            }
                        return r
                    }(e, t, a, r, i, s)
                }
                o(s.byeaster) && (this.eastermask = function(e, t) {
                    void 0 === t && (t = 0);
                    var s = e % 19,
                        n = Math.floor(e / 100),
                        a = e % 100,
                        o = Math.floor(n / 4),
                        r = n % 4,
                        i = Math.floor((n + 8) / 25),
                        c = Math.floor((n - i + 1) / 3),
                        l = Math.floor(19 * s + n - o - c + 15) % 30,
                        d = Math.floor(a / 4),
                        u = a % 4,
                        m = Math.floor(32 + 2 * r + 2 * d - l - u) % 7,
                        h = Math.floor((s + 11 * l + 22 * m) / 451),
                        p = Math.floor((l + m - 7 * h + 114) / 31),
                        g = (l + m - 7 * h + 114) % 31 + 1,
                        f = Date.UTC(e, p - 1, g + t),
                        b = Date.UTC(e, 0, 1);
                    return [Math.ceil((f - b) / 864e5)]
                }(e, s.byeaster))
            }, Object.defineProperty(e.prototype, "lastyear", {
                get: function() {
                    return this.monthinfo ? this.monthinfo.lastyear : null
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "lastmonth", {
                get: function() {
                    return this.monthinfo ? this.monthinfo.lastmonth : null
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "yearlen", {
                get: function() {
                    return this.yearinfo.yearlen
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "yearordinal", {
                get: function() {
                    return this.yearinfo.yearordinal
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "mrange", {
                get: function() {
                    return this.yearinfo.mrange
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "wdaymask", {
                get: function() {
                    return this.yearinfo.wdaymask
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "mmask", {
                get: function() {
                    return this.yearinfo.mmask
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "wnomask", {
                get: function() {
                    return this.yearinfo.wnomask
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "nwdaymask", {
                get: function() {
                    return this.monthinfo ? this.monthinfo.nwdaymask : []
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "nextyearlen", {
                get: function() {
                    return this.yearinfo.nextyearlen
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "mdaymask", {
                get: function() {
                    return this.yearinfo.mdaymask
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(e.prototype, "nmdaymask", {
                get: function() {
                    return this.yearinfo.nmdaymask
                },
                enumerable: !1,
                configurable: !0
            }), e.prototype.ydayset = function() {
                return [l(this.yearlen), 0, this.yearlen]
            }, e.prototype.mdayset = function(e, t) {
                for (var s = this.mrange[t - 1], n = this.mrange[t], a = d(null, this.yearlen), o = s; o < n; o++) a[o] = o;
                return [a, s, n]
            }, e.prototype.wdayset = function(e, t, s) {
                for (var n = d(null, this.yearlen + 7), a = _(y(e, t, s)) - this.yearordinal, o = a, r = 0; r < 7 && (n[a] = a, ++a, this.wdaymask[a] !== this.options.wkst); r++);
                return [n, o, a]
            }, e.prototype.ddayset = function(e, t, s) {
                var n = d(null, this.yearlen),
                    a = _(y(e, t, s)) - this.yearordinal;
                return n[a] = a, [n, a, a + 1]
            }, e.prototype.htimeset = function(e, t, s, n) {
                var a = this,
                    o = [];
                return this.options.byminute.forEach((function(t) {
                    o = o.concat(a.mtimeset(e, t, s, n))
                })), M(o), o
            }, e.prototype.mtimeset = function(e, t, s, n) {
                var a = this.options.bysecond.map((function(s) {
                    return new ee(e, t, s, n)
                }));
                return M(a), a
            }, e.prototype.stimeset = function(e, t, s, n) {
                return [new ee(e, t, s, n)]
            }, e.prototype.getdayset = function(e) {
                switch (e) {
                    case q.YEARLY:
                        return this.ydayset.bind(this);
                    case q.MONTHLY:
                        return this.mdayset.bind(this);
                    case q.WEEKLY:
                        return this.wdayset.bind(this);
                    case q.DAILY:
                    default:
                        return this.ddayset.bind(this)
                }
            }, e.prototype.gettimeset = function(e) {
                switch (e) {
                    case q.HOURLY:
                        return this.htimeset.bind(this);
                    case q.MINUTELY:
                        return this.mtimeset.bind(this);
                    case q.SECONDLY:
                        return this.stimeset.bind(this)
                }
            }, e
        }();

        function Ee(e, t, s, n, a, r) {
            for (var i = [], c = 0; c < e.length; c++) {
                var l = void 0,
                    d = void 0,
                    u = e[c];
                u < 0 ? (l = Math.floor(u / t.length), d = h(u, t.length)) : (l = Math.floor((u - 1) / t.length), d = h(u - 1, t.length));
                for (var m = [], p = s; p < n; p++) {
                    var g = r[p];
                    o(g) && m.push(g)
                }
                var f = void 0;
                f = l < 0 ? m.slice(l)[0] : m[l];
                var y = t[d],
                    v = C(a.yearordinal + f),
                    w = N(v, y);
                b(i, w) || i.push(w)
            }
            return M(i), i
        }

        function Oe(e, t) {
            var s = t.dtstart,
                n = t.freq,
                a = t.interval,
                r = t.until,
                i = t.bysetpos,
                c = t.count;
            if (0 === c || 0 === a) return He(e);
            var l = te.fromDate(s),
                d = new Ne(t);
            d.rebuild(l.year, l.month);
            for (var u = function(e, t, s) {
                    var n = s.freq,
                        a = s.byhour,
                        o = s.byminute,
                        r = s.bysecond;
                    if (J(n)) return function(e) {
                        var t = e.dtstart.getTime() % 1e3;
                        if (!J(e.freq)) return [];
                        var s = [];
                        return e.byhour.forEach((function(n) {
                            e.byminute.forEach((function(a) {
                                e.bysecond.forEach((function(e) {
                                    s.push(new ee(n, a, e, t))
                                }))
                            }))
                        })), s
                    }(s);
                    if (n >= ze.HOURLY && f(a) && !b(a, t.hour) || n >= ze.MINUTELY && f(o) && !b(o, t.minute) || n >= ze.SECONDLY && f(r) && !b(r, t.second)) return [];
                    return e.gettimeset(n)(t.hour, t.minute, t.second, t.millisecond)
                }(d, l, t);;) {
                var m = d.getdayset(n)(l.year, l.month, l.day),
                    h = m[0],
                    p = m[1],
                    g = m[2],
                    y = Fe(h, p, g, d, t);
                if (f(i))
                    for (var v = Ee(i, u, p, g, d, h), w = 0; w < v.length; w++) {
                        var x = v[w];
                        if (r && x > r) return He(e);
                        if (x >= s) {
                            var j = De(x, t);
                            if (!e.accept(j)) return He(e);
                            if (c && !--c) return He(e)
                        }
                    } else
                        for (w = p; w < g; w++) {
                            var T = h[w];
                            if (o(T))
                                for (var S = C(d.yearordinal + T), P = 0; P < u.length; P++) {
                                    var _ = u[P];
                                    x = N(S, _);
                                    if (r && x > r) return He(e);
                                    if (x >= s) {
                                        j = De(x, t);
                                        if (!e.accept(j)) return He(e);
                                        if (c && !--c) return He(e)
                                    }
                                }
                        }
                if (0 === t.interval) return He(e);
                if (l.add(t, y), l.year > k) return He(e);
                J(n) || (u = d.gettimeset(n)(l.hour, l.minute, l.second, 0)), d.rebuild(l.year, l.month)
            }
        }

        function Me(e, t, s) {
            var n = s.bymonth,
                a = s.byweekno,
                o = s.byweekday,
                r = s.byeaster,
                i = s.bymonthday,
                c = s.bynmonthday,
                l = s.byyearday;
            return f(n) && !b(n, e.mmask[t]) || f(a) && !e.wnomask[t] || f(o) && !b(o, e.wdaymask[t]) || f(e.nwdaymask) && !e.nwdaymask[t] || null !== r && !b(e.eastermask, t) || (f(i) || f(c)) && !b(i, e.mdaymask[t]) && !b(c, e.nmdaymask[t]) || f(l) && (t < e.yearlen && !b(l, t + 1) && !b(l, -e.yearlen + t) || t >= e.yearlen && !b(l, t + 1 - e.yearlen) && !b(l, -e.nextyearlen + t - e.yearlen))
        }

        function De(e, t) {
            return new le(e, t.tzid).rezonedDate()
        }

        function He(e) {
            return e.getValue()
        }

        function Fe(e, t, s, n, a) {
            for (var o = !1, r = t; r < s; r++) {
                var i = e[r];
                (o = Me(n, i, a)) && (e[i] = null)
            }
            return o
        }
        var Ze = {
                MO: new a(0),
                TU: new a(1),
                WE: new a(2),
                TH: new a(3),
                FR: new a(4),
                SA: new a(5),
                SU: new a(6)
            },
            Le = {
                freq: q.YEARLY,
                dtstart: null,
                interval: 1,
                wkst: Ze.MO,
                count: null,
                until: null,
                tzid: null,
                bysetpos: null,
                bymonth: null,
                bymonthday: null,
                bynmonthday: null,
                byyearday: null,
                byweekno: null,
                byweekday: null,
                bynweekday: null,
                byhour: null,
                byminute: null,
                bysecond: null,
                byeaster: null
            },
            Be = Object.keys(Le),
            ze = function() {
                function e(e, t) {
                    void 0 === e && (e = {}), void 0 === t && (t = !1), this._cache = t ? null : new he, this.origOptions = se(e);
                    var s = ne(e).parsedOptions;
                    this.options = s
                }
                return e.parseText = function(e, t) {
                    return Y(e, t)
                }, e.fromText = function(e, t) {
                    return K(e, t)
                }, e.fromString = function(t) {
                    return new e(e.parseString(t) || void 0)
                }, e.prototype._iter = function(e) {
                    return Oe(e, this.options)
                }, e.prototype._cacheGet = function(e, t) {
                    return !!this._cache && this._cache._cacheGet(e, t)
                }, e.prototype._cacheAdd = function(e, t, s) {
                    if (this._cache) return this._cache._cacheAdd(e, t, s)
                }, e.prototype.all = function(e) {
                    if (e) return this._iter(new B("all", {}, e));
                    var t = this._cacheGet("all");
                    return !1 === t && (t = this._iter(new Z("all", {})), this._cacheAdd("all", t)), t
                }, e.prototype.between = function(e, t, s, n) {
                    if (void 0 === s && (s = !1), !P(e) || !P(t)) throw new Error("Invalid date passed in to RRule.between");
                    var a = {
                        before: t,
                        after: e,
                        inc: s
                    };
                    if (n) return this._iter(new B("between", a, n));
                    var o = this._cacheGet("between", a);
                    return !1 === o && (o = this._iter(new Z("between", a)), this._cacheAdd("between", o, a)), o
                }, e.prototype.before = function(e, t) {
                    if (void 0 === t && (t = !1), !P(e)) throw new Error("Invalid date passed in to RRule.before");
                    var s = {
                            dt: e,
                            inc: t
                        },
                        n = this._cacheGet("before", s);
                    return !1 === n && (n = this._iter(new Z("before", s)), this._cacheAdd("before", n, s)), n
                }, e.prototype.after = function(e, t) {
                    if (void 0 === t && (t = !1), !P(e)) throw new Error("Invalid date passed in to RRule.after");
                    var s = {
                            dt: e,
                            inc: t
                        },
                        n = this._cacheGet("after", s);
                    return !1 === n && (n = this._iter(new Z("after", s)), this._cacheAdd("after", n, s)), n
                }, e.prototype.count = function() {
                    return this.all().length
                }, e.prototype.toString = function() {
                    return de(this.origOptions)
                }, e.prototype.toText = function(e, t, s) {
                    return function(e, t, s, n) {
                        return new V(e, t, s, n).toString()
                    }(this, e, t, s)
                }, e.prototype.isFullyConvertibleToText = function() {
                    return X(this)
                }, e.prototype.clone = function() {
                    return new e(this.origOptions)
                }, e.FREQUENCIES = ["YEARLY", "MONTHLY", "WEEKLY", "DAILY", "HOURLY", "MINUTELY", "SECONDLY"], e.YEARLY = q.YEARLY, e.MONTHLY = q.MONTHLY, e.WEEKLY = q.WEEKLY, e.DAILY = q.DAILY, e.HOURLY = q.HOURLY, e.MINUTELY = q.MINUTELY, e.SECONDLY = q.SECONDLY, e.MO = Ze.MO, e.TU = Ze.TU, e.WE = Ze.WE, e.TH = Ze.TH, e.FR = Ze.FR, e.SA = Ze.SA, e.SU = Ze.SU, e.parseString = ae, e.optionsToString = de, e
            }();
        var Ue = {
            dtstart: null,
            cache: !1,
            unfold: !1,
            forceset: !1,
            compatible: !1,
            tzid: null
        };

        function We(e, t) {
            var s = [],
                n = [],
                a = [],
                o = [],
                r = oe(e),
                i = r.dtstart,
                c = r.tzid,
                l = function(e, t) {
                    void 0 === t && (t = !1);
                    if (e = e && e.trim(), !e) throw new Error("Invalid empty string");
                    if (!t) return e.split(/\s/);
                    var s = e.split("\n"),
                        n = 0;
                    for (; n < s.length;) {
                        var a = s[n] = s[n].replace(/\s+$/g, "");
                        a ? n > 0 && " " === a[0] ? (s[n - 1] += a.slice(1), s.splice(n, 1)) : n += 1 : s.splice(n, 1)
                    }
                    return s
                }(e, t.unfold);
            return l.forEach((function(e) {
                var t;
                if (e) {
                    var r = function(e) {
                            var t = function(e) {
                                    if (-1 === e.indexOf(":")) return {
                                        name: "RRULE",
                                        value: e
                                    };
                                    var t = m(e, ":", 1),
                                        s = t[0],
                                        n = t[1];
                                    return {
                                        name: s,
                                        value: n
                                    }
                                }(e),
                                s = t.name,
                                n = t.value,
                                a = s.split(";");
                            if (!a) throw new Error("empty property name");
                            return {
                                name: a[0].toUpperCase(),
                                parms: a.slice(1),
                                value: n
                            }
                        }(e),
                        i = r.name,
                        l = r.parms,
                        d = r.value;
                    switch (i.toUpperCase()) {
                        case "RRULE":
                            if (l.length) throw new Error("unsupported RRULE parm: ".concat(l.join(",")));
                            s.push(ae(e));
                            break;
                        case "RDATE":
                            var u = (null !== (t = /RDATE(?:;TZID=([^:=]+))?/i.exec(e)) && void 0 !== t ? t : [])[1];
                            u && !c && (c = u), n = n.concat(qe(d, l));
                            break;
                        case "EXRULE":
                            if (l.length) throw new Error("unsupported EXRULE parm: ".concat(l.join(",")));
                            a.push(ae(d));
                            break;
                        case "EXDATE":
                            o = o.concat(qe(d, l));
                            break;
                        case "DTSTART":
                            break;
                        default:
                            throw new Error("unsupported property: " + i)
                    }
                }
            })), {
                dtstart: i,
                tzid: c,
                rrulevals: s,
                rdatevals: n,
                exrulevals: a,
                exdatevals: o
            }
        }

        function Ge(e, t) {
            return void 0 === t && (t = {}),
                function(e, t) {
                    var s = We(e, t),
                        n = s.rrulevals,
                        a = s.rdatevals,
                        o = s.exrulevals,
                        r = s.exdatevals,
                        i = s.dtstart,
                        c = s.tzid,
                        l = !1 === t.cache;
                    if (t.compatible && (t.forceset = !0, t.unfold = !0), t.forceset || n.length > 1 || a.length || o.length || r.length) {
                        var d = new Ye(l);
                        return d.dtstart(i), d.tzid(c || void 0), n.forEach((function(e) {
                            d.rrule(new ze(Ve(e, i, c), l))
                        })), a.forEach((function(e) {
                            d.rdate(e)
                        })), o.forEach((function(e) {
                            d.exrule(new ze(Ve(e, i, c), l))
                        })), r.forEach((function(e) {
                            d.exdate(e)
                        })), t.compatible && t.dtstart && d.rdate(i), d
                    }
                    var u = n[0] || {};
                    return new ze(Ve(u, u.dtstart || t.dtstart || i, u.tzid || t.tzid || c), l)
                }(e, function(e) {
                    var t = [],
                        s = Object.keys(e),
                        n = Object.keys(Ue);
                    if (s.forEach((function(e) {
                            b(n, e) || t.push(e)
                        })), t.length) throw new Error("Invalid options: " + t.join(", "));
                    return (0, L.pi)((0, L.pi)({}, Ue), e)
                }(t))
        }

        function Ve(e, t, s) {
            return (0, L.pi)((0, L.pi)({}, e), {
                dtstart: t,
                tzid: s
            })
        }

        function qe(e, t) {
            return function(e) {
                e.forEach((function(e) {
                    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(e)) throw new Error("unsupported RDATE/EXDATE parm: " + e)
                }))
            }(t), e.split(",").map((function(e) {
                return H(e)
            }))
        }

        function Qe(e) {
            var t = this;
            return function(s) {
                if (void 0 !== s && (t["_".concat(e)] = s), void 0 !== t["_".concat(e)]) return t["_".concat(e)];
                for (var n = 0; n < t._rrule.length; n++) {
                    var a = t._rrule[n].origOptions[e];
                    if (a) return a
                }
            }
        }
        var Ye = function(e) {
            function t(t) {
                void 0 === t && (t = !1);
                var s = e.call(this, {}, t) || this;
                return s.dtstart = Qe.apply(s, ["dtstart"]), s.tzid = Qe.apply(s, ["tzid"]), s._rrule = [], s._rdate = [], s._exrule = [], s._exdate = [], s
            }
            return (0, L.ZT)(t, e), t.prototype._iter = function(e) {
                return function(e, t, s, n, a, o) {
                    var r = {},
                        i = e.accept;

                    function c(e, t) {
                        s.forEach((function(s) {
                            s.between(e, t, !0).forEach((function(e) {
                                r[Number(e)] = !0
                            }))
                        }))
                    }
                    a.forEach((function(e) {
                        var t = new le(e, o).rezonedDate();
                        r[Number(t)] = !0
                    })), e.accept = function(e) {
                        var t = Number(e);
                        return isNaN(t) ? i.call(this, e) : !(!r[t] && (c(new Date(t - 1), new Date(t + 1)), !r[t])) || (r[t] = !0, i.call(this, e))
                    }, "between" === e.method && (c(e.args.after, e.args.before), e.accept = function(e) {
                        var t = Number(e);
                        return !!r[t] || (r[t] = !0, i.call(this, e))
                    });
                    for (var l = 0; l < n.length; l++) {
                        var d = new le(n[l], o).rezonedDate();
                        if (!e.accept(new Date(d.getTime()))) break
                    }
                    t.forEach((function(t) {
                        Oe(e, t.options)
                    }));
                    var u = e._result;
                    switch (M(u), e.method) {
                        case "all":
                        case "between":
                            return u;
                        case "before":
                            return u.length && u[u.length - 1] || null;
                        default:
                            return u.length && u[0] || null
                    }
                }(e, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid())
            }, t.prototype.rrule = function(e) {
                Je(e, this._rrule)
            }, t.prototype.exrule = function(e) {
                Je(e, this._exrule)
            }, t.prototype.rdate = function(e) {
                Ke(e, this._rdate)
            }, t.prototype.exdate = function(e) {
                Ke(e, this._exdate)
            }, t.prototype.rrules = function() {
                return this._rrule.map((function(e) {
                    return Ge(e.toString())
                }))
            }, t.prototype.exrules = function() {
                return this._exrule.map((function(e) {
                    return Ge(e.toString())
                }))
            }, t.prototype.rdates = function() {
                return this._rdate.map((function(e) {
                    return new Date(e.getTime())
                }))
            }, t.prototype.exdates = function() {
                return this._exdate.map((function(e) {
                    return new Date(e.getTime())
                }))
            }, t.prototype.valueOf = function() {
                var e = [];
                return !this._rrule.length && this._dtstart && (e = e.concat(de({
                    dtstart: this._dtstart
                }))), this._rrule.forEach((function(t) {
                    e = e.concat(t.toString().split("\n"))
                })), this._exrule.forEach((function(t) {
                    e = e.concat(t.toString().split("\n").map((function(e) {
                        return e.replace(/^RRULE:/, "EXRULE:")
                    })).filter((function(e) {
                        return !/^DTSTART/.test(e)
                    })))
                })), this._rdate.length && e.push($e("RDATE", this._rdate, this.tzid())), this._exdate.length && e.push($e("EXDATE", this._exdate, this.tzid())), e
            }, t.prototype.toString = function() {
                return this.valueOf().join("\n")
            }, t.prototype.clone = function() {
                var e = new t(!!this._cache);
                return this._rrule.forEach((function(t) {
                    return e.rrule(t.clone())
                })), this._exrule.forEach((function(t) {
                    return e.exrule(t.clone())
                })), this._rdate.forEach((function(t) {
                    return e.rdate(new Date(t.getTime()))
                })), this._exdate.forEach((function(t) {
                    return e.exdate(new Date(t.getTime()))
                })), e
            }, t
        }(ze);

        function Je(e, t) {
            if (!(e instanceof ze)) throw new TypeError(String(e) + " is not RRule instance");
            b(t.map(String), String(e)) || t.push(e)
        }

        function Ke(e, t) {
            if (!(e instanceof Date)) throw new TypeError(String(e) + " is not Date instance");
            b(t.map(Number), Number(e)) || (t.push(e), M(t))
        }

        function $e(e, t, s) {
            var n = !s || "UTC" === s.toUpperCase(),
                a = n ? "".concat(e, ":") : "".concat(e, ";TZID=").concat(s, ":"),
                o = t.map((function(e) {
                    return D(e.valueOf(), n)
                })).join(",");
            return "".concat(a).concat(o)
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(22),
            o = s(97),
            r = s(44),
            i = s(318),
            c = s(1);
        const l = [],
            d = n.Hocs.compose(n.Hocs.withObservables(["counters"], (({
                counters: e
            }) => ({
                counters: n.Rx.wrap(e)
            }))))((e => {
                const {
                    groupRoot: t,
                    onNewTaskFormShow: s,
                    taskGroup: d,
                    isCollapsed: u,
                    counters: m,
                    taskDetailsProps: h,
                    onToggleCollapse: p
                } = e, g = n.Hooks.useIntl(), f = (0, i.c)(t, g.formatDate), b = (0, r.aO)(s, h);
                return (0, c.jsx)(o.Z, {
                    onCollapsePress: p,
                    isCollapsed: u,
                    needsReview: null == d ? void 0 : d.items.some((e => e.doesNeedReview)),
                    hasActivity: null == d ? void 0 : d.items.some((e => e.isUnread)),
                    isCapitalized: !0,
                    right: s ? (0, c.jsx)(a.default, {
                        name: "ū",
                        iconSize: 28,
                        color: "onBackground3",
                        onPress: b,
                        accessibilityLabel: g.f.mJ
                    }) : null,
                    counters: null == m ? void 0 : m.activeTasks,
                    tasks: (null == d ? void 0 : d.items) || l,
                    children: f
                }, "calendar_section-" + t.toString())
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => C
        });
        var n = s(0),
            a = s(92),
            o = s(11),
            r = s(21),
            i = s(144),
            c = s(64),
            l = s(194),
            d = s(280),
            u = s(120),
            m = s(1467),
            h = s(36);
        const {
            vars: p,
            mixins: g,
            zcolor: f,
            rgba: b
        } = h, {
            size: y,
            spacing: v,
            radius: w,
            color: k,
            layer: x,
            fontWeight: j
        } = p, T = s(760);
        var S = s(1);
        const P = s(42).wx,
            _ = [...Array(7).keys()],
            C = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                firstWeekday: n.Rx.from(e.native.fetchFirstWeekday())
            }))))((e => {
                const {
                    selectedDate: t,
                    goToToday: s,
                    goForward: h,
                    goBack: p,
                    setSelectedDate: g,
                    firstWeekday: f,
                    showWeeklyView: b,
                    hasOverdue: y
                } = e, v = n.Hooks.useIntl(), w = n.Hooks.useModalState(), k = (0, i.Z)(t, (0, r.weekStartsOn)(f));
                return (0, S.jsxs)(S.Fragment, {
                    children: [(0, S.jsxs)("div", {
                        className: T.root,
                        children: [(0, S.jsxs)("div", {
                            className: T.top,
                            children: [(0, S.jsx)("div", {
                                className: T.row,
                                ref: w.target,
                                children: (0, S.jsx)(a.Z, {
                                    className: T.button,
                                    label: v.formatDate(t, {
                                        year: "numeric",
                                        month: "long"
                                    }),
                                    onPress: w.open
                                })
                            }), (0, S.jsxs)("div", {
                                className: T.row,
                                children: [(0, S.jsx)(a.Z, {
                                    className: T.button,
                                    size: "tinyPadding",
                                    label: "",
                                    iconName: "š",
                                    onPress: () => {
                                        s(!0)
                                    },
                                    color: y ? "red" : "onBackground2"
                                }), (0, S.jsx)(a.Z, {
                                    className: T.button,
                                    size: "tinyPadding",
                                    label: "",
                                    iconName: "7",
                                    onPress: p
                                }), (0, S.jsx)(a.Z, {
                                    className: T.button,
                                    size: "tinyPadding",
                                    label: "",
                                    iconName: "9",
                                    onPress: h
                                }), (0, S.jsx)(a.Z, {
                                    className: T.button,
                                    label: v.f.gd,
                                    onPress: () => {
                                        s(!1)
                                    }
                                })]
                            })]
                        }), b ? (0, S.jsx)("div", {
                            className: T.row,
                            children: _.map(((e, s) => {
                                const a = (0, c.Z)(k, s),
                                    r = (0, l.Z)(a),
                                    i = (0, d.Z)(a),
                                    h = (0, u.Z)(a, t);
                                return (0, S.jsxs)(o.Z, {
                                    className: T.day,
                                    style: (() => {
                                        const e = h ? {
                                            borderColor: n.Styling.factoryColor("onBackground2")
                                        } : {};
                                        return r ? Object.assign({}, e, {
                                            background: n.Styling.rgba(n.Styling.factoryColor("purple"), .2),
                                            backgroundColor: n.Styling.rgba(n.Styling.factoryColor("purple"), .2)
                                        }) : i ? Object.assign({}, e, {
                                            opacity: .2
                                        }) : h ? e : void 0
                                    })(),
                                    onPress: () => g(a),
                                    children: [(0, S.jsx)("span", {
                                        className: T.dayLabel,
                                        style: r ? {
                                            color: n.Styling.factoryColor("purple")
                                        } : void 0,
                                        children: v.formatDate(a, {
                                            weekday: "short"
                                        })
                                    }), (0, S.jsx)("span", {
                                        className: T.dayNumber,
                                        style: r ? {
                                            color: n.Styling.factoryColor("purple")
                                        } : void 0,
                                        children: (0, m.Z)(a)
                                    })]
                                }, a.getTime())
                            }))
                        }) : null]
                    }), w.isOpen ? (0, S.jsx)(P.Date, {
                        bundle$close: w.close,
                        currentDateTime: r.DateTime.fromLegacyDueDate({
                            date: t,
                            isAllDay: !0
                        }),
                        onConfirm: e => (g(null == e ? void 0 : e.local), {
                            shouldClose: !0
                        }),
                        target: w.target,
                        onClose: w.close,
                        onCancel: w.close
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n, a = s(0),
            o = s(32),
            r = s(20),
            i = s(84),
            c = s(66),
            l = s(47),
            d = s(1);
        const u = s(107).wx,
            m = a.Hocs.compose(a.Hocs.memo)((e => {
                var t;
                const {
                    target: s,
                    closeMenu: m,
                    saveToCSV: h,
                    isShowingThePast: p,
                    onPressShowThePast: g,
                    isShowingWeeklyView: f,
                    onPressChangeTimeframe: b
                } = e, y = a.Hooks.useIntl(), [v, w] = a.Hooks.useStateMachine("menu"), k = (0, c.Bd)(), [{
                    closeAnimated: x
                }, j] = (0, o.XH)();
                return (0, d.jsx)(d.Fragment, {
                    children: v.map({
                        menu: () => (0, d.jsxs)(o.ZP, {
                            ref: j,
                            target: s,
                            onClose: m,
                            children: [(0, d.jsx)(i.Z, {
                                isShowingThePast: p,
                                onPress: a.ReactUtils.callBoth(x, g)
                            }), (0, d.jsx)(r.Z, {
                                icon: "«",
                                label: f ? y.f.ga : y.f.gb,
                                onPress: a.ReactUtils.callBoth(x, b)
                            }), k(x), n || (n = (0, d.jsx)(o.ZP.Separator, {})), (0, d.jsx)(r.Z, {
                                icon: "R",
                                label: y.f.b8,
                                onPress: w("calendars"),
                                hasArrow: !0
                            }), (0, d.jsx)(l.Z, {
                                onPress: a.ReactUtils.callBoth(x, h)
                            })]
                        }),
                        calendars: () => t || (t = (0, d.jsx)(u.CalendarIntegration, {
                            bundle$close: m,
                            onClose: m,
                            target: s
                        }))
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(32),
            o = s(66),
            r = s(84),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                target: t,
                isShowingThePast: s,
                onToggleThePast: c,
                closeMenu: l
            } = e, d = (0, o.Bd)(), [{
                closeAnimated: u
            }, m] = (0, a.XH)();
            return (0, i.jsxs)(a.ZP, {
                ref: m,
                onClose: l,
                target: t,
                children: [(0, i.jsx)(r.Z, {
                    isShowingThePast: s,
                    onPress: n.ReactUtils.callBoth(u, c)
                }), d(u)]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(56),
            o = s(11),
            r = s(71),
            i = s(941);
        s(2), s(3);
        const c = s(764);
        var l = s(1);
        const d = n.Hocs.compose(n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
            currentTeam: e
        }) => ({
            members: e.membersExcludingRequests.observe()
        }))))((e => {
            const {
                members: t,
                currentMember: s,
                currentTeam: d
            } = e, u = n.Hooks.useIntl(), m = t.filter((e => e.id !== s.id && e.isActive)), h = [m.slice(0, 2), m.slice(2, 5), m.slice(5, 7)], p = (0, i.W)(d);
            return (0, l.jsxs)("div", {
                className: c.root,
                children: [(0, l.jsx)("div", {
                    className: c.avatarContainer,
                    children: h.map((e => {
                        var t;
                        return (0, l.jsx)("div", {
                            className: c.avatarRow,
                            children: e.map((e => (0, l.jsx)(r.default, {
                                renderLabel: e.preferredName,
                                children: (0, l.jsx)(o.Z, {
                                    onPress: () => p({
                                        member: e
                                    }),
                                    children: (0, l.jsx)(a.default, {
                                        member: e,
                                        size: "large",
                                        avatarStyle: "message"
                                    })
                                })
                            }, e.id)))
                        }, null == (t = e[0]) ? void 0 : t.id)
                    }))
                }), (0, l.jsx)("span", {
                    className: c.title,
                    children: u.f.rb
                }), (0, l.jsx)("span", {
                    className: c.subtitle,
                    children: u.f.rc
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(32),
            o = s(111),
            r = s(84),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.memo)((e => {
            const {
                target: t,
                closeMenu: s,
                isShowingThePast: c,
                onToggleThePast: l
            } = e, [{
                closeAnimated: d
            }, u] = (0, a.XH)(), m = n.Hooks.useIntl();
            return (0, i.jsxs)(a.ZP, {
                ref: u,
                onClose: s,
                target: t,
                children: [(0, i.jsx)(o.Z, {
                    type: "messages",
                    item: void 0,
                    onPress: d
                }), (0, i.jsx)(r.Z, {
                    label: c ? m.f.re : m.f.rf,
                    isShowingThePast: c,
                    onPress: n.ReactUtils.callBoth(d, l)
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n, a = s(0),
            o = s(12),
            r = s(6),
            i = s(1);
        const c = [{
                iconName: "ø",
                color: "mauve",
                size: 250
            }, {
                iconName: "ù",
                color: "lightpink",
                size: 250
            }, {
                iconName: "ú",
                color: "pedro",
                size: 250
            }, {
                iconName: "û",
                color: "aubergine",
                opacity: .5,
                size: 250
            }],
            l = a.Hocs.compose((0, r.LU)())((() => {
                const e = a.Hooks.useIntl(),
                    {
                        closeAnimated: t
                    } = (0, r.vR)();
                return (0, i.jsxs)(i.Fragment, {
                    children: [(0, i.jsx)(r.u_.Header, {
                        children: e.f.ri
                    }), (0, i.jsxs)(r.u_.Content, {
                        children: [n || (n = (0, i.jsx)(r.u_.IconStack, {
                            stack: c
                        })), (0, i.jsx)(r.u_.Heading, {
                            children: e.f.rh
                        }), (0, i.jsx)(r.u_.Paragraph, {
                            children: e.f.rg
                        }), (0, i.jsx)(r.u_.Buttons, {
                            children: (0, i.jsx)(o.default, {
                                label: e.f.fy,
                                onPress: t,
                                marginTop: "small",
                                color: "darkgreen",
                                variant: "opaque"
                            })
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n = s(0),
            a = s(14),
            o = s(53),
            r = s(13);
        s(2), s(3);
        const i = s(765);
        var c = s(1);
        const l = e => {
            const {
                refTaskId: t
            } = e.match.params, {
                hash: s
            } = e.location;
            n.Hooks.useOnDidLaunch();
            const [l, d] = n.React.useState(!1), u = n.Hooks.useServices(), {
                currentTeam: m
            } = n.Hooks.useIdentity(), h = n.Hooks.useIntl(), p = !u.history.isFirstRoute();
            return n.Hooks.useAsyncEffect((async () => {
                const e = async () => {
                    const e = () => (async (e, t, s) => {
                        const o = await e.collections.get(n.Model.Tables.tasks).find(t || ""),
                            r = await o.fetchCurrentProject(),
                            i = await r.getCurrentTeam(),
                            {
                                path: c
                            } = a.smartPathToTask(i, r, o);
                        e.router.replace({
                            path: c,
                            hash: s
                        })
                    })(u, t, s);
                    try {
                        await e().catch((async () => (await u.sync.synchronize(), e())))
                    } catch (e) {
                        d(!0)
                    }
                };
                n.Misc.isElectron ? e() : (n.ReactUtils.openUrl("nozbe4://goto/teams/" + m.id + "/task_id/" + (t || ""), "_self"), setTimeout(e, 100))
            }), [s, u, t]), (0, c.jsxs)("div", {
                className: i.root,
                children: [(0, c.jsx)(r.default, {
                    name: l ? "Œ" : "ƞ",
                    color: "onBackground3",
                    size: 48
                }), l ? (0, c.jsxs)(c.Fragment, {
                    children: [(0, c.jsx)("span", {
                        className: i.text,
                        children: h.f.IG
                    }), (0, c.jsx)(o.default, {
                        label: p ? h.f.fd : h.f.iG,
                        onPress: p ? () => {
                            u.history.goBack()
                        } : () => {
                            u.router.goTo(a.pathToPriority(m))
                        }
                    })]
                }) : (0, c.jsx)("span", {
                    className: i.text,
                    children: h.f.IF
                })]
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => m
        });
        var n = s(0),
            a = s(12),
            o = s(40),
            r = s(57),
            i = s(30),
            c = s(367);
        s(2), s(3);
        const l = s(771);
        var d, u = s(1);
        const m = n.Hocs.compose()((() => {
            const e = n.Hooks.useIntl(),
                t = n.Hooks.useServices(),
                s = n.Hooks.useDesktopLayout(),
                [m, h] = n.React.useState("needsInviteCode"),
                [p, g] = n.React.useState(""),
                [f, b] = n.React.useState(!1),
                [y, v] = n.React.useState(!1),
                w = n.React.useCallback((async () => {
                    try {
                        b(!1), v(!0), await t.api.account.checkInviteCode({
                            inviteCode: p
                        }), h("waitingForApproval")
                    } catch (t) {
                        var e, s, n;
                        if (444 === (null == (e = t.originalResponse) ? void 0 : e.status)) return void h("needsInviteCode");
                        if (445 === (null == (s = t.originalResponse) ? void 0 : s.status)) return void h("contactAdmin");
                        if (447 === (null == (n = t.originalResponse) ? void 0 : n.status)) return void h("needsInviteCode");
                        b(!0)
                    } finally {
                        v(!1)
                    }
                }), [p, t.api]);
            n.React.useEffect((() => {
                w()
            }), []), n.React.useEffect((() => {
                let e = null;
                const s = () => {
                    "waitingForApproval" === m && (t.sync.synchronize(), e = setTimeout(s, 5e3))
                };
                return s(), () => {
                    e && clearTimeout(e)
                }
            }), [m, t]);
            const k = () => {
                    n.ReactUtils.openUrl(n.ReactUtils.helpUrl(e, "general/video-tutorial/?utm_source=nt_app&utm_medium=referral&utm_campaign=video-tutorial"))
                },
                {
                    width: x
                } = {
                    width: 200
                },
                j = [{
                    iconName: "ī",
                    color: "purple",
                    size: "100%"
                }, {
                    iconName: "ĭ",
                    color: "purple",
                    opacity: .1,
                    size: "100%"
                }];
            return (0, u.jsxs)(i.xD, {
                withoutMarginsNative: !0,
                children: [(0, u.jsx)("div", {
                    className: l.iconContainer + (s ? " " + l.iconContainerDesktop : ""),
                    children: (0, u.jsx)(o.default, {
                        className: l.iconStack,
                        layers: j
                    })
                }), (0, u.jsxs)("div", {
                    className: l.root,
                    children: [f ? (0, u.jsx)("span", {
                        className: l.description + " " + l.descriptionPadding,
                        children: e.f.kY
                    }) : null, (() => {
                        if (y) return (0, u.jsx)("div", {
                            className: l.activityIndicator,
                            children: d || (d = (0, u.jsx)(r.default, {}))
                        });
                        switch (m) {
                            case "waitingForApproval":
                                return (0, u.jsxs)(u.Fragment, {
                                    children: [(0, u.jsx)("span", {
                                        className: l.title,
                                        children: e.f.j0
                                    }), (0, u.jsx)("span", {
                                        className: l.description + " " + l.descriptionPadding,
                                        children: e.f.jX
                                    }), (0, u.jsx)("span", {
                                        className: l.description,
                                        children: e.f.jZ
                                    }), (0, u.jsx)(a.default, {
                                        marginTop: "big",
                                        onPress: k,
                                        label: e.f.jY
                                    })]
                                });
                            case "needsInviteCode":
                                return (0, u.jsx)(c.ZP, {
                                    title: e.f.kh,
                                    inviteCode: p,
                                    onDonePress: w,
                                    setInviteCode: g
                                });
                            case "contactAdmin":
                                return (0, u.jsxs)(u.Fragment, {
                                    children: [(0, u.jsx)("span", {
                                        className: l.title,
                                        children: e.f.j0
                                    }), (0, u.jsx)("span", {
                                        className: l.description + " " + l.descriptionPadding,
                                        children: e.f.jW
                                    })]
                                });
                            default:
                                return null
                        }
                    })(), (0, u.jsx)(a.default, {
                        marginTop: "big",
                        onPress: () => {
                            setTimeout((() => {
                                t.app.logOut(!0)
                            }), 0)
                        },
                        label: e.f.cU
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n, a = s(0),
            o = s(30),
            r = s(12),
            i = s(1);
        const c = a.Hocs.compose()((() => {
            const e = a.Hooks.useServices(),
                t = a.Hooks.useIntl(),
                s = (0, o.AG)();
            return (0, i.jsxs)(o.xD, {
                children: [s ? n || (n = (0, i.jsx)(o.TR, {})) : null, (0, i.jsx)(o.v0, {
                    text: t.f.gp,
                    atBottom: !1
                }), (0, i.jsx)(r.default, {
                    onPress: () => {
                        e.appState.resetCancelAccountState()
                    },
                    marginTop: "big",
                    label: t.f.fd
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => D
        });
        var n = s(0),
            a = s(14),
            o = s(1);
        s(259).wx;
        const r = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "GeneralTour",
            render: "alert"
        }), n.Hocs.withServices, n.Hocs.withObservables(["services"], (({
            services: e
        }) => ({
            requiresNewOnboarding: e.modelRoot.settings.requiresNewOnboarding.observe(),
            sawGeneralOnboarding: e.modelRoot.settings.sawGeneralOnboarding.observe(),
            sawGeneralPersonalOnboarding: e.modelRoot.settings.sawGeneralPersonalOnboarding.observe(),
            hasNPAccount: e.modelRoot.settings.hasNPAccount.observe(),
            prefersPersonalUI: e.modelRoot.settings.prefersPersonalUI
        }))), n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
            currentTeam: e
        }) => ({
            isTeamOfOne: e.isTeamOfOne
        }))))((e => {
            const {
                requiresNewOnboarding: t,
                sawGeneralOnboarding: a,
                sawGeneralPersonalOnboarding: r,
                hasNPAccount: i,
                isTeamOfOne: c,
                prefersPersonalUI: l
            } = e, {
                isLimitedAccount: d
            } = n.Hooks.useIdentity();
            if (!d && t && !(l && r || !l && a)) {
                const e = s(906).Z;
                return (0, o.jsx)(e, {
                    hasNPAccount: i
                })
            }
            if (!c && l && !a) {
                const e = s(907).Z;
                return (0, o.jsx)(e, {})
            }
            return null
        }));
        var i = s(113),
            c = s(11);
        s(2), s(3);
        const l = s(780),
            d = n.ReactUtils.lazy((() => s(1401))),
            u = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                error: e.sync.queue.pipe(n.Rx.map((e => e.error)))
            }))))((e => {
                const {
                    error: t
                } = e, s = n.Hooks.useDesktopLayout(), a = n.Hooks.useIntl(), r = n.Hooks.useServices(), u = n.Hooks.useModalState(), m = !!t, h = n.React.useRef(null), p = n.React.useRef(!1);
                return n.React.useEffect((() => {
                    !m || h.current || p.current || (h.current = setTimeout((async () => {
                        try {
                            await r.sync.synchronize()
                        } catch (e) {
                            e.isNetworkErrorLikely || (p.current = !0, u.open())
                        } finally {
                            h.current = null
                        }
                    }), 18e4))
                }), [m, r.sync, u]), n.React.useEffect((() => {
                    m || (u.close(), clearTimeout(h.current), p.current = !1)
                }), [m, u]), (0, o.jsxs)(o.Fragment, {
                    children: [(0, o.jsx)(i.GR, {
                        name: "SyncIndicator",
                        children: t ? (0, o.jsx)(c.Z, {
                            className: l.indicator + (s ? " " + l.indicatorIsDesktop : ""),
                            onPress: u.open,
                            children: (0, o.jsx)("span", {
                                className: l.text,
                                children: a.f.FQ
                            })
                        }) : null
                    }), u.isOpen && t ? (0, o.jsx)(d, {
                        onClose: u.close,
                        onRetry: async () => {
                            try {
                                u.close(), await r.sync.synchronize()
                            } catch (e) {
                                u.open()
                            }
                        },
                        error: t
                    }) : null]
                })
            }));
        var m = s(9),
            h = s(54),
            p = s(364);
        const g = (e, t) => {
            const [s] = (0, p.Z)(), n = h.useModalState(), a = n.open, o = m.useRef(null);
            return m.useEffect((() => {
                !t && e && !o.current && s && a(), o.current = e
            }), [t, e, a, s]), n
        };
        var f = s(108),
            b = s(124);
        const y = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIdentity, n.Hocs.withObservables(["currentTeam"], (({
            currentTeam: e,
            services: t
        }) => ({
            favoriteProjects: e.favoriteProjects.observeWithColumns(f.L$),
            favoriteMembers: e.favoriteMembers.observeWithColumns(f.L$),
            favoriteTags: e.allFavoriteTags,
            teams: t.modelRoot.teams.observeWithColumns(b.xv)
        }))))((e => {
            const {
                favoriteProjects: t,
                favoriteMembers: s,
                favoriteTags: o,
                teams: r
            } = e, i = n.Hooks.useServices(), {
                currentTeam: c
            } = n.Hooks.useIdentity(), l = n.Hooks.useIntl(), d = (0, f.B6)([...t, ...s, ...o], c), u = (0, b.Hc)(l)(r), m = e => {
                if (e instanceof n.Model.Models.Project) return n.Styling.getProjectName(e, l);
                if (e instanceof n.Model.Models.Tag) return e.name;
                if (e instanceof n.Model.Models.TeamMember) return null;
                throw new Error("unreachable")
            }, h = e => async () => {
                i.router.goTo(((e, t) => {
                    if (t.table === n.Model.Tables.projects) return a.smartPathToProject(e, t);
                    if (t.table === n.Model.Tables.tags) return a.smartPathToTag(e, t);
                    if (t.table === n.Model.Tables.teamMembers) return a.smartPathToMember(e, t);
                    throw new Error("unreachable")
                })(c, e), void 0, !0)
            };
            return n.Hooks.useShortcutProviders([{
                id: "global.newWindow",
                action: async () => i.app.createScene()
            }, {
                id: "global.sync",
                action: async () => i.sync.synchronize()
            }, {
                id: "global.quickAddGlobal",
                action: n.Misc.isElectron ? async () => i.app.createScene("quick_add") : n.FP.noop
            }, {
                id: "global.quickAdd",
                action: () => i.uiState.quickAddModal.open()
            }, {
                id: "global.shortucts_help",
                action: () => i.uiState.shortcutsModal.open()
            }, {
                id: "global.reload",
                action: () => i.native.reload()
            }, {
                id: "global.jumpTo",
                action: () => i.uiState.jumpToModal.open()
            }, {
                id: "go.priority",
                action: () => i.router.goTo(a.pathToPriority(c))
            }, {
                id: "go.incoming",
                action: () => i.router.goTo(a.pathToIncoming(c))
            }, {
                id: "go.activity",
                action: () => i.router.goTo(a.pathToActivity(c))
            }, {
                id: "go.single_tasks",
                action: () => i.router.goTo(a.pathToSingleTasks(c))
            }, {
                id: "go.search",
                action: () => i.router.goTo(a.pathToSearch(c))
            }, {
                id: "go.next_30_days",
                action: () => i.router.goTo(a.pathToCalendar(c))
            }, {
                id: "go.messages",
                action: () => i.router.goTo(a.pathToMessages(c))
            }, ...d.slice(0, 4).map(((e, t) => ({
                id: "go.favorite_" + (t + 1),
                title: m(e),
                action: h(e)
            }))), ...u.slice(0, 5).map(((e, t) => ({
                id: "teams.team_" + (t + 1),
                title: n.Styling.getTeamName(e, l),
                action: () => i.router.goTo(a.pathToPriority(e)),
                isSelected: e.id === c.id
            })))].filter(Boolean)), n.Hooks.useShortcutProviders(n.Misc.isElectron ? [{
                id: "go.back",
                action: () => i.history._history.goBack()
            }, {
                id: "go.forward",
                action: () => i.history._history.goForward()
            }] : []), null
        }));
        var v, w, k, x, j = s(121);

        function T(e) {
            const {
                modal: t,
                children: s
            } = e;
            return (0, o.jsx)(j.Z, {
                observables: {
                    state: t.observe()
                },
                resetOn: [t],
                children: ({
                    state: e
                }) => e.isOpen ? s({
                    context: e.context,
                    onClose: () => {
                        t.close()
                    }
                }) : null
            })
        }

        function S(e) {
            const {
                state: t,
                children: s
            } = e;
            return (0, o.jsx)(j.Z, {
                observables: {
                    value: t.asObservable()
                },
                resetOn: [t],
                children: ({
                    value: e
                }) => null != e ? s({
                    value: e,
                    onClose: () => {
                        t.next(null)
                    }
                }) : null
            })
        }
        const P = s(770).wx,
            _ = s(208).wx,
            C = (n.ReactUtils.nullElement, n.ReactUtils.lazy((() => s(945)))),
            R = n.ReactUtils.lazy((() => s(363))),
            A = (n.ReactUtils.nullElement, n.ReactUtils.lazy((() => s(1405)))),
            I = n.ReactUtils.lazy((() => s(1406))),
            N = n.ReactUtils.lazy((() => s(1407))),
            E = n.ReactUtils.lazy((() => s(625))),
            O = n.ReactUtils.lazy((() => s(1408))),
            M = n.ReactUtils.lazy((() => s(1413))),
            D = n.Hocs.compose(n.Hocs.withRouter, n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                teamWelcomeSetting: e.modelRoot.settings.observeTeamWelcomingModalSetting()
            }))))((e => {
                const {
                    teamWelcomeSetting: t,
                    location: i
                } = e, c = n.Hooks.useServices(), {
                    uiState: l,
                    appState: d
                } = c, {
                    currentTeam: m,
                    isLimitedAccount: h
                } = n.Hooks.useIdentity(), p = g(!0, h), f = n.Hooks.useModalState(), b = n.Hooks.useModalState(), j = null == t ? void 0 : t.find((e => e.visible)), D = n.Hooks.useModalState({
                    isOpen: !!j
                });
                n.React.useEffect((() => {
                    j ? D.open() : D.close()
                }), [D, j]);
                const {
                    hash: H
                } = i;
                return n.React.useEffect((() => {
                    if (c.app._addDebugLog("[ROOT] hash changed: " + H), "#thirdparty-invite" === H && b.open(), "#pending-members" === H && (c.layout.openSidebar(), c.navigation.showSidebar()), "#integration" === H && f.open(), "#buy-premium" === H || "#buy-business" === H) {
                        const e = m.planInfo.canBeExtended && !m.isExpired ? "plan-extending" : "plan-changing";
                        c.payments.requirements.set(m, e, {
                            withPromotion: !0,
                            shouldDisplayBusinessOffer: "#buy_business" === H
                        })
                    }
                }), [H]), n.React.useEffect((() => {}), []), (0, o.jsxs)(o.Fragment, {
                    children: [v || (v = (0, o.jsx)(y, {})), w || (w = (0, o.jsx)(M, {})), null, (0, o.jsx)(S, {
                        state: d.teamInvitation,
                        children: ({
                            value: e,
                            onClose: t
                        }) => (0, o.jsx)(E, {
                            token: e,
                            onClose: t
                        })
                    }), (0, o.jsx)(S, {
                        state: d.projectInvitationToken,
                        children: ({
                            value: e,
                            onClose: t
                        }) => (0, o.jsx)(P.JoinProject, {
                            bundle$close: t,
                            onClose: t,
                            token: e
                        })
                    }), h ? null : (0, o.jsxs)(o.Fragment, {
                        children: [j ? null : k || (k = (0, o.jsx)(r, {})), null, (0, o.jsx)(C, {
                            team: m
                        }), (0, o.jsx)(T, {
                            modal: l.jumpToModal,
                            children: ({
                                onClose: e
                            }) => (0, o.jsx)(P.JumpTo, {
                                bundle$close: e,
                                onClose: e
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.quickAddModal,
                            children: ({
                                onClose: e
                            }) => (0, o.jsx)(P.QuickAdd, {
                                bundle$close: e,
                                onClose: e
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.shortcutsModal,
                            children: ({
                                onClose: e
                            }) => (0, o.jsx)(P.ShortcutsModal, {
                                bundle$close: e,
                                onClose: e
                            })
                        }), D.isOpen && j ? (0, o.jsx)(A, {
                            onClose: D.close,
                            teamId: j.team_id
                        }) : null, f.isOpen ? (0, o.jsx)(N, {
                            onClose: () => {
                                f.close(), c.router.goTo((0, a.pathToPriority)(m))
                            }
                        }) : null, b.isOpen ? (0, o.jsx)(I, {
                            onClose: b.close
                        }) : null, (0, o.jsx)(T, {
                            modal: l.addTeamModal,
                            children: ({
                                context: e,
                                onClose: t
                            }) => (0, o.jsx)(P.AddTeamModal, {
                                bundle$close: t,
                                businessId: null == e ? void 0 : e.businessId,
                                initialSetup: null == e ? void 0 : e.initialSetup,
                                onClose: t
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.newsFeedModal,
                            children: ({
                                onClose: e
                            }) => s(107).sY(e, (({
                                NewsFeed: t
                            }) => (0, o.jsx)(t, {
                                onClose: e
                            })))
                        }), (0, o.jsx)(T, {
                            modal: l.referralModal,
                            children: ({
                                onClose: e
                            }) => (0, o.jsx)(_.ReferralInfo, {
                                bundle$close: e,
                                onClose: e
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.appSettingsModal,
                            children: ({
                                context: e,
                                onClose: t
                            }) => s(107).sY(t, (({
                                SettingsMenu: s
                            }) => (0, o.jsx)(s, {
                                closeMenu: t,
                                initialView: e.pane
                            })))
                        }), (0, o.jsx)(T, {
                            modal: l.npImporterModal,
                            children: ({
                                onClose: e
                            }) => s(107).sY(e, (({
                                NPImporter: t
                            }) => (0, o.jsx)(t, {
                                onClose: e,
                                team: m
                            })))
                        }), (0, o.jsx)(T, {
                            modal: l.reviewModal,
                            children: ({
                                onClose: e
                            }) => (0, o.jsx)(O, {
                                onClose: e
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.taskActionEventModal,
                            children: ({
                                context: e,
                                onClose: t
                            }) => (0, o.jsx)(P.TaskActionEventPrompt, {
                                bundle$close: t,
                                onClose: t,
                                event: e
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.teamSettingsModal,
                            children: ({
                                context: e,
                                onClose: t
                            }) => (0, o.jsx)(P.ManageTeamModal, {
                                teamId: e.teamId,
                                bundle$close: t,
                                onClose: t
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.businessSettingsModal,
                            children: ({
                                context: e,
                                onClose: t
                            }) => (0, o.jsx)(P.ManageBusinessModal, {
                                businessId: e.businessId,
                                bundle$close: t,
                                initialPane: e.pane,
                                onClose: t
                            })
                        })]
                    }), (0, o.jsx)(T, {
                        modal: l.contactFormModal,
                        children: ({
                            onClose: e
                        }) => (0, o.jsx)(P.ContactForm, {
                            bundle$close: e,
                            onClose: e
                        })
                    }), p.isOpen ? (0, o.jsx)(R, {
                        onClose: p.close
                    }) : null, (0, o.jsxs)(o.Fragment, {
                        children: [(0, o.jsx)(S, {
                            state: d.taskInvitationToken,
                            children: ({
                                value: e,
                                onClose: t
                            }) => (0, o.jsx)(P.JoinTask, {
                                bundle$close: t,
                                onClose: t,
                                token: e
                            })
                        }), (0, o.jsx)(T, {
                            modal: l.accountUpgradeModal,
                            children: ({
                                onClose: e
                            }) => (0, o.jsx)(P.AccountUpgradeModal, {
                                bundle$close: e,
                                onClose: e
                            })
                        }), (0, o.jsx)(S, {
                            state: d.accountMerge,
                            children: ({
                                value: e,
                                onClose: t
                            }) => (0, o.jsx)(P.AccountMerge, {
                                bundle$close: t,
                                onClose: t,
                                accountMergeRequest: e
                            })
                        })]
                    }), (0, o.jsx)(T, {
                        modal: l.moveTasksModal,
                        children: ({
                            context: e,
                            onClose: t
                        }) => (0, o.jsx)(P.MoveTasks, {
                            bundle$close: t,
                            tasks: e.tasks,
                            onClose: t
                        })
                    }), x || (x = (0, o.jsx)(u, {}))]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n = s(0),
            a = s(6),
            o = s(11),
            r = s(13),
            i = s(12);
        var c = s(772);
        s(2), s(3);
        const l = s(773);
        var d = s(1);
        const u = s(105).wx,
            m = e => e instanceof n.Model.Models.Project,
            h = n.Hocs.compose((0, a.LU)({
                minWidth: 500
            }))((e => {
                const {
                    onCreated: t,
                    useCase: s
                } = e, h = n.Hooks.useServices(), p = n.Hooks.useIntl(), {
                    currentTeam: g
                } = n.Hooks.useIdentity(), [f, b] = n.React.useState(s), [y, v] = n.React.useState([]), w = n.React.useMemo((() => function(e) {
                    return {
                        business: [{
                            ranking: 1,
                            id: "general",
                            title: e.f.r2
                        }, {
                            ranking: 4,
                            id: "marketing",
                            title: e.f.r5
                        }, {
                            ranking: 4,
                            id: "sales",
                            title: e.f.r7
                        }, {
                            ranking: 2,
                            id: "hr",
                            title: e.f.r3
                        }, {
                            ranking: 0,
                            id: "clients",
                            title: e.f.rZ
                        }, {
                            ranking: 0,
                            id: "orders",
                            title: e.f.r6
                        }, {
                            ranking: 3,
                            id: "design",
                            title: e.f.r0
                        }, {
                            ranking: 4,
                            id: "administration",
                            title: e.f.rY
                        }, {
                            ranking: 3,
                            id: "finance",
                            title: e.f.r1
                        }, {
                            ranking: 3,
                            id: "legal",
                            title: e.f.r4
                        }],
                        personal: [{
                            ranking: 0,
                            id: "house",
                            title: e.f.sd
                        }, {
                            ranking: 6,
                            id: "groceries",
                            title: e.f.sa
                        }, {
                            ranking: 2,
                            id: "study",
                            title: e.f.sh
                        }, {
                            ranking: 1,
                            id: "kids",
                            title: e.f.se
                        }, {
                            ranking: 3,
                            id: "finance",
                            title: e.f.r_
                        }, {
                            ranking: 4,
                            id: "hobby",
                            title: e.f.sb
                        }, {
                            ranking: 7,
                            id: "holidays",
                            title: e.f.sc
                        }, {
                            ranking: 8,
                            id: "renovation",
                            title: e.f.sg
                        }, {
                            ranking: 9,
                            id: "language",
                            title: e.f.sf
                        }]
                    }
                }(p)), [p]), k = f ? w[f] : [], x = y.filter((e => m(e))), j = e => y.some((t => t.id === e.id)), T = 3 <= y.length, S = 1 <= y.length, P = async () => {
                    const e = n.FP.sortWith([n.FP.descend((e => m(e))), n.FP.descend((e => e.ranking))])(y);
                    e.forEach((e => {
                        m(e) || h.ab.projectPresetsBaseline.trackEvery(e.id)
                    })), h.ab.projectPresetsBaseline.trackEvery(y.length + "projects"), h.ab.projectPresetsBaseline.trackEvery(x.length + "custom");
                    const s = (await n.FP.allPromises((e => m(e) ? Promise.resolve(e) : g.do.createProject({
                        name: e.title,
                        isOpen: !0,
                        color: n.FP.randomElement(n.Styling.projectColors)
                    })), e))[0];
                    t(s)
                }, _ = async e => {
                    v([...y, e])
                }, [C, R] = n.Hooks.useStateMachine(f ? "presets" : "useCase");
                return (0, d.jsx)(d.Fragment, {
                    children: C.map({
                        useCase: () => (0, d.jsx)(c.Z, {
                            setUseCase: e => (e => {
                                n.ReactUtils.animateNext(), b(e), R("presets")(), h.ab.projectPresetsBaseline.trackOnce(e)
                            })(e)
                        }),
                        presets: () => (0, d.jsxs)(d.Fragment, {
                            children: [(0, d.jsx)(a.u_.Header, {
                                children: p.f.sl
                            }), (0, d.jsxs)(a.u_.Content, {
                                children: [(0, d.jsxs)(a.u_.Paragraph, {
                                    children: [(0, d.jsx)(a.u_.Emphasis, {
                                        children: "business" === f ? p.f.r8 : p.f.r9
                                    }), " ", p.f.si]
                                }), (0, d.jsxs)(a.u_.Section, {
                                    className: l.projectChips,
                                    children: [k.map((e => {
                                        const {
                                            id: t,
                                            title: s
                                        } = e, n = j(e), a = !n && T;
                                        return (0, d.jsx)(o.Z, {
                                            className: l.projectChip + (n ? " " + l.projectChipSelected : "") + (a ? " " + l.projectChipDisabled : ""),
                                            webComponent: "button",
                                            isDisabled: a,
                                            onPress: () => (e => {
                                                j(e) ? v(y.filter((t => t.id !== e.id))) : T || v([...y, e])
                                            })(e),
                                            children: (0, d.jsx)("span", {
                                                className: l.projectChipText + (n ? " " + l.projectChipTextSelected : "") + (a ? " " + l.projectChipTextDisabled : ""),
                                                children: s
                                            })
                                        }, t)
                                    })), x.map((e => (0, d.jsx)(o.Z, {
                                        className: l.projectChip + " " + l.projectChipSelected,
                                        webComponent: "button",
                                        children: (0, d.jsx)("span", {
                                            className: l.projectChipText + " " + l.projectChipTextSelected,
                                            children: n.Styling.getProjectName(e, p)
                                        })
                                    }, e.id)))]
                                }), (0, d.jsx)(a.u_.Section, {
                                    className: l.projectChips,
                                    children: (0, d.jsxs)(o.Z, {
                                        className: l.projectChip + (T ? " " + l.projectChipDisabled : ""),
                                        isDisabled: T,
                                        onPress: R("addCustom"),
                                        children: [(0, d.jsx)(r.default, {
                                            className: l.plusIcon,
                                            name: "ū",
                                            color: T ? "textSecondary" : "blue"
                                        }), (0, d.jsx)("span", {
                                            className: l.projectChipText + (T ? " " + l.projectChipTextDisabled : ""),
                                            children: p.f.r$
                                        })]
                                    })
                                }), (0, d.jsx)(a.u_.Buttons, {
                                    children: (0, d.jsx)(i.default, {
                                        isDisabled: !S,
                                        color: S ? "dodgerblue" : void 0,
                                        variant: T ? "opaque" : "standard",
                                        label: p.f.fD,
                                        onPress: P
                                    })
                                })]
                            })]
                        }),
                        addCustom: () => (0, d.jsx)(u.Project, {
                            bundle$close: R("presets"),
                            team: g,
                            onAddProject: _,
                            onClose: R("presets")
                        })
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => w
        });
        var n = s(0),
            a = s(43),
            o = s(6),
            r = (s(53), s(198)),
            i = s(125),
            c = s(774),
            l = s(944),
            d = s(57);
        s(2), s(3);
        const u = s(778);
        var m, h = s(1);
        const p = n.Hocs.compose()((e => {
            const {
                isLoading: t = !1,
                timeout: s = 1e3
            } = e, [a, o] = n.React.useState(t), r = n.React.useRef();
            return n.React.useEffect((() => t ? (r.current = setTimeout((() => o(!0)), s), () => clearTimeout(r.current)) : (o(!1), n.FP.noop)), [t, s]), a ? (0, h.jsx)("div", {
                className: u.root,
                children: m || (m = (0, h.jsx)(d.default, {}))
            }) : null
        }));
        var g = s(9),
            f = (s(5), s(4)),
            b = s(54);
        const y = f.always({
            isValid: !0
        });
        const v = s(779),
            w = n.Hocs.compose((0, o.LU)({
                minWidth: 450
            }), n.Hocs.withPersonalUI)((e => {
                const {
                    onSave: t,
                    shouldRenderPersonalUI: s
                } = e, {
                    api: d,
                    sync: u
                } = n.Hooks.useServices(), m = n.Hooks.useIntl(), {
                    currentTeam: w
                } = n.Hooks.useIdentity(), {
                    closeAnimated: k
                } = (0, o.vR)(), x = n.Hooks.useIsMounted(), [j, T, S, P] = n.Hooks.useLoadingState(), _ = function(e) {
                    const t = f.toPairs(e),
                        [s, n] = g.useState((() => ({
                            isSaved: !1,
                            values: f.fromPairs(t.map((([e, t]) => [e, {
                                initial: t.value,
                                current: t.value,
                                isSaved: !1
                            }])))
                        }))),
                        a = f.fromPairs(t.map((([e, t]) => {
                            const {
                                current: n
                            } = s.values[e];
                            return [e, [n, t.validators || [y]]]
                        }))),
                        o = b.useValidation(a),
                        r = f.fromPairs(t.map((([e]) => {
                            const {
                                current: t,
                                initial: a,
                                isSaved: r
                            } = s.values[e];
                            return [e, {
                                value: t,
                                initialValue: a,
                                isSaved: r,
                                isDirty: t !== a,
                                validation: o[e],
                                onChange: t => {
                                    n({
                                        isSaved: !1,
                                        values: Object.assign({}, s.values, {
                                            [e]: Object.assign({}, s.values[e], {
                                                current: t,
                                                isSaved: !1
                                            })
                                        })
                                    })
                                }
                            }]
                        }))),
                        i = f.values(r).some((e => e.isDirty)),
                        c = i && o.isValid;
                    return Object.assign({}, r, {
                        isSaved: s.isSaved,
                        isDirty: i,
                        canSave: c,
                        validation: o,
                        save: () => {
                            c && n({
                                isSaved: !0,
                                values: f.fromPairs(t.map((([e]) => {
                                    const {
                                        value: t,
                                        isDirty: s
                                    } = r[e];
                                    return [e, {
                                        initial: t,
                                        current: t,
                                        isSaved: s
                                    }]
                                })))
                            })
                        }
                    })
                }({
                    name: {
                        value: w.name,
                        validators: [a.C1, a.BS(n.Model.MaxLengths.teams.name)]
                    },
                    avatar: {
                        value: w.avatarId
                    }
                });
                return (0, h.jsxs)(h.Fragment, {
                    children: [(0, h.jsx)(o.u_.Header, {
                        right: null,
                        children: s ? m.f.JZ : m.f.JX
                    }), (0, h.jsxs)(o.u_.Content, {
                        isStatic: !0,
                        containsScroll: !0,
                        children: [(0, h.jsx)(p, {
                            isLoading: j.isLoading
                        }), (0, h.jsxs)(o.u_.Scroll, {
                            className: v.scroll,
                            children: [(0, h.jsx)(o.u_.Heading, {
                                children: s ? m.f.t9 : m.f.Jz
                            }), (0, h.jsx)(o.u_.Section, {
                                children: (0, h.jsx)(l.default, {
                                    value: _.avatar.value,
                                    team: w,
                                    isDisabled: j.isLoading,
                                    onChange: _.avatar.onChange
                                })
                            }), (0, h.jsx)(o.u_.Heading, {
                                children: s ? m.f.ul : m.f.JV
                            }), (0, h.jsx)(o.u_.Section, {
                                children: (0, h.jsx)(r.Z, {
                                    value: _.name.value,
                                    isDisabled: j.isLoading,
                                    isSaved: _.name.isSaved,
                                    errors: _.name.validation.errors,
                                    onChange: _.name.onChange
                                })
                            }), (0, h.jsx)(o.u_.Section, {
                                children: (0, h.jsx)(i.Z, {
                                    hint: m.f.fC,
                                    helpPageUrl: n.ReactUtils.helpUrl(m, "management/team/#team_settings")
                                })
                            })]
                        }), j.isError ? (0, h.jsx)(o.u_.Error, {
                            children: m.f.JY
                        }) : null, (0, h.jsxs)(o.u_.Actions, {
                            children: [(0, h.jsx)(c.Z, {
                                label: m.f.f3,
                                onPress: k
                            }), (0, h.jsx)(c.Z, {
                                label: m.f.fD,
                                color: "purple",
                                variant: "opaque",
                                isDisabled: j.isLoading,
                                onPress: async () => {
                                    await (async () => {
                                        if (_.canSave) {
                                            T();
                                            try {
                                                if (_.name.isDirty && await w.do.rename(_.name.value), _.avatar.isDirty) {
                                                    const e = _.avatar.value;
                                                    e ? (await d.attachments.uploadAvatar(e, w), await u.synchronize()) : w.avatarId && (await d.attachments.deleteAvatar(w.avatarId, w), await u.synchronize())
                                                }
                                                x.current && (_.save(), S())
                                            } catch (e) {
                                                x.current && P()
                                            }
                                        }
                                    })(), null == t || t()
                                }
                            })]
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(25),
            o = s(12);
        s(2), s(3);
        const r = s(781);
        var i = s(1);
        const c = n.Hocs.compose()((e => {
            const {
                onClose: t,
                onRetry: s,
                error: c
            } = e, l = n.Hooks.useIntl(), d = n.Hooks.useContactSupport(), u = Object.prototype.hasOwnProperty.call(c, "isNetworkErrorLikely") ? c : null, m = (null == u ? void 0 : u.isNetworkErrorLikely) || !1, h = null == u ? void 0 : u.originalResponse, p = null == h ? void 0 : h.status, g = m ? l.f.CJ : 429 === p ? l.f.CL : u ? l.g("CK", {
                status: p
            }) : l.f.CI;
            return (0, i.jsx)(a.default, {
                type: m ? "confirm" : "delete",
                headerIcon: "Ɯ",
                onClose: t,
                onConfirmPress: t,
                onBackPress: s,
                confirmButtonMessage: l.f.fF,
                secondaryButtonMessage: l.f.fQ,
                hasTextContent: !1,
                children: (0, i.jsxs)("div", {
                    className: r.content,
                    children: [(0, i.jsx)("span", {
                        className: r.text,
                        children: l.f.CG
                    }), (0, i.jsx)("span", {
                        className: r.text,
                        style: {
                            paddingTop: 14
                        },
                        children: l.g("CH", {
                            reasonText: g
                        })
                    }), m ? null : (0, i.jsxs)(i.Fragment, {
                        children: [(0, i.jsx)("span", {
                            className: r.text,
                            style: {
                                paddingTop: 24
                            },
                            children: l.f.CB
                        }), (0, i.jsx)(o.default, {
                            onPress: () => {
                                d({
                                    subject: l.f.CF,
                                    body: l.f.CC + "\n\n" + l.f.CD,
                                    withDiagnostics: !0,
                                    extraDiagnosticText: "Sync error: " + c.message + ", http status " + (p || "unknown") + ", errorType " + ((null == u ? void 0 : u.errorType) || "unknown")
                                })
                            },
                            label: l.f.dO,
                            iconName: "Ã",
                            marginTop: "big",
                            color: "darkgreen"
                        })]
                    })]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(25),
            o = s(302),
            r = s(1);
        const i = ({
                intl: e,
                isOpenProjectsLimitExceeded: t,
                isSharedProjectsLimitExceeded: s,
                isMembersLimitExceeded: n,
                isAdminsLimitExceeded: a,
                isTagsLimitExceeded: o,
                isSectionsLimitExceeded: r
            }) => t ? e.f.wU : s ? e.f.wV : n ? e.f.wT : a ? e.f.wS : o ? e.f.wX : r ? e.f.wW : e.f.wY,
            c = n.Hocs.compose(n.Hocs.withObservables(["team"], (({
                team: e
            }) => ({
                isProjectsLimitExceeded: (0, o.RL)(e),
                isTeamMembersLimitExceeded: (0, o.zQ)(e),
                isTagsLimitExceeded: (0, o.TS)(e),
                isSectionsLimitExceeded: (0, o.Cb)(e)
            }))))((e => {
                const {
                    onClose: t,
                    isProjectsLimitExceeded: s,
                    isTeamMembersLimitExceeded: o,
                    isTagsLimitExceeded: c,
                    isSectionsLimitExceeded: l
                } = e, d = n.Hooks.useIntl(), {
                    isOpenProjectsLimitExceeded: u,
                    isSharedProjectsLimitExceeded: m
                } = s, {
                    isMembersLimitExceeded: h,
                    isAdminsLimitExceeded: p
                } = o;
                return (0, r.jsx)(a.default, {
                    level: 90,
                    type: "delete",
                    confirmButtonMessage: d.f.wR,
                    onConfirmPress: () => {
                        n.ReactUtils.openEmailUrl({
                            to: "support@nozbe.com",
                            subject: d.f.u3,
                            body: d.f.u2
                        })
                    },
                    onBackPress: t,
                    onClose: t,
                    headerIcon: "Ã",
                    children: i({
                        intl: d,
                        isOpenProjectsLimitExceeded: u,
                        isSharedProjectsLimitExceeded: m,
                        isMembersLimitExceeded: h,
                        isAdminsLimitExceeded: p,
                        isTagsLimitExceeded: c,
                        isSectionsLimitExceeded: l
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(25);
        s(2), s(3);
        const o = s(782);
        var r = s(302),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.withObservables(["team"], (({
            team: e
        }) => ({
            business: e.business
        }))))((e => {
            const {
                team: t,
                business: s,
                onClose: c,
                previousPlan: l
            } = e, d = n.Hooks.useIntl(), {
                isFree: u,
                planInfo: m
            } = t, {
                planName: h,
                validUntil: p,
                autoRenewal: g
            } = (0, r.hi)({
                team: t,
                intl: d
            }), f = l ? (0, r.UV)(l, d) : null;
            return (0, i.jsx)(a.default, {
                type: "accept",
                confirmButtonMessage: d.f.fF,
                onConfirmPress: c,
                onClose: c,
                level: 90,
                hasTextContent: !1,
                children: (0, i.jsxs)("div", {
                    className: o.root,
                    children: [(0, i.jsx)("div", {
                        className: o.container,
                        children: (0, i.jsx)("span", {
                            className: o.headerText,
                            children: d.g("v2", (0, r.m$)({
                                team: t,
                                business: s
                            }))
                        })
                    }), f ? (0, i.jsx)("div", {
                        className: o.container,
                        children: (0, i.jsx)("span", {
                            className: o.text,
                            children: f
                        })
                    }) : null, (0, i.jsx)("div", {
                        className: o.container,
                        children: (0, i.jsx)("span", {
                            className: o.text,
                            children: h
                        })
                    }), u ? null : (0, i.jsxs)(i.Fragment, {
                        children: [(0, i.jsx)("div", {
                            className: o.container,
                            children: (0, i.jsx)("span", {
                                className: o.text,
                                children: p
                            })
                        }), m.canBeAutomaticallyRenewed ? (0, i.jsx)("div", {
                            className: o.container,
                            children: (0, i.jsx)("span", {
                                className: o.text,
                                children: g
                            })
                        }) : null]
                    })]
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(25),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                onClose: t
            } = e, s = n.Hooks.useIntl();
            return (0, o.jsx)(a.default, {
                type: "accept",
                confirmButtonMessage: s.f.fF,
                onConfirmPress: t,
                onClose: t,
                level: 90,
                children: s.f.vQ
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => h
        });
        var n = s(0),
            a = s(19),
            o = s(16),
            r = s(607),
            i = s(6);
        s(2), s(3);
        const c = s(783);
        var l, d = s(1);
        const u = [{
                iconName: "ĝ",
                color: "incoming",
                size: 200
            }, {
                iconName: "Ğ",
                color: "red",
                size: 200
            }],
            m = n.Hocs.compose((0, i.LU)({
                maxWidth: 500
            }))((e => {
                const {
                    team: t,
                    admins: s
                } = e, a = n.Hooks.useIntl();
                return (0, d.jsxs)(d.Fragment, {
                    children: [(0, d.jsx)(i.u_.Header, {
                        children: a.f.Jw
                    }), (0, d.jsxs)(i.u_.Content, {
                        children: [l || (l = (0, d.jsx)(i.u_.IconStack, {
                            stack: u
                        })), (0, d.jsx)(i.u_.Heading, {
                            children: a.g("Jx", {
                                teamName: null == t ? void 0 : t.name
                            })
                        }), (0, d.jsxs)("div", {
                            className: c.adminList,
                            children: [(0, d.jsx)("span", {
                                className: c.adminsPrefix,
                                children: a.f.Jv
                            }), s.map((e => (0, d.jsx)("div", {
                                className: c.mention,
                                children: (0, d.jsx)(r.Z, {
                                    comment: null,
                                    memberId: e.id,
                                    groupMentionId: null
                                })
                            }, e.id)))]
                        })]
                    })]
                })
            })),
            h = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                teams: e.modelRoot.teams
            }))), n.Hocs.withHooks((({
                teams: e,
                teamId: t
            }) => ({
                team: n.FP.find((e => e.id === t), e)
            }))), n.Hocs.withObservables(["team"], (({
                team: e,
                teamId: t
            }) => ({
                admins: e ? e.collections.get(o.w.teamMembers).query(a.Q.and(a.Q.where(o.o.teamMembers.role, a.Q.oneOf(["admin", "owner"])), a.Q.where(o.o.teamMembers.status, "active"), a.Q.where(o.o.teamMembers.teamId, t))).observe() : n.Rx.of([])
            }))))((e => {
                const {
                    teamId: t,
                    admins: s,
                    team: a,
                    onClose: o
                } = e, r = n.Hooks.useServices(), {
                    currentTeam: i
                } = n.Hooks.useIdentity();
                return a && i === a ? (0, d.jsx)(m, {
                    onClose: async e => {
                        await r.modelRoot.settings.markTeamAsWelcomed(t), o(e)
                    },
                    admins: s,
                    team: a
                }) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => v
        });
        var n = s(0),
            a = s(6),
            o = s(12),
            r = s(18),
            i = s(93),
            c = s(151),
            l = s(124),
            d = s(202);
        s(2), s(3);
        const u = s(784);
        var m = s(1);
        const h = ({
                name: e
            }) => () => {
                const t = n.React.useMemo((() => (0, l.m6)()), []);
                return (0, m.jsx)(i.default, {
                    color: t,
                    name: e,
                    size: "small"
                })
            },
            p = e => () => {
                const {
                    name: t,
                    isActive: s
                } = e, a = e.isTextBolded || s;
                return (0, m.jsx)(r.default, {
                    className: u.text,
                    style: {
                        color: n.Styling.factoryColor("textPrimary"),
                        fontWeight: a ? "600" : "normal"
                    },
                    children: t
                })
            },
            g = n.FP.omit(["isChecked", "color"]),
            f = n.Hocs.compose(n.Hocs.memo)((e => n.React.createElement(c.Z, Object.assign({
                renderLeft: h(e),
                renderLabel: p(e)
            }, g(e), {
                renderRight: (0, d.j)(e, {
                    isOnRight: !0
                })
            })))),
            b = s(785),
            y = n.ReactUtils.createQueryParamParser("handler"),
            v = n.Hocs.compose((0, a.LU)())((() => {
                const {
                    history: e,
                    api: t,
                    payments: s
                } = n.Hooks.useServices(), {
                    currentTeam: r
                } = n.Hooks.useIdentity(), i = n.Hooks.useIntl(), {
                    closeAnimated: c
                } = (0, a.vR)(), l = n.Hooks.useLayoutBottomInset(), d = (e => {
                    const t = y(e);
                    return invariant(t, "Missing intergation third party handler name"), t
                })(e.currentPath.getValue()), [u, h] = n.React.useState([]), [p, g, v, w] = n.Hooks.useLoadingState({
                    status: "loading",
                    result: []
                }), k = p.result || [];
                n.Hooks.useAsyncEffect((async e => {
                    g();
                    try {
                        const s = await t.account.getThirdPartyMembers({
                                teamId: r.id,
                                thirdPartyName: d
                            }),
                            {
                                thirdPartyMembers: n
                            } = s;
                        e.isPending() && v(n)
                    } catch (t) {
                        e.isPending() && w()
                    }
                }), [t, r.id, w, g, v, d]);
                const x = (e, t) => {
                    h(n.FP.toggleSelected(t.id, u))
                };
                return (0, m.jsxs)(m.Fragment, {
                    children: [(0, m.jsx)(a.u_.Header, {
                        children: i.g("J8", {
                            thirdPartyName: d
                        })
                    }), (0, m.jsxs)("div", {
                        className: b.root,
                        style: {
                            paddingBottom: l
                        },
                        children: [(0, m.jsx)(a.u_.Paragraph, {
                            children: i.g("J7", {
                                teamName: r.name,
                                thirdPartyName: d
                            })
                        }), (0, m.jsxs)(a.u_.Loader, {
                            status: p.status,
                            children: [(0, m.jsx)(o.default, {
                                label: i.f.fV,
                                onPress: () => {
                                    h(k.map((({
                                        id: e
                                    }) => e)))
                                },
                                isDisabled: u.length === k.length
                            }), (0, m.jsx)(a.u_.Content, {
                                children: k.map((e => (0, m.jsx)(f, {
                                    name: e.name,
                                    bottomDescription: e.email,
                                    onPress: x,
                                    onPressExtraParam: e,
                                    isActive: u.includes(e.id)
                                }, e.email)))
                            })]
                        }), (0, m.jsxs)("div", {
                            className: b.buttonContainer,
                            children: [(0, m.jsx)(o.default, {
                                className: b.button,
                                label: i.f.fz,
                                variant: "opaque",
                                color: "orange",
                                onPress: async e => {
                                    s.invokeActionOrProposeUpgrade({
                                        name: "invite-to-team",
                                        currentTeam: r,
                                        membersCount: u.length
                                    }, (async () => {
                                        try {
                                            const s = k.filter((({
                                                id: e
                                            }) => u.includes(e)));
                                            await t.account.inviteThirdPartyMembers({
                                                teamId: r.id,
                                                thirdPartyName: d,
                                                thirdPartyMembers: s
                                            }), c(e)
                                        } catch (e) {}
                                    }))
                                },
                                isDisabled: !u.length
                            }), (0, m.jsx)(o.default, {
                                className: b.button,
                                label: i.f.fe,
                                onPress: c
                            })]
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => v
        });
        var n = s(0),
            a = s(6),
            o = s(12);
        const r = n.ReactUtils.createQueryParamParser("handler"),
            i = n.ReactUtils.createQueryParamParser("state"),
            c = n.ReactUtils.createQueryParamParser("code"),
            l = n.ReactUtils.createQueryParamParser("oauth_verifier"),
            d = n.ReactUtils.createQueryParamParser("client_info"),
            u = n.ReactUtils.createQueryParamParser("is_for_all_spaces");
        var m = s(370),
            h = s(371),
            p = s(372),
            g = s(373),
            f = s(946);
        var b, y = s(1);
        const v = n.Hocs.compose((0, a.LU)({
            minWidth: 400,
            maxWidth: 500
        }))((() => {
            var e;
            const t = n.Hooks.useServices(),
                s = n.Hooks.useIntl(),
                {
                    closeAnimated: v
                } = (0, a.vR)(),
                {
                    currentTeam: w
                } = n.Hooks.useIdentity(),
                {
                    handler: k,
                    code: x,
                    state: j,
                    oauthVerifier: T,
                    clientInfo: S,
                    isForAllSpaces: P
                } = function() {
                    const {
                        search: e
                    } = n.Hooks.useLocation();
                    return n.React.useMemo((() => ({
                        handler: r(e),
                        code: c(e),
                        state: i(e),
                        oauthVerifier: l(e),
                        clientInfo: d(e),
                        isForAllSpaces: "true" === u(e)
                    })), [e])
                }(),
                {
                    iconStack: _,
                    name: C,
                    description: R,
                    buttonColor: A
                } = function(e, t, s) {
                    const a = n.Hooks.useIntl(),
                        o = t.name,
                        r = s ? 2 : 1;
                    switch (e) {
                        case "gcal":
                            return {
                                iconStack: (0, f.hB)("gcal"), name: a.f.cy, description: a.g("nU", {
                                    teamName: o
                                }), buttonColor: "blue"
                            };
                        case "mcal":
                            return {
                                iconStack: (0, f.hB)("mcal"), name: a.f.c_, description: a.g("n2", {
                                    teamName: o
                                }), buttonColor: "blue"
                            };
                        case "evernote":
                            return {
                                iconStack: m.Z, name: a.f.cx, description: a.g("nM", {
                                    teamName: o
                                }), buttonColor: "avatarColor4"
                            };
                        case "dropbox":
                            return {
                                iconStack: h.y, name: a.f.ch, description: a.g("nG", {
                                    teamName: o,
                                    teamCount: r
                                }), buttonColor: "blue"
                            };
                        case "gdrive":
                            return {
                                iconStack: p.y, name: a.f.cA, description: a.g("nW", {
                                    teamName: o,
                                    teamCount: r
                                }), buttonColor: "brown"
                            };
                        case "onedrive":
                            return {
                                iconStack: g.$, name: a.f.c$, description: a.g("n0", {
                                    teamName: o,
                                    teamCount: r
                                }), buttonColor: "lightblue"
                            };
                        default: {
                            const t = e ? n.FP.capitalize(e) : a.f.n9;
                            return {
                                iconStack: [{
                                    iconName: "i",
                                    color: "incoming",
                                    opacity: .2,
                                    size: 200
                                }, {
                                    iconName: "Ɓ",
                                    color: "incoming",
                                    size: 150
                                }],
                                name: t,
                                description: a.g("nE", {
                                    name: t
                                }),
                                buttonColor: "incoming"
                            }
                        }
                    }
                }(k, w, P),
                I = n.Hooks.useErrorHandler({
                    AuthorizationRejected: s.f.nI,
                    UnsupportedIntegration: s.f.nK,
                    ConfirmationFail: s.f.nJ
                }),
                {
                    ErrorCodes: N
                } = I,
                E = n.Hooks.useAsyncState(),
                O = n.Hooks.useAsyncFetcher(E, (async () => {
                    const e = I.boom(N.ConfirmationFail);
                    if (!x) throw e;
                    const s = await (async () => {
                        switch (k) {
                            case "gcal":
                            case "mcal":
                                return t.api.integrations.confirmCalendarIntegration(w, k, x);
                            case "evernote":
                                if (!T) throw I.boom(N.AuthorizationRejected);
                                return t.api.integrations.confirmEvernoteConnect(w, x, T);
                            case "dropbox":
                            case "gdrive":
                                if (!j) throw I.boom(N.AuthorizationRejected);
                                switch (k) {
                                    case "dropbox":
                                        return t.api.integrations.confirmDropboxConnect(w, x, j);
                                    case "gdrive":
                                        return t.api.integrations.confirmGoogleDriveConnect(w, x, j);
                                    default:
                                        throw new Error("Unhandled")
                                }
                            case "onedrive":
                                if (!j || !S) throw I.boom(N.AuthorizationRejected);
                                return t.api.integrations.confirmOneDriveConnect(w, x, j, S);
                            default:
                                throw n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.DIAGNOSTIC_ERROR, k ? 'Unknown integration to confirm: "' + k + '"' : "No integration to confirm"), I.boom(N.UnsupportedIntegration)
                        }
                    })();
                    if ("success" === s.result) await t.sync.synchronize();
                    else if ("fail" === s.result) throw e.context.retryAuthUrl = s.retryAuthUrl, e
                }));
            return n.Hooks.useAsyncEffect(O, []), (0, y.jsxs)(y.Fragment, {
                children: [(0, y.jsx)(a.u_.Header, {
                    children: C
                }), (0, y.jsxs)(a.u_.Content, {
                    padded: !0,
                    children: [(0, y.jsx)(a.u_.IconStack, {
                        stack: _
                    }), E.map.progress({
                        unresolved: () => b || (b = (0, y.jsx)(a.u_.Loader, {
                            isLoading: !0
                        })),
                        succeeded: () => (0, y.jsxs)(y.Fragment, {
                            children: [e || (e = (0, y.jsx)(a.u_.Paragraph, {
                                children: R
                            })), (0, y.jsx)(a.u_.Buttons, {
                                children: (0, y.jsx)(o.default, {
                                    label: s.f.fy,
                                    color: A,
                                    variant: "opaque",
                                    onPress: v
                                })
                            })]
                        }),
                        errored: ({
                            error: e
                        }) => (0, y.jsxs)(y.Fragment, {
                            children: [(0, y.jsx)(a.u_.Paragraph, {
                                children: I.translate(e)
                            }), (0, y.jsx)(a.u_.Buttons, {
                                children: e.context.retryAuthUrl ? (0, y.jsx)(o.default, {
                                    label: s.f.f4,
                                    color: A,
                                    onPress: t => {
                                        n.ReactUtils.openUrl(e.context.retryAuthUrl, n.Misc.isElectron ? "_blank" : "_self"), v(t)
                                    }
                                }) : (0, y.jsx)(o.default, {
                                    label: s.f.fh,
                                    onPress: v
                                })
                            })]
                        })
                    })]
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(1);
        const o = n.ReactUtils.lazy((() => s(1409))),
            r = n.ReactUtils.lazy((() => s(1410))),
            i = n.ReactUtils.lazy((() => s(1411))),
            c = n.Hocs.compose()((e => {
                var t;
                const {
                    onClose: s
                } = e, [c, l] = n.Hooks.useStateMachine("rating"), d = e => {
                    l("feedback", {
                        score: e
                    })()
                };
                return c.map({
                    rating: () => (0, a.jsx)(o, {
                        onClose: s,
                        goToReview: l("g2Review"),
                        goToFeedback: d
                    }),
                    g2Review: () => t || (t = (0, a.jsx)(r, {
                        onClose: s
                    })),
                    feedback: ({
                        score: e
                    }) => (0, a.jsx)(i, {
                        score: e,
                        onClose: s
                    })
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(6),
            o = s(53);
        s(2), s(3);
        const r = s(786);
        var i = s(1);
        const c = ({
                onPress: e,
                score: t
            }) => (0, i.jsx)(o.default, {
                className: r.scoreButton,
                label: "" + t,
                onPress: s => e(s, t),
                hasMinWidth: !1
            }),
            l = ({
                onButtonPress: e
            }) => (0, i.jsx)("div", {
                className: r.scoresSection,
                children: Array.from({
                    length: 11
                }, ((t, s) => (0, i.jsx)(c, {
                    score: s,
                    onPress: e
                }, s)))
            }),
            d = n.Hocs.compose()((({
                goToReview: e,
                goToFeedback: t,
                onClose: s
            }) => {
                const o = n.Hooks.useServices(),
                    c = n.Hooks.useIntl(),
                    d = n.Hooks.useDesktopLayout(),
                    [{
                        closeAnimated: u
                    }, m] = (0, a.P9)();
                n.React.useEffect((() => {
                    o.ab.netPromoterScore2.trackEvery("rendered")
                }), [o.ab]);
                const h = n.React.useMemo((() => [{
                    iconName: "Ă",
                    color: "purple",
                    size: d ? 300 : 220
                }, {
                    iconName: "ă",
                    color: "purple",
                    opacity: .6,
                    size: d ? 300 : 220
                }, {
                    iconName: "Ą",
                    color: "purple",
                    opacity: .3,
                    size: d ? 300 : 220
                }]), [d]);
                return (0, i.jsxs)(a.u_, {
                    onClose: s,
                    ref: m,
                    size: "fullscreen",
                    onDismiss: async e => {
                        const t = await o.modelRoot.settings.npsRatingSetting.fetch(),
                            s = null == t ? void 0 : t.rating;
                        "number" != typeof s ? await o.modelRoot.settings.changeRating(-2) : await o.modelRoot.settings.changeRating(s), o.ab.netPromoterScore2.trackEvery("dismissed"), u(e)
                    },
                    children: [(0, i.jsx)(a.u_.Header, {
                        children: c.f.k7
                    }), (0, i.jsx)(a.u_.Content, {
                        isStatic: !1,
                        contentContainerStyle: {
                            flex: 1
                        },
                        children: (0, i.jsxs)("div", {
                            className: r.root,
                            children: [(0, i.jsx)(a.u_.IconStack, {
                                stack: h
                            }), (0, i.jsx)("span", {
                                className: r.title,
                                children: c.f.rP
                            }), (0, i.jsx)(l, {
                                onButtonPress: async (s, n) => {
                                    o.ab.netPromoterScore2.trackEvery(n + "score"), o.ab.netPromoterScore2.trackEvery("rated"), await o.modelRoot.settings.changeRating(n), 9 <= n ? (o.ab.netPromoterScore2.trackEvery("promoter"), e()) : (o.ab.netPromoterScore2.trackEvery(7 <= n ? "passive" : "detractor"), t(n))
                                }
                            }), (0, i.jsxs)("div", {
                                className: r.labels,
                                children: [(0, i.jsx)("span", {
                                    className: r.label,
                                    children: c.g("rN", {
                                        number: 0
                                    })
                                }), (0, i.jsx)("span", {
                                    className: r.label,
                                    children: c.g("rO", {
                                        number: 10
                                    })
                                })]
                            })]
                        })
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n, a = s(0),
            o = s(12),
            r = s(6),
            i = s(37),
            c = s(1);
        const l = [{
                iconName: "Đ",
                color: "green",
                opacity: .2,
                size: 140
            }, {
                iconName: "Ē",
                color: "green",
                opacity: 1,
                size: 140
            }],
            d = a.Hocs.compose((0, r.LU)())((() => {
                const e = a.Hooks.useIntl(),
                    t = a.Hooks.useServices(),
                    {
                        closeAnimated: s
                    } = (0, r.vR)();
                return a.Hooks.useAsyncEffect((async () => {
                    await t.localStorage.set(i.d.lastPromptedForReviewAt, Date.now())
                }), []), (0, c.jsxs)(c.Fragment, {
                    children: [(0, c.jsx)(r.u_.Header, {
                        children: e.f.k$
                    }), (0, c.jsxs)(r.u_.Content, {
                        children: [n || (n = (0, c.jsx)(r.u_.IconStack, {
                            stack: l
                        })), (0, c.jsx)(r.u_.Heading, {
                            children: e.f.k9
                        }), (0, c.jsx)(r.u_.Paragraph, {
                            children: e.f.k8
                        }), (0, c.jsxs)(r.u_.Buttons, {
                            children: [(0, c.jsx)(o.default, {
                                label: e.f.fB,
                                onPress: s
                            }), (0, c.jsx)(o.default, {
                                label: e.f.f$,
                                onPress: e => {
                                    a.ReactUtils.openUrl("https://www.g2.com/products/nozbe/reviews/start"), s(e)
                                },
                                variant: "opaque",
                                color: "green"
                            })]
                        })]
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => l
        });
        var n, a = s(0),
            o = s(6),
            r = s(947),
            i = s(1);
        const c = [{
                iconName: "æ",
                color: "pedro",
                size: 150
            }, {
                iconName: "ç",
                color: "pedro",
                opacity: .3,
                size: 150
            }],
            l = a.Hocs.compose((0, o.LU)())((e => {
                const {
                    score: t
                } = e, s = a.Hooks.useIntl(), l = a.Hooks.useServices(), {
                    closeAnimated: d
                } = (0, o.vR)(), u = 6 >= t;
                return (0, i.jsx)(r.Z, {
                    title: s.f.k6,
                    description: (0, i.jsxs)(i.Fragment, {
                        children: [n || (n = (0, i.jsx)(o.u_.IconStack, {
                            stack: c
                        })), (0, i.jsx)(o.u_.Heading, {
                            children: u ? s.f.k4 : s.f.k5
                        }), (0, i.jsx)(o.u_.Paragraph, {
                            children: u ? s.f.k2 : s.f.k3
                        })]
                    }),
                    hideMessageTypePicker: !0,
                    initialType: "feedback",
                    onClose: d,
                    onSubmit: () => {
                        l.ab.netPromoterScore2.trackEvery("feedbackSent")
                    }
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(20),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)({
            maxHeight: 500,
            size: "content",
            isDesktopModal: !1
        }))((e => {
            const {
                onSelect: t,
                items: s
            } = e, i = n.Hooks.useIntl(), {
                closeAnimated: c
            } = (0, a.vR)();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Header, {
                    isPickerHeader: !0,
                    children: i.f.hG
                }), (0, r.jsx)(a.u_.Content, {
                    children: s.map((e => (0, r.jsx)(o.Z, {
                        label: e.label,
                        onPress: s => {
                            t(e), c(s)
                        }
                    }, e.type)))
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(52),
            a = s(0),
            o = s(1);
        const r = ["_id"],
            i = a.ReactUtils.lazy((() => s(908))),
            c = a.Hocs.compose(a.Hocs.withServices, a.Hocs.withObservables(["services"], (({
                services: e
            }) => ({
                snackbarState: e.uiState.snackbarStack.pipe(a.Rx.map((e => e[0])))
            }))))((e => {
                const {
                    snackbarState: t
                } = e, s = a.Hooks.useServices(), c = a.React.useRef(), l = a.React.useRef(), d = a.React.useCallback((() => {
                    c.current && clearTimeout(c.current), l.current && clearTimeout(l.current)
                }), []), u = a.React.useCallback((() => {
                    d(), c.current = setTimeout((() => h(!0)), 4500), l.current = setTimeout((() => {
                        null == t || null == t.onHideSnackbar || t.onHideSnackbar(), t && s.uiState.removeSnackbarFromStack(t._id)
                    }), 5e3)
                }), [s.uiState, t, d]), [m, h] = a.React.useState(!1);
                if (a.React.useEffect((() => null != t && t._id ? (h(!1), u(), d) : () => {}), [t, u, d]), !t || m) return null;
                const {
                    _id: p
                } = t, g = (0, n.Z)(t, r);
                return (0, o.jsx)(i, Object.assign({}, g, {
                    onMouseEnter: () => {
                        d(), g.onMouseEnter && g.onMouseEnter()
                    },
                    onMouseLeave: () => {
                        u(), g.onMouseLeave && g.onMouseLeave()
                    },
                    onHideSnackbar: () => {
                        null == g.onHideSnackbar || g.onHideSnackbar(), p && s.uiState.removeSnackbarFromStack(p)
                    },
                    onButtonPress: t.onButtonPress ? () => {
                        t && s.uiState.removeSnackbarFromStack(p), g.onButtonPress && g.onButtonPress()
                    } : void 0
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => c
        });
        var n = s(0),
            a = s(6),
            o = s(864),
            r = s(1);
        const i = (e, t) => {
                switch (e) {
                    case "generic_error":
                        return t.f.gG;
                    case "insufficient_powers":
                        return t.f.gH;
                    case "token_invalid":
                        return t.f.gI;
                    default:
                        return t.f.kY
                }
            },
            c = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables([], (({
                services: e
            }) => ({
                teamsWithCurrentMemberOwner: e.modelRoot.activeTeams.pipe(n.Rx.switchMap((e => n.Rx.combineLatestTuples(e.map((e => [e, e.currentMember]))))), n.Rx.map((e => e.filter((([, e]) => e.isOwner)))))
            }))))((e => {
                const {
                    token: t,
                    services: {
                        appState: s,
                        api: c,
                        sync: l
                    },
                    teamsWithCurrentMemberOwner: d
                } = e, u = n.Hooks.useIntl(), [m, h, p, g] = n.Hooks.useLoadingState(), [f, b] = n.React.useState(d[0][0]), y = n.Hooks.useIsMounted(), v = n.React.useCallback((async e => {
                    if (h(), t) try {
                        await c.payments.claimPurchase({
                            team: e,
                            token: t
                        }), await l.synchronize(), y.current && p("granted")
                    } catch (e) {
                        y.current && g("generic_error")
                    } else s.finishClaimPurchase()
                }), [c, s, y, g, h, p, l, t]);
                return n.React.useEffect((() => {
                    (async () => {
                        if (h(), t) {
                            try {
                                await c.validateToken({
                                    tokenId: t,
                                    tokenType: "unclaimed_purchases"
                                })
                            } catch (e) {
                                if (y.current) return void g("token_invalid")
                            }
                            switch (d.length) {
                                case 0:
                                    return void g("insufficient_powers");
                                case 1:
                                    return void await v(f);
                                default:
                                    p("pick_team")
                            }
                        } else s.finishClaimPurchase()
                    })()
                }), [c, s, v, y, f, g, h, p, t, d]), (0, r.jsxs)(a.u_, {
                    onClose: () => {
                        s.finishClaimPurchase()
                    },
                    minWidth: 400,
                    children: [(0, r.jsx)(a.u_.Header, {
                        children: u.f.gL
                    }), (0, r.jsxs)(a.u_.Content, {
                        children: [(0, r.jsx)(a.u_.Loader, {
                            status: m.status,
                            errorMsg: m.error ? i(m.error, u) : void 0,
                            successMsg: "granted" === m.result ? u.g("gK", {
                                teamName: (0, r.jsx)(a.u_.Emphasis, {
                                    children: f.name
                                }, f.id)
                            }) : void 0
                        }), "pick_team" === m.result ? (0, r.jsxs)(r.Fragment, {
                            children: [(0, r.jsx)(a.u_.Paragraph, {
                                children: u.f.gJ
                            }), d.map((([e]) => (0, r.jsx)(o.ZP, {
                                team: e,
                                onPress: async () => {
                                    b(e), await v(e)
                                }
                            }, e.id)))]
                        }) : null]
                    })]
                })
            }))
    }, , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(180);
        async function a() {
            await (0, n.default)([() => (s(46), s(4)), () => s(5), () => s(8), () => (s(23), s(14)), () => (s(19), s(33)), () => s(39), () => (s(54), s(154)), () => s(36), () => (s(17), s(237)), () => s(21), () => (s(362), s(614))], (e => new Promise((t => {
                e(), setTimeout((() => {
                    t()
                }), 0)
            }))))
        }
    }, , , , , , , , , , , , , (e, t, s) => {
        "use strict";

        function n(e, t) {
            if (e.length !== t.length) return !1;
            for (let s = 0; s < e.length; s += 1)
                if (e[s] !== t[s]) return !1;
            return !0
        }
        s.d(t, {
            Z: () => n
        })
    }, , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        var n = s(191);

        function a(e, t = "OK", s = "Cancel") {
            return globalThis.electron ? globalThis.electron.devConfirm(e, t, s) : Promise.resolve((0, n.Z)().confirm(e))
        }
    }, , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(830);
        const a = e => e.reduce((([e, t], s) => {
                const a = (0, n.LV)(s);
                return 1 <= a.maxTeamMembers && (a.isMonthly ? e.push(a) : t.push(a)), [e, t]
            }), [
                [],
                []
            ]),
            o = async ({
                api: e,
                team: t,
                reason: s,
                isRenewal: n
            }) => {
                const o = await e.payments.fetchPlansJSON(t.id, s, n);
                invariant((e => "object" == typeof e && "string" == typeof e.currency && (Array.isArray(e.plans) && 0 < e.plans.length || Array.isArray(e.business_plans) && 0 < e.business_plans.length))(o), "Invalid pricing for team#" + t.id);
                const [r, i] = a(o.plans), [c, l] = o.promo_plans ? a(o.promo_plans) : [], [d, u] = o.business_plans ? a(o.business_plans) : [], m = 0 < (null == d ? void 0 : d.length) || 0 < (null == u ? void 0 : u.length), [h, p] = o.business_promo_plans ? a(o.business_promo_plans) : [], g = r.some((e => e.trialWebUrlOrNativeId)) || i.some((e => e.trialWebUrlOrNativeId));
                return {
                    currency: o.currency,
                    vat: o.vat,
                    taxId: o.tax_id,
                    version: o.version,
                    plansMonthly: 0 < (null == r ? void 0 : r.length) ? r : void 0,
                    plansYearly: 0 < (null == i ? void 0 : i.length) ? i : void 0,
                    promoPlansMonthly: 0 < (null == c ? void 0 : c.length) ? c : void 0,
                    promoPlansYearly: 0 < (null == l ? void 0 : l.length) ? l : void 0,
                    isTrialAvailable: g,
                    businessPlansMonthly: 0 < (null == d ? void 0 : d.length) ? d : void 0,
                    businessPlansYearly: 0 < (null == u ? void 0 : u.length) ? u : void 0,
                    businessPromoPlansMonthly: 0 < (null == h ? void 0 : h.length) ? h : void 0,
                    businessPromoPlansYearly: 0 < (null == p ? void 0 : p.length) ? p : void 0,
                    hasBusinessPlans: m
                }
            }
    }, , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = ({
            children: e
        }) => e
    }, , , , , , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => p
        });
        var n, a = s(0),
            o = s(12),
            r = s(14),
            i = s(30),
            c = s(648),
            l = s(1);
        const d = a.ReactUtils.lazy((() => s(1330))),
            u = a.ReactUtils.createQueryParamParser("code"),
            m = a.ReactUtils.createQueryParamParser("conflict"),
            h = a.ReactUtils.createQueryParamParser("is_new"),
            p = a.Hocs.compose()((e => {
                var t;
                const {
                    location: s
                } = e, p = a.Hooks.useIntl(), {
                    search: g,
                    state: f = {},
                    pathname: b
                } = s, y = f.code || u(g), v = f.conflict || m(g), w = null != (t = f.isNewAccount) ? t : "True" === h(g), k = f.provider || (e => {
                    switch (e) {
                        case r.routeToGoogleSignInRedirect:
                            return "google";
                        case r.routeToAppleSignInRedirect:
                            return "apple";
                        case r.routeToNozbeSignInRedirect:
                            return "nt";
                        default:
                            throw new Error("path for unknown provider")
                    }
                })(b), x = (0, i.AG)(), j = (0, i.Rg)();
                return a.Hooks.useBackButton((() => (j(), !0))), (0, i.tZ)(v ? "oauth_conflict" : "oauth_redirect"), y ? (invariant(!v, "Expected no conflict when third party provider code is present"), (0, l.jsx)(d, {
                    code: y,
                    provider: k,
                    isNewAccount: w
                })) : (invariant(v, "No code and no conflict were reported by the third party provider"), (0, l.jsx)(i.xD, {
                    forceNoScroll: !0,
                    children: (0, l.jsxs)(c.i, {
                        children: [x ? n || (n = (0, l.jsx)(i.TR, {
                            size: "medium"
                        })) : null, (0, l.jsx)(i.v0, {
                            text: p.f.jf,
                            atBottom: !1
                        }), (0, l.jsx)(o.default, {
                            onPress: () => j(),
                            label: p.f.fd
                        })]
                    })
                }))
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => k
        });
        var n = s(0),
            a = s(14),
            o = s(17),
            r = s(29),
            i = s(171),
            c = s(65),
            l = s(89),
            d = s(70),
            u = s(47),
            m = s(74),
            h = s(44),
            p = s(48),
            g = s(1364),
            f = s(855),
            b = s(1);
        const y = n.ReactUtils.lazy((() => s(1373))),
            v = n.ReactUtils.lazy((() => s(1374))),
            w = e => null === e.root || 0 < e.items.length,
            k = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withIntl, n.Hocs.withIdentity, n.Hocs.withErrorBoundary({
                name: "Tag",
                onReset: ({
                    services: e,
                    currentTeam: t,
                    isLimitedAccount: s
                }) => {
                    e.router.goTo((0, a.getPathToCurrentTeamRoot)(t, s))
                }
            }), n.Hocs.withHooks((({
                match: e
            }) => ({
                tagId: e.params.tagId
            }))), n.Hocs.withObservables(["tagId"], (({
                tagId: e,
                services: t
            }) => ({
                tag: t.collections.get(o.Tables.tags).findAndObserve(e)
            }))), n.Hocs.withHooks((({
                services: e,
                tag: t,
                currentTeam: s
            }) => {
                n.React.useEffect((() => {
                    t.isActive && t.openOnSidebar(s)
                }), [t, s, e]);
                return (0, h.Nk)(t)
            })), n.Hocs.withHooks((({
                tag: e
            }) => ({
                viewId: e.id
            }))), (0, d.hp)((({
                viewId: e
            }) => ({
                viewId: e,
                initialState: {
                    disabledOptions: [],
                    groupBy: "project"
                }
            }))), n.Hocs.withObservables(["currentTeam"], (({
                services: e,
                currentTeam: t
            }) => ({
                justEndedTasks: e.uiState.forTeam(t).justEndedTasks
            }))), n.Hocs.withObservables(["filterState", "viewId"], (({
                services: e,
                filterState: t,
                viewId: s
            }) => ({
                tasksPositionMap: t.sort ? n.Rx.of({}) : (0, i.C)(s, e.collections)
            }))), n.Hocs.withObservables(["tag", "filterState", "currentTeam", "justEndedTasks", "tasksPositionMap", "isShowingThePast"], (({
                tag: e,
                filterState: t,
                justEndedTasks: s,
                currentTeam: a,
                tasksPositionMap: o,
                intl: i,
                isShowingThePast: c
            }) => {
                const u = e.tasksInTeam(a);
                return {
                    tasks: (c ? u.allTasks : u.tasks).pipe(n.Rx.switchMap((e => e.extend(...(0, l.Z)((0, d.LB)(t))).observeWithColumns(r.yw))), n.Rx.switchMap((e => (0, r.c_)(t.sort, s, e, i, o)))),
                    activeTasksCounter: e.tasksInTeam(a).activeTasks.pipe(n.Rx.map((e => e.observeCount())))
                }
            })), n.Hocs.withObservables(["currentTeam"], (({
                currentTeam: e
            }) => ({
                singleTasks: e.singleTasks
            }))), n.Hocs.withObservables(["tasks", "singleTasks", "isShowingThePast", "filterState"], (({
                tasks: e,
                singleTasks: t,
                isShowingThePast: s,
                services: {
                    database: a
                },
                intl: o,
                filterState: r
            }) => ({
                projects: "project" === r.groupBy ? (0, c.Dp)(a, e, t, o, {
                    withEnded: s
                }) : n.Rx.of([])
            }))))((e => {
                const {
                    tag: t,
                    setEndedTasksState: s,
                    isShowingThePast: o,
                    toggleShowThePast: r,
                    singleTasks: c,
                    endedTasksStates: l,
                    projects: d,
                    justEndedTasks: k,
                    tasks: x,
                    filterState: j,
                    setFilterState: T,
                    activeTasksCounter: S,
                    viewId: P,
                    tasksPositionMap: _
                } = e, C = n.Hooks.useServices(), R = n.Hooks.useModalState(), {
                    collapsedSectionsStates: A,
                    toggleSectionCollapse: I
                } = (0, h.SK)(), {
                    taskGroups: N,
                    sortedTasks: E
                } = (0, g.U)({
                    sections: [null, ...d],
                    groupTasksBySection: () => "project" === j.groupBy ? (0, h.f5)(x, c) : new Map([
                        [null, x]
                    ]),
                    getTasksForSection: (e, t) => t.get((null == e ? void 0 : e.id) || null) || [],
                    endedTasksStates: l,
                    isShowingThePast: o,
                    listRootId: t.id,
                    collapsedSectionsStates: A,
                    justEndedTasks: k,
                    shouldRenderSection: w
                }), O = (0, h.Or)(a.routeToTagTask), {
                    newTaskFormVisibility: M,
                    newTaskFormProps: D
                } = (0, h.G8)({
                    defaultProject: c,
                    rootRecord: t,
                    taskGroups: N,
                    mapNewTaskOptions: async e => {
                        const s = e.tags || {
                                added: [],
                                removed: []
                            },
                            n = {
                                added: [...s.added, t],
                                removed: s.removed
                            };
                        return Object.assign({}, e, {
                            tags: n
                        })
                    }
                }), H = (0, u.x)(E, t.name), F = (0, p.W$)(N), {
                    stats: Z,
                    renderStatsModal: L
                } = (0, p.bB)({
                    root: t,
                    tasks: x,
                    taskGroups: N,
                    filterState: j
                });
                return (0, b.jsx)(p.MV, {
                    counters: F,
                    children: (0, b.jsx)(p.aq, {
                        stats: Z,
                        children: (0, b.jsx)(m.Z, {
                            rootRecord: t,
                            taskDetailsProps: O,
                            title: t.name,
                            isEnded: t.isArchived,
                            activeTasksCounter: S,
                            color: t.color,
                            openViewMenu: R.open,
                            leftIcon: n.Styling.defaultTagIcon(t.icon),
                            menuTarget: R.target,
                            sortedTasks: E,
                            newTaskFormVisibility: M,
                            newTaskFormProps: D,
                            filterState: j,
                            setFilterState: T,
                            onDragEnd: async e => {
                                const {
                                    destination: t,
                                    source: s
                                } = e;
                                if (!t || !s) return;
                                const n = N.find((e => (0, f.r)(e.root) === s.droppableId)),
                                    a = N.find((e => (0, f.r)(e.root) === t.droppableId));
                                if (!n || !a) return;
                                const o = n.items[e.source.index];
                                invariant(o, "Unexpected missing draggedTask");
                                const r = (0, i.A)(o, a.items, t.index, _, P);
                                await C.database.write((() => C.database.batch(r)))
                            },
                            children: (0, b.jsxs)(b.Fragment, {
                                children: [(0, b.jsx)(v, {
                                    singleTasks: c,
                                    tag: t,
                                    toggleSectionCollapse: I,
                                    collapsedSectionsStates: A,
                                    taskGroups: N,
                                    onSetEndedTasksState: s,
                                    newTaskFormProps: D,
                                    setEndedTasksState: s,
                                    filterState: j
                                }), R.isOpen ? (0, b.jsx)(y, {
                                    tag: t,
                                    isShowingThePast: o,
                                    onToggleThePast: r,
                                    closeMenu: R.close,
                                    saveToCSV: H,
                                    target: R.target
                                }) : null, L()]
                            })
                        })
                    })
                })
            }))
    }, , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => d
        });
        var n = s(0),
            a = (s(53), s(6)),
            o = s(201),
            r = s(43),
            i = (s(252), s(1));
        const c = n.ReactUtils.lazy((() => s(1284))),
            l = n.ReactUtils.lazy((() => s(1285))),
            d = n.Hocs.compose(n.Hocs.memo, n.Hocs.withRemindExpired((({
                onClose: e,
                item: t
            }) => ({
                onExpired: () => e(n.ReactUtils.nullEvent()),
                team: t instanceof n.Model.Models.Team ? t : void 0
            }))))((e => {
                const {
                    onClose: t,
                    onConfirm: s,
                    onCancel: d,
                    item: u,
                    taskAccess: m,
                    startAtEmail: h,
                    initialEmails: p,
                    cancelButtonLabel: g,
                    saveButtonLabel: f,
                    saveEmptyButtonLabel: b,
                    level: y
                } = e, v = n.Hooks.useIntl(), w = u.table === n.Model.Tables.teams, [k, x] = n.React.useState(null != p ? p : [""]), j = n.Hooks.useMultipleValidation([r.Jh], k), [T, S] = n.React.useState(h ? "email" : "code"), [{
                    closeAnimated: P
                }, _] = (0, a.P9)();
                return (0, i.jsx)(i.Fragment, {
                    children: (0, i.jsxs)(a.u_, {
                        ref: _,
                        onClose: t,
                        size: "content",
                        level: y,
                        minWidth: 500,
                        children: [(0, i.jsx)(a.u_.Header, {
                            helpPageUrl: w ? n.ReactUtils.helpUrl(v, "management/team/#team_invite") : void 0,
                            right: null,
                            children: w ? v.f.JT : v.f.zi
                        }), (0, i.jsxs)(a.u_.Content, {
                            keyboardShouldPersistTaps: "handled",
                            children: [(0, i.jsx)(o.Z, {
                                selectedOptionId: T,
                                options: [{
                                    id: "code",
                                    label: v.f.JR
                                }, {
                                    id: "email",
                                    label: v.f.JG
                                }],
                                selectOption: (e, t) => {
                                    S(t)
                                }
                            }), "code" === T ? (0, i.jsx)(c, {
                                item: u,
                                taskAccess: m
                            }) : (0, i.jsx)(l, {
                                setEmails: x,
                                emails: k,
                                onConfirm: e => s({
                                    e,
                                    emails: k,
                                    validation: j,
                                    closeCallback: P
                                }),
                                onClose: t,
                                onCancel: d,
                                validation: j,
                                cancelButtonLabel: g,
                                saveButtonLabel: f,
                                saveEmptyButtonLabel: b,
                                allowMultipleEmails: w
                            })]
                        })]
                    })
                })
            }))
    }, , , , , , , , , , , , , , , , (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(305),
            a = s(173);

        function o(e, t) {
            if (!t) {
                throw (0, n.y4)("Invariant must be used with errorMessage")
            }
            if (!e) {
                const e = (0, n.y4)(t);
                throw e.framesToPop += 1, (0, a.uT)(e), e
            }
        }
        globalThis.invariant = o
    }, , (e, t, s) => {
        "use strict";
        s.d(t, {
            j: () => o
        });
        var n = s(76),
            a = s(16);
        const o = (0, n.appSchema)({
            version: 126,
            tables: [(0, n.tableSchema)({
                name: a.w.businesses,
                columns: [{
                    name: a.o.businesses.name,
                    type: "string"
                }, {
                    name: a.o.businesses.color,
                    type: "string"
                }, {
                    name: a.o.businesses.limits,
                    type: "string"
                }, {
                    name: a.o.businesses.planInfo,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.businesses.paymentInfo,
                    type: "string",
                    isOptional: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.businessMembers,
                columns: [{
                    name: a.o.businessMembers.businessId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.businessMembers.userId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.businessMembers.role,
                    type: "string"
                }, {
                    name: a.o.businessMembers.vacations,
                    type: "string",
                    isOptional: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.teams,
                columns: [{
                    name: a.o.teams.color,
                    type: "string"
                }, {
                    name: a.o.teams.name,
                    type: "string"
                }, {
                    name: a.o.teams.avatarId,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.teams.isPersonal,
                    type: "boolean"
                }, {
                    name: a.o.teams.businessId,
                    type: "string",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.teams.limits,
                    type: "string"
                }, {
                    name: a.o.teams.planInfo,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.teams.paymentInfo,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.teams.isShared,
                    type: "boolean",
                    isIndexed: !0
                }, {
                    name: a.o.teams.sidebarPosition,
                    type: "number"
                }]
            }), (0, n.tableSchema)({
                name: a.w.projects,
                columns: [{
                    name: a.o.projects.authorId,
                    type: "string"
                }, {
                    name: a.o.projects.userColor,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.projects.teamColor,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.projects.createdAt,
                    type: "number"
                }, {
                    name: a.o.projects.description,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.projects.endedAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.projects.isFavorite,
                    type: "boolean",
                    isIndexed: !0
                }, {
                    name: a.o.projects.isOpen,
                    type: "boolean"
                }, {
                    name: a.o.projects.isTemplate,
                    type: "boolean"
                }, {
                    name: a.o.projects.isSingleTasks,
                    type: "boolean"
                }, {
                    name: a.o.projects.lastEventAt,
                    type: "number",
                    isIndexed: !0
                }, {
                    name: a.o.projects.lastSeenEventAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.projects.name,
                    type: "string"
                }, {
                    name: a.o.projects.preferences,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.projects.extra,
                    type: "string"
                }, {
                    name: a.o.projects.sidebarPosition,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.projects.teamId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.projects.sharedTeamId,
                    type: "string",
                    isIndexed: !0,
                    isOptional: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.projectSections,
                columns: [{
                    name: a.o.projectSections.archivedAt,
                    type: "number",
                    isOptional: !0
                }, {
                    name: a.o.projectSections.createdAt,
                    type: "number"
                }, {
                    name: a.o.projectSections.name,
                    type: "string"
                }, {
                    name: a.o.projectSections.position,
                    type: "number"
                }, {
                    name: a.o.projectSections.projectId,
                    type: "string",
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.projectAccesses,
                columns: [{
                    name: a.o.projectAccesses.isManager,
                    type: "boolean"
                }, {
                    name: a.o.projectAccesses.memberId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.projectAccesses.projectId,
                    type: "string",
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.projectEvents,
                columns: [{
                    name: a.o.projectEvents.authorId,
                    type: "string"
                }, {
                    name: a.o.projectEvents.createdAt,
                    type: "number"
                }, {
                    name: a.o.projectEvents.projectId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.projectEvents.type,
                    type: "string"
                }]
            }), (0, n.tableSchema)({
                name: a.w.projectPositions,
                columns: [{
                    name: a.o.projectPositions.listId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.projectPositions.projectId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.projectPositions.position,
                    type: "number"
                }]
            }), (0, n.tableSchema)({
                name: a.w.tasks,
                columns: [{
                    name: a.o.tasks.authorId,
                    type: "string"
                }, {
                    name: a.o.tasks.createdAt,
                    type: "number"
                }, {
                    name: a.o.tasks.commentsCached,
                    type: "number",
                    isOptional: !0
                }, {
                    name: a.o.tasks.dueAt,
                    type: "number",
                    isOptional: !0
                }, {
                    name: a.o.tasks.endedAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tasks.isAbandoned,
                    type: "boolean"
                }, {
                    name: a.o.tasks.isAllDay,
                    type: "boolean"
                }, {
                    name: a.o.tasks.extra,
                    type: "string"
                }, {
                    name: a.o.tasks.isFollowed,
                    type: "boolean",
                    isIndexed: !0
                }, {
                    name: a.o.tasks.lastActivityAt,
                    type: "number",
                    isIndexed: !0
                }, {
                    name: a.o.tasks.lastReviewedAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tasks.lastSeenActivityAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tasks.missedRepeats,
                    type: "number"
                }, {
                    name: a.o.tasks.name,
                    type: "string"
                }, {
                    name: a.o.tasks.priorityPosition,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tasks.projectId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.tasks.projectPosition,
                    type: "number"
                }, {
                    name: a.o.tasks.projectSectionId,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.tasks.recurrenceId,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.tasks.responsibleId,
                    type: "string",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tasks.reviewReason,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.tasks.reviewTriggeredAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tasks.timeNeeded,
                    type: "number"
                }, {
                    name: a.o.tasks.timeSpent,
                    type: "number"
                }, {
                    name: a.o.tasks.recurrenceOriginAt,
                    type: "number",
                    isOptional: !0
                }, {
                    name: a.o.tasks.type,
                    type: "string",
                    isOptional: !0,
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.taskAccesses,
                columns: [{
                    name: a.o.taskAccesses.taskId,
                    type: "string"
                }, {
                    name: a.o.taskAccesses.granteeId,
                    type: "string"
                }, {
                    name: a.o.taskAccesses.granterId,
                    type: "string"
                }, {
                    name: a.o.taskAccesses.granteeType,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.taskAccesses.granteeEmail,
                    type: "string",
                    isOptional: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.taskRecurrences,
                columns: [{
                    name: a.o.taskRecurrences.currentTaskId,
                    type: "string"
                }, {
                    name: a.o.taskRecurrences.pattern,
                    type: "string"
                }, {
                    name: a.o.taskRecurrences.projectId,
                    type: "string"
                }]
            }), (0, n.tableSchema)({
                name: a.w.taskPositions,
                columns: [{
                    name: a.o.taskPositions.taskId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.taskPositions.listId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.taskPositions.position,
                    type: "number"
                }]
            }), (0, n.tableSchema)({
                name: a.w.teamMembers,
                columns: [{
                    name: a.o.teamMembers.alias,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.teamMembers.description,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.teamMembers.isFavorite,
                    type: "boolean",
                    isIndexed: !0
                }, {
                    name: a.o.teamMembers.role,
                    type: "string"
                }, {
                    name: a.o.teamMembers.sidebarPosition,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.teamMembers.status,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.teamMembers.teamId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.teamMembers.userId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.teamMembers.contactInfo,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.teamMembers.vacations,
                    type: "string",
                    isOptional: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.users,
                columns: [{
                    name: a.o.users.avatarId,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.users.color,
                    type: "string"
                }, {
                    name: a.o.users.email,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.users.invitationEmail,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.users.isPlaceholder,
                    type: "boolean"
                }, {
                    name: a.o.users.isLimited,
                    type: "boolean"
                }, {
                    name: a.o.users.name,
                    type: "string"
                }, {
                    name: a.o.users.timeZone,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.users.isMe,
                    type: "boolean"
                }]
            }), (0, n.tableSchema)({
                name: a.w.tags,
                columns: [{
                    name: a.o.tags.userColor,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.tags.teamColor,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.tags.icon,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.tags.isFavorite,
                    type: "boolean",
                    isIndexed: !0
                }, {
                    name: a.o.tags.name,
                    type: "string"
                }, {
                    name: a.o.tags.sidebarPosition,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tags.teamId,
                    type: "string",
                    isOptional: !0,
                    isIndexed: !0
                }, {
                    name: a.o.tags.preferences,
                    type: "string"
                }, {
                    name: a.o.tags.archivedAt,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.tagAssignments,
                columns: [{
                    name: a.o.tagAssignments.tagId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.tagAssignments.taskId,
                    type: "string",
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.memberGroups,
                columns: [{
                    name: a.o.memberGroups.teamId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.memberGroups.isAdminGroup,
                    type: "boolean"
                }, {
                    name: a.o.memberGroups.name,
                    type: "string"
                }]
            }), (0, n.tableSchema)({
                name: a.w.projectGroups,
                columns: [{
                    name: a.o.projectGroups.teamId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.projectGroups.name,
                    type: "string"
                }, {
                    name: a.o.projectGroups.isPrivate,
                    type: "boolean"
                }, {
                    name: a.o.projectGroups.sidebarPosition,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.groupAssignments,
                columns: [{
                    name: a.o.groupAssignments.groupId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.groupAssignments.objectId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.groupAssignments.groupType,
                    type: "string"
                }, {
                    name: a.o.groupAssignments.sidebarPosition,
                    type: "number",
                    isOptional: !0,
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.comments,
                columns: [{
                    name: a.o.comments.authorId,
                    type: "string"
                }, {
                    name: a.o.comments.body,
                    type: "string"
                }, {
                    name: a.o.comments.createdAt,
                    type: "number"
                }, {
                    name: a.o.comments.editedAt,
                    type: "number",
                    isOptional: !0
                }, {
                    name: a.o.comments.extra,
                    type: "string"
                }, {
                    name: a.o.comments.isDeleted,
                    type: "boolean"
                }, {
                    name: a.o.comments.isPinned,
                    type: "boolean"
                }, {
                    name: a.o.comments.isTeam,
                    type: "boolean"
                }, {
                    name: a.o.comments.reactions,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.comments.taskId,
                    type: "string",
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.taskEvents,
                columns: [{
                    name: a.o.taskEvents.authorId,
                    type: "string"
                }, {
                    name: a.o.taskEvents.createdAt,
                    type: "number"
                }, {
                    name: a.o.taskEvents.change,
                    type: "string"
                }, {
                    name: a.o.taskEvents.taskId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.taskEvents.integration,
                    type: "string",
                    isOptional: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.reminders,
                columns: [{
                    name: a.o.reminders.taskId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.reminders.remindAt,
                    type: "number",
                    isIndexed: !0
                }, {
                    name: a.o.reminders.isRelative,
                    type: "boolean",
                    isIndexed: !0
                }, {
                    name: a.o.reminders.isAllDay,
                    type: "boolean"
                }]
            }), (0, n.tableSchema)({
                name: a.w.settings,
                columns: [{
                    name: a.o.settings.teamId,
                    type: "string",
                    isIndexed: !0,
                    isOptional: !0
                }, {
                    name: a.o.settings.name,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.settings.value,
                    type: "string"
                }]
            }), (0, n.tableSchema)({
                name: a.w.attachments,
                columns: [{
                    name: a.o.attachments.parentId,
                    type: "string",
                    isIndexed: !0
                }]
            }), (0, n.tableSchema)({
                name: a.w.attachmentVersions,
                columns: [{
                    name: a.o.attachmentVersions.name,
                    type: "string"
                }, {
                    name: a.o.attachmentVersions.size,
                    type: "number"
                }, {
                    name: a.o.attachmentVersions.status,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.attachmentVersions.integrationType,
                    type: "string",
                    isOptional: !0
                }, {
                    name: a.o.attachmentVersions.mimeType,
                    type: "string"
                }, {
                    name: a.o.attachmentVersions.extra,
                    type: "string"
                }, {
                    name: a.o.attachmentVersions.attachmentId,
                    type: "string",
                    isIndexed: !0
                }, {
                    name: a.o.attachmentVersions.authorId,
                    type: "string"
                }, {
                    name: a.o.attachmentVersions.createdAt,
                    type: "number"
                }]
            })]
        })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        var n = s(95),
            a = s(1151);
        s(515);

        function o(e, t) {
            const o = (0, a.ri)(t);
            if (o.performance.markInit(e), (0, a.be)(o), globalThis.electron) {
                const e = new(0, s(1279).Z)(o);
                globalThis.electron.setBridge(((t, s) => e.call(t, s)))
            } {
                const e = "font-family: 'SFMono-Regular', 'Roboto Mono', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;";
                (0, n.Z)("ad").log("%cwe're hiring", e + "color: #FFFFFF;background: #3F0756;text-shadow: -5px 5px 0px #E675DF, -10px 10px 0px #AE29CC, -15px 15px 0px #74147E;font-weight: bold;padding: 20px 40px;font-size: 50px;"), (0, n.Z)("ad").log("%cdev@nozbe.com", e + "padding: 15px 60px; font-size: 25px; background: #eee; color: #360550;")
            }
            return setTimeout((() => s(403).I()), 0), setTimeout((() => s(1280).Z()), 1), setTimeout((() => s(1281).Z(o)), 2), setTimeout((() => s(1316).Z(o)), 10), o
        }
    }, , , , , , , , , , , , (e, t, s) => {
        "use strict";

        function n(e) {
            return e.getFullYear() + "-" + a(e.getMonth() + 1) + "-" + a(e.getDate())
        }
        s.d(t, {
            Z: () => n
        });
        const a = e => 10 > e ? "0" + e : "" + e
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            E4: () => r,
            Kz: () => c,
            _v: () => d,
            o6: () => l,
            rS: () => i,
            vn: () => o
        });
        var n = s(8);
        const a = null == globalThis.matchMedia ? void 0 : globalThis.matchMedia("(prefers-color-scheme: dark)");

        function o() {
            return null != a && a.matches ? "dark" : "light"
        }

        function r(e) {
            if (a) {
                const t = () => {
                    e(o())
                };
                return a.addListener(t), () => a.removeListener(t)
            }
            return () => {}
        }
        const i = new n.BehaviorSubject(o());

        function c(e) {
            i.subscribe((t => {
                const s = e.document.documentElement;
                s && (s.dataset.theme = t)
            }))
        }

        function l() {}

        function d(e) {
            i.next(e)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => n
        });
        const n = ({
            children: e
        }) => e
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            $: () => l,
            c: () => c
        });
        const n = e => "number" != typeof e || 0 > e ? 1 / 0 : e,
            a = 1048576;

        function o(e, t) {
            return e ? n(e) : t.isFree ? 10 * a : 200 * a
        }
        const r = (e, t) => ({
                openProjects: n(e.projects_open),
                sharedProjects: n(e.projects_shared),
                projectTemplates: n(e.project_templates),
                projectSections: n(e.project_sections),
                sharedTags: n(e.tags),
                privateTags: n(e.private_tags),
                teamAdmins: n(e.team_admins),
                teamMembers: n(e.team_members),
                memberGroups: n(e.member_groups),
                projectGroups: n(e.project_groups),
                maxAttachmentSize: o(e.max_attachment_size, t)
            }),
            i = {
                projects_open: -1,
                projects_shared: -1,
                project_sections: -1,
                project_templates: -1,
                tags: -1,
                private_tags: -1,
                team_admins: -1,
                team_members: -1,
                member_groups: -1,
                project_groups: -1
            },
            c = {
                openProjects: 3,
                sharedProjects: 0,
                projectTemplates: 1,
                projectSections: 3,
                sharedTags: 3,
                privateTags: 0,
                teamAdmins: 0,
                teamMembers: 3,
                projectGroups: 0,
                memberGroups: 0
            };

        function l(e, t) {
            return r("object" != typeof e ? i : e, t)
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => v
        });
        var n, a = s(24),
            o = s(19),
            r = s(33),
            i = s(4),
            c = (s(5), s(8)),
            l = s(39),
            d = s(21),
            u = s(194),
            m = s(280),
            h = s(16),
            p = s(29),
            g = s(1233),
            f = s(1236),
            b = s(476);
        const y = (e, t, s) => (0, a.Z)(e.prototype, t, s, Object.getOwnPropertyDescriptor(e.prototype, t), e.prototype);
        let v = (y(n = class {
            get asModel() {
                return this.project
            }
            get database() {
                return this.project.database
            }
            constructor(e) {
                this.project = e
            }
            async getProjectPositionForForm(e, t) {
                const {
                    project: s
                } = this;
                return (0, l.getNewPositionForForm)({
                    position: e,
                    list: t,
                    getTopPosition: () => s.getTopPosition(),
                    getBottomPosition: () => s.getBottomPosition(),
                    selector: e => e.projectPosition,
                    updater: (e, t) => {
                        e.projectPosition = t
                    }
                })
            }
            createProjectPosition(e, t) {
                const {
                    project: s
                } = this;
                return s.collections.get(h.w.projectPositions).prepareCreate((n => {
                    n.project.set(s), n.position = t, n.listId = e
                }))
            }
            async _getTopPriorityPosition() {
                const {
                    project: e
                } = this;
                return (await e.getCurrentTeam()).do.getTopPriorityPosition()
            }
            async addTask(e) {
                const {
                    project: t
                } = this;
                t._ensureNotEnded();
                const {
                    name: s,
                    isPriority: n,
                    responsibleId: a,
                    granteeEmail: o,
                    projectSectionId: r,
                    projectPosition: i,
                    priorityPosition: c,
                    dueDate: l,
                    skipDueDateSanitization: g,
                    recurrence: f,
                    reminders: b,
                    shouldCheckAccess: y,
                    reviewReason: v,
                    tags: w,
                    comment: k,
                    endedAt: x,
                    fromCommentId: j
                } = Object.assign({}, p.PB, e);
                invariant(b, "reminders should be present"), invariant(s, "Options for new task must have at least name"), l && invariant(a, "Responsible must be set if due date is set");
                const T = !g && t.isTemplate && l ? (0, d.toRelativeDateTime)(l) : l,
                    S = await t._me,
                    P = null != i ? i : await t.getTopPosition(),
                    _ = n ? null != c ? c : await this._getTopPriorityPosition() : null,
                    C = y && a ? await t.collections.get(h.w.teamMembers).find(a) : null,
                    R = !!C && !await t.permissions.doesMemberHaveAccess(C);
                invariant(!R || C !== S, "Grantee cannot be the same member as granter");
                const A = t.collections.get(h.w.tasks).prepareCreate((e => {
                        e._project.id = t.id, e.projectSection.id = r, e.projectPosition = P, e.author.set(S), e.lastActivityAt = e.createdAt, e.lastSeenActivityAt = e.createdAt, e.name = s, e.responsible.id = a, e.dates.dueDate = T, e.priorityPosition = _, e.isFollowed = !0, e.unsafeSetReviewReason(v), e.endedAt = x, v || t.isTemplate || !T || a !== S.id || ((0, u.Z)(T.local) || (0, m.Z)(T.local)) && e.unsafeSetReviewReason("due_date")
                    })),
                    I = R && C ? {
                        member: C
                    } : o ? {
                        email: o
                    } : null;
                return await t.batch(A, A.do._prepareEvent({
                    created: !0
                }, S, {
                    when: A.createdAt
                }), I ? A.do._prepareAccess(I, S) : void 0), k && await t.callWriter((async () => {
                    const e = await A.timeline.do.addComment(k);
                    j && e.do.markAsClonedFromId(j)
                })), await t.callWriter((() => A.dates.do.updateReminders(b))), A.isActive && await t.callWriter((() => A.dates.do.updateRecurrence(f))), null != w && w.added.length && await t.callWriter((() => A.do.updateTags(w))), A
            }
            async _getLastSectionPosition() {
                const {
                    project: e
                } = this, t = await e.activeSections.fetch();
                return i.getLastPosition(t, (e => e.position))
            }
            async createSection({
                name: e,
                position: t,
                archivedAt: s
            }) {
                const {
                    project: n
                } = this;
                invariant(await n.canCreateSection(), "Sections limit has been reached"), n._ensureNotSingleTasks(), n._ensureNotEnded();
                const a = null != t ? t : await this._getLastSectionPosition();
                return n.collections.get(h.w.projectSections).create((t => {
                    t.project.id = n.id, t.position = a, t.name = e, t.archivedAt = s
                }))
            }
            async updateDescription(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), t._ensureNotEnded(), await t.update((() => {
                    t.description = e || null
                }))
            }
            async updateHidePurpose(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), await t.update((() => {
                    t.preferences = Object.assign({}, t.preferences, {
                        [f.u.shouldHidePurpose]: e
                    })
                }))
            }
            async updateProposeUnfollow(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), await t.update((() => {
                    t.preferences = Object.assign({}, t.preferences, {
                        [f.u.shouldProposeUnfollow]: e
                    })
                }))
            }
            async updateUseTeamColor(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), await t.update((() => {
                    t.preferences = Object.assign({}, t.preferences, {
                        [f.u.shouldUseTeamColor]: e
                    })
                }))
            }
            async updateGroups({
                added: e,
                removed: t
            }) {
                const {
                    project: s
                } = this, n = i.pluckIds(t), a = await s.groupAssignments.extend(o.Q.where(h.o.groupAssignments.groupId, o.Q.oneOf(n))).fetch();
                await s.batch(...e.map((e => s.collections.get(h.w.groupAssignments).prepareCreate((t => {
                    t._project.set(s), t.groupType = "project", t._projectGroup.set(e)
                })))), ...a.map((e => e.prepareMarkAsDeleted())))
            }
            async rename(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), t._ensureNotEnded(), await t._ensureCanBeEdited(), await t.update((() => {
                    t._name = e
                }))
            }
            async updateUserColor(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), t._ensureNotEnded(), await t.update((() => {
                    t.userColor = e
                }))
            }
            async updateTeamColor(e) {
                const {
                    project: t
                } = this;
                t._ensureNotSingleTasks(), t._ensureNotEnded(), await t._ensureCanBeEdited(), await t.update((() => {
                    t.teamColor = e
                }))
            }
            async markAsSeen() {
                const {
                    project: e
                } = this;
                e.hasUnseenEvents && e.update((() => {
                    this._markAsSeen()
                }))
            }
            async markAsSeenWithTasks(e) {
                const {
                    project: t
                } = this;
                await t.batch(t.prepareUpdate((() => {
                    this._markAsSeen()
                })), ...e.map((e => e.prepareUpdate((() => {
                    e.do._markAsRead()
                })))))
            }
            async markAsNotSeenWithTasks(e) {
                const {
                    project: t
                } = this;
                await t.batch(t.prepareUpdate((() => {
                    this._markAsNotSeen()
                })), ...e.map((e => e.prepareUpdate((() => {
                    e.do.markAsUnread()
                })))))
            }
            _markAsSeen() {
                const {
                    project: e
                } = this;
                e.hasUnseenEvents && (e.lastSeenEventAt = e.lastEventAt)
            }
            _markAsNotSeen() {
                const {
                    project: e
                } = this;
                e.hasUnseenEvents || (e.lastSeenEventAt = null)
            }
            async _markEndedTasksAsRead() {
                const {
                    project: e
                } = this, t = await e.endedTasks.extend(p.DY).fetch();
                await e.batch(...t.map((e => e.prepareUpdate((() => {
                    e.do._markAsRead()
                })))))
            }
            async end() {
                const {
                    project: e
                } = this;
                e._ensureNotSingleTasks();
                const t = await e._me;
                if (e.isActive) {
                    const s = new Date;
                    await e.batch(e.prepareUpdate((() => {
                        e.endedAt = s, this._bumpLastEventAt(s)
                    })), this._prepareEvent("ended", t, {
                        when: s
                    }))
                }
            }
            async restore() {
                const {
                    project: e
                } = this;
                e._ensureNotSingleTasks(), e.isShared && invariant(await e.isHostSharedProject, "Project can be restored only by the host");
                const t = await e.team.fetch();
                if (invariant(e.permissions.isOpen ? t.canCreateOpenProjects() : t.canInviteToProject(), "Can't restore project#" + e.id + " - limit has been reached"), e.isEnded) {
                    const t = new Date,
                        s = await e._me;
                    await e.batch(e.prepareUpdate((() => {
                        e.endedAt = null, this._bumpLastEventAt(t)
                    })), this._prepareEvent("restored", s, {
                        when: t
                    }));
                    const n = await c.takeFirst(e.permissions.members),
                        a = i.pluckIds(n);
                    await (0, p.yN)(e.activeTasks.extend(o.Q.where(h.o.tasks.responsibleId, o.Q.notIn(a))))
                }
            }
            _prepareEvent(e, t, {
                when: s
            }) {
                const {
                    project: n
                } = this;
                return n._ensureNotSingleTasks(), n.collections.get(h.w.projectEvents).prepareCreate((a => {
                    a.author.set(t), a.project.id = n.id, a.createdAt = s, a.type = e
                }))
            }
            _bumpLastEventAt(e) {
                const {
                    project: t
                } = this;
                t.lastEventAt = e, t.lastSeenEventAt = e
            }
            async clone(e) {
                return s(920).D(this.project, e)
            }
            copy(e) {
                return s(920).J(this.project, e)
            }
            async setInvitation(e, t) {
                await this.project.update((s => {
                    s.extra = Object.assign({}, s.extra, {
                        [g.k.invitation]: {
                            status: b.m.Pending,
                            email: t,
                            invited_by: e.id
                        }
                    })
                }))
            }
            async clearInvitation() {
                this.project.extra[g.k.invitation] && await this.project.update((e => {
                    e.extra = Object.assign({}, e.extra, {
                        [g.k.invitation]: void 0
                    })
                }))
            }
            async setAreTimeAttributesEnabled(e) {
                e && invariant(await this.project.canEnableTimeAttributes(), "Cannot enable time attributes for project"), await this.project.update((t => {
                    t.extra = Object.assign({}, t.extra, {
                        [g.k.areTimeAttributesEnabled]: e
                    })
                }))
            }
            async unshare() {
                const {
                    project: e
                } = this;
                e._ensureNotEnded(), e._ensureIsShared(), await e._ensureCanBeEdited(), await e.update((() => {
                    e.sharedTeam.set(null)
                }))
            }
            async markAsClonedFromId(e) {
                await this.project.update((t => {
                    t.extra = Object.assign({}, t.extra, {
                        [g.k.clonedFromId]: e
                    })
                }))
            }
        }, "addTask", [r.writer]), y(n, "createSection", [r.writer]), y(n, "updateDescription", [r.writer]), y(n, "updateHidePurpose", [r.writer]), y(n, "updateProposeUnfollow", [r.writer]), y(n, "updateUseTeamColor", [r.writer]), y(n, "updateGroups", [r.writer]), y(n, "rename", [r.writer]), y(n, "updateUserColor", [r.writer]), y(n, "updateTeamColor", [r.writer]), y(n, "markAsSeen", [r.writer]), y(n, "markAsSeenWithTasks", [r.writer]), y(n, "markAsNotSeenWithTasks", [r.writer]), y(n, "_markEndedTasksAsRead", [r.writer]), y(n, "end", [r.writer]), y(n, "restore", [r.writer]), y(n, "clone", [r.writer]), y(n, "copy", [r.writer]), y(n, "setInvitation", [r.writer]), y(n, "clearInvitation", [r.writer]), y(n, "setAreTimeAttributesEnabled", [r.writer]), y(n, "unshare", [r.writer]), y(n, "markAsClonedFromId", [r.writer]), n)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            K: () => o,
            n: () => a
        });
        var n = s(9);
        const a = n.createContext(void 0);

        function o() {
            const e = n.useContext(a);
            return invariant(e, "Right pane is not wrapped in a context provider"), e
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            p: () => a
        });
        var n = s(0);
        const a = e => n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(["filterState"], (({
            filterState: {
                filterProject: e,
                filterProjects: t,
                filterResponsibles: s,
                filterSection: a,
                filterTags: o,
                filterGroups: r
            },
            services: i
        }) => ({
            project: e ? i.collections.get(n.Model.Tables.projects).findAndObserve(e) : n.Rx.of(null === e ? null : void 0),
            projects: t ? n.Rx.combineLatest(t.map((e => i.collections.get(n.Model.Tables.projects).findAndObserve(e)))) : n.Rx.of([]),
            projectSection: a ? i.collections.get(n.Model.Tables.projectSections).findAndObserve(a) : n.Rx.of(null === a ? null : void 0),
            teamMembers: s ? n.Rx.combineLatest(s.map((e => e ? i.collections.get(n.Model.Tables.teamMembers).findAndObserve(e) : n.Rx.of(null)))) : n.Rx.of(s || void 0),
            tags: o ? n.Rx.combineLatest(o.map((e => e ? i.collections.get(n.Model.Tables.tags).findAndObserve(e) : n.Rx.of(null)))) : n.Rx.of([]),
            groups: r ? n.Rx.combineLatest(r.map((e => e ? i.collections.get(n.Model.Tables.projectGroups).findAndObserve(e) : n.Rx.of(null)))) : n.Rx.of([])
        }))), n.Hocs.withObservables(["teamMembers", "filterState"], (({
            teamMembers: e
        }) => ({
            responsibleNames: e ? n.Rx.combineLatest(e.map((e => e ? e.preferredName : n.Rx.of(null)))) : n.Rx.of([])
        }))))(e)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Hd: () => i,
            Jp: () => c,
            NM: () => p,
            R5: () => l,
            SM: () => h,
            _k: () => f,
            i0: () => g,
            og: () => u,
            rZ: () => b,
            xn: () => m,
            xw: () => d
        });
        var n = s(0),
            a = s(21),
            o = s(309),
            r = s(494);

        function i(e, t) {
            return t.map((t => n.Styling.getProjectName(t, e))).join(", ")
        }

        function c(e, t) {
            return t ? t.name : null === t ? e.f.Ie : ""
        }

        function l(e, t) {
            return t.map((t => t || e.f.zp)).join(", ")
        }

        function d(e, t) {
            return t.map((t => t ? t.name : e.f.Il)).join(", ")
        }

        function u({
            intl: e,
            filterDueDate: t,
            filterDueDateStart: s,
            filterDueDateEnd: i,
            filterDueDateRelative: c,
            filterDueDateOverdue: l
        }) {
            function d(t) {
                return (0, a.formatDateTime)({
                    dateTime: t,
                    intl: e,
                    format: "numeric"
                })
            }
            if (null === t) return e.f.H$;
            if (l) return e.f.nx;
            if ((0, r.Mf)(t)) {
                if (c) {
                    const s = (0, o.US)(t, !0);
                    return s ? function(t) {
                        return n.FP.capitalize((0, a.formatDateTimeRelativeFromNow)({
                            dateTime: t,
                            intl: e
                        }))
                    }(s) : ""
                }
                return invariant("number" != typeof t, "Expected due date to be a DateTime"), d(t)
            }
            return s && i ? e.g("H8", {
                start: d(s),
                end: d(i)
            }) : s && !i ? e.g("H4", {
                date: d(s)
            }) : !s && i ? e.g("H6", {
                date: d(i)
            }) : ""
        }

        function m(e, t) {
            return void 0 === t ? "" : t ? e.f.Ic : e.f.Id
        }

        function h(e, t) {
            return void 0 === t ? "" : t ? e.f.Ic : e.f.Id
        }

        function p(e, t) {
            return void 0 === t ? "" : t ? e.f.If : e.f.Ig
        }

        function g(e, t) {
            return t.map((t => t ? t.name : e.f.H_)).join(", ")
        }

        function f(e, t, s) {
            switch (t) {
                case "assignee":
                    return e.g("EQ", {
                        order: s
                    });
                case "dueDate":
                    return e.g("EU", {
                        order: s
                    });
                case "name":
                    return e.g("EW", {
                        order: s
                    });
                case "lastActivityAt":
                    return e.g("EV", {
                        order: s
                    });
                case "createdAt":
                    return e.g("ES", {
                        order: s
                    });
                case "comments":
                    return e.g("ER", {
                        order: s
                    });
                case "timeNeeded":
                    return e.g("EX", {
                        order: s
                    });
                case "timeSpent":
                    return e.g("EY", {
                        order: s
                    });
                default:
                    return ""
            }
        }

        function b(e, t) {
            return "project" === t ? e.f.us : ""
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(5),
            a = (s(4), s(8), s(164)),
            o = s(173),
            r = s(37);
        async function i(e, {
            skipAppStateChange: t = !1,
            skipNotificationsRegister: s = !1
        }) {
            const i = e => {
                    try {
                        e()
                    } catch (e) {
                        n.logError("diagnostic error", e)
                    }
                },
                l = async e => {
                    try {
                        await e()
                    } catch (e) {
                        n.logError("diagnostic error", e)
                    }
                };
            if (await e.localStorage.get(r.d.hasUnfinishedLogin)) return await e._forceLogOut({
                reason: "unfinished login"
            }), null;
            e._isServiceMode = !1;
            const [d] = await e.modelRoot._currentUserQuery.fetch();
            if (!d) return await e._forceLogOut({
                shouldPushHistory: !1,
                reason: "ensure not logged in"
            }), null;
            const u = await e.keychain.apiToken,
                m = await e.localStorage.get(r.d.syncDisabled);
            if (!u && !0 !== m) return await e._forceLogOut({
                reason: "no api token"
            }), null;
            await l((() => {
                e.themeSettings.restoreUserTheme()
            })), i((() => {
                e.ab.unsafeUserId = d.id
            })), t || e.appState.isLoggedIn.next(!0);
            const h = await e.modelRoot.teams.fetch();
            return i((() => (0, o.v)(e._launchId, d, h))), s || d.isLimited || (0, a.R)((() => l((() => e.notifications.register((async () => {
                if (!await e.api.isAuthenticated()) return;
                const t = await e.api.getVapidPublicKey();
                t && await e.native.serviceWorker.subscribeToNotifications(t)
            })))))), l((() => e.localization.enableLocaleSync())), (0, a.R)((async () => {
                const [t] = await e.modelRoot._currentUserQuery.fetch();
                t ? (l((() => e.uploader.clearAbortedUploads())), i((() => e.uploader.run())), i((() => e.sync.setAutoSyncEnabled(function(e, t) {
                    return !e.isServiceMode && !t.some((e => c.includes(e.id)))
                }(e, h)))), l((async () => {
                    await e.persistSystemSettings(), await e.sync.synchronize()
                })), i((() => {
                    e.serverLink.initialize()
                })), globalThis.electron && (l((async () => {
                    if ("mac" === globalThis.electron.platform) {
                        const t = await e.modelRoot.settings.isTrayEnabled.fetch();
                        globalThis.electron.setTrayEnabled(t)
                    } else globalThis.electron.setTrayEnabled(!0)
                })), l((async () => {
                    await e.modelRoot.settings.updateLastUsedDesktopAt()
                }))), l((async () => {}))) : n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] abort restoreUserSession, logged out")
            })), n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] Logged in"), d
        }
        const c = ["9JX1kC2ik2hNhNuQ"]
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => l
        });
        var n = s(5),
            a = s(4),
            o = (s(8), s(237)),
            r = s(173),
            i = s(181),
            c = s(510);

        function l(e, {
            shouldPushHistory: t = !0,
            pathToPush: s = {
                path: "/",
                state: void 0
            },
            reason: l,
            skipRemovingCaches: d
        }) {
            return e.db.write((async () => {
                n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.NO_PRIVATE).log("[Services] Forcing log out (reason: " + l + ")");
                let u = !1;
                const m = e => {
                        try {
                            e()
                        } catch (e) {
                            n.logError("diagnostic error", e), u = !0
                        }
                    },
                    h = async e => {
                        try {
                            await e()
                        } catch (e) {
                            n.logError("diagnostic error", e), u = !0
                        }
                    }, p = t => {
                        t.preventDefault();
                        const s = e.localization.formatMessage("C6");
                        return t.returnValue = s, s
                    };
                m((() => globalThis.addEventListener("beforeunload", p))), m((() => e.appState.finishAcceptingProjectInvitation())), m((() => e.appState.finishAcceptingTeamInvitation())), m((() => e.appState.finishAcceptingTaskInvitation())), m((() => e.appState.finishAcceptingAccountMerge())), m((() => e.appState.isLoggedIn.getValue() && e.appState.isLoggingOut.next(!0))), m((() => e.appState.isLoggedIn.next(!1))), n.isElectron && m((() => {
                    e.scenes.forEach(((e, t) => {
                        var s;
                        0 < t && (null == (s = e.webWindow) || s.close())
                    }))
                })), m((() => {
                    e.ab.unsafeUserId = null, e.ab.unsafeTeamId = null
                })), m((() => e.sync.setAutoSyncEnabled(!1))), m((() => e.uploader.abort())), m((() => e.resources.invalidate())), m((() => e.scenes.forEach((e => e._forceLogOut())))), m((() => e.serverLink.invalidate())), h((() => e.localization.disableLocaleSync())), await a.delay(100), await h((() => e.db.unsafeResetDatabase())), await a.delay(10), m((() => {
                    e.modelRoot = new o.default(e.database)
                })), m((() => {
                    e.uploader = e._makeUploader()
                })), m((() => {
                    e.resources = new c.Z(e.api)
                })), m((() => {
                    const e = null == globalThis ? void 0 : globalThis.localStorage;
                    if (e) {
                        const t = "nozbe_teams_logout_info",
                            s = (() => {
                                try {
                                    return Array.from(JSON.parse(e.getItem(t) || "")).slice(-10)
                                } catch (e) {
                                    return []
                                }
                            })(),
                            n = (() => {
                                try {
                                    const t = [];
                                    for (let s = 0; s < e.length; s += 1) {
                                        const n = e.key(s) || "?";
                                        n.startsWith("enduring_") && t.push([n, e.getItem(n) || ""])
                                    }
                                    return t
                                } catch (e) {
                                    return []
                                }
                            })();
                        e.clear(), s.push({
                            at: Date.now(),
                            reason: l
                        }), e.setItem(t, JSON.stringify(s)), n.forEach((([t, s]) => {
                            e.setItem(t, s)
                        }))
                    }
                })), m((() => e.keychain.clear())), m((() => e.notifications.unregister())), d || m((() => e.native.removeAllCaches())), m((() => e.native.cancelNativeNetworkingOperations())), m((() => (0, r.v)(e._launchId, null, []))), m((() => e.scenes.forEach((e => {
                    e.history.clean(), t && e.history.unsafePushWithoutPrefetch(s.path, s.state)
                })))), m((() => e.native.removeAllUserActivities())), m((() => {
                    e.native.supportsBadge && e.native.updateBadgeCount(0)
                })), m((() => globalThis.removeEventListener("beforeunload", p))), m((() => e.payments.requirements.clear())), m((() => e.appState.isLoggingOut.next(!1))), u && (await (0, i.Z)(e.localization.formatMessage("C8")), globalThis.location.reload()), n.PROD_CONSOLE(n.PROD_CONSOLE_REASON.SAFE_LITERAL).log("[Services] Logged out")
            }))
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => o
        });
        s(4), s(8);
        var n = s(5),
            a = (s(17), s(514));
        class o {
            constructor(e) {
                this._api = e
            }
            async checkEmailAvailability({
                email: e,
                serverUrl: t
            }) {
                t && await this._api.setServerUrl(t);
                const s = await this._api._fetch(["email_availability"], {
                    method: "POST",
                    body: JSON.stringify({
                        email: e
                    })
                });
                try {
                    const e = await s.json();
                    return {
                        isAvailable: e.is_available,
                        isRegisteredInNP: e.is_available && e.is_np_account
                    }
                } catch (e) {
                    return {
                        isAvailable: !1,
                        isRegisteredInNP: !1
                    }
                }
            }
            async getAccountToken({
                tokenType: e,
                tokenId: t,
                serverUrl: s
            }) {
                s && await this._api.setServerUrl(s);
                const n = await this._api._fetch(["token_status", e, t]);
                try {
                    const e = await n.json();
                    return {
                        email: e.email,
                        teamName: e.team_name,
                        teamId: e.team_id,
                        inviterName: e.inviter_name,
                        inviterEmail: e.inviter_email,
                        inviterAvatarUrl: e.inviter_avatar_url,
                        teamAvatarUrl: e.team_avatar_url,
                        providers: e.providers
                    }
                } catch (e) {
                    return {
                        email: "",
                        teamName: "",
                        teamId: null,
                        inviterName: "",
                        inviterEmail: "",
                        inviterAvatarUrl: null,
                        teamAvatarUrl: null,
                        providers: null
                    }
                }
            }
            async _setApiTokenFromResponse(e) {
                const t = await e.json();
                invariant("string" == typeof t, "Invalid response"), this._api._keychain.apiToken = t
            }
            async authThirdParty({
                email: e,
                password: t,
                otp: s,
                integrationToken: n,
                thirdPartyName: a
            }) {
                const o = await this._api._fetch([a, "auth", ""], {
                    method: "POST",
                    body: JSON.stringify({
                        email: e,
                        password: t,
                        otp: s,
                        code: n
                    })
                });
                if (202 === o.status) return {
                    needsOTP: !0
                };
                const {
                    teams: r,
                    token: i,
                    id: c
                } = await o.json();
                return {
                    needsOTP: !1,
                    teams: r,
                    authenticationToken: i,
                    patchToken: c
                }
            }
            async pickTeamForThirdParty({
                teamId: e,
                patchToken: t,
                thirdPartyName: s,
                authenticationToken: n
            }) {
                await this._api._fetch([s, "auth", t], {
                    method: "PATCH",
                    body: JSON.stringify({
                        team_id: e
                    }),
                    headers: Object.assign({}, await this._api._headers(), {
                        Authorization: n
                    })
                })
            }
            async getThirdPartyMembers({
                teamId: e,
                thirdPartyName: t
            }) {
                const {
                    third_party_members: s
                } = await this._api._fetchJSON([t, "invite", e], {
                    method: "GET"
                });
                return {
                    thirdPartyMembers: s
                }
            }
            async inviteThirdPartyMembers({
                teamId: e,
                thirdPartyName: t,
                thirdPartyMembers: s
            }) {
                await this._api._fetch([t, "invite", e], {
                    method: "POST",
                    body: JSON.stringify({
                        selected_users: s
                    })
                })
            }
            async verifySignInWithAppleTokens({
                code: e,
                idToken: t,
                user: s,
                state: n
            }) {
                try {
                    const o = (0, a.hv)({
                            code: e,
                            id_token: t,
                            user: s,
                            state: n
                        }),
                        r = await this._api._fetchJSON(["apple-signin"], {
                            method: "POST",
                            body: o,
                            headers: Object.assign({}, await this._api._headers(), {
                                "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
                            })
                        });
                    return {
                        code: r.code,
                        isNewAccount: r.is_new
                    }
                } catch (e) {
                    var o;
                    if (409 === (null == (o = e.originalResponse) ? void 0 : o.status)) return {
                        conflict: !0
                    };
                    throw e
                }
            }
            async verifyGoogleSignIn({
                code: e,
                state: t
            }) {
                invariant(n.platform.isMacElectron, "Web verification should be handled via redirect to backend");
                try {
                    const s = await this._api._fetchJSON(["google-signin"], {}, {
                        code: e,
                        platform: n.platformName,
                        state: t
                    });
                    return {
                        code: s.code,
                        isNewAccount: s.is_new
                    }
                } catch (e) {
                    var s;
                    if (409 === (null == (s = e.originalResponse) ? void 0 : s.status)) return {
                        conflict: !0
                    };
                    throw e
                }
            }
            async authenticateWithThirdParty({
                code: e,
                idToken: t,
                name: s,
                teamName: n,
                inviteCode: a,
                provider: o,
                marketingConsent: r
            }) {
                const i = await this._api._fetch(["login", "oauth"], {
                    method: "POST",
                    body: JSON.stringify({
                        provider: o,
                        code: e,
                        name: s,
                        id_token: t,
                        team_name: n,
                        invite_code: a,
                        marketing_consent: r
                    }),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0
                    }))
                });
                return await this._setApiTokenFromResponse(i), {
                    needsOTP: !1
                }
            }
            async basicAuthenticate({
                email: e,
                password: t,
                otp: s,
                userId: n,
                apiToken: a
            }) {
                n && invariant(!1, "Authenticating using userId is not allowed in production builds");
                const o = await this._api._fetch(["login"], {
                    method: "POST",
                    body: JSON.stringify(Object.assign({
                        email: e,
                        password: t,
                        otp: s
                    }, n ? {
                        user_id: n
                    } : {})),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0,
                        apiToken: a
                    }))
                });
                return 202 === o.status ? {
                    needsOTP: !0
                } : (await this._setApiTokenFromResponse(o), {
                    needsOTP: !1,
                    isServiceMode: !!n
                })
            }
            async setUp2FA({
                password: e,
                type: t,
                phoneNumber: s
            }) {
                const {
                    is_2fa_confirmed: n,
                    "2fa_secret": a,
                    "2fa_type": o,
                    url: r,
                    "2fa_recovery_codes": i,
                    qr_image: c
                } = await this._api._fetchJSON(["2fa"], {
                    method: "POST",
                    body: JSON.stringify({
                        password: e,
                        type: t,
                        phone_number: s
                    })
                });
                return {
                    is2faConfirmed: n,
                    secret: a,
                    url: r,
                    type: o,
                    recoveryCodes: i,
                    qr: c
                }
            }
            async get2FA() {
                const {
                    is_2fa_confirmed: e,
                    type: t
                } = await this._api._fetchJSON(["2fa"]);
                return {
                    is2faConfirmed: e,
                    type: t
                }
            }
            async confirm2FA({
                otp: e
            }) {
                const t = await this._api._fetch(["2fa"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        otp: e
                    })
                });
                await this._setApiTokenFromResponse(t)
            }
            async delete2FA({
                password: e
            }) {
                const t = await this._api._fetch(["2fa"], {
                    method: "DELETE",
                    body: JSON.stringify({
                        password: e
                    })
                });
                await this._setApiTokenFromResponse(t)
            }
            async changePassword({
                user: e,
                password: t,
                currentPassword: s
            }) {
                const n = await this._api._fetch(["account", e.id, "password"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        password: t,
                        current_password: s
                    })
                });
                await this._setApiTokenFromResponse(n)
            }
            async changeEmail({
                user: e,
                password: t,
                email: s
            }) {
                await this._api._fetch(["account", e.id, "email"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        password: t,
                        email: s
                    })
                })
            }
            async confirmEmailChange({
                confirmId: e
            }) {
                await this._api._fetch(["confirm_email", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        confirm: !0
                    })
                })
            }
            async changePasswordWithReset({
                newPassword: e,
                tokenId: t
            }) {
                const s = await this._api._fetch(["password_reset", t], {
                    method: "PATCH",
                    body: JSON.stringify({
                        password: e
                    })
                });
                try {
                    return await this._setApiTokenFromResponse(s), !0
                } catch (e) {
                    return !1
                }
            }
            async resetPassword({
                email: e
            }) {
                await this._api._fetch(["password_reset"], {
                    method: "POST",
                    body: JSON.stringify({
                        email: e
                    })
                })
            }
            async signUp({
                email: e,
                name: t,
                password: s,
                teamName: a,
                teamMembers: o,
                inviteId: r,
                locale: i,
                isInviteCode: c,
                isSkippingTeam: l,
                marketingConsent: d,
                apiToken: u
            }) {
                const m = o ? o.map((e => ({
                    invitation_email: e
                }))) : void 0;
                return this._api._fetch(["signup"].concat(r ? [r] : []), {
                    method: "POST",
                    body: JSON.stringify({
                        email: e,
                        password: s,
                        name: t,
                        team_name: a,
                        team_members: m,
                        locale: i,
                        is_invite_code: c,
                        has_skipped_team_setup: l,
                        marketing_consent: d,
                        is_electron: n.isElectron,
                        disable_onboarding: !0
                    }),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0,
                        apiToken: u
                    }))
                })
            }
            async confirmEmail({
                confirmId: e,
                inviteCode: t
            }) {
                const s = await this._api._fetch(["signup", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        confirm: !0,
                        invite_code: t
                    }),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0
                    }))
                });
                return await this._setApiTokenFromResponse(s), {
                    needsInviteCode: !1
                }
            }
            async resolveTeamInvitation({
                inviteToken: e,
                accept: t
            }) {
                return this._api._fetch(["invite", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        accept: t
                    }),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0
                    }))
                })
            }
            async requestJoinTeam({
                joinCode: e
            }) {
                return this._api._fetch(["invite", e], {
                    method: "PATCH",
                    body: JSON.stringify({
                        is_invite_code: !0
                    }),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0
                    }))
                })
            }
            async checkInviteCode({
                inviteCode: e
            }) {
                return this._api._fetch(["invite"].concat(e ? [e] : [""]), {
                    method: "PATCH",
                    body: JSON.stringify({
                        is_invite_code: !0
                    }),
                    headers: Object.assign({}, await this._api._headers({
                        hello: !0
                    }))
                })
            }
            async createInviteCode(e) {
                const t = await this._api._fetch(["teams", e, "invite_code"], {
                        method: "POST"
                    }),
                    s = await t.json();
                return {
                    invitationId: null != s ? s : ""
                }
            }
            async getInviteCode(e) {
                const t = await this._api._fetch(["teams", e, "invite_code"]),
                    s = await t.json();
                return {
                    invitationId: null != s ? s : ""
                }
            }
            async deleteInviteCode(e) {
                await this._api._fetch(["teams", e, "invite_code"], {
                    method: "DELETE"
                })
            }
            async getApiTokens() {
                const e = await this._api._fetch(["api_keys", ""]);
                return (await e.json()).map(a.$n)
            }
            async addApiToken(e, t) {
                const s = await this._api._fetch(["api_keys", ""], {
                        method: "POST",
                        body: JSON.stringify({
                            name: e,
                            team_id: t
                        })
                    }),
                    n = await s.json();
                return (0, a.$n)(n)
            }
            async removeApiToken(e) {
                return this._api._fetch(["api_keys", e], {
                    method: "DELETE"
                })
            }
            async cancelAccount(e, t) {
                await this._api._fetch(["account", e.id, "cancel"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        password: t
                    })
                })
            }
            async checkLoginProvider(e) {
                const {
                    provider: t
                } = await this._api._fetchJSON(["login_providers", e], {
                    method: "PATCH"
                });
                return t
            }
            async finishChallenges() {
                await this._api._fetch(["challenges"], {
                    method: "POST"
                })
            }
            async optOutOfChallenges() {
                await this._api._fetch(["challenges"], {
                    method: "DELETE"
                })
            }
            async sendContactForm(e, t, s, n, a) {
                const o = await fetch("https://webapp.nozbe.com/sync3/contact_form/lang-" + a.split("-")[0] + "/app_key-new_nozbe", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded;charset=UTF"
                        },
                        body: "email=" + encodeURIComponent(e) + "&title=" + encodeURIComponent(t) + "&body=" + encodeURIComponent(s) + "&nt_user_id=" + encodeURIComponent(n)
                    }),
                    r = await o.json();
                if (!o.ok || "ok" !== r.result) throw Error("Contact form failes")
            }
            async requestAccountBackup(e, t, s) {
                await this._api._fetch(["archiving", e.id], {
                    method: "POST",
                    body: JSON.stringify({
                        skip_files: t,
                        with_csv: s
                    })
                })
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a
        });
        s(17);
        var n = s(514);
        class a {
            constructor(e) {
                this._api = e
            }
            async getEmailToNozbe(e, t) {
                const {
                    email: s,
                    is_created: n
                } = await this._api._fetchJSON(["email_prefixes", e.id, (null == t ? void 0 : t.id) || ""]);
                return {
                    email: s,
                    isCreated: n
                }
            }
            async deactivateEmailToNozbe(e, t) {
                return this._api._fetch(["email_prefixes", e.id, (null == t ? void 0 : t.id) || ""], {
                    method: "DELETE"
                })
            }
            async getAvaliableImporters() {
                return this._api._fetchJSON(["import"])
            }
            async importFrom3rdParty({
                code: e,
                teamId: t,
                app_key: s,
                login: n,
                password: a,
                auth_token: o
            }) {
                await this._api._fetch(["import"], {
                    method: "POST",
                    body: JSON.stringify({
                        code: e,
                        team_id: t,
                        app_key: s,
                        login: n,
                        password: a,
                        auth_token: o
                    })
                })
            }
            async importFromNP({
                npAuthToken: e,
                teamId: t,
                projectsIds: s,
                shouldSkipDuplicates: n,
                importMembers: a
            }) {
                await this._api._fetch(["np_import"], {
                    method: "PATCH",
                    body: JSON.stringify({
                        np_auth_token: e,
                        team_id: t,
                        selected_projects: s,
                        skip_dupes: n,
                        import_team: a
                    })
                })
            }
            async getCalendarIntegrationUrl(e, t) {
                const {
                    auth_url: s
                } = await this._api._fetchJSON([e], {}, (0, n.F2)(t));
                return s
            }
            async getCalendarIntegrationStatus(e, t) {
                return this._api._fetch([e + "-status", t.id])
            }
            async removeCalendarIntegration(e, t) {
                return this._api._fetch([e], {
                    method: "DELETE",
                    body: JSON.stringify({
                        team_id: t.id
                    })
                })
            }
            async confirmCalendarIntegration(e, t, s) {
                return o(await this._api._fetch([t], {}, Object.assign({}, (0, n.F2)(e), {
                    code: s
                })))
            }
            async getCalendarTokens() {
                return (await this._api._fetchJSON(["api_keys", "ical"])).map(n.$n)
            }
            async createCalendarToken() {
                const e = await this._api._fetchJSON(["api_keys", "ical"], {
                    method: "POST"
                });
                return (0, n.$n)(e)
            }
            async createCalendarLink(e) {
                return this._api._url(["ical"], {
                    token: e.value
                })
            }
            async getEvernoteConnectUrl(e, t) {
                const {
                    auth_url: s
                } = await this._api._fetchJSON(["evernote"], {}, (0, n.F2)(e, t));
                return s
            }
            async confirmEvernoteConnect(e, t, s) {
                return o(await this._api._fetch(["evernote"], {}, Object.assign({}, (0, n.F2)(e), {
                    code: t,
                    oauth_verifier: s
                })))
            }
            async disconnectEvernote(e) {
                const t = e ? {
                    team_id: e.id
                } : void 0;
                await this._api._fetch(["evernote"], {
                    method: "DELETE"
                }, t)
            }
            async fetchEvernoteNotes(e, t) {
                const s = {
                    team_id: e.id
                };
                if (t) {
                    const {
                        page: e,
                        limit: n,
                        query: a
                    } = t;
                    void 0 !== e && (s.page = String(e)), void 0 !== n && (s.limit = String(n)), void 0 !== a && (s.q = a)
                }
                return this._api._fetchJSON(["evernote", "notes"], {}, s)
            }
            async getDropboxConnectUrl(e, t) {
                const {
                    auth_url: s
                } = await this._api._fetchJSON(["dropbox"], {}, (0, n.F2)(e, t));
                return s
            }
            async confirmDropboxConnect(e, t, s) {
                return o(await this._api._fetch(["dropbox"], {}, Object.assign({}, (0, n.F2)(e), {
                    code: t,
                    state: s
                })))
            }
            async disconnectDropbox(e) {
                const t = e ? {
                    team_id: e.id
                } : void 0;
                await this._api._fetch(["dropbox"], {
                    method: "DELETE"
                }, t)
            }
            async fetchDropboxFiles(e, t) {
                const s = t ? {
                    path: t
                } : void 0;
                return this._api._fetchJSON(["dropbox", "browse"], {
                    method: "POST",
                    body: JSON.stringify(s)
                }, {
                    team_id: e.id
                })
            }
            async getSlackConnectUrl(e) {
                const {
                    auth_url: t
                } = await this._api._fetchJSON(["slack"], {}, (0, n.F2)(e));
                return t
            }
            async confirmSlackConnect(e, t, s) {
                return o(await this._api._fetch(["slack"], {}, Object.assign({}, (0, n.F2)(e), {
                    code: t,
                    state: s
                })))
            }
            async disconnectSlack(e) {
                const t = e ? {
                    team_id: e.id
                } : void 0;
                await this._api._fetch(["slack"], {
                    method: "DELETE"
                }, t)
            }
            async getGoogleDriveConnectUrl(e, t) {
                const {
                    auth_url: s
                } = await this._api._fetchJSON(["gdrive"], {}, (0, n.F2)(e, t));
                return s
            }
            async confirmGoogleDriveConnect(e, t, s) {
                return o(await this._api._fetch(["gdrive"], {}, Object.assign({}, (0, n.F2)(e), {
                    code: t,
                    state: s
                })))
            }
            async disconnectGoogleDrive(e) {
                const t = e ? {
                    team_id: e.id
                } : void 0;
                await this._api._fetch(["gdrive"], {
                    method: "DELETE"
                }, t)
            }
            async fetchGoogleDriveFiles(e, t) {
                const s = t ? {
                    path: t
                } : void 0;
                return this._api._fetchJSON(["gdrive", "browse"], {
                    method: "POST",
                    body: JSON.stringify(s)
                }, {
                    team_id: e.id
                })
            }
            async getOneDriveConnectUrl(e, t) {
                const {
                    auth_url: s
                } = await this._api._fetchJSON(["onedrive"], {}, (0, n.F2)(e, t));
                return s
            }
            async confirmOneDriveConnect(e, t, s, a) {
                return o(await this._api._fetch(["onedrive"], {}, Object.assign({}, (0, n.F2)(e), {
                    code: t,
                    state: s,
                    client_info: a
                })))
            }
            async fetchOneDriveFiles(e, t) {
                const s = t ? {
                    path: t
                } : void 0;
                return this._api._fetchJSON(["onedrive", "browse"], {
                    method: "POST",
                    body: JSON.stringify(s)
                }, {
                    team_id: e.id
                })
            }
            async disconnectOneDrive(e) {
                const t = e ? {
                    team_id: e.id
                } : void 0;
                await this._api._fetch(["onedrive"], {
                    method: "DELETE"
                }, t)
            }
        }
        async function o(e) {
            const t = await e.json().catch((() => null));
            return t ? {
                result: "fail",
                retryAuthUrl: t.auth_url
            } : {
                result: "success"
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(45),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                validation: t,
                type: s,
                autoComplete: r,
                placeholder: i,
                newItemPlaceholder: c,
                onChange: l,
                values: d,
                forEntryViews: u,
                withBorderOnNative: m,
                autoFocus: h,
                onSubmit: p
            } = e, g = n.React.useMemo((() => d.length - 1), [d.length]), f = n.React.useRef(), b = () => {
                f.current && f.current.focus()
            };
            n.React.useEffect((() => {
                h && b()
            }), []);
            const y = e => {
                    l(n.FP.unique([...d.filter((e => !!e)), ...e]))
                },
                v = () => {
                    t.isAnyValid && ("" === d[g] && p && p(), y([""]))
                },
                w = e => t => {
                    e === g ? (e => {
                        if (e.trim().length) {
                            const t = e.split(/,| |\r|\n|\r\n/gu).filter((e => e.trim()));
                            1 < t.length ? y(t) : l(n.FP.update(g, t[t.length - 1], d))
                        } else l(n.FP.update(g, e, d))
                    })(t) : n.FP.isEmpty(t.trim()) ? l(d.filter(((t, s) => s !== e))) : l(n.FP.update(e, t, d))
                };
            return (0, o.jsx)(o.Fragment, {
                children: d.map(((e, n) => (0, o.jsx)(a.default, {
                    placeholder: c || i,
                    value: e,
                    showErrorMessage: n === g,
                    blurOnSubmit: !1,
                    errors: t["" + n].errors,
                    onChange: w(n),
                    autoComplete: r,
                    type: s,
                    withBorderOnNative: m,
                    inputRef: n === g ? f : void 0,
                    returnKeyType: "next",
                    forEntryViews: u,
                    onSubmit: n === g ? v : b
                }, "" + (g - n))))
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(139),
            o = s(1);
        const r = n.ReactUtils.lazy((() => s(566))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                teamMemberships: e.modelRoot.currentUser.pipe(n.Rx.switchMap((e => (null == e ? void 0 : e.teamMemberships.observe()) || n.Rx.of([])))),
                projectInvitations: e.modelRoot.settings.projectInvitations.observeAll()
            }))))((e => {
                const {
                    teamMemberships: t,
                    projectInvitations: s
                } = e, i = n.Hooks.useServices(), c = n.Hooks.useIntl(), l = n.Hooks.useModalState();
                return t.some((e => e.isActive)) && s.length ? (0, o.jsxs)(o.Fragment, {
                    children: [(0, o.jsx)(a.Z, {
                        title: c.f.Eg,
                        count: s.length,
                        onPress: () => {
                            if (1 < s.length) l.open();
                            else {
                                const e = s[0];
                                i.appState.startAcceptingProjectInvitation(e.invitation_id)
                            }
                        }
                    }), l.isOpen ? (0, o.jsx)(r, {
                        onClose: l.close,
                        invitations: s
                    }) : null]
                }) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(139),
            o = s(1);
        const r = n.ReactUtils.lazy((() => s(567))),
            i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
                services: e
            }) => ({
                accountMerges: e.modelRoot.settings.accountMerge.observeAll()
            }))))((e => {
                const {
                    accountMerges: t,
                    services: s
                } = e, i = n.Hooks.useIntl(), c = n.Hooks.useModalState();
                return t.length ? (0, o.jsxs)(o.Fragment, {
                    children: [(0, o.jsx)(a.Z, {
                        title: i.f.Dh,
                        count: t.length,
                        onPress: () => {
                            if (1 < t.length) c.open();
                            else {
                                const e = t[0];
                                s.appState.startAcceptingAccountMerge(e)
                            }
                        }
                    }), c.isOpen ? (0, o.jsx)(r, {
                        onClose: c.close,
                        accountMerges: t
                    }) : null]
                }) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(14),
            o = s(79),
            r = s(1);
        const i = n.Hocs.compose()((() => {
            const e = n.Hooks.useIntl(),
                {
                    currentTeam: t
                } = n.Hooks.useIdentity();
            return (0, r.jsx)(o.Z, {
                linkTo: (0, a.pathToCalendar)(t),
                title: e.f.Ed,
                icon: "R"
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(14),
            o = s(79),
            r = s(1);
        const i = n.Hocs.compose()((() => {
            const e = n.Hooks.useIntl(),
                {
                    currentTeam: t
                } = n.Hooks.useIdentity();
            return (0, r.jsx)(o.Z, {
                linkTo: (0, a.pathToActivity)(t),
                title: e.f.y,
                icon: "±",
                iconColor: "activity",
                counter: t.activityTasksCounter,
                testId: n.Misc.testIds.sidebar_activity
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => a,
            o: () => n
        });
        const n = s(0).React.createContext({}),
            a = e => {
                const {
                    children: t
                } = e;
                return t
            }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            m: () => c,
            u: () => i
        });
        var n = s(0),
            a = s(254),
            o = s(581),
            r = s(1);
        const i = e => {
                const t = n.Styling.blendWithSurface(e, .1).toRgbString();
                return "linear-gradient(to right, " + n.Styling.blendWithSurface(e, .1).setAlpha(0).toRgbString() + ", " + t
            },
            c = e => (0, r.jsx)(a.Z, {
                className: o.Z.gradient,
                style: {
                    background: e.background
                },
                children: e.children
            })
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(92),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                label: t,
                color: s,
                icon: n,
                onPress: r
            } = e;
            return (0, o.jsx)(a.Z, {
                label: t,
                color: s,
                iconName: n,
                isOpaque: !!s,
                isFullWidth: !1,
                onPress: r
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n, a = s(0),
            o = s(1306),
            r = s(1);
        const i = a.ReactUtils.lazy((() => s(1308))),
            c = a.ReactUtils.lazy((() => s(1309))),
            l = a.ReactUtils.lazy((() => s(1311))),
            d = a.Hocs.compose(a.Hocs.withErrorBoundary({
                name: "PreviewContent",
                render: () => n || (n = (0, r.jsx)(l, {}))
            }))((e => {
                const {
                    title: t,
                    content: s
                } = e;
                if (s.url) return (0, r.jsx)(c, {
                    title: t,
                    content: s
                });
                switch (invariant(s.file, "Unexpected missing file to preview"), (0, o.A)(s.file.type)) {
                    case "image":
                        return (0, r.jsx)(i, {
                            title: t,
                            file: s.file
                        });
                    case "html":
                    case "video":
                    case "pdf":
                        return (0, r.jsx)(c, {
                            title: t,
                            content: s
                        });
                    default:
                        return null
                }
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(133),
            o = s(1);
        const r = s(230).wx,
            i = n.Hocs.compose()((() => {
                const e = n.Hooks.useIntl(),
                    t = n.Hooks.useModalState();
                return (0, o.jsxs)(o.Fragment, {
                    children: [(0, o.jsx)(a.Z, {
                        iconName: "Ã",
                        accessibilityLabel: e.f.cB,
                        modalWebTarget: t.target,
                        onPress: t.open,
                        isActive: t.isOpen,
                        testId: n.Misc.testIds.sidebar_helpButton
                    }), t.isOpen ? (0, o.jsx)(r.HelpMenu, {
                        bundle$close: t.close,
                        closeMenu: t.close,
                        target: t.target
                    }) : null]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            KZ: () => l,
            Kj: () => d,
            ZP: () => u,
            zu: () => c
        });
        var n = s(0),
            a = s(131),
            o = s(94);
        const r = ["image/jpeg", "image/png"],
            i = n.FP.formatBytes(a.i4),
            c = (e, t) => {
                switch (e) {
                    case "invalid_file_type":
                        return t.f.qA;
                    case "file_size_exceeded":
                        return t.g("qz", {
                            size: i
                        });
                    default:
                        return t.f.kY
                }
            },
            l = e => !!e && r.includes(e),
            d = e => e <= a.i4;

        function u(e) {
            const {
                model: t,
                autosave: s,
                onSave: a
            } = e || {}, r = null == t ? void 0 : t.avatarId, i = t instanceof n.Model.Models.Team ? t : void 0, u = n.Hooks.useServices(), m = n.Hooks.useIntl(), h = n.Hooks.useIsMounted(), [p, g, f, b] = n.Hooks.useLoadingState(), [y, v, w, k] = n.Hooks.useLoadingState(), x = p.result, j = (0, o.n)(x), T = async e => {
                v();
                try {
                    await u.api.attachments.uploadAvatar(e, i), await u.sync.synchronize(), h.current && w()
                } catch (e) {
                    h.current && k()
                }
            };
            return {
                avatar: p,
                uploading: y,
                pickedAvatarPreview: j,
                pickedAvatarErrorMessage: p.error ? c(p.error, m) : null,
                pickAvatarFile: (e = "files") => {
                    g(), u.nativeScene.pickFile((e => {
                        if (!h.current || !e) return;
                        if (!e.length) return void f(x);
                        const [t] = e;
                        l(t.type) ? d(t.size) ? (f(t), s && T(t)) : b("file_size_exceeded") : b("invalid_file_type")
                    }), {
                        multiple: !1,
                        type: e,
                        mimeType: "image/*"
                    })
                },
                saveAvatar: async e => {
                    x && (T(x), null == a || a(e))
                },
                removeAvatar: async () => {
                    if (r) {
                        v();
                        try {
                            await u.api.attachments.deleteAvatar(r, i), await u.sync.synchronize(), h.current && w()
                        } catch (e) {
                            h.current && k()
                        }
                    }
                },
                clearAvatarPreview: () => f(null),
                clearAvatarError: () => b(null)
            }
        }
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => p
        });
        var n = s(0),
            a = s(61),
            o = s(43),
            r = s(45),
            i = s(127),
            c = s(12),
            l = s(1460),
            d = s(30),
            u = s(1);
        const m = (0, u.jsx)(a.Z, {
                id: "ko"
            }, "entry.register.error.account_exists"),
            h = (e, t) => s => ({
                error: m,
                isValid: !t || s !== e
            }),
            p = n.Hocs.compose(n.Hocs.withErrorBoundary({
                name: "EmailPassword",
                render: "screen"
            }))((e => {
                const {
                    goToNext: t,
                    goBack: s,
                    email: a,
                    onEmailChange: m,
                    password: p,
                    onPasswordChange: g,
                    initialEmail: f,
                    isEmailUsed: b,
                    serverUrl: y,
                    setServerUrl: v
                } = e, w = n.Hooks.useIntl(), k = n.Hooks.useValidation({
                    email: [a, [o.C1, o.Jh, h(f, b)]],
                    password: [p, o.dZ]
                }), x = k.isValid ? t : void 0;
                return (0, u.jsxs)(u.Fragment, {
                    children: [(0, u.jsxs)(i.Z, {
                        onSubmit: x,
                        children: [(0, u.jsx)(d.bu, {
                            label: w.f.uf
                        }), (0, u.jsx)(r.default, {
                            placeholder: w.f.iR,
                            autoFocus: !a,
                            autoComplete: "username",
                            type: "email",
                            onChange: m,
                            value: a,
                            returnKeyType: "next",
                            errors: k.email.errors,
                            blurOnSubmit: !1,
                            forEntryViews: !0,
                            autoCorrect: !0
                        }), (0, u.jsx)(d.bu, {
                            label: w.f.up,
                            hasTopMargin: !0
                        }), (0, u.jsx)(r.default, {
                            placeholder: w.f.j5,
                            autoComplete: "new-password",
                            autoFocus: !!a,
                            type: "password",
                            onChange: g,
                            value: p,
                            returnKeyType: "next",
                            errors: k.password.errors,
                            blurOnSubmit: !1,
                            forEntryViews: !0,
                            helpText: w.f.KM
                        }), null]
                    }), (0, u.jsx)(l.Z, {
                        paddingToKeyboard: 12,
                        children: (0, u.jsx)(c.default, {
                            onPress: t,
                            marginTop: "big",
                            isDisabled: !k.isValid,
                            variant: "opaque",
                            color: "purple",
                            label: w.f.fD
                        })
                    }), (0, u.jsx)(c.default, {
                        marginTop: "big",
                        onPress: s,
                        label: w.f.fd
                    })]
                })
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(12),
            o = s(658),
            r = s(1);
        const i = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "NewTeam",
            render: "screen"
        }))((e => {
            const {
                avatarModalProps: t,
                name: s,
                setName: i,
                goBack: c,
                goToNext: l,
                skipTeam: d
            } = e, u = n.Hooks.useIntl();
            return (0, r.jsx)(o.Z, {
                avatarModalProps: t,
                name: s,
                setName: i,
                goBack: c,
                goToNext: l,
                autoCompleteType: "organization",
                label: u.f.JV,
                description: u.f.jG,
                placeholder: u.f.jV,
                isTeam: !0,
                avatarButtonLabel: u.f.kk,
                children: (0, r.jsx)(a.default, {
                    label: u.f.jR,
                    color: "purple",
                    marginTop: "big",
                    onPress: d
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => r
        });
        var n = s(0),
            a = s(658),
            o = s(1);
        const r = n.Hocs.compose(n.Hocs.withErrorBoundary({
            name: "Name",
            render: "screen"
        }))((e => {
            const {
                avatarModalProps: t,
                name: s,
                setName: r,
                goBack: i,
                goToNext: c
            } = e, l = n.Hooks.useIntl();
            return (0, o.jsx)(a.Z, {
                avatarModalProps: t,
                name: s,
                setName: r,
                goBack: i,
                goToNext: c,
                autoCompleteType: "name",
                label: l.f.jy,
                placeholder: l.f.jz,
                isTeam: !1,
                avatarButtonLabel: l.f.kl
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(1);
        const o = (e, t) => {
                if (0 === t) return e(), n.FP.noop;
                const s = setTimeout(e, t);
                return () => {
                    clearTimeout(s)
                }
            },
            r = n.Hocs.compose()((e => {
                const {
                    isMounted: t,
                    children: s,
                    timeout: r
                } = e, [i, c] = n.React.useState(t ? "entered" : "unmounted"), l = n.React.useMemo((() => "string" == typeof r ? (e => {
                    try {
                        return 1e3 * parseFloat(e.replace("s", ""))
                    } catch (t) {
                        return n.Misc.logError(n.Misc.PROD_CONSOLE_REASON.SAFE_LITERAL, "Couldn't parse timeout string " + e), 0
                    }
                })(r) : r), [r]);
                return n.React.useEffect((() => {
                    if (t) {
                        c("mounted");
                        const e = setTimeout((() => {
                            c("entering")
                        }), 10);
                        return () => {
                            clearTimeout(e)
                        }
                    }
                    c("leaving");
                    return o((() => {
                        c("unmounted")
                    }), l)
                }), [t, l]), n.React.useEffect((() => {
                    if ("entering" === i) {
                        return o((() => {
                            c("entered")
                        }), l)
                    }
                    return n.FP.noop
                }), [i, l]), "unmounted" !== i ? (0, a.jsx)(a.Fragment, {
                    children: s({
                        status: i
                    })
                }) : null
            }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(257),
            o = s(1336),
            r = s(1);
        s(253).wx;
        const i = n.Hocs.compose(n.Hocs.withServices, n.Hocs.withObservables(null, (({
            services: e
        }) => ({
            areTaskDetailsMaximized: e.layout.areTaskDetailsMaximized
        }))))((e => {
            const {
                match: t,
                history: i,
                location: c,
                areTaskDetailsMaximized: l
            } = e, d = n.Hooks.useDesktopLayout(), {
                isNarrowLayout: u
            } = n.Hooks.useLayoutVariant(), m = n.Hooks.useServices();
            n.Hooks.useShortcutProviders(d && !u ? [{
                id: "task.toggle_fullscreen",
                action: () => {
                    l ? m.layout.minimizeTaskDetails() : m.layout.maximizeTaskDetails()
                }
            }] : []), n.React.useEffect((() => () => {
                d && m.layout.minimizeTaskDetails()
            }), [d, m.layout]), (0, a.Sn)();
            const h = n.React.createElement(s(260).TaskDetails, {
                match: t,
                history: i,
                location: c
            });
            return d ? (0, r.jsx)("div", {
                className: o.Z.right + (l ? " " + o.Z.rightExpanded : ""),
                children: h
            }) : h
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => c
        });
        var n = s(0),
            a = s(227),
            o = s(228),
            r = s(88),
            i = s(1);
        const c = n.Hocs.compose(n.Hocs.memo, n.Hocs.withServices, n.Hocs.withObservables(["attachmentVersion"], (({
            attachmentVersion: e,
            services: t
        }) => ({
            attachmentVersion: e,
            thumbnailSource: n.Rx.from(t.api.attachments.thumbnailSource(e, 500))
        }))), n.Hocs.withHooks((({
            services: e,
            attachmentVersion: t
        }) => ({
            uploadJob: e.uploader.getJob(t)
        }))), n.Hocs.withObservables(["uploadJob"], (({
            uploadJob: e
        }) => ({
            uploadStatus: n.Rx.wrap(null == e ? void 0 : e.status)
        }))))((e => {
            const {
                attachmentVersion: t,
                showThumbnail: s,
                thumbnailSource: c,
                onPress: l,
                downloadStatus: d,
                uploadStatus: u,
                removeButton: m
            } = e, h = n.Hooks.useIntl(), p = "downloading" === (null == d ? void 0 : d.state), g = "uploading" === t.status, f = "uploaded" === t.status, b = "error" === t.status, y = b ? h.g("e3", {
                fileName: t.name
            }) : p ? h.f.eJ : t.name, v = "uploading" !== t.status ? "" : u ? "pending" === u.state ? h.f.e4 : "uploading" === u.state ? u.progress ? h.f.e6 + " " + Math.round(100 * u.progress) + "%" : h.f.e6 : h.f.e5 : t.isExternal ? h.f.e6 : "", w = (0, r.zK)(t), k = (0, o.mQ)(w, null == d ? void 0 : d.progress), x = (() => {
                if (s) {
                    const {
                        file: e
                    } = t;
                    if (e && (0, o.TO)(e)) return {
                        state: "loaded",
                        file: e
                    };
                    if (f) return {
                        state: "loaded",
                        source: c
                    };
                    if (g) return {
                        state: "loading"
                    }
                }
                return null
            })(), j = p ? {
                name: "}"
            } : b ? {
                name: "Œ",
                color: "red"
            } : g && !x ? {
                name: "Ɯ",
                isSpinning: !0
            } : (0, o.WG)(w), T = {
                onPress: f && !p ? l : void 0,
                accessibilityLabel: h.g("ma", {
                    fileName: t.name
                }),
                style: g ? {
                    opacity: .5
                } : void 0
            };
            return (0, i.jsx)(a.default, {
                name: y,
                statusText: v,
                infoText: k,
                icon: j,
                thumbnail: x,
                contentButton: T,
                removeButton: m
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => d
        });
        var n = s(0),
            a = s(932),
            o = s(299),
            r = s(6),
            i = s(77),
            c = s(14),
            l = s(1);
        const d = n.Hocs.compose(n.Hocs.withPersonalUI)((e => {
            const {
                task: t,
                project: s,
                onClose: d,
                shouldRenderPersonalUI: u
            } = e, m = n.Hooks.useServices(), {
                currentTeam: h
            } = n.Hooks.useIdentity(), p = n.Hooks.useIntl(), [g, f] = n.Hooks.useToggle();
            return (0, l.jsx)(a.Z, {
                header: p.f.IV,
                description: p.g("IU", {
                    taskName: (0, l.jsx)(r.u_.Emphasis, {
                        children: t.name
                    }, "taskName")
                }),
                helpPageUrl: n.ReactUtils.helpUrl(p, "taskmanagement/new-tasks/#tasks_convert"),
                onConvertPress: async e => {
                    const a = s.permissions.isOpen ? {
                        name: "create-projects",
                        currentTeam: h
                    } : {
                        name: "invite-to-project",
                        currentTeam: h
                    };
                    await m.payments.invokeActionOrProposeUpgrade(a, (async () => {
                        const e = await t.do.convertToProject({
                            usesPersonalUI: u,
                            formatTaskName: e => (0, o.t)(e, p),
                            onlyPinnedComments: g,
                            annotations: {
                                projectDescription: p.g("IX", {
                                    TaskButton: n.ReactUtils.fullUrl((0, c.smartPathToTask)(h, s, t))
                                }),
                                projectResources: p.f.IY,
                                taskNotes: p.f.I1,
                                taskFiles: p.f.I0,
                                taskAbandoned: e => p.g("IZ", {
                                    projectLink: n.ReactUtils.fullUrl((0, c.smartPathToProject)(h, e))
                                }),
                                commentFile: e => p.g("gY", {
                                    attachmentCount: e
                                })
                            }
                        });
                        m.router.goTo((0, c.smartPathToProject)(h, e)), await m.sync.synchronizeTwice()
                    })) || d(e)
                },
                onClose: d,
                children: (0, l.jsx)(r.u_.Section, {
                    children: (0, l.jsx)(i.Z, {
                        label: p.f.IW,
                        isActive: g,
                        colorActive: "blue",
                        onChange: f
                    })
                })
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.r(t), s.d(t, {
            default: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(1256),
            r = s(1);
        const i = n.Hocs.compose((0, a.LU)({
            minWidth: 500
        }))((e => {
            const {
                project: t
            } = e, s = n.Hooks.useIntl(), {
                closeAnimated: i
            } = (0, a.vR)();
            return (0, r.jsxs)(r.Fragment, {
                children: [(0, r.jsx)(a.u_.Header, {
                    children: s.f.BB
                }), (0, r.jsx)(a.u_.Content, {
                    padded: !0,
                    children: (0, r.jsx)(o.Z, {
                        project: t,
                        onClose: i
                    })
                })]
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => i
        });
        var n = s(0),
            a = s(6),
            o = s(25),
            r = s(1);
        const i = n.Hocs.compose()((e => {
            const {
                team: t,
                onConfirm: s,
                onCancel: i,
                onClose: c
            } = e, l = n.Hooks.useIntl();
            return (0, r.jsx)(o.default, {
                type: "confirm",
                level: 20,
                confirmButtonMessage: l.f.fq,
                onConfirmPress: s,
                onBackPress: i,
                onClose: c,
                children: t ? l.g("n7", {
                    teamName: (0, r.jsx)(a.u_.Emphasis, {
                        children: t.name
                    }, t.name)
                }) : l.f.n6
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            N: () => a,
            m: () => o
        });
        var n = s(4);
        const a = n.sortByProp("createdAt"),
            o = e => n.pipe((e => n.pipe(n.filter((t => !e.lastSeenEventAt || t.createdAt > e.lastSeenEventAt)), a))(e), n.last)
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            l: () => a
        });
        var n = s(0);

        function a(e) {
            const t = n.Hooks.useIntl(),
                {
                    currentUser: s
                } = n.Hooks.useIdentity(),
                a = new Date;
            if (null == s || !s.timeZone || !e.timeZone) return !1;
            return t.formatTime(a, {
                timeZone: s.timeZone
            }) !== t.formatTime(a, {
                timeZone: e.timeZone
            })
        }
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(0),
            a = s(25),
            o = s(1);
        const r = n.Hocs.compose()((e => {
            const {
                onConfirmPress: t,
                onBackPress: s,
                onClose: r
            } = e, i = n.Hooks.useIntl();
            return (0, o.jsx)(a.default, {
                type: "confirm",
                onConfirmPress: t,
                onBackPress: s,
                headerIcon: "R",
                confirmButtonMessage: i.f.fi,
                onClose: r,
                children: i.f.yg
            })
        }))
    }, (e, t, s) => {
        "use strict";
        s.d(t, {
            Z: () => r
        });
        var n = s(1143),
            a = s(95),
            o = s(1446);
        async function r(e, t, s, r) {
            try {
                (0, n.Z)("diagnostic error", e);
                await (0, o.Z)(t, s, r) && ((0, a.Z)("safe literal").log("Trying to remove database..."), await new Promise(((e, t) => {
                    const s = globalThis.indexedDB.deleteDatabase("nozbe");
                    s.onerror = t, s.onsuccess = e
                })))
            } catch (e) {
                (0, a.Z)("safe literal").error("Failed to remove database..."), (0, n.Z)("diagnostic error", e)
            } finally {
                setTimeout((() => globalThis.location.reload()), 500)
            }
        }
    }], e => {
        e.O(0, [179], (() => {
            [429, 730, 650, 144, 400, 54, 810, 105, 654, 532, 537, 216, 419, 284, 509, 221, 378, 210, 90, 886, 373, 840].map(e.E)
        }), 5);
        var t = t => e(e.s = t);
        e.O(0, [532, 216], (() => (t(1508), t(1044))));
        e.O()
    }
]);